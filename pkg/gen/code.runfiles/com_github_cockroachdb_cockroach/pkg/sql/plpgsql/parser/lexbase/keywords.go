// Code generated by pkg/sql/lexbase/allkeywords. DO NOT EDIT.

package lexbase

var KeywordsCategories = map[string]string{
"absolute": "U",
"alias": "U",
"all": "R",
"and": "U",
"array": "U",
"assert": "U",
"backward": "U",
"begin": "R",
"by": "R",
"call": "U",
"case": "R",
"chain": "U",
"close": "U",
"collate": "U",
"column": "U",
"column_name": "U",
"commit": "U",
"constant": "U",
"constraint": "U",
"constraint_name": "U",
"continue": "U",
"current": "U",
"cursor": "U",
"datatype": "U",
"debug": "U",
"declare": "R",
"default": "U",
"detail": "U",
"diagnostics": "U",
"do": "U",
"dump": "U",
"else": "R",
"elsif": "U",
"end": "R",
"end_case": "R",
"end_if": "R",
"errcode": "U",
"error": "U",
"exception": "U",
"execute": "R",
"exit": "U",
"fetch": "U",
"first": "U",
"for": "R",
"foreach": "R",
"forward": "U",
"from": "R",
"get": "U",
"hint": "U",
"if": "R",
"import": "U",
"in": "R",
"info": "U",
"insert": "U",
"into": "R",
"is": "U",
"language": "U",
"last": "U",
"log": "U",
"loop": "R",
"merge": "U",
"message": "U",
"message_text": "U",
"move": "U",
"next": "U",
"no": "U",
"not": "R",
"notice": "U",
"no_scroll": "U",
"null": "R",
"open": "U",
"option": "U",
"or": "R",
"perform": "U",
"pg_context": "U",
"pg_datatype_name": "U",
"pg_exception_context": "U",
"pg_exception_detail": "U",
"pg_exception_hint": "U",
"print_strict_params": "U",
"prior": "U",
"query": "U",
"raise": "U",
"relative": "U",
"return": "U",
"returned_sqlstate": "U",
"return_next": "U",
"return_query": "U",
"reverse": "U",
"rollback": "U",
"rowtype": "U",
"row_count": "U",
"schema": "U",
"schema_name": "U",
"scroll": "U",
"slice": "U",
"sqlstate": "U",
"stacked": "U",
"strict": "R",
"table": "U",
"table_name": "U",
"then": "R",
"to": "R",
"type": "U",
"upsert": "U",
"use_column": "U",
"use_variable": "U",
"using": "R",
"variable_conflict": "U",
"warning": "U",
"when": "R",
"while": "R",
}

// KeywordNames contains all keywords sorted, so that pg_get_keywords returns
// deterministic results.
var KeywordNames = []string{
"absolute",
"alias",
"all",
"and",
"array",
"assert",
"backward",
"begin",
"by",
"call",
"case",
"chain",
"close",
"collate",
"column",
"column_name",
"commit",
"constant",
"constraint",
"constraint_name",
"continue",
"current",
"cursor",
"datatype",
"debug",
"declare",
"default",
"detail",
"diagnostics",
"do",
"dump",
"else",
"elsif",
"end",
"end_case",
"end_if",
"errcode",
"error",
"exception",
"execute",
"exit",
"fetch",
"first",
"for",
"foreach",
"forward",
"from",
"get",
"hint",
"if",
"import",
"in",
"info",
"insert",
"into",
"is",
"language",
"last",
"log",
"loop",
"merge",
"message",
"message_text",
"move",
"next",
"no",
"not",
"notice",
"no_scroll",
"null",
"open",
"option",
"or",
"perform",
"pg_context",
"pg_datatype_name",
"pg_exception_context",
"pg_exception_detail",
"pg_exception_hint",
"print_strict_params",
"prior",
"query",
"raise",
"relative",
"return",
"returned_sqlstate",
"return_next",
"return_query",
"reverse",
"rollback",
"rowtype",
"row_count",
"schema",
"schema_name",
"scroll",
"slice",
"sqlstate",
"stacked",
"strict",
"table",
"table_name",
"then",
"to",
"type",
"upsert",
"use_column",
"use_variable",
"using",
"variable_conflict",
"warning",
"when",
"while",
}

var keywordID = map[string]int32{
"absolute": ABSOLUTE,
"alias": ALIAS,
"all": ALL,
"and": AND,
"array": ARRAY,
"assert": ASSERT,
"backward": BACKWARD,
"begin": BEGIN,
"by": BY,
"call": CALL,
"case": CASE,
"chain": CHAIN,
"close": CLOSE,
"collate": COLLATE,
"column": COLUMN,
"column_name": COLUMN_NAME,
"commit": COMMIT,
"constant": CONSTANT,
"constraint": CONSTRAINT,
"constraint_name": CONSTRAINT_NAME,
"continue": CONTINUE,
"current": CURRENT,
"cursor": CURSOR,
"datatype": DATATYPE,
"debug": DEBUG,
"declare": DECLARE,
"default": DEFAULT,
"detail": DETAIL,
"diagnostics": DIAGNOSTICS,
"do": DO,
"dump": DUMP,
"else": ELSE,
"elsif": ELSIF,
"end": END,
"end_case": END_CASE,
"end_if": END_IF,
"errcode": ERRCODE,
"error": ERROR,
"exception": EXCEPTION,
"execute": EXECUTE,
"exit": EXIT,
"fetch": FETCH,
"first": FIRST,
"for": FOR,
"foreach": FOREACH,
"forward": FORWARD,
"from": FROM,
"get": GET,
"hint": HINT,
"if": IF,
"import": IMPORT,
"in": IN,
"info": INFO,
"insert": INSERT,
"into": INTO,
"is": IS,
"language": LANGUAGE,
"last": LAST,
"log": LOG,
"loop": LOOP,
"merge": MERGE,
"message": MESSAGE,
"message_text": MESSAGE_TEXT,
"move": MOVE,
"next": NEXT,
"no": NO,
"not": NOT,
"notice": NOTICE,
"no_scroll": NO_SCROLL,
"null": NULL,
"open": OPEN,
"option": OPTION,
"or": OR,
"perform": PERFORM,
"pg_context": PG_CONTEXT,
"pg_datatype_name": PG_DATATYPE_NAME,
"pg_exception_context": PG_EXCEPTION_CONTEXT,
"pg_exception_detail": PG_EXCEPTION_DETAIL,
"pg_exception_hint": PG_EXCEPTION_HINT,
"print_strict_params": PRINT_STRICT_PARAMS,
"prior": PRIOR,
"query": QUERY,
"raise": RAISE,
"relative": RELATIVE,
"return": RETURN,
"returned_sqlstate": RETURNED_SQLSTATE,
"return_next": RETURN_NEXT,
"return_query": RETURN_QUERY,
"reverse": REVERSE,
"rollback": ROLLBACK,
"rowtype": ROWTYPE,
"row_count": ROW_COUNT,
"schema": SCHEMA,
"schema_name": SCHEMA_NAME,
"scroll": SCROLL,
"slice": SLICE,
"sqlstate": SQLSTATE,
"stacked": STACKED,
"strict": STRICT,
"table": TABLE,
"table_name": TABLE_NAME,
"then": THEN,
"to": TO,
"type": TYPE,
"upsert": UPSERT,
"use_column": USE_COLUMN,
"use_variable": USE_VARIABLE,
"using": USING,
"variable_conflict": VARIABLE_CONFLICT,
"warning": WARNING,
"when": WHEN,
"while": WHILE,
}

// GetKeywordID returns the lex id of the SQL keyword k or IDENT if k is
// not a keyword.
//
//gcassert:inline
func GetKeywordID(k string) int32 {
	id, ok := keywordID[k]
	if !ok {
		return IDENT
	}
	return id
}
