// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props/physical"
)

func (_e *explorer) exploreGroupMember(
	state *exploreState,
	member memo.RelExpr,
	ordinal int,
	required *physical.Required,
) (_fullyExplored bool) {
	switch t := member.(type) {
	case *memo.MemoCycleTestRelExpr:
		return _e.exploreMemoCycleTestRel(state, t, ordinal, required)
	case *memo.InsertExpr:
		return _e.exploreInsert(state, t, ordinal, required)
	case *memo.ScanExpr:
		return _e.exploreScan(state, t, ordinal, required)
	case *memo.SelectExpr:
		return _e.exploreSelect(state, t, ordinal, required)
	case *memo.ProjectExpr:
		return _e.exploreProject(state, t, ordinal, required)
	case *memo.InnerJoinExpr:
		return _e.exploreInnerJoin(state, t, ordinal, required)
	case *memo.LeftJoinExpr:
		return _e.exploreLeftJoin(state, t, ordinal, required)
	case *memo.RightJoinExpr:
		return _e.exploreRightJoin(state, t, ordinal, required)
	case *memo.FullJoinExpr:
		return _e.exploreFullJoin(state, t, ordinal, required)
	case *memo.SemiJoinExpr:
		return _e.exploreSemiJoin(state, t, ordinal, required)
	case *memo.AntiJoinExpr:
		return _e.exploreAntiJoin(state, t, ordinal, required)
	case *memo.LookupJoinExpr:
		return _e.exploreLookupJoin(state, t, ordinal, required)
	case *memo.GroupByExpr:
		return _e.exploreGroupBy(state, t, ordinal, required)
	case *memo.ScalarGroupByExpr:
		return _e.exploreScalarGroupBy(state, t, ordinal, required)
	case *memo.DistinctOnExpr:
		return _e.exploreDistinctOn(state, t, ordinal, required)
	case *memo.EnsureDistinctOnExpr:
		return _e.exploreEnsureDistinctOn(state, t, ordinal, required)
	case *memo.UpsertDistinctOnExpr:
		return _e.exploreUpsertDistinctOn(state, t, ordinal, required)
	case *memo.EnsureUpsertDistinctOnExpr:
		return _e.exploreEnsureUpsertDistinctOn(state, t, ordinal, required)
	case *memo.UnionExpr:
		return _e.exploreUnion(state, t, ordinal, required)
	case *memo.IntersectExpr:
		return _e.exploreIntersect(state, t, ordinal, required)
	case *memo.ExceptExpr:
		return _e.exploreExcept(state, t, ordinal, required)
	case *memo.IntersectAllExpr:
		return _e.exploreIntersectAll(state, t, ordinal, required)
	case *memo.ExceptAllExpr:
		return _e.exploreExceptAll(state, t, ordinal, required)
	case *memo.LimitExpr:
		return _e.exploreLimit(state, t, ordinal, required)
	case *memo.OffsetExpr:
		return _e.exploreOffset(state, t, ordinal, required)
	case *memo.TopKExpr:
		return _e.exploreTopK(state, t, ordinal, required)
	}

	// No rules for other operator types.
	return true
}

func (_e *explorer) exploreMemoCycleTestRel(
	_rootState *exploreState,
	_root *memo.MemoCycleTestRelExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [MemoCycleTestRelRule]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			filters := _root.Filters
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.MemoCycleTestRelRule) {
				_expr := &memo.MemoCycleTestRelExpr{
					Input: _e.f.ConstructMemoCycleTestRel(
						input,
						filters,
					),
					Filters: filters,
				}
				_interned := _e.mem.AddMemoCycleTestRelToGroup(_expr, _root)
				if _e.o.appliedRule != nil {
					if _interned != _expr {
						_e.o.appliedRule(opt.MemoCycleTestRelRule, _root, nil)
					} else {
						_e.o.appliedRule(opt.MemoCycleTestRelRule, _root, _interned)
					}
				}
			}
		}
	}

	// [MemoCycleTestRelRuleFilter]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			filters := _root.Filters
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.MemoCycleTestRelRuleFilter) {
				_expr := &memo.SelectExpr{
					Input: input,
					Filters: memo.FiltersExpr{
						_e.f.ConstructFiltersItem(
							_e.f.ConstructExists(
								_e.f.ConstructMemoCycleTestRel(
									input,
									filters,
								),
								_e.funcs.EmptyExistsPrivate(),
							),
						),
					},
				}
				_interned := _e.mem.AddSelectToGroup(_expr, _root)
				if _e.o.appliedRule != nil {
					if _interned != _expr {
						_e.o.appliedRule(opt.MemoCycleTestRelRuleFilter, _root, nil)
					} else {
						_e.o.appliedRule(opt.MemoCycleTestRelRuleFilter, _root, _interned)
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreInsert(
	_rootState *exploreState,
	_root *memo.InsertExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [InsertFastPath]
	{
		if _rootOrd >= _rootState.start {
			insInput := _root.Input
			unique := _root.UniqueChecks
			newFastPathUnique, ok := _e.funcs.CanUseUniqueChecksForInsertFastPath(_root)
			if ok {
				fk := _root.FKChecks
				mutations := &_root.MutationPrivate
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.InsertFastPath) {
					_expr := &memo.InsertExpr{
						Input:                insInput,
						UniqueChecks:         unique,
						FastPathUniqueChecks: newFastPathUnique,
						FKChecks:             fk,
						MutationPrivate:      *mutations,
					}
					_interned := _e.mem.AddInsertToGroup(_expr, _root)
					if _e.o.appliedRule != nil {
						if _interned != _expr {
							_e.o.appliedRule(opt.InsertFastPath, _root, nil)
						} else {
							_e.o.appliedRule(opt.InsertFastPath, _root, _interned)
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreScan(
	_rootState *exploreState,
	_root *memo.ScanExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateIndexScans]
	{
		if _rootOrd >= _rootState.start {
			scanPrivate := &_root.ScanPrivate
			if _e.funcs.IsCanonicalScan(scanPrivate) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateIndexScans) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateIndexScans(_root, _required, scanPrivate)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateIndexScans, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateLocalityOptimizedScan]
	{
		if _rootOrd >= _rootState.start {
			scanPrivate := &_root.ScanPrivate
			if _e.funcs.CanMaybeGenerateLocalityOptimizedScan(scanPrivate) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedScan) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateLocalityOptimizedScan(_root, _required, scanPrivate)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateLocalityOptimizedScan, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSelect(
	_rootState *exploreState,
	_root *memo.SelectExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateParameterizedJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			scan = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.GenericRulesEnabled() {
						if _e.funcs.IsCanonicalScan(scanPrivate) {
							filters := _root.Filters
							if _e.funcs.HasPlaceholdersOrStableExprs(_root) {
								values, newFilters, ok := _e.funcs.GenerateParameterizedJoinValuesAndFilters(filters)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateParameterizedJoin) {
										_expr := &memo.ProjectExpr{
											Input: _e.f.ConstructInnerJoin(
												values,
												_scan,
												newFilters,
												_e.funcs.ParameterizedJoinPrivate(),
											),
											Projections: memo.EmptyProjectionsExpr,
											Passthrough: _e.funcs.OutputCols(_root),
										}
										_interned := _e.mem.AddProjectToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.GenerateParameterizedJoin, _root, nil)
											} else {
												_e.o.appliedRule(opt.GenerateParameterizedJoin, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GeneratePartialIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GeneratePartialIndexScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GeneratePartialIndexScans(_root, _required, scanPrivate, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GeneratePartialIndexScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateConstrainedScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateConstrainedScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateConstrainedScans(_root, _required, scanPrivate, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateConstrainedScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedIndexScans) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedIndexScans(_root, _required, scanPrivate, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedIndexScans, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateMinimalInvertedIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			input = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMinimalInvertedIndexScans) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateMinimalInvertedIndexScans(_root, _required, _scan, scanPrivate, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateMinimalInvertedIndexScans, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateTrigramSimilarityInvertedIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateTrigramSimilarityInvertedIndexScans) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateTrigramSimilarityInvertedIndexScans(_root, _required, scanPrivate, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateTrigramSimilarityInvertedIndexScans, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateZigzagJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scan := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scan) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateZigzagJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateZigzagJoins(_root, _required, scan, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateZigzagJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedIndexZigzagJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scan := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scan) {
						if _e.funcs.HasInvertedIndexes(scan) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedIndexZigzagJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedIndexZigzagJoins(_root, _required, scan, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedIndexZigzagJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunction]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			input = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasStrictKey(_scan) {
							if !_e.funcs.HasZeroOrOneRow(_scan) {
								filters := _root.Filters
								leftFilter, rightFilter, itemToReplace, ok := _e.funcs.SplitDisjunction(scanPrivate, filters)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunction) {
										leftScanPrivate := _e.funcs.DuplicateScanPrivate(scanPrivate)
										leftScan := _e.f.ConstructScan(
											leftScanPrivate,
										)
										rightScanPrivate := _e.funcs.DuplicateScanPrivate(scanPrivate)
										rightScan := _e.f.ConstructScan(
											rightScanPrivate,
										)
										_expr := &memo.DistinctOnExpr{
											Input: _e.f.ConstructUnionAll(
												_e.f.ConstructSelect(
													leftScan,
													_e.funcs.RemapScanColsInFilter(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, leftFilter), scanPrivate, leftScanPrivate),
												),
												_e.f.ConstructSelect(
													rightScan,
													_e.funcs.RemapScanColsInFilter(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, rightFilter), scanPrivate, rightScanPrivate),
												),
												_e.funcs.MakeSetPrivate(_e.funcs.OutputCols(leftScan), _e.funcs.OutputCols(rightScan), _e.funcs.OutputCols(_scan)),
											),
											Aggregations:    _e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.NonKeyCols(_scan)),
											GroupingPrivate: *_e.funcs.MakeGrouping(_e.funcs.KeyCols(_scan), _e.funcs.EmptyOrdering()),
										}
										_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitDisjunction, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitDisjunction, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunctionAddKey]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			input = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if !_e.funcs.HasStrictKey(_scan) {
							filters := _root.Filters
							leftFilter, rightFilter, itemToReplace, ok := _e.funcs.SplitDisjunction(scanPrivate, filters)
							if ok {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunctionAddKey) {
									leftScanPrivate := _e.funcs.DuplicateScanPrivate(scanPrivate)
									leftScan := _e.f.ConstructScan(
										_e.funcs.AddPrimaryKeyColsToScanPrivate(leftScanPrivate),
									)
									rightScanPrivate := _e.funcs.DuplicateScanPrivate(scanPrivate)
									rightScan := _e.f.ConstructScan(
										_e.funcs.AddPrimaryKeyColsToScanPrivate(rightScanPrivate),
									)
									_expr := &memo.ProjectExpr{
										Input: _e.f.ConstructUnion(
											_e.f.ConstructSelect(
												leftScan,
												_e.funcs.RemapScanColsInFilter(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, leftFilter), scanPrivate, leftScanPrivate),
											),
											_e.f.ConstructSelect(
												rightScan,
												_e.funcs.RemapScanColsInFilter(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, rightFilter), scanPrivate, rightScanPrivate),
											),
											_e.funcs.MakeSetPrivate(_e.funcs.OutputCols(leftScan), _e.funcs.OutputCols(rightScan), _e.funcs.UnionCols(_e.funcs.OutputCols(_scan), _e.funcs.PrimaryKeyCols(_e.funcs.TableIDFromScanPrivate(scanPrivate)))),
										),
										Projections: memo.EmptyProjectionsExpr,
										Passthrough: _e.funcs.OutputCols(_scan),
									}
									_interned := _e.mem.AddProjectToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.SplitDisjunctionAddKey, _root, nil)
										} else {
											_e.o.appliedRule(opt.SplitDisjunctionAddKey, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreProject(
	_rootState *exploreState,
	_root *memo.ProjectExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ConvertParameterizedLookupJoinToPlaceholderScan]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_lookupJoin, _ := _member.(*memo.LookupJoinExpr)
			if _lookupJoin != nil {
				values := _lookupJoin.Input
				_state := _e.lookupExploreState(values)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = values.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					values = _member
					if !_partlyExplored || _ord >= _state.start {
						_values, _ := _member.(*memo.ValuesExpr)
						if _values != nil {
							if len(_values.Rows) == 1 {
								_item := _values.Rows[0]
								_tuple, _ := _item.(*memo.TupleExpr)
								if _tuple != nil {
									row := _tuple.Elems
									if len(_lookupJoin.On) == 0 {
										lookupPrivate := &_lookupJoin.LookupJoinPrivate
										if len(_root.Projections) == 0 {
											outputCols := _root.Passthrough
											if _e.funcs.GenericRulesEnabled() {
												if _e.funcs.HasPlaceholdersOrStableExprs(_values) {
													span, scanPrivate, ok := _e.funcs.PlaceholderScanSpanAndPrivate(lookupPrivate, _values, row, outputCols)
													if ok {
														if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConvertParameterizedLookupJoinToPlaceholderScan) {
															_expr := &memo.PlaceholderScanExpr{
																Span:        span,
																ScanPrivate: *scanPrivate,
															}
															_interned := _e.mem.AddPlaceholderScanToGroup(_expr, _root)
															if _e.o.appliedRule != nil {
																if _interned != _expr {
																	_e.o.appliedRule(opt.ConvertParameterizedLookupJoinToPlaceholderScan, _root, nil)
																} else {
																	_e.o.appliedRule(opt.ConvertParameterizedLookupJoinToPlaceholderScan, _root, _interned)
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinInsideProject]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					projections := _root.Projections
					passthrough := _root.Passthrough
					if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(_e.funcs.ProjectionOuterCols(projections), passthrough), _e.funcs.OutputCols(input)) {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinInsideProject) {
							_expr := &memo.ProjectExpr{
								Input:       input,
								Projections: projections,
								Passthrough: passthrough,
							}
							_interned := _e.mem.AddProjectToGroup(_expr, _root)
							if _e.o.appliedRule != nil {
								if _interned != _expr {
									_e.o.appliedRule(opt.EliminateIndexJoinInsideProject, _root, nil)
								} else {
									_e.o.appliedRule(opt.EliminateIndexJoinInsideProject, _root, _interned)
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreInnerJoin(
	_rootState *exploreState,
	_root *memo.InnerJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root, _required)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitDisjunctionOfJoinTerms]
	{
		if _rootOrd >= _rootState.start {
			on := _root.On
			firstOnClause, secondOnClause, itemToReplace, ok := _e.funcs.CanSplitJoinWithDisjuncts(_root, on)
			if ok {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunctionOfJoinTerms) {
					firstJoin, secondJoin, newRelationCols, aggCols, groupingCols := _e.funcs.SplitJoinWithDisjuncts(_root, on, firstOnClause, secondOnClause, itemToReplace)
					firstJoinCols := _e.funcs.OutputCols(firstJoin)
					secondJoinCols := _e.funcs.OutputCols(secondJoin)
					_expr := &memo.ProjectExpr{
						Input: _e.f.ConstructDistinctOn(
							_e.f.ConstructUnionAll(
								firstJoin,
								secondJoin,
								_e.funcs.MakeSetPrivate(firstJoinCols, secondJoinCols, newRelationCols),
							),
							_e.funcs.MakeAggCols(opt.ConstAggOp, aggCols),
							_e.funcs.MakeGrouping(groupingCols, _e.funcs.EmptyOrdering()),
						),
						Projections: memo.EmptyProjectionsExpr,
						Passthrough: _e.funcs.OutputCols(_root),
					}
					_interned := _e.mem.AddProjectToGroup(_expr, _root)
					if _e.o.appliedRule != nil {
						if _interned != _expr {
							_e.o.appliedRule(opt.SplitDisjunctionOfJoinTerms, _root, nil)
						} else {
							_e.o.appliedRule(opt.SplitDisjunctionOfJoinTerms, _root, _interned)
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, _required, opt.InnerJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, _required, opt.InnerJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, _required, opt.InnerJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, _required, opt.InnerJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, _required, opt.InnerJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualCols]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								virtualCols := _e.funcs.VirtualColumns(scanPrivate)
								if !_e.funcs.ColsAreEmpty(virtualCols) {
									projections := _project.Projections
									projectedVirtualCols := _e.funcs.ProjectionCols(projections)
									if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
										on := _root.On
										if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
											private := &_root.JoinPrivate
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualCols) {
												var _last memo.RelExpr
												if _e.o.appliedRule != nil {
													_last = memo.LastGroupMember(_root)
												}
												_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.InnerJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, on, private)
												if _e.o.appliedRule != nil {
													_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualCols, _root, _last.NextExpr())
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualColsAndFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					_partlyExplored := _partlyExplored && _ord < _state.start
					_select, _ := _member.(*memo.SelectExpr)
					if _select != nil {
						_state := _e.lookupExploreState(_select.Input)
						if !_state.fullyExplored {
							_fullyExplored = false
						}
						var _member memo.RelExpr
						for _ord := 0; _ord < _state.end; _ord++ {
							if _member == nil {
								_member = _select.Input.FirstExpr()
							} else {
								_member = _member.NextExpr()
							}
							if !_partlyExplored || _ord >= _state.start {
								_scan, _ := _member.(*memo.ScanExpr)
								if _scan != nil {
									scanPrivate := &_scan.ScanPrivate
									if _e.funcs.IsCanonicalScan(scanPrivate) {
										virtualCols := _e.funcs.VirtualColumns(scanPrivate)
										if !_e.funcs.ColsAreEmpty(virtualCols) {
											filters := _select.Filters
											projections := _project.Projections
											projectedVirtualCols := _e.funcs.ProjectionCols(projections)
											if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
												on := _root.On
												if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
													private := &_root.JoinPrivate
													if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter) {
														var _last memo.RelExpr
														if _e.o.appliedRule != nil {
															_last = memo.LastGroupMember(_root)
														}
														_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.InnerJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
														if _e.o.appliedRule != nil {
															_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter, _root, _last.NextExpr())
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushJoinIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(left)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = left.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			left = _member
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					indexInput := _indexJoin.Input
					indexPrivate := &_indexJoin.IndexJoinPrivate
					right := _root.Right
					if !_e.funcs.HasOuterCols(right) {
						on := _root.On
						if _e.funcs.FiltersBoundBy(on, _e.funcs.OutputCols2(indexInput, right)) {
							joinPrivate := &_root.JoinPrivate
							if _e.funcs.NoJoinHints(joinPrivate) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushJoinIntoIndexJoin) {
									_expr := &memo.LookupJoinExpr{
										Input: _e.f.ConstructInnerJoin(
											indexInput,
											right,
											on,
											joinPrivate,
										),
										On:                memo.EmptyFiltersExpr,
										LookupJoinPrivate: *_e.funcs.ConvertIndexToLookupJoinPrivate(indexPrivate, _e.funcs.OutputCols2(_indexJoin, right)),
									}
									_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushJoinIntoIndexJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushJoinIntoIndexJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [HoistProjectFromInnerJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		proj := _root.Right
		_state := _e.lookupExploreState(proj)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = proj.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			proj = _member
			if !_partlyExplored || _ord >= _state.start {
				_project, _ := _member.(*memo.ProjectExpr)
				if _project != nil {
					right := _project.Input
					if _e.funcs.CanHoistProjectInput(right) {
						projections := _project.Projections
						if !_e.funcs.HasVolatileProjection(projections) {
							passthrough := _project.Passthrough
							on := _root.On
							if !_e.funcs.ColsIntersect(_e.funcs.ProjectionCols(projections), _e.funcs.FilterOuterCols(on)) {
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.HoistProjectFromInnerJoin) {
									_expr := &memo.ProjectExpr{
										Input: _e.f.ConstructInnerJoin(
											left,
											right,
											on,
											private,
										),
										Projections: projections,
										Passthrough: _e.funcs.UnionCols(passthrough, _e.funcs.OutputCols(left)),
									}
									_interned := _e.mem.AddProjectToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.HoistProjectFromInnerJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.HoistProjectFromInnerJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLeftJoin(
	_rootState *exploreState,
	_root *memo.LeftJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root, _required)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [CommuteLeftJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.CommuteLeftJoin) {
				_expr := &memo.RightJoinExpr{
					Left:        right,
					Right:       left,
					On:          on,
					JoinPrivate: *_e.funcs.CommuteJoinFlags(private),
				}
				_interned := _e.mem.AddRightJoinToGroup(_expr, _root)
				if _e.o.appliedRule != nil {
					if _interned != _expr {
						_e.o.appliedRule(opt.CommuteLeftJoin, _root, nil)
					} else {
						_e.o.appliedRule(opt.CommuteLeftJoin, _root, _interned)
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, _required, opt.LeftJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, _required, opt.LeftJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, _required, opt.LeftJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, _required, opt.LeftJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, _required, opt.LeftJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualCols]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								virtualCols := _e.funcs.VirtualColumns(scanPrivate)
								if !_e.funcs.ColsAreEmpty(virtualCols) {
									projections := _project.Projections
									projectedVirtualCols := _e.funcs.ProjectionCols(projections)
									if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
										on := _root.On
										if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
											private := &_root.JoinPrivate
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualCols) {
												var _last memo.RelExpr
												if _e.o.appliedRule != nil {
													_last = memo.LastGroupMember(_root)
												}
												_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.LeftJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, on, private)
												if _e.o.appliedRule != nil {
													_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualCols, _root, _last.NextExpr())
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualColsAndFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					_partlyExplored := _partlyExplored && _ord < _state.start
					_select, _ := _member.(*memo.SelectExpr)
					if _select != nil {
						_state := _e.lookupExploreState(_select.Input)
						if !_state.fullyExplored {
							_fullyExplored = false
						}
						var _member memo.RelExpr
						for _ord := 0; _ord < _state.end; _ord++ {
							if _member == nil {
								_member = _select.Input.FirstExpr()
							} else {
								_member = _member.NextExpr()
							}
							if !_partlyExplored || _ord >= _state.start {
								_scan, _ := _member.(*memo.ScanExpr)
								if _scan != nil {
									scanPrivate := &_scan.ScanPrivate
									if _e.funcs.IsCanonicalScan(scanPrivate) {
										virtualCols := _e.funcs.VirtualColumns(scanPrivate)
										if !_e.funcs.ColsAreEmpty(virtualCols) {
											filters := _select.Filters
											projections := _project.Projections
											projectedVirtualCols := _e.funcs.ProjectionCols(projections)
											if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
												on := _root.On
												if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
													private := &_root.JoinPrivate
													if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter) {
														var _last memo.RelExpr
														if _e.o.appliedRule != nil {
															_last = memo.LastGroupMember(_root)
														}
														_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.LeftJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
														if _e.o.appliedRule != nil {
															_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter, _root, _last.NextExpr())
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [HoistProjectFromLeftJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_project, _ := _member.(*memo.ProjectExpr)
				if _project != nil {
					right := _project.Input
					if _e.funcs.CanHoistProjectInput(right) {
						projections := _project.Projections
						if !_e.funcs.HasVolatileProjection(projections) {
							passthrough := _project.Passthrough
							on := _root.On
							if !_e.funcs.ColsIntersect(_e.funcs.ProjectionCols(projections), _e.funcs.FilterOuterCols(on)) {
								canaryCol := _e.funcs.FindLeftJoinCanaryColumn(right, on)
								if _e.funcs.FoundCanaryColumn(canaryCol) {
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.HoistProjectFromLeftJoin) {
										_expr := &memo.ProjectExpr{
											Input: _e.f.ConstructLeftJoin(
												left,
												right,
												on,
												private,
											),
											Projections: _e.funcs.MakeProjectionsForOuterJoin(canaryCol, projections),
											Passthrough: _e.funcs.UnionCols(passthrough, _e.funcs.OutputCols(left)),
										}
										_interned := _e.mem.AddProjectToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.HoistProjectFromLeftJoin, _root, nil)
											} else {
												_e.o.appliedRule(opt.HoistProjectFromLeftJoin, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreRightJoin(
	_rootState *exploreState,
	_root *memo.RightJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, _required, opt.RightJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreFullJoin(
	_rootState *exploreState,
	_root *memo.FullJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root, _required)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, _required, opt.FullJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSemiJoin(
	_rootState *exploreState,
	_root *memo.SemiJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root, _required)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [CommuteSemiJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if _e.funcs.IsSimpleEquality(on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.CommuteSemiJoin) {
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructInnerJoin(
								left,
								_e.f.ConstructDistinctOn(
									right,
									memo.EmptyAggregationsExpr,
									_e.funcs.MakeGrouping(_e.funcs.IntersectionCols(_e.funcs.OutputCols(right), _e.funcs.FilterOuterCols(on)), _e.funcs.EmptyOrdering()),
								),
								on,
								private,
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.CommuteSemiJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.CommuteSemiJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [ConvertSemiToInnerJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if !_e.funcs.IsSimpleEquality(on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConvertSemiToInnerJoin) {
						newLeft := _e.funcs.EnsureKey(left)
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructDistinctOn(
								_e.f.ConstructInnerJoin(
									newLeft,
									right,
									on,
									private,
								),
								_e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.NonKeyCols(newLeft)),
								_e.funcs.MakeGrouping(_e.funcs.KeyCols(newLeft), _e.funcs.EmptyOrdering()),
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.ConvertSemiToInnerJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.ConvertSemiToInnerJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunctionOfJoinTerms]
	{
		if _rootOrd >= _rootState.start {
			on := _root.On
			firstOnClause, secondOnClause, itemToReplace, ok := _e.funcs.CanSplitJoinWithDisjuncts(_root, on)
			if ok {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunctionOfJoinTerms) {
					firstJoin, secondJoin, newRelationCols, aggCols, groupingCols := _e.funcs.SplitJoinWithDisjuncts(_root, on, firstOnClause, secondOnClause, itemToReplace)
					firstJoinCols := _e.funcs.OutputCols(firstJoin)
					secondJoinCols := _e.funcs.OutputCols(secondJoin)
					_expr := &memo.ProjectExpr{
						Input: _e.f.ConstructDistinctOn(
							_e.f.ConstructUnionAll(
								firstJoin,
								secondJoin,
								_e.funcs.MakeSetPrivate(firstJoinCols, secondJoinCols, newRelationCols),
							),
							_e.funcs.MakeAggCols(opt.ConstAggOp, aggCols),
							_e.funcs.MakeGrouping(groupingCols, _e.funcs.EmptyOrdering()),
						),
						Projections: memo.EmptyProjectionsExpr,
						Passthrough: _e.funcs.OutputCols(_root),
					}
					_interned := _e.mem.AddProjectToGroup(_expr, _root)
					if _e.o.appliedRule != nil {
						if _interned != _expr {
							_e.o.appliedRule(opt.SplitDisjunctionOfJoinTerms, _root, nil)
						} else {
							_e.o.appliedRule(opt.SplitDisjunctionOfJoinTerms, _root, _interned)
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, _required, opt.SemiJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, _required, opt.SemiJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, _required, opt.SemiJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, _required, opt.SemiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, _required, opt.SemiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualCols]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								virtualCols := _e.funcs.VirtualColumns(scanPrivate)
								if !_e.funcs.ColsAreEmpty(virtualCols) {
									projections := _project.Projections
									projectedVirtualCols := _e.funcs.ProjectionCols(projections)
									if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
										on := _root.On
										if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
											private := &_root.JoinPrivate
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualCols) {
												var _last memo.RelExpr
												if _e.o.appliedRule != nil {
													_last = memo.LastGroupMember(_root)
												}
												_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.SemiJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, on, private)
												if _e.o.appliedRule != nil {
													_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualCols, _root, _last.NextExpr())
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualColsAndFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					_partlyExplored := _partlyExplored && _ord < _state.start
					_select, _ := _member.(*memo.SelectExpr)
					if _select != nil {
						_state := _e.lookupExploreState(_select.Input)
						if !_state.fullyExplored {
							_fullyExplored = false
						}
						var _member memo.RelExpr
						for _ord := 0; _ord < _state.end; _ord++ {
							if _member == nil {
								_member = _select.Input.FirstExpr()
							} else {
								_member = _member.NextExpr()
							}
							if !_partlyExplored || _ord >= _state.start {
								_scan, _ := _member.(*memo.ScanExpr)
								if _scan != nil {
									scanPrivate := &_scan.ScanPrivate
									if _e.funcs.IsCanonicalScan(scanPrivate) {
										virtualCols := _e.funcs.VirtualColumns(scanPrivate)
										if !_e.funcs.ColsAreEmpty(virtualCols) {
											filters := _select.Filters
											projections := _project.Projections
											projectedVirtualCols := _e.funcs.ProjectionCols(projections)
											if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
												on := _root.On
												if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
													private := &_root.JoinPrivate
													if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter) {
														var _last memo.RelExpr
														if _e.o.appliedRule != nil {
															_last = memo.LastGroupMember(_root)
														}
														_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.SemiJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
														if _e.o.appliedRule != nil {
															_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter, _root, _last.NextExpr())
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreAntiJoin(
	_rootState *exploreState,
	_root *memo.AntiJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root, _required)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitDisjunctionOfAntiJoinTerms]
	{
		if _rootOrd >= _rootState.start {
			on := _root.On
			firstOnClause, secondOnClause, itemToReplace, ok := _e.funcs.CanSplitJoinWithDisjuncts(_root, on)
			if ok {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunctionOfAntiJoinTerms) {
					firstJoin, secondJoin, newRelationCols, aggCols, groupingCols := _e.funcs.SplitJoinWithDisjuncts(_root, on, firstOnClause, secondOnClause, itemToReplace)
					firstJoinCols := _e.funcs.OutputCols(firstJoin)
					secondJoinCols := _e.funcs.OutputCols(secondJoin)
					_expr := &memo.ProjectExpr{
						Input: _e.f.ConstructDistinctOn(
							_e.f.ConstructIntersectAll(
								firstJoin,
								secondJoin,
								_e.funcs.MakeSetPrivate(firstJoinCols, secondJoinCols, newRelationCols),
							),
							_e.funcs.MakeAggCols(opt.ConstAggOp, aggCols),
							_e.funcs.MakeGrouping(groupingCols, _e.funcs.EmptyOrdering()),
						),
						Projections: memo.EmptyProjectionsExpr,
						Passthrough: _e.funcs.OutputCols(_root),
					}
					_interned := _e.mem.AddProjectToGroup(_expr, _root)
					if _e.o.appliedRule != nil {
						if _interned != _expr {
							_e.o.appliedRule(opt.SplitDisjunctionOfAntiJoinTerms, _root, nil)
						} else {
							_e.o.appliedRule(opt.SplitDisjunctionOfAntiJoinTerms, _root, _interned)
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, _required, opt.AntiJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, _required, opt.AntiJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, _required, opt.AntiJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, _required, opt.AntiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, _required, opt.AntiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualCols]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								virtualCols := _e.funcs.VirtualColumns(scanPrivate)
								if !_e.funcs.ColsAreEmpty(virtualCols) {
									projections := _project.Projections
									projectedVirtualCols := _e.funcs.ProjectionCols(projections)
									if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
										on := _root.On
										if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
											private := &_root.JoinPrivate
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualCols) {
												var _last memo.RelExpr
												if _e.o.appliedRule != nil {
													_last = memo.LastGroupMember(_root)
												}
												_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.AntiJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, on, private)
												if _e.o.appliedRule != nil {
													_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualCols, _root, _last.NextExpr())
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualColsAndFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					_partlyExplored := _partlyExplored && _ord < _state.start
					_select, _ := _member.(*memo.SelectExpr)
					if _select != nil {
						_state := _e.lookupExploreState(_select.Input)
						if !_state.fullyExplored {
							_fullyExplored = false
						}
						var _member memo.RelExpr
						for _ord := 0; _ord < _state.end; _ord++ {
							if _member == nil {
								_member = _select.Input.FirstExpr()
							} else {
								_member = _member.NextExpr()
							}
							if !_partlyExplored || _ord >= _state.start {
								_scan, _ := _member.(*memo.ScanExpr)
								if _scan != nil {
									scanPrivate := &_scan.ScanPrivate
									if _e.funcs.IsCanonicalScan(scanPrivate) {
										virtualCols := _e.funcs.VirtualColumns(scanPrivate)
										if !_e.funcs.ColsAreEmpty(virtualCols) {
											filters := _select.Filters
											projections := _project.Projections
											projectedVirtualCols := _e.funcs.ProjectionCols(projections)
											if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
												on := _root.On
												if _e.funcs.ColsIntersect(projectedVirtualCols, _e.funcs.FilterOuterCols(on)) {
													private := &_root.JoinPrivate
													if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter) {
														var _last memo.RelExpr
														if _e.o.appliedRule != nil {
															_last = memo.LastGroupMember(_root)
														}
														_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, _required, opt.AntiJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
														if _e.o.appliedRule != nil {
															_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter, _root, _last.NextExpr())
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLookupJoin(
	_rootState *exploreState,
	_root *memo.LookupJoinExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateLocalityOptimizedAntiJoin]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			on := _root.On
			private := &_root.LookupJoinPrivate
			if _e.funcs.IsAntiJoin(private) {
				localExpr, remoteExpr, ok := _e.funcs.GetLocalityOptimizedLookupJoinExprs(on, private)
				if ok {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedAntiJoin) {
						_expr := &memo.LookupJoinExpr{
							Input: _e.f.ConstructLookupJoin(
								input,
								on,
								_e.funcs.CreateLocalityOptimizedLookupJoinPrivateIncludingCols(localExpr, _e.funcs.EmptyFiltersExpr(), private, _e.funcs.OutputCols(input)),
							),
							On:                on,
							LookupJoinPrivate: *_e.funcs.CreateRemoteOnlyLookupJoinPrivate(remoteExpr, private),
						}
						_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.GenerateLocalityOptimizedAntiJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.GenerateLocalityOptimizedAntiJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLocalityOptimizedLookupJoin]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			if !_e.funcs.IsSelectFromRemoteTableRowsOnly(input) {
				on := _root.On
				private := &_root.LookupJoinPrivate
				if !_e.funcs.IsAntiJoin(private) {
					localExpr, remoteExpr, ok := _e.funcs.GetLocalityOptimizedLookupJoinExprs(on, private)
					if ok {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedLookupJoin) {
							_expr := &memo.LookupJoinExpr{
								Input:             input,
								On:                on,
								LookupJoinPrivate: *_e.funcs.CreateLocalityOptimizedLookupJoinPrivate(localExpr, remoteExpr, private),
							}
							_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
							if _e.o.appliedRule != nil {
								if _interned != _expr {
									_e.o.appliedRule(opt.GenerateLocalityOptimizedLookupJoin, _root, nil)
								} else {
									_e.o.appliedRule(opt.GenerateLocalityOptimizedLookupJoin, _root, _interned)
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLocalityOptimizedSearchOfLocalityOptimizedJoin]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			if _e.funcs.IsRegionalByRowTableScanOrSelect(input) {
				if _e.funcs.IsCardinalityAboveMaxForLocalityOptimizedScan(input) {
					on := _root.On
					private := &_root.LookupJoinPrivate
					if !_e.funcs.IsAntiJoin(private) {
						localExpr, remoteExpr, ok := _e.funcs.GetLocalityOptimizedLookupJoinExprs(on, private)
						if ok {
							inputScan, inputFilters, ok2 := _e.funcs.CanMaybeGenerateLocalityOptimizedSearchOfLookupJoins(_root)
							if ok2 {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedSearchOfLocalityOptimizedJoin) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLocalityOptimizedSearchOfLookupJoins(_root, _required, _root, inputScan, inputFilters, _e.funcs.CreateLocalityOptimizedLookupJoinPrivate(localExpr, remoteExpr, private))
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLocalityOptimizedSearchOfLocalityOptimizedJoin, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLocalityOptimizedSearchOfLookupJoins]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			if _e.funcs.IsRegionalByRowTableScanOrSelect(input) {
				if _e.funcs.IsCardinalityAboveMaxForLocalityOptimizedScan(input) {
					private := &_root.LookupJoinPrivate
					if !_e.funcs.IsAntiJoin(private) {
						if !_e.funcs.IsLocalityOptimizedJoin(private) {
							inputScan, inputFilters, ok := _e.funcs.CanMaybeGenerateLocalityOptimizedSearchOfLookupJoins(_root)
							if ok {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedSearchOfLookupJoins) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLocalityOptimizedSearchLOJ(_root, _required, _root, inputScan, inputFilters)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLocalityOptimizedSearchOfLookupJoins, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreGroupBy(
	_rootState *exploreState,
	_root *memo.GroupByExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReplaceMinWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggregations := _root.Aggregations
			for i := range aggregations {
				item := &aggregations[i]
				_min, _ := item.Agg.(*memo.MinExpr)
				if _min != nil {
					variable := _min.Input
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						if _e.funcs.IsColNotNull(col, input) {
							if _e.funcs.OtherAggsAreConst(aggregations, item) {
								groupingPrivate := &_root.GroupingPrivate
								if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
									groupingCols := _e.funcs.GroupingCols(groupingPrivate)
									if _e.funcs.ColsAreConst(groupingCols, input) {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceMinWithLimit) {
											var _last memo.RelExpr
											if _e.o.appliedRule != nil {
												_last = memo.LastGroupMember(_root)
											}
											_e.funcs.MakeProjectFromPassthroughAggs(_root, _required, _e.f.ConstructLimit(
												input,
												_e.funcs.IntConst(_e.funcs.DInt(1)),
												_e.funcs.MakeOrderingChoiceFromColumn(opt.MinOp, col),
											), aggregations, groupingCols)
											if _e.o.appliedRule != nil {
												_e.o.appliedRule(opt.ReplaceMinWithLimit, _root, _last.NextExpr())
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ReplaceMaxWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggregations := _root.Aggregations
			for i := range aggregations {
				item := &aggregations[i]
				_max, _ := item.Agg.(*memo.MaxExpr)
				if _max != nil {
					variable := _max.Input
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						if _e.funcs.OtherAggsAreConst(aggregations, item) {
							groupingPrivate := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
								groupingCols := _e.funcs.GroupingCols(groupingPrivate)
								if _e.funcs.ColsAreConst(groupingCols, input) {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceMaxWithLimit) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.MakeProjectFromPassthroughAggs(_root, _required, _e.f.ConstructLimit(
											input,
											_e.funcs.IntConst(_e.funcs.DInt(1)),
											_e.funcs.MakeOrderingChoiceFromColumn(opt.MaxOp, col),
										), aggregations, groupingCols)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.ReplaceMaxWithLimit, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, _required, opt.GroupByOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitGroupByScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			scan = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							aggs := _root.Aggregations
							private := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(private) {
								unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByScanIntoUnionScans) {
										_expr := &memo.GroupByExpr{
											Input:           unionScans,
											Aggregations:    aggs,
											GroupingPrivate: *private,
										}
										_interned := _e.mem.AddGroupByToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitGroupByFilteredScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					scan = _member
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									aggs := _root.Aggregations
									private := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(private) {
										unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
										if ok {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByFilteredScanIntoUnionScans) {
												_expr := &memo.GroupByExpr{
													Input: _e.f.ConstructSelect(
														unionScans,
														filters,
													),
													Aggregations:    aggs,
													GroupingPrivate: *private,
												}
												_interned := _e.mem.AddGroupByToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, nil)
													} else {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.GroupByExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreScalarGroupBy(
	_rootState *exploreState,
	_root *memo.ScalarGroupByExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [ReplaceScalarMinMaxWithScalarSubqueries]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						aggregations := _root.Aggregations
						if _e.funcs.TwoOrMoreMinOrMax(aggregations) {
							groupingPrivate := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceScalarMinMaxWithScalarSubqueries) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.MakeMinMaxScalarSubqueries(_root, _required, scanPrivate, aggregations)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithScalarSubqueries, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ReplaceFilteredScalarMinMaxWithSubqueries]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								aggregations := _root.Aggregations
								if _e.funcs.TwoOrMoreMinOrMax(aggregations) {
									groupingPrivate := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceFilteredScalarMinMaxWithSubqueries) {
											var _last memo.RelExpr
											if _e.o.appliedRule != nil {
												_last = memo.LastGroupMember(_root)
											}
											_e.funcs.MakeMinMaxScalarSubqueriesWithFilter(_root, _required, scanPrivate, aggregations, filters)
											if _e.o.appliedRule != nil {
												_e.o.appliedRule(opt.ReplaceFilteredScalarMinMaxWithSubqueries, _root, _last.NextExpr())
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ReplaceScalarMinMaxWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			if len(_root.Aggregations) == 1 {
				_item := &_root.Aggregations[0]
				agg := _item.Agg
				if agg.Op() == opt.MinOp || agg.Op() == opt.MaxOp {
					variable := agg.Child(0).(opt.ScalarExpr)
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						aggPrivate := _item.Col
						groupingPrivate := &_root.GroupingPrivate
						if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceScalarMinMaxWithLimit) {
								_expr := &memo.ScalarGroupByExpr{
									Input: _e.f.ConstructLimit(
										_e.f.ConstructSelect(
											input,
											memo.FiltersExpr{
												_e.f.ConstructFiltersItem(
													_e.f.ConstructIsNot(
														_variable,
														_e.f.ConstructNull(
															_e.funcs.AnyType(),
														),
													),
												),
											},
										),
										_e.funcs.IntConst(_e.funcs.DInt(1)),
										_e.funcs.MakeOrderingChoiceFromColumn(agg.Op(), col),
									),
									Aggregations: memo.AggregationsExpr{
										_e.f.ConstructAggregationsItem(
											_e.f.ConstructConstAgg(
												_variable,
											),
											aggPrivate,
										),
									},
									GroupingPrivate: *groupingPrivate,
								}
								_interned := _e.mem.AddScalarGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithLimit, _root, nil)
									} else {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithLimit, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.ScalarGroupByExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddScalarGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreDistinctOn(
	_rootState *exploreState,
	_root *memo.DistinctOnExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, _required, opt.DistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitGroupByScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			scan = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							aggs := _root.Aggregations
							private := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(private) {
								unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByScanIntoUnionScans) {
										_expr := &memo.DistinctOnExpr{
											Input:           unionScans,
											Aggregations:    aggs,
											GroupingPrivate: *private,
										}
										_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitGroupByFilteredScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					scan = _member
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									aggs := _root.Aggregations
									private := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(private) {
										unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
										if ok {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByFilteredScanIntoUnionScans) {
												_expr := &memo.DistinctOnExpr{
													Input: _e.f.ConstructSelect(
														unionScans,
														filters,
													),
													Aggregations:    aggs,
													GroupingPrivate: *private,
												}
												_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, nil)
													} else {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.DistinctOnExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreEnsureDistinctOn(
	_rootState *exploreState,
	_root *memo.EnsureDistinctOnExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, _required, opt.EnsureDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreUpsertDistinctOn(
	_rootState *exploreState,
	_root *memo.UpsertDistinctOnExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, _required, opt.UpsertDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreEnsureUpsertDistinctOn(
	_rootState *exploreState,
	_root *memo.EnsureUpsertDistinctOnExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, _required, opt.EnsureUpsertDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitGroupByScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			scan = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							aggs := _root.Aggregations
							private := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(private) {
								unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByScanIntoUnionScans) {
										_expr := &memo.EnsureUpsertDistinctOnExpr{
											Input:           unionScans,
											Aggregations:    aggs,
											GroupingPrivate: *private,
										}
										_interned := _e.mem.AddEnsureUpsertDistinctOnToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitGroupByFilteredScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					scan = _member
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									aggs := _root.Aggregations
									private := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(private) {
										unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
										if ok {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByFilteredScanIntoUnionScans) {
												_expr := &memo.EnsureUpsertDistinctOnExpr{
													Input: _e.f.ConstructSelect(
														unionScans,
														filters,
													),
													Aggregations:    aggs,
													GroupingPrivate: *private,
												}
												_interned := _e.mem.AddEnsureUpsertDistinctOnToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, nil)
													} else {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.EnsureUpsertDistinctOnExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddEnsureUpsertDistinctOnToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreUnion(
	_rootState *exploreState,
	_root *memo.UnionExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, _required, opt.UnionOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreIntersect(
	_rootState *exploreState,
	_root *memo.IntersectExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, _required, opt.IntersectOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreExcept(
	_rootState *exploreState,
	_root *memo.ExceptExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, _required, opt.ExceptOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreIntersectAll(
	_rootState *exploreState,
	_root *memo.IntersectAllExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, _required, opt.IntersectAllOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreExceptAll(
	_rootState *exploreState,
	_root *memo.ExceptAllExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, _required, opt.ExceptAllOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLimit(
	_rootState *exploreState,
	_root *memo.LimitExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateLimitedGroupByScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_groupBy, _ := _member.(*memo.GroupByExpr)
			if _groupBy != nil {
				_state := _e.lookupExploreState(_groupBy.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _groupBy.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								aggs := _groupBy.Aggregations
								groupbyPrivate := &_groupBy.GroupingPrivate
								if _e.funcs.IsCanonicalGroupBy(groupbyPrivate) {
									limitExpr := _root.Limit
									_const, _ := limitExpr.(*memo.ConstExpr)
									if _const != nil {
										limit := _const.Value
										if _e.funcs.IsPositiveInt(limit) {
											ordering := _root.Ordering
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLimitedGroupByScans) {
												var _last memo.RelExpr
												if _e.o.appliedRule != nil {
													_last = memo.LastGroupMember(_root)
												}
												_e.funcs.GenerateLimitedGroupByScans(_root, _required, scanPrivate, aggs, groupbyPrivate, _const, ordering)
												if _e.o.appliedRule != nil {
													_e.o.appliedRule(opt.GenerateLimitedGroupByScans, _root, _last.NextExpr())
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLimitedScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						_const, _ := _root.Limit.(*memo.ConstExpr)
						if _const != nil {
							limit := _const.Value
							if _e.funcs.IsPositiveInt(limit) {
								ordering := _root.Ordering
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLimitedScans) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLimitedScans(_root, _required, scanPrivate, limit, ordering)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLimitedScans, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoFilteredScan]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					_const, _ := _root.Limit.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _e.funcs.IsPositiveInt(limit) {
							ordering := _root.Ordering
							if _e.funcs.CanLimitFilteredScan(scanPrivate, ordering) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoFilteredScan) {
									_expr := &memo.ScanExpr{
										ScanPrivate: *_e.funcs.LimitScanPrivate(scanPrivate, limit, ordering),
									}
									_interned := _e.mem.AddScanToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushLimitIntoFilteredScan, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushLimitIntoFilteredScan, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoProjectFilteredScan]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							projections := _project.Projections
							passthrough := _project.Passthrough
							if _e.funcs.PushLimitIntoProjectFilteredScanEnabled() {
								_const, _ := _root.Limit.(*memo.ConstExpr)
								if _const != nil {
									limit := _const.Value
									if _e.funcs.IsPositiveInt(limit) {
										ordering := _root.Ordering
										if _e.funcs.CanLimitFilteredScan(scanPrivate, ordering) {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoProjectFilteredScan) {
												_expr := &memo.ProjectExpr{
													Input: _e.f.ConstructScan(
														_e.funcs.LimitScanPrivate(scanPrivate, limit, ordering),
													),
													Projections: projections,
													Passthrough: passthrough,
												}
												_interned := _e.mem.AddProjectToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.PushLimitIntoProjectFilteredScan, _root, nil)
													} else {
														_e.o.appliedRule(opt.PushLimitIntoProjectFilteredScan, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					indexJoinPrivate := &_indexJoin.IndexJoinPrivate
					if _e.funcs.IndexJoinPreservesRows(indexJoinPrivate) {
						limitExpr := _root.Limit
						_const, _ := limitExpr.(*memo.ConstExpr)
						if _const != nil {
							limit := _const.Value
							if _e.funcs.IsPositiveInt(limit) {
								ordering := _root.Ordering
								cols := _e.funcs.OutputCols(input)
								if _e.funcs.OrderingCanProjectCols(ordering, cols) {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoIndexJoin) {
										_expr := &memo.IndexJoinExpr{
											Input: _e.f.ConstructLimit(
												input,
												_const,
												_e.funcs.PruneOrdering(ordering, cols),
											),
											IndexJoinPrivate: *indexJoinPrivate,
										}
										_interned := _e.mem.AddIndexJoinToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.PushLimitIntoIndexJoin, _root, nil)
											} else {
												_e.o.appliedRule(opt.PushLimitIntoIndexJoin, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitLimitedScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			scan = _member
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							limitExpr := _root.Limit
							_const, _ := limitExpr.(*memo.ConstExpr)
							if _const != nil {
								limit := _const.Value
								if _e.funcs.IsPositiveInt(limit) {
									ordering := _root.Ordering
									unionScans, ok := _e.funcs.SplitLimitedScanIntoUnionScans(ordering, _scan, scanPrivate, limit)
									if ok {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitLimitedScanIntoUnionScans) {
											_expr := &memo.LimitExpr{
												Input:    unionScans,
												Limit:    _const,
												Ordering: ordering,
											}
											_interned := _e.mem.AddLimitToGroup(_expr, _root)
											if _e.o.appliedRule != nil {
												if _interned != _expr {
													_e.o.appliedRule(opt.SplitLimitedScanIntoUnionScans, _root, nil)
												} else {
													_e.o.appliedRule(opt.SplitLimitedScanIntoUnionScans, _root, _interned)
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitLimitedSelectIntoUnionSelects]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					scan = _member
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									limitExpr := _root.Limit
									_const, _ := limitExpr.(*memo.ConstExpr)
									if _const != nil {
										limit := _const.Value
										if _e.funcs.IsPositiveInt(limit) {
											ordering := _root.Ordering
											unionScans, ok := _e.funcs.SplitLimitedSelectIntoUnionScansOrSelects(ordering, _scan, scanPrivate, limit, filters)
											if ok {
												if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitLimitedSelectIntoUnionSelects) {
													_expr := &memo.LimitExpr{
														Input:    unionScans,
														Limit:    _const,
														Ordering: ordering,
													}
													_interned := _e.mem.AddLimitToGroup(_expr, _root)
													if _e.o.appliedRule != nil {
														if _interned != _expr {
															_e.o.appliedRule(opt.SplitLimitedSelectIntoUnionSelects, _root, nil)
														} else {
															_e.o.appliedRule(opt.SplitLimitedSelectIntoUnionSelects, _root, _interned)
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateTopK]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			limitExpr := _root.Limit
			_const, _ := limitExpr.(*memo.ConstExpr)
			if _const != nil {
				limit := _const.Value
				if _e.funcs.IsPositiveInt(limit) {
					ordering := _root.Ordering
					if !_e.funcs.IsSameOrdering(ordering, _e.funcs.EmptyOrdering()) {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateTopK) {
							_expr := &memo.TopKExpr{
								Input:       input,
								TopKPrivate: *_e.funcs.MakeTopKPrivate(limit, ordering),
							}
							_interned := _e.mem.AddTopKToGroup(_expr, _root)
							if _e.o.appliedRule != nil {
								if _interned != _expr {
									_e.o.appliedRule(opt.GenerateTopK, _root, nil)
								} else {
									_e.o.appliedRule(opt.GenerateTopK, _root, _interned)
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateStreamingGroupByLimitOrderingHint]
	{
		_partlyExplored := _rootOrd < _rootState.start
		aggregation := _root.Input
		_state := _e.lookupExploreState(aggregation)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = aggregation.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			aggregation = _member
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.GroupByOp || _member.Op() == opt.DistinctOnOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := *_member.Child(1).(*memo.AggregationsExpr)
					private := _member.Private().(*memo.GroupingPrivate)
					if _e.funcs.IsCanonicalGroupBy(private) {
						_const, _ := _root.Limit.(*memo.ConstExpr)
						if _const != nil {
							limit := _const.Value
							if _e.funcs.IsPositiveInt(limit) {
								ordering := _root.Ordering
								groupingCols, newOrdering, ok := _e.funcs.GroupingColsClosureOverlappingOrdering(input, private, ordering)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupByLimitOrderingHint) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateStreamingGroupByLimitOrderingHint(_root, _required, _root, aggregation, input, aggs, private, groupingCols, newOrdering)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateStreamingGroupByLimitOrderingHint, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateVectorSearch]
	{
		_partlyExplored := _rootOrd < _rootState.start
		project := _root.Input
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			project = _member
			if !_partlyExplored || _ord >= _state.start {
				_project, _ := _member.(*memo.ProjectExpr)
				if _project != nil {
					input := _project.Input
					scan, filters, ok := _e.funcs.GetFilteredCanonicalScan(input)
					if ok {
						projections := _project.Projections
						for i := range projections {
							_item := &projections[i]
							distOp := _item.Element
							if distOp.Op() == opt.VectorDistanceOp || distOp.Op() == opt.VectorCosDistanceOp || distOp.Op() == opt.VectorNegInnerProductOp {
								_variable, _ := distOp.Child(0).(opt.ScalarExpr).(*memo.VariableExpr)
								if _variable != nil {
									vectorCol := _variable.Col
									if _e.funcs.IsFixedWidthVectorCol(vectorCol) {
										queryVector := distOp.Child(1).(opt.ScalarExpr)
										if queryVector.Op() == opt.ConstOp || queryVector.Op() == opt.PlaceholderOp {
											distanceCol := _item.Col
											passthrough := _project.Passthrough
											if !_e.funcs.HasOuterCols(_project) {
												_const, _ := _root.Limit.(*memo.ConstExpr)
												if _const != nil {
													limit := _const.Value
													if _e.funcs.IsPositiveInt(limit) {
														ordering := _root.Ordering
														if _e.funcs.OrderingBySingleColAsc(ordering, distanceCol) {
															if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateVectorSearch) {
																var _last memo.RelExpr
																if _e.o.appliedRule != nil {
																	_last = memo.LastGroupMember(_root)
																}
																_e.funcs.TryGenerateVectorSearch(_root, _required, scan, filters, passthrough, vectorCol, distOp.Op(), queryVector, projections, limit, ordering)
																if _e.o.appliedRule != nil {
																	_e.o.appliedRule(opt.GenerateVectorSearch, _root, _last.NextExpr())
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreOffset(
	_rootState *exploreState,
	_root *memo.OffsetExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [PushOffsetIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					indexJoinPrivate := &_indexJoin.IndexJoinPrivate
					if _e.funcs.CanPushOffsetIntoIndexJoin() {
						if _e.funcs.IndexJoinPreservesRows(indexJoinPrivate) {
							offsetExpr := _root.Offset
							_const, _ := offsetExpr.(*memo.ConstExpr)
							if _const != nil {
								offset := _const.Value
								if _e.funcs.IsPositiveInt(offset) {
									ordering := _root.Ordering
									cols := _e.funcs.OutputCols(input)
									if _e.funcs.OrderingCanProjectCols(ordering, cols) {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushOffsetIntoIndexJoin) {
											_expr := &memo.IndexJoinExpr{
												Input: _e.f.ConstructOffset(
													input,
													_const,
													_e.funcs.PruneOrdering(ordering, cols),
												),
												IndexJoinPrivate: *indexJoinPrivate,
											}
											_interned := _e.mem.AddIndexJoinToGroup(_expr, _root)
											if _e.o.appliedRule != nil {
												if _interned != _expr {
													_e.o.appliedRule(opt.PushOffsetIntoIndexJoin, _root, nil)
												} else {
													_e.o.appliedRule(opt.PushOffsetIntoIndexJoin, _root, _interned)
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreTopK(
	_rootState *exploreState,
	_root *memo.TopKExpr,
	_rootOrd int,
	_required *physical.Required,
) (_fullyExplored bool) {
	opt.MaybeInjectOptimizerTestingPanic(_e.ctx, _e.evalCtx)
	_fullyExplored = true

	// [GenerateLimitedTopKScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						topKPrivate := &_root.TopKPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLimitedTopKScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLimitedTopKScans(_root, _required, scanPrivate, topKPrivate)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLimitedTopKScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GeneratePartialOrderTopK]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			private := &_root.TopKPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GeneratePartialOrderTopK) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GeneratePartialOrderTopK(_root, _required, input, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GeneratePartialOrderTopK, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}
