// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/data.proto

package roachpb

import (
	bytes "bytes"
	fmt "fmt"
	lock "github.com/cockroachdb/cockroach/pkg/kv/kvserver/concurrency/lock"
	rspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/readsummary/rspb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_storage_enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ValueType defines a set of type constants placed in the "tag" field of Value
// messages. These are defined as a protocol buffer enumeration for historical
// reasons.
type ValueType int32

const (
	// This is a subset of the SQL column type values, representing the underlying
	// storage for various types.
	ValueType_UNKNOWN  ValueType = 0
	ValueType_INT      ValueType = 1
	ValueType_FLOAT    ValueType = 2
	ValueType_BYTES    ValueType = 3
	ValueType_TIME     ValueType = 4
	ValueType_DECIMAL  ValueType = 5
	ValueType_DURATION ValueType = 6
	ValueType_TIMETZ   ValueType = 12
	ValueType_GEO      ValueType = 13
	ValueType_BOX2D    ValueType = 14
	// TUPLE represents a DTuple, encoded as repeated pairs of varint field number
	// followed by a value encoded Datum.
	ValueType_TUPLE    ValueType = 10
	ValueType_BITARRAY ValueType = 11
	// TIMESERIES is applied to values which contain InternalTimeSeriesData.
	ValueType_TIMESERIES ValueType = 100
	// MVCC_EXTENDED_ENCODING_SENTINEL is a sentinel tag value used in the
	// MVCCValue extended encoding to indicate that an encoded Value is wrapped
	// with a header. It should not be used in the Value encoding directly. See
	// MVCCValue for more details.
	ValueType_MVCC_EXTENDED_ENCODING_SENTINEL ValueType = 101
)

var ValueType_name = map[int32]string{
	0:   "UNKNOWN",
	1:   "INT",
	2:   "FLOAT",
	3:   "BYTES",
	4:   "TIME",
	5:   "DECIMAL",
	6:   "DURATION",
	12:  "TIMETZ",
	13:  "GEO",
	14:  "BOX2D",
	10:  "TUPLE",
	11:  "BITARRAY",
	100: "TIMESERIES",
	101: "MVCC_EXTENDED_ENCODING_SENTINEL",
}

var ValueType_value = map[string]int32{
	"UNKNOWN":                         0,
	"INT":                             1,
	"FLOAT":                           2,
	"BYTES":                           3,
	"TIME":                            4,
	"DECIMAL":                         5,
	"DURATION":                        6,
	"TIMETZ":                          12,
	"GEO":                             13,
	"BOX2D":                           14,
	"TUPLE":                           10,
	"BITARRAY":                        11,
	"TIMESERIES":                      100,
	"MVCC_EXTENDED_ENCODING_SENTINEL": 101,
}

func (x ValueType) String() string {
	return proto.EnumName(ValueType_name, int32(x))
}

func (ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{0}
}

// ReplicaChangeType is a parameter of ChangeReplicasTrigger.
type ReplicaChangeType int32

const (
	ADD_VOTER        ReplicaChangeType = 0
	REMOVE_VOTER     ReplicaChangeType = 1
	ADD_NON_VOTER    ReplicaChangeType = 2
	REMOVE_NON_VOTER ReplicaChangeType = 3
)

var ReplicaChangeType_name = map[int32]string{
	0: "ADD_VOTER",
	1: "REMOVE_VOTER",
	2: "ADD_NON_VOTER",
	3: "REMOVE_NON_VOTER",
}

var ReplicaChangeType_value = map[string]int32{
	"ADD_VOTER":        0,
	"REMOVE_VOTER":     1,
	"ADD_NON_VOTER":    2,
	"REMOVE_NON_VOTER": 3,
}

func (x ReplicaChangeType) String() string {
	return proto.EnumName(ReplicaChangeType_name, int32(x))
}

func (ReplicaChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{1}
}

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of PREPARED, STAGING, COMMITTED, or
	// ABORTED. Mutations made as part of a PENDING transactions are
	// recorded as "intents" in the underlying MVCC model.
	PENDING TransactionStatus = 0
	// PREPARED is the state for a transaction which has been prepared as
	// part of the XA two-phase commit protocol. Transactions in state
	// PREPARED can be subsequently moved to either state COMMITTED or
	// ABORTED. Once a transaction is in state PREPARED, it is guaranteed
	// to be able to commit if the coordinator node decides to do so;
	// conflicting transactions cannot prevent it from doing so by pushing
	// it to a higher timestamp or aborting it.
	PREPARED TransactionStatus = 4
	// STAGING is the state for a transaction which has issued all of
	// its writes and is in the process of committing. Mutations made
	// as part of a transaction in this state may still be in-flight
	// and can not be assumed to have succeeded. A transaction may
	// transition from the STAGING to the COMMITTED state only if all
	// of its in-flight mutations are confirmed to have succeeded. A
	// transaction may transition from the STAGING to PENDING or ABORTED
	// state only if one of its in-flight requests is prevented from ever
	// succeeding.
	STAGING TransactionStatus = 3
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	4: "PREPARED",
	3: "STAGING",
	1: "COMMITTED",
	2: "ABORTED",
}

var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"PREPARED":  4,
	"STAGING":   3,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}

func (TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{2}
}

// LeaseAcquisitionType indicates the type of lease acquisition event that
// resulted in the current lease.
type LeaseAcquisitionType int32

const (
	LeaseAcquisitionType_Unspecified LeaseAcquisitionType = 0
	// Transfer indicates that the current lease is a result of a (co-operative)
	// lease transfer.
	LeaseAcquisitionType_Transfer LeaseAcquisitionType = 1
	// Request indicates that the current lease is a result of a (non-cooperative)
	// lease request.
	LeaseAcquisitionType_Request LeaseAcquisitionType = 2
)

var LeaseAcquisitionType_name = map[int32]string{
	0: "Unspecified",
	1: "Transfer",
	2: "Request",
}

var LeaseAcquisitionType_value = map[string]int32{
	"Unspecified": 0,
	"Transfer":    1,
	"Request":     2,
}

func (x LeaseAcquisitionType) String() string {
	return proto.EnumName(LeaseAcquisitionType_name, int32(x))
}

func (LeaseAcquisitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{3}
}

// RangeClosedTimestampPolicy represents the policy used by the leaseholder of a
// range to establish and publish closed timestamps. The policy dictates how far
// in the past (lag) or in the future (lead) MVCC history is closed off.
type RangeClosedTimestampPolicy int32

const (
	// LAG_BY_CLUSTER_SETTING indicates that the range's closed timestamp is
	// configured to lag behind present time by the value configured for the
	// `kv.closed_timestamp.target_duration` cluster setting.
	LAG_BY_CLUSTER_SETTING RangeClosedTimestampPolicy = 0
	// LEAD_FOR_GLOBAL_READS indicates that the range's closed timestamp is
	// configured to lead present time such that all followers of the range are
	// able to serve consistent, present time reads. Because the policy describes
	// a goal and not the lead time itself, the lead time is allowed vary as a
	// function of maximum clock uncertainty and closed timestamp propagation time
	// (which itself is a function of leaseholder -> follower network latency and
	// closed timestamp update periodicity).
	LEAD_FOR_GLOBAL_READS RangeClosedTimestampPolicy = 1
	// Keep this sentinel value higher than the rest.
	MAX_CLOSED_TIMESTAMP_POLICY RangeClosedTimestampPolicy = 2
)

var RangeClosedTimestampPolicy_name = map[int32]string{
	0: "LAG_BY_CLUSTER_SETTING",
	1: "LEAD_FOR_GLOBAL_READS",
	2: "MAX_CLOSED_TIMESTAMP_POLICY",
}

var RangeClosedTimestampPolicy_value = map[string]int32{
	"LAG_BY_CLUSTER_SETTING":      0,
	"LEAD_FOR_GLOBAL_READS":       1,
	"MAX_CLOSED_TIMESTAMP_POLICY": 2,
}

func (x RangeClosedTimestampPolicy) String() string {
	return proto.EnumName(RangeClosedTimestampPolicy_name, int32(x))
}

func (RangeClosedTimestampPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{4}
}

// Span is a key range with an inclusive start Key and an exclusive end Key.
type Span struct {
	// The start key of the key range.
	Key Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The end key of the key range. The value is empty if the key range
	// contains only a single key. Otherwise, it must order strictly after Key.
	// In such a case, the Span encompasses the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey Key `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=Key" json:"end_key,omitempty"`
}

func (m *Span) Reset()      { *m = Span{} }
func (*Span) ProtoMessage() {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{0}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

// Value specifies the value at a key. Multiple values at the same key are
// supported based on timestamp. The data stored within a value is typed
// (ValueType) and custom encoded into the raw_bytes field. A custom encoding
// is used instead of separate proto fields to avoid proto overhead and to
// avoid unnecessary encoding and decoding as the value gets read from disk and
// passed through the network. The format is:
//
//	<4-byte-checksum><1-byte-tag><encoded-data>
//
// A CRC-32-IEEE checksum is computed from the associated key, tag and encoded
// data, in that order.
//
// TODO(peter): Is a 4-byte checksum overkill when most (all?) values
// will be less than 64KB?
type Value struct {
	// raw_bytes contains the encoded value and checksum.
	//
	// Its contents may be modified on the next call to Value.SetFoo.
	RawBytes []byte `protobuf:"bytes,1,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
	// Timestamp of value.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{1}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key   Key   `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Value Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{2}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"cluster_id"`
	NodeID    NodeID                                              `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	StoreID   StoreID                                             `protobuf:"varint,3,opt,name=store_id,json=storeId,proto3,casttype=StoreID" json:"store_id,omitempty"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}
func (*StoreIdent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{3}
}
func (m *StoreIdent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreIdent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreIdent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreIdent.Merge(m, src)
}
func (m *StoreIdent) XXX_Size() int {
	return m.Size()
}
func (m *StoreIdent) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreIdent.DiscardUnknown(m)
}

var xxx_messageInfo_StoreIdent proto.InternalMessageInfo

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated left hand side of the split's
// range descriptor (left_desc) and the new range descriptor covering
// the right hand side of the split (right_desc). This information
// allows the final bookkeeping for the split to be completed and the
// new range put into operation.
type SplitTrigger struct {
	LeftDesc  RangeDescriptor `protobuf:"bytes,1,opt,name=left_desc,json=leftDesc,proto3" json:"left_desc"`
	RightDesc RangeDescriptor `protobuf:"bytes,2,opt,name=right_desc,json=rightDesc,proto3" json:"right_desc"`
	// Pre-computed stats for the LHS spans corresponding to user data.
	// Used in splitTrigger to estimate the LHS range's MVCC stats.
	PreSplitLeftUserStats enginepb.MVCCStats `protobuf:"bytes,5,opt,name=pre_split_left_user_stats,json=preSplitLeftUserStats,proto3" json:"pre_split_left_user_stats"`
	// Pre-computed stats for the entire range.
	// Used in splitTrigger to fall back to accurate stats computation if these
	// pre-computed stats differ significantly from the stats retrieved from
	// disk while holding latches in splitTrigger.
	PreSplitStats enginepb.MVCCStats `protobuf:"bytes,6,opt,name=pre_split_stats,json=preSplitStats,proto3" json:"pre_split_stats"`
	// UseEstimatesBecauseExternalBytesArePresent is true if we should consider estimating MVCC
	// stats when calculating them in the splitTrigger.
	UseEstimatesBecauseExternalBytesArePresent bool `protobuf:"varint,7,opt,name=use_estimates_because_external_bytes_are_present,json=useEstimatesBecauseExternalBytesArePresent,proto3" json:"use_estimates_because_external_bytes_are_present,omitempty"`
	// ManualSplit indicates that this split is manually triggered via an AdminSplitRequest by a sql client.
	ManualSplit bool `protobuf:"varint,8,opt,name=manualSplit,proto3" json:"manualSplit,omitempty"`
}

func (m *SplitTrigger) Reset()         { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string { return proto.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()    {}
func (*SplitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{4}
}
func (m *SplitTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SplitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitTrigger.Merge(m, src)
}
func (m *SplitTrigger) XXX_Size() int {
	return m.Size()
}
func (m *SplitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_SplitTrigger proto.InternalMessageInfo

// A MergeTrigger is run after a successful commit of an AdminMerge
// command. It provides the updated left hand side of the split's
// range descriptor (left_desc) that now encompasses what was
// originally both ranges and the soon-to-be-invalid range descriptor
// that used to cover the subsumed, right hand side of the merge
// (right_desc). This information allows the final bookkeeping for the
// merge to be completed and put into operation.
type MergeTrigger struct {
	LeftDesc                   RangeDescriptor    `protobuf:"bytes,1,opt,name=left_desc,json=leftDesc,proto3" json:"left_desc"`
	RightDesc                  RangeDescriptor    `protobuf:"bytes,2,opt,name=right_desc,json=rightDesc,proto3" json:"right_desc"`
	RightMVCCStats             enginepb.MVCCStats `protobuf:"bytes,4,opt,name=right_mvcc_stats,json=rightMvccStats,proto3" json:"right_mvcc_stats"`
	RightRangeIDLocalMVCCStats enginepb.MVCCStats `protobuf:"bytes,9,opt,name=right_range_id_local_mvcc_stats,json=rightRangeIdLocalMvccStats,proto3" json:"right_range_id_local_mvcc_stats"`
	// FreezeStart is a timestamp that is guaranteed to be greater than the
	// timestamps at which any requests were serviced by the right-hand side range
	// before it stopped responding to requests altogether (in anticipation of
	// being subsumed). It is suitable for use as the timestamp cache's low water
	// mark for the keys previously owned by the subsumed range, though this role
	// is largely being... subsumed by the RightReadSummary.
	FreezeStart github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=freeze_start,json=freezeStart,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"freeze_start"`
	// right_closed_timestamp is the closed timestamp of the RHS at the moment of
	// the subsumption. Because the SubsumeRequest synchronizes with all other
	// requests, the range's closed timestamp does not advance past the snapshot
	// captured here.
	//
	// Like the freeze_start, this is used by the merged range to conditionally
	// bump the timestamp cache for the keys previously owned by the subsumed
	// range.
	//
	// Note that the closed timestamp is also reflected in the right_read_summary.
	// However, we carry it explicitly too because, in case the leaseholders of
	// the two sides are collocated at merge time, we don't need to use the
	// read_summary and simply use this field.
	RightClosedTimestamp hlc.Timestamp `protobuf:"bytes,6,opt,name=right_closed_timestamp,json=rightClosedTimestamp,proto3" json:"right_closed_timestamp"`
	// RightReadSummary is a summary of the reads that have been performed on the
	// right-hand side up to the point of the Subsume request, which serializes
	// with past reads and begins blocking future reads. It is suitable for use to
	// update the timestamp cache for the keys previously owned by the subsumed
	// range.
	//
	// RightReadSummary can be used in place of FreezeStart, when available. It
	// has two distinct advantages:
	// 1. it can transfer a higher-resolution snapshot of the reads on the range
	//    through a range merge, to make the merge less disruptive to writes on
	//    the post-merge range because the timestamp cache won't be bumped as
	//    high.
	// 2. it can transfer information about reads with future-time timestamps,
	//    which are not otherwise captured by the FreezeStart clock timestamp.
	//
	// When a RightReadSummary is set in ReplicatedEvalResult.Merge.Trigger, there
	// is always also a write to the RangePriorReadSummaryKey in the corresponding
	// RaftCommand.WriteBatch. The persisted summary may be identical to the
	// summary in this field, but it does not have to be. Notably, we intended for
	// the summary included in the ReplicatedEvalResult.Merge.Trigger to
	// eventually be a much higher-resolution version of the ReadSummary than the
	// version persisted. This scheme of persisting a compressed ReadSummary
	// indefinitely and including a higher-resolution ReadSummary on the
	// RaftCommand allows us to optimize for the common case where the merge is
	// applied on the LHS's leaseholder through Raft log application while
	// ensuring correctness in the case where the merge is applied on the LHS's
	// leaseholder through a Raft snapshot.
	RightReadSummary *rspb.ReadSummary `protobuf:"bytes,7,opt,name=right_read_summary,json=rightReadSummary,proto3" json:"right_read_summary,omitempty"`
	// WriteGCHint is a version gate to only enable writing GC hints in merge
	// trigger if cluster was upgraded to required version.
	// TODO(replication): remove this field in the 23.2 cycle (i.e. on master after
	// 23.1 has been cut).
	WriteGCHint bool `protobuf:"varint,8,opt,name=write_gc_hint,json=writeGcHint,proto3" json:"write_gc_hint,omitempty"`
}

func (m *MergeTrigger) Reset()         { *m = MergeTrigger{} }
func (m *MergeTrigger) String() string { return proto.CompactTextString(m) }
func (*MergeTrigger) ProtoMessage()    {}
func (*MergeTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{5}
}
func (m *MergeTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeTrigger.Merge(m, src)
}
func (m *MergeTrigger) XXX_Size() int {
	return m.Size()
}
func (m *MergeTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_MergeTrigger proto.InternalMessageInfo

// ChangeReplicasTrigger carries out a replication change. The Added() and
// Removed() methods return the replicas being added and removed, respectively.
// If more than one change is specified (i.e. len(Added())+len(Removed())
// exceeds one), this initiates an atomic replication change in which the
// "removed" replicas are of type VOTER_OUTGOING or VOTER_DEMOTING_{LEARNER,
// NON_VOTER} (if they are to be turned into learners or non-voters instead); as
// a caveat a single demotion already counts as two changes (and is tracked as a
// Removal() only). This joint configuration is left via another
// ChangeReplicasTrigger which does not specify any additions nor removals.
type ChangeReplicasTrigger struct {
	// The updated range descriptor.
	Desc *RangeDescriptor `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	// The new replicas added to the range descriptor in this change, exactly as
	// they appear in the updated range descriptor.
	//
	// TODO(tbg): rename internal_x_replicas to just x_replicas and remove the getter.
	InternalAddedReplicas []ReplicaDescriptor `protobuf:"bytes,6,rep,name=internal_added_replicas,json=internalAddedReplicas,proto3" json:"internal_added_replicas"`
	// The replicas whose removal is being initiated in this change. If the
	// replica is still present as an outgoing voter in the updated descriptor
	// (i.e. if this is a full atomic replication change), then the replica here
	// must match that in the descriptor; otherwise it must match the replica
	// removed from the descriptor in the course of this change (which is itself
	// not visible to this trigger).
	InternalRemovedReplicas []ReplicaDescriptor `protobuf:"bytes,7,rep,name=internal_removed_replicas,json=internalRemovedReplicas,proto3" json:"internal_removed_replicas"`
}

func (m *ChangeReplicasTrigger) Reset()      { *m = ChangeReplicasTrigger{} }
func (*ChangeReplicasTrigger) ProtoMessage() {}
func (*ChangeReplicasTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{6}
}
func (m *ChangeReplicasTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeReplicasTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangeReplicasTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeReplicasTrigger.Merge(m, src)
}
func (m *ChangeReplicasTrigger) XXX_Size() int {
	return m.Size()
}
func (m *ChangeReplicasTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeReplicasTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeReplicasTrigger proto.InternalMessageInfo

// ModifiedSpanTrigger indicates that a specific span has been modified.
// This can be used to trigger scan-and-gossip for the given span.
type ModifiedSpanTrigger struct {
	// node_liveness_span is set to indicate that node liveness records
	// need re-gossiping after modification or range lease updates. The
	// span is set to a single key when nodes update their liveness records
	// with heartbeats to extend the expiration timestamp. Changes to the
	// range lease for the range containing node liveness triggers re-gossip
	// of the entire node liveness key range.
	NodeLivenessSpan *Span `protobuf:"bytes,2,opt,name=node_liveness_span,json=nodeLivenessSpan,proto3" json:"node_liveness_span,omitempty"`
}

func (m *ModifiedSpanTrigger) Reset()         { *m = ModifiedSpanTrigger{} }
func (m *ModifiedSpanTrigger) String() string { return proto.CompactTextString(m) }
func (*ModifiedSpanTrigger) ProtoMessage()    {}
func (*ModifiedSpanTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{7}
}
func (m *ModifiedSpanTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifiedSpanTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModifiedSpanTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifiedSpanTrigger.Merge(m, src)
}
func (m *ModifiedSpanTrigger) XXX_Size() int {
	return m.Size()
}
func (m *ModifiedSpanTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifiedSpanTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_ModifiedSpanTrigger proto.InternalMessageInfo

// StickyBitTrigger indicates that the sticky bit of a range should be changed.
// This trigger is used in two cases:
//  1. Unsplitting a range. Note that unsplitting and merging are different
//     operations. Unsplitting a range will only update the expiration time
//     associated with the range to hlc.Timestamp{}.
//  2. Splitting at the start key of a range. In this case, no range is split but
//     the sticky bit is might be updated, so we need to use this trigger instead
//     of SplitTrigger.
//
// Note that the sticky_bit should always be set to the same timestamp used to
// update the range descriptor and it's the client's responsibility that the
// timestamps are aligned.
type StickyBitTrigger struct {
	// Set to nil to remove a RangeDescriptor's sticky bit.
	StickyBit hlc.Timestamp `protobuf:"bytes,1,opt,name=sticky_bit,json=stickyBit,proto3" json:"sticky_bit"`
}

func (m *StickyBitTrigger) Reset()         { *m = StickyBitTrigger{} }
func (m *StickyBitTrigger) String() string { return proto.CompactTextString(m) }
func (*StickyBitTrigger) ProtoMessage()    {}
func (*StickyBitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{8}
}
func (m *StickyBitTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StickyBitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StickyBitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StickyBitTrigger.Merge(m, src)
}
func (m *StickyBitTrigger) XXX_Size() int {
	return m.Size()
}
func (m *StickyBitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_StickyBitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_StickyBitTrigger proto.InternalMessageInfo

// InternalCommitTrigger encapsulates all of the internal-only commit triggers.
// Only one may be set.
type InternalCommitTrigger struct {
	SplitTrigger          *SplitTrigger          `protobuf:"bytes,1,opt,name=split_trigger,json=splitTrigger,proto3" json:"split_trigger,omitempty"`
	MergeTrigger          *MergeTrigger          `protobuf:"bytes,2,opt,name=merge_trigger,json=mergeTrigger,proto3" json:"merge_trigger,omitempty"`
	ChangeReplicasTrigger *ChangeReplicasTrigger `protobuf:"bytes,3,opt,name=change_replicas_trigger,json=changeReplicasTrigger,proto3" json:"change_replicas_trigger,omitempty"`
	ModifiedSpanTrigger   *ModifiedSpanTrigger   `protobuf:"bytes,4,opt,name=modified_span_trigger,json=modifiedSpanTrigger,proto3" json:"modified_span_trigger,omitempty"`
	StickyBitTrigger      *StickyBitTrigger      `protobuf:"bytes,5,opt,name=sticky_bit_trigger,json=stickyBitTrigger,proto3" json:"sticky_bit_trigger,omitempty"`
}

func (m *InternalCommitTrigger) Reset()         { *m = InternalCommitTrigger{} }
func (m *InternalCommitTrigger) String() string { return proto.CompactTextString(m) }
func (*InternalCommitTrigger) ProtoMessage()    {}
func (*InternalCommitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{9}
}
func (m *InternalCommitTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalCommitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InternalCommitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalCommitTrigger.Merge(m, src)
}
func (m *InternalCommitTrigger) XXX_Size() int {
	return m.Size()
}
func (m *InternalCommitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalCommitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_InternalCommitTrigger proto.InternalMessageInfo

func (m *InternalCommitTrigger) GetSplitTrigger() *SplitTrigger {
	if m != nil {
		return m.SplitTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetMergeTrigger() *MergeTrigger {
	if m != nil {
		return m.MergeTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetChangeReplicasTrigger() *ChangeReplicasTrigger {
	if m != nil {
		return m.ChangeReplicasTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetModifiedSpanTrigger() *ModifiedSpanTrigger {
	if m != nil {
		return m.ModifiedSpanTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetStickyBitTrigger() *StickyBitTrigger {
	if m != nil {
		return m.StickyBitTrigger
	}
	return nil
}

type ObservedTimestamp struct {
	NodeID    NodeID                                                       `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	Timestamp github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,2,opt,name=timestamp,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"timestamp"`
}

func (m *ObservedTimestamp) Reset()         { *m = ObservedTimestamp{} }
func (m *ObservedTimestamp) String() string { return proto.CompactTextString(m) }
func (*ObservedTimestamp) ProtoMessage()    {}
func (*ObservedTimestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{10}
}
func (m *ObservedTimestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObservedTimestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObservedTimestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObservedTimestamp.Merge(m, src)
}
func (m *ObservedTimestamp) XXX_Size() int {
	return m.Size()
}
func (m *ObservedTimestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_ObservedTimestamp.DiscardUnknown(m)
}

var xxx_messageInfo_ObservedTimestamp proto.InternalMessageInfo

// A Transaction is a unit of work performed on the database.
// Cockroach transactions always operate at the serializable isolation
// level. Each Cockroach transaction is assigned a random priority.
// This priority will be used to decide whether a transaction will be
// aborted during contention.
//
// If you add fields to Transaction you'll need to update
// Transaction.Clone. Failure to do so will result in test failures.
type Transaction struct {
	// The transaction metadata. This field includes the subset of information
	// that is persisted with every write intent.
	enginepb.TxnMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	// A free-text identifier for debug purposes.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The status of the transaction.
	Status TransactionStatus `protobuf:"varint,4,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	// The last time that the transaction's record was sent a heartbeat by its
	// coordinator to indicate client activity. Concurrent transactions will
	// avoid aborting a transaction if it observes recent-enough activity.
	//
	// NOTE: this could use a ClockTimestamp type, but doing so results in a
	// large diff that doesn't seem worth it, given that we never feed this
	// timestamp back into a clock.
	LastHeartbeat hlc.Timestamp `protobuf:"bytes,5,opt,name=last_heartbeat,json=lastHeartbeat,proto3" json:"last_heartbeat"`
	// The transaction's read timestamp. All reads are performed at this
	// timestamp, ensuring that the transaction runs on top of a consistent
	// snapshot of the database.
	// Writes are performed at the transaction's write timestamp (meta.timestamp).
	// The write timestamp can diverge from the read timestamp when a write is
	// "pushed": for example in case a write runs into the timestamp cache, we're
	// forced to write at a higher timestamp. Being serializable, the transaction
	// can't commit if the write timestamp diverged from the read timestamp unless
	// we prove that the read timestamp can also be advanced to match the
	// write timestamp; it can be advanced if the two timestamps are equivalent
	// for everything that the transaction has read (meaning that there's no
	// values in between the read timestamp and the write timestamp for any key in
	// the txn's read set). We call checking whether the read timestamp can
	// advance "refreshing the read set". So, the read timestamp advances after a
	// successful refresh or, if the refresh is unsuccessful, after a transaction
	// restart.
	ReadTimestamp hlc.Timestamp `protobuf:"bytes,15,opt,name=read_timestamp,json=readTimestamp,proto3" json:"read_timestamp"`
	// This flag is set if the transaction's read timestamp is fixed and can not
	// be modified. If true, this prevents the transaction's timestamp from being
	// adjusted by a read refresh or, for read committed transactions, by a read
	// timestamp step.
	//
	// For serializable transactions (who do not tolerate write skew), this flag
	// also has the effect of fixing the transaction's commit timestamp. This
	// means that the txn can not commit at a higher timestamp than its read
	// timestamp without resorting to a client-side retry. For this reason, the
	// flag is set if the transaction's timestamp was "leaked" beyond the
	// transaction (e.g. via cluster_logical_timestamp()).
	ReadTimestampFixed bool `protobuf:"varint,16,opt,name=read_timestamp_fixed,json=readTimestampFixed,proto3" json:"read_timestamp_fixed,omitempty"`
	// The transaction's global uncertainty limit is its initial timestamp +
	// maximum cluster-wide clock skew. This value defines the inclusive upper
	// bound of the transaction's uncertainty interval.
	//
	// Reads which encounter values with timestamps between read_timestamp and
	// global_uncertainty_limit ("within the uncertainty interval") trigger a
	// retry error (ReadWithinUncertaintyIntervalError). This forces the
	// transaction to increase its read timestamp, either through a refresh or a
	// retry, in order to ensure that the transaction observes the "uncertain"
	// value.
	//
	// However, the uncertainty limit applied to values can be reduced when
	// evaluating a request on a node from which the transaction has acquired an
	// observed timestamp. This reduced uncertainty limit is reflected in the
	// local_uncertainty_limit variable at the time of request evaluation.
	//
	// See pkg/kv/kvserver/uncertainty for more details.
	//
	// The case global_uncertainty_limit < read_timestamp is possible for
	// transactions which have been pushed or have refreshed; in this case,
	// global_uncertainty_limit should be ignored.
	GlobalUncertaintyLimit hlc.Timestamp `protobuf:"bytes,7,opt,name=global_uncertainty_limit,json=globalUncertaintyLimit,proto3" json:"global_uncertainty_limit"`
	// A list of <NodeID, timestamp> pairs. The list maps NodeIDs to timestamps
	// as observed from their local clock during this transaction. The purpose
	// of this list is to allow a transaction to avoid uncertainty related
	// restarts which occur when reading a value in the near future, per the
	// global_uncertainty_limit field. The list helps avoid these restarts by
	// establishing a lower local_uncertainty_limit when evaluating a request on
	// a node in the list.
	//
	// See pkg/kv/kvserver/uncertainty for more details.
	//
	// The slice of observed timestamps is kept sorted by NodeID. Use
	// Transaction.UpdateObservedTimestamp to maintain the sorted order. The
	// slice should be treated as immutable and all updates should be performed
	// on a copy of the slice.
	ObservedTimestamps []ObservedTimestamp `protobuf:"bytes,8,rep,name=observed_timestamps,json=observedTimestamps,proto3" json:"observed_timestamps"`
	// Set of spans that the transaction has acquired locks within. These are
	// spans which must be resolved on txn completion. Note that these spans
	// may be condensed to cover aggregate spans if the keys locked by the
	// transaction exceeded a size threshold.
	//
	// The set logically extends to include the keys of all writes in the
	// in-flight write set. However, those keys are not stored in this set
	// to avoid duplication. This means that elements that are removed from
	// that set should be merged into this one.
	//
	// The slice is maintained in sorted order and all spans are maximally
	// merged such that no two spans here overlap each other. It should be
	// treated as immutable and all updates should be performed on a copy
	// of the slice.
	LockSpans []Span `protobuf:"bytes,11,rep,name=lock_spans,json=lockSpans,proto3" json:"lock_spans"`
	// Set of in-flight intent writes that have been issued by the transaction but
	// which may not have succeeded yet. If any in-flight writes are provided, a
	// committing EndTxn request will move a PENDING transaction to the STAGING
	// status instead of the COMMITTED status. These in-flight writes must then
	// all be confirmed as successful before the transaction can be moved from
	// STAGING to COMMITTED. Because of this, the set will only ever contain
	// entries when the transaction is STAGING. For more, see txnCommitter.
	//
	// The slice is maintained in sorted order by sequence number. It should be
	// treated as immutable and all updates should be performed on a copy of the
	// slice.
	InFlightWrites []SequencedWrite `protobuf:"bytes,17,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	// A list of ignored seqnum ranges.
	//
	// The slice is maintained as non-overlapping, non-contiguous (i.e. it must
	// coalesce ranges to avoid situations where a range's end seqnum is equal to
	// the next range's start seqnum), and sorted in seqnum order. It should be
	// treated as immutable and all updates should be performed on a copy of the
	// slice.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,18,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
	// AdmissionPriority is the priority assigned for admission control, at
	// transaction creation time. It is immutable.
	//
	// TODO(sumeer): Use gogoproto.customtype to make this
	// admissionpb.WorkPriority.
	AdmissionPriority int32 `protobuf:"zigzag32,19,opt,name=admission_priority,json=admissionPriority,proto3" json:"admission_priority,omitempty"`
	// When set to true, all of the transaction's writes will be filtered out by
	// rangefeeds, and will not be available in changefeeds. This allows users to
	// choose which writes are exported on a per-transaction basis.
	OmitInRangefeeds bool `protobuf:"varint,20,opt,name=omit_in_rangefeeds,json=omitInRangefeeds,proto3" json:"omit_in_rangefeeds,omitempty"`
}

func (m *Transaction) Reset()      { *m = Transaction{} }
func (*Transaction) ProtoMessage() {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{11}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

// A TransactionRecord message contains the subset of the fields in a
// Transaction message that must be persisted in a transaction record.
// It can be thought of as a mask for the fields in Transaction that
// end up persisted in a transaction record.
//
// The message type is wire-compatible with persisted Transaction protos,
// but avoids the overhead of the fields in Transaction that don't need to
// be persisted in a transaction record. It also serves as a specification
// for the fields that must be present in a transaction record.
//
// NOTE: any changes to this type must be reflected in the AsRecord and
// AsTransaction methods.
type TransactionRecord struct {
	// See comments on Transaction proto.
	enginepb.TxnMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Status           TransactionStatus             `protobuf:"varint,4,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	LastHeartbeat    hlc.Timestamp                 `protobuf:"bytes,5,opt,name=last_heartbeat,json=lastHeartbeat,proto3" json:"last_heartbeat"`
	LockSpans        []Span                        `protobuf:"bytes,11,rep,name=lock_spans,json=lockSpans,proto3" json:"lock_spans"`
	InFlightWrites   []SequencedWrite              `protobuf:"bytes,17,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	IgnoredSeqNums   []enginepb.IgnoredSeqNumRange `protobuf:"bytes,18,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *TransactionRecord) Reset()         { *m = TransactionRecord{} }
func (m *TransactionRecord) String() string { return proto.CompactTextString(m) }
func (*TransactionRecord) ProtoMessage()    {}
func (*TransactionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{12}
}
func (m *TransactionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRecord.Merge(m, src)
}
func (m *TransactionRecord) XXX_Size() int {
	return m.Size()
}
func (m *TransactionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRecord proto.InternalMessageInfo

// A Lock is a Key together with a Transaction metadata (the lock holder) and a
// strength. They are used on the return path of e.g. scans, to report the
// existence of a locks on a key.
//
// Note: avoid constructing Lock directly; use MakeLock or MakeIntent instead.
type Lock struct {
	Lock_SingleKeySpan `protobuf:"bytes,1,opt,name=single_key_span,json=singleKeySpan,proto3,embedded=single_key_span" json:"single_key_span"`
	Txn                enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	Strength           lock.Strength    `protobuf:"varint,3,opt,name=strength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"strength,omitempty"`
}

func (m *Lock) Reset()         { *m = Lock{} }
func (m *Lock) String() string { return proto.CompactTextString(m) }
func (*Lock) ProtoMessage()    {}
func (*Lock) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{13}
}
func (m *Lock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Lock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lock.Merge(m, src)
}
func (m *Lock) XXX_Size() int {
	return m.Size()
}
func (m *Lock) XXX_DiscardUnknown() {
	xxx_messageInfo_Lock.DiscardUnknown(m)
}

var xxx_messageInfo_Lock proto.InternalMessageInfo

// SingleKeySpan preserves wire compatibility with an earlier version of this
// proto which used a Span. A Lock never spans keys, so there was no need for
// this to contain an EndKey.
type Lock_SingleKeySpan struct {
	// The start key of the key range.
	Key Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
}

func (m *Lock_SingleKeySpan) Reset()         { *m = Lock_SingleKeySpan{} }
func (m *Lock_SingleKeySpan) String() string { return proto.CompactTextString(m) }
func (*Lock_SingleKeySpan) ProtoMessage()    {}
func (*Lock_SingleKeySpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{13, 0}
}
func (m *Lock_SingleKeySpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lock_SingleKeySpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Lock_SingleKeySpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lock_SingleKeySpan.Merge(m, src)
}
func (m *Lock_SingleKeySpan) XXX_Size() int {
	return m.Size()
}
func (m *Lock_SingleKeySpan) XXX_DiscardUnknown() {
	xxx_messageInfo_Lock_SingleKeySpan.DiscardUnknown(m)
}

var xxx_messageInfo_Lock_SingleKeySpan proto.InternalMessageInfo

// A LockAcquisition represents the action of a Transaction acquiring a lock
// with a specified durability level and strength over a Span of keys.
type LockAcquisition struct {
	Span       `protobuf:"bytes,1,opt,name=span,proto3,embedded=span" json:"span"`
	Txn        enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	Durability lock.Durability  `protobuf:"varint,3,opt,name=durability,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Durability" json:"durability,omitempty"`
	Strength   lock.Strength    `protobuf:"varint,4,opt,name=strength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"strength,omitempty"`
	// IgnoredSeqNums is a list of sequence numbers that have been rolled back
	// by the transaction at the time of the lock acquisition.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,5,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *LockAcquisition) Reset()         { *m = LockAcquisition{} }
func (m *LockAcquisition) String() string { return proto.CompactTextString(m) }
func (*LockAcquisition) ProtoMessage()    {}
func (*LockAcquisition) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{14}
}
func (m *LockAcquisition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockAcquisition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockAcquisition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockAcquisition.Merge(m, src)
}
func (m *LockAcquisition) XXX_Size() int {
	return m.Size()
}
func (m *LockAcquisition) XXX_DiscardUnknown() {
	xxx_messageInfo_LockAcquisition.DiscardUnknown(m)
}

var xxx_messageInfo_LockAcquisition proto.InternalMessageInfo

// A LockUpdate is a Span together with Transaction state. LockUpdate messages
// are used to update all locks held by the transaction within the span to the
// transaction's authoritative state. As such, the message is used as input
// argument to intent resolution, to pass the current txn status, timestamps,
// ignored seqnum ranges, and clock observations to the resolution algorithm.
// For details about these arguments, see the comments on ResolveIntentRequest.
type LockUpdate struct {
	Span              `protobuf:"bytes,1,opt,name=span,proto3,embedded=span" json:"span"`
	Txn               enginepb.TxnMeta              `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	Status            TransactionStatus             `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	IgnoredSeqNums    []enginepb.IgnoredSeqNumRange `protobuf:"bytes,4,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
	ClockWhilePending ObservedTimestamp             `protobuf:"bytes,5,opt,name=clock_while_pending,json=clockWhilePending,proto3" json:"clock_while_pending"`
}

func (m *LockUpdate) Reset()         { *m = LockUpdate{} }
func (m *LockUpdate) String() string { return proto.CompactTextString(m) }
func (*LockUpdate) ProtoMessage()    {}
func (*LockUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{15}
}
func (m *LockUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockUpdate.Merge(m, src)
}
func (m *LockUpdate) XXX_Size() int {
	return m.Size()
}
func (m *LockUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_LockUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_LockUpdate proto.InternalMessageInfo

// A LockStateInfo represents the metadata of a lock tracked in a replica's
// lock table.  This includes any current lock holder, as well as waiting
// readers and writers.
type LockStateInfo struct {
	// The range that owns the Lock Table containing this lock.
	RangeID RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=RangeID" json:"range_id,omitempty"`
	// The key that this lock controls access to.
	Key Key `protobuf:"bytes,2,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The current lock holder, or nil if the lock is not held.
	LockHolder *enginepb.TxnMeta `protobuf:"bytes,3,opt,name=lock_holder,json=lockHolder,proto3" json:"lock_holder,omitempty"`
	// The durability that the lock is held at, or Unreplicated if not held.
	Durability lock.Durability `protobuf:"varint,4,opt,name=durability,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Durability" json:"durability,omitempty"`
	// The wall clock duration since this lock was acquired (or zero, if not held).
	HoldDuration time.Duration `protobuf:"bytes,5,opt,name=hold_duration,json=holdDuration,proto3,stdduration" json:"hold_duration"`
	// The readers and writers currently waiting on the lock.  Stable ordering
	// is not guaranteed.
	Waiters []lock.Waiter `protobuf:"bytes,6,rep,name=waiters,proto3" json:"waiters"`
	// The strength of the lock is being held at.
	LockStrength lock.Strength `protobuf:"varint,7,opt,name=lock_strength,json=lockStrength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"lock_strength,omitempty"`
}

func (m *LockStateInfo) Reset()      { *m = LockStateInfo{} }
func (*LockStateInfo) ProtoMessage() {}
func (*LockStateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{16}
}
func (m *LockStateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockStateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockStateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockStateInfo.Merge(m, src)
}
func (m *LockStateInfo) XXX_Size() int {
	return m.Size()
}
func (m *LockStateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LockStateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LockStateInfo proto.InternalMessageInfo

// A SequencedWrite is a point write to a key with a certain sequence number.
type SequencedWrite struct {
	// The key that the write was made at.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The sequence number of the request that created the write.
	Sequence github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,2,opt,name=sequence,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"sequence,omitempty"`
	// The strength with which the lock was acquired at.
	Strength lock.Strength `protobuf:"varint,3,opt,name=strength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"strength,omitempty"`
}

func (m *SequencedWrite) Reset()         { *m = SequencedWrite{} }
func (m *SequencedWrite) String() string { return proto.CompactTextString(m) }
func (*SequencedWrite) ProtoMessage()    {}
func (*SequencedWrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{17}
}
func (m *SequencedWrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequencedWrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequencedWrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequencedWrite.Merge(m, src)
}
func (m *SequencedWrite) XXX_Size() int {
	return m.Size()
}
func (m *SequencedWrite) XXX_DiscardUnknown() {
	xxx_messageInfo_SequencedWrite.DiscardUnknown(m)
}

var xxx_messageInfo_SequencedWrite proto.InternalMessageInfo

// Lease contains information about range leases including the
// expiration and lease holder.
type Lease struct {
	// The start is a timestamp at which the lease begins. This value
	// must be greater than the last lease expiration or the lease request
	// is considered invalid.
	Start github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,1,opt,name=start,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"start"`
	// The expiration is a timestamp at which the lease expires. This means that a
	// new lease can be granted for a later timestamp. This field is only set for
	// expiration-based leases.
	//
	// This is an exclusive value, i.e. the lease is valid in [start, expiration).
	Expiration *hlc.Timestamp `protobuf:"bytes,2,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// The address of the would-be lease holder.
	Replica ReplicaDescriptor `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica"`
	// The start of the lease stasis period. This field is deprecated.
	//
	// TODO(erikgrinaker): remove this. Migration:
	//
	// - 2016: the field was deprecated (#10305).
	//
	// - 24.1: stop reading the field. 23.2 nodes compare the field below Raft in
	//   Lease.Equal(), so we must populate the field for backwards compatibility.
	//
	// - 24.2 or later: remove the field when backwards compatibility with 23.2
	//   is no longer needed.
	DeprecatedStartStasis *hlc.Timestamp `protobuf:"bytes,4,opt,name=deprecated_start_stasis,json=deprecatedStartStasis,proto3" json:"deprecated_start_stasis,omitempty"`
	// The current timestamp when this lease has been proposed. Used after a
	// transfer and after a node restart to enforce that a node only uses leases
	// proposed after the time of the said transfer or restart. This is nullable
	// to help with the rollout (such that a lease applied by some nodes before
	// the rollout and some nodes after the rollout is serialized the same).
	ProposedTS github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=proposed_ts,json=proposedTs,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"proposed_ts"`
	// The epoch of the lease holder's node liveness record. The lease inherits
	// the expiration of the node liveness record for as long as the node liveness
	// record retains this epoch. The lease is invalid if the node liveness record
	// is updated with a different epoch.
	//
	// This field is only set for epoch-based leases. If this value is non-zero,
	// the expiration field and the term field must not be set.
	Epoch int64 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// A zero-indexed sequence number which is incremented during the acquisition
	// of each new range lease that is not equivalent to the previous range lease
	// (i.e. an acquisition that implies a leaseholder change). The sequence
	// number is used to detect lease changes between command proposal and
	// application without requiring that we send the entire lease through Raft.
	// Lease sequence numbers are a reflection of the "lease equivalency" property
	// (see Lease.Equivalent). Two adjacent leases that are equivalent will have
	// the same sequence number and two adjacent leases that are not equivalent
	// will have different sequence numbers.
	Sequence LeaseSequence `protobuf:"varint,7,opt,name=sequence,proto3,casttype=LeaseSequence" json:"sequence,omitempty"`
	// The type of acquisition event that result in this lease (transfer or
	// request).
	AcquisitionType LeaseAcquisitionType `protobuf:"varint,8,opt,name=acquisition_type,json=acquisitionType,proto3,enum=cockroach.roachpb.LeaseAcquisitionType" json:"acquisition_type,omitempty"`
	// The minimum expiration at which the lease expires, independent of any other
	// expiry condition. This field can be used to place a floor on the expiration
	// for epoch-based leases and leader leases to prevent expiration regressions
	// when upgrading from an expiration-based lease. It is not supported for
	// expiration-based leases.
	//
	// Like expiration above, this is an exclusive value, i.e. the lease is valid
	// in [start, max(min_expiration, <expiration from epoch or term>)).
	MinExpiration hlc.Timestamp `protobuf:"bytes,9,opt,name=min_expiration,json=minExpiration,proto3" json:"min_expiration"`
	// The term of the raft leader that a leader lease is associated with. The
	// lease is valid for as long as the raft leader has a guarantee from store
	// liveness that it remains the leader under this term. The lease is invalid
	// if the raft leader loses leadership (i.e. changes its term).
	//
	// This field is only set for leader leases. If non-zero, the expiration field
	// and the epoch field must not be set.
	Term uint64 `protobuf:"varint,10,opt,name=term,proto3" json:"term,omitempty"`
}

func (m *Lease) Reset()      { *m = Lease{} }
func (*Lease) ProtoMessage() {}
func (*Lease) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{18}
}
func (m *Lease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Lease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lease.Merge(m, src)
}
func (m *Lease) XXX_Size() int {
	return m.Size()
}
func (m *Lease) XXX_DiscardUnknown() {
	xxx_messageInfo_Lease.DiscardUnknown(m)
}

var xxx_messageInfo_Lease proto.InternalMessageInfo

// AbortSpanEntry contains information about a transaction which has
// been aborted. It's written to a range's AbortSpan if the range
// may have contained intents of the aborted txn. In the event that
// the same transaction attempts to read keys it may have written
// previously, this entry informs the transaction that it has aborted
// and must start fresh with an updated priority.
type AbortSpanEntry struct {
	// The key of the associated transaction.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The candidate commit timestamp the transaction record held at the time
	// it was aborted.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	// The priority of the transaction.
	Priority github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnPriority `protobuf:"varint,3,opt,name=priority,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnPriority" json:"priority,omitempty"`
}

func (m *AbortSpanEntry) Reset()         { *m = AbortSpanEntry{} }
func (m *AbortSpanEntry) String() string { return proto.CompactTextString(m) }
func (*AbortSpanEntry) ProtoMessage()    {}
func (*AbortSpanEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{19}
}
func (m *AbortSpanEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AbortSpanEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AbortSpanEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AbortSpanEntry.Merge(m, src)
}
func (m *AbortSpanEntry) XXX_Size() int {
	return m.Size()
}
func (m *AbortSpanEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AbortSpanEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AbortSpanEntry proto.InternalMessageInfo

// BufferedWrite contains information about all writes buffered on the root txn
// for a given key.
type BufferedWrite struct {
	ID   uint64              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Key  Key                 `protobuf:"bytes,2,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Vals []BufferedWrite_Val `protobuf:"bytes,3,rep,name=vals,proto3" json:"vals"`
}

func (m *BufferedWrite) Reset()         { *m = BufferedWrite{} }
func (m *BufferedWrite) String() string { return proto.CompactTextString(m) }
func (*BufferedWrite) ProtoMessage()    {}
func (*BufferedWrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{20}
}
func (m *BufferedWrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferedWrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BufferedWrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferedWrite.Merge(m, src)
}
func (m *BufferedWrite) XXX_Size() int {
	return m.Size()
}
func (m *BufferedWrite) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferedWrite.DiscardUnknown(m)
}

var xxx_messageInfo_BufferedWrite proto.InternalMessageInfo

type BufferedWrite_Val struct {
	Val Value                                                        `protobuf:"bytes,1,opt,name=val,proto3" json:"val"`
	Seq github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,2,opt,name=seq,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"seq,omitempty"`
}

func (m *BufferedWrite_Val) Reset()         { *m = BufferedWrite_Val{} }
func (m *BufferedWrite_Val) String() string { return proto.CompactTextString(m) }
func (*BufferedWrite_Val) ProtoMessage()    {}
func (*BufferedWrite_Val) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{20, 0}
}
func (m *BufferedWrite_Val) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferedWrite_Val) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BufferedWrite_Val) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferedWrite_Val.Merge(m, src)
}
func (m *BufferedWrite_Val) XXX_Size() int {
	return m.Size()
}
func (m *BufferedWrite_Val) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferedWrite_Val.DiscardUnknown(m)
}

var xxx_messageInfo_BufferedWrite_Val proto.InternalMessageInfo

// LeafTxnInputState is the state from a transaction coordinator
// necessary and sufficient to set up a leaf transaction coordinator
// on another node.
type LeafTxnInputState struct {
	// txn is a copy of the transaction record.
	Txn Transaction `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// refresh_invalid indicates that the root txn is not
	// collecting refresh spans so the leaf should also avoid
	// collecting them. This is an optimization: it avoids
	// the collection work in that cases and also possibly
	// reduces memory usage.
	RefreshInvalid bool `protobuf:"varint,7,opt,name=refresh_invalid,json=refreshInvalid,proto3" json:"refresh_invalid,omitempty"`
	// in_flight_writes stores all writes that are in-flight and have not yet
	// been proven to have succeeded. Overlapping requests must chain on to
	// their success using a QueryIntent request.
	//
	// If DistSQLUseReducedLeafWriteSets is enabled, then this set might only
	// include writes overlapping with key spans that the caller will read.
	InFlightWrites []SequencedWrite `protobuf:"bytes,8,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	// Whether stepping mode is enabled. False indicates synchronous
	// read-own-writes, where every KV read is able to observe the
	// latest writes. True indicates that KV reads should be done at the
	// read_seq_num specified below.
	SteppingModeEnabled bool `protobuf:"varint,9,opt,name=stepping_mode_enabled,json=steppingModeEnabled,proto3" json:"stepping_mode_enabled,omitempty"`
	// Current read seqnum. When stepping_mode_enabled is true,
	// this field becomes the sequence number used for reads,
	// regardless of the current seqnum generated for writes. This is
	// updated via the (kv.TxnSender).Step() operation.
	ReadSeqNum github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,10,opt,name=read_seq_num,json=readSeqNum,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"read_seq_num,omitempty"`
	// buffered_writes stores all writes that are buffered on the root txn (on the
	// gateway node). Overlapping read requests need to be aware of these in order
	// to support read-your-own-writes.
	//
	// If DistSQLUseReducedLeafWriteSets is enabled, then this set might only
	// include writes overlapping with key spans that the caller will read.
	BufferedWrites []BufferedWrite `protobuf:"bytes,11,rep,name=buffered_writes,json=bufferedWrites,proto3" json:"buffered_writes"`
}

func (m *LeafTxnInputState) Reset()         { *m = LeafTxnInputState{} }
func (m *LeafTxnInputState) String() string { return proto.CompactTextString(m) }
func (*LeafTxnInputState) ProtoMessage()    {}
func (*LeafTxnInputState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{21}
}
func (m *LeafTxnInputState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafTxnInputState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeafTxnInputState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafTxnInputState.Merge(m, src)
}
func (m *LeafTxnInputState) XXX_Size() int {
	return m.Size()
}
func (m *LeafTxnInputState) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafTxnInputState.DiscardUnknown(m)
}

var xxx_messageInfo_LeafTxnInputState proto.InternalMessageInfo

// LeafTxnFinalState is the state from a leaf transaction coordinator
// necessary and sufficient to update a RootTxn on the gateway
// coordinator.
type LeafTxnFinalState struct {
	// txn is a copy of the transaction record.
	// TODO(knz,andrei): We don't actually need the fully txn
	// record. This can be simplified.
	// See: https://github.com/cockroachdb/cockroach/issues/43192
	Txn Transaction `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// refresh_spans contains the key spans read by the leaf. The root will add
	// them to its own tracking of reads.
	RefreshSpans []Span `protobuf:"bytes,4,rep,name=refresh_spans,json=refreshSpans,proto3" json:"refresh_spans"`
	// refresh_invalid is set if refresh spans have not been collected. In this
	// case, refresh_spans is empty. It may be set because the leaf was asked not
	// to collect spans or because the leaf's reads exceeded the tracking memory
	// budget.
	RefreshInvalid bool `protobuf:"varint,7,opt,name=refresh_invalid,json=refreshInvalid,proto3" json:"refresh_invalid,omitempty"`
}

func (m *LeafTxnFinalState) Reset()         { *m = LeafTxnFinalState{} }
func (m *LeafTxnFinalState) String() string { return proto.CompactTextString(m) }
func (*LeafTxnFinalState) ProtoMessage()    {}
func (*LeafTxnFinalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{22}
}
func (m *LeafTxnFinalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafTxnFinalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeafTxnFinalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafTxnFinalState.Merge(m, src)
}
func (m *LeafTxnFinalState) XXX_Size() int {
	return m.Size()
}
func (m *LeafTxnFinalState) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafTxnFinalState.DiscardUnknown(m)
}

var xxx_messageInfo_LeafTxnFinalState proto.InternalMessageInfo

// ClientRangeInfo represents the kvclient's knowledge about the state of the
// range (i.e. of the range descriptor, lease, and closed timestamp policy). The
// kvserver checks whether the client's info is up to date and, if it isn't, it
// will return a RangeInfo with up-to-date information.
type ClientRangeInfo struct {
	DescriptorGeneration RangeGeneration `protobuf:"varint,1,opt,name=descriptor_generation,json=descriptorGeneration,proto3,casttype=RangeGeneration" json:"descriptor_generation,omitempty"`
	LeaseSequence        LeaseSequence   `protobuf:"varint,2,opt,name=lease_sequence,json=leaseSequence,proto3,casttype=LeaseSequence" json:"lease_sequence,omitempty"`
	// NB: This field may occasionally be constructed with the (wire-invalid)
	// value of -1, corresponding to rangecache's unknownClosedTimestampPolicy.
	// Before attaching to a request, it is coalesced to a valid enum value.
	//
	// See: https://github.com/cockroachdb/cockroach/issues/129981.
	ClosedTimestampPolicy RangeClosedTimestampPolicy `protobuf:"varint,3,opt,name=closed_timestamp_policy,json=closedTimestampPolicy,proto3,enum=cockroach.roachpb.RangeClosedTimestampPolicy" json:"closed_timestamp_policy,omitempty"`
	// ExplicitlyRequested causes range info to be returned even if other fields
	// are up-to-date or empty.
	ExplicitlyRequested bool `protobuf:"varint,4,opt,name=explicitly_requested,json=explicitlyRequested,proto3" json:"explicitly_requested,omitempty"`
}

func (m *ClientRangeInfo) Reset()         { *m = ClientRangeInfo{} }
func (m *ClientRangeInfo) String() string { return proto.CompactTextString(m) }
func (*ClientRangeInfo) ProtoMessage()    {}
func (*ClientRangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{23}
}
func (m *ClientRangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientRangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClientRangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientRangeInfo.Merge(m, src)
}
func (m *ClientRangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClientRangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientRangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClientRangeInfo proto.InternalMessageInfo

// RangeInfo describes a range which executed a request. It contains the range
// descriptor, lease information, and closed timestamp policy at the time of
// execution.
type RangeInfo struct {
	Desc                  RangeDescriptor            `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	Lease                 Lease                      `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	ClosedTimestampPolicy RangeClosedTimestampPolicy `protobuf:"varint,3,opt,name=closed_timestamp_policy,json=closedTimestampPolicy,proto3,enum=cockroach.roachpb.RangeClosedTimestampPolicy" json:"closed_timestamp_policy,omitempty"`
}

func (m *RangeInfo) Reset()      { *m = RangeInfo{} }
func (*RangeInfo) ProtoMessage() {}
func (*RangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{24}
}
func (m *RangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeInfo.Merge(m, src)
}
func (m *RangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *RangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RangeInfo proto.InternalMessageInfo

// A TenantID is a unique ID associated with a tenant in a multi-tenant cluster.
// Each tenant is granted exclusive access to a portion of the keyspace and a
// collection of SQL tables in that keyspace which comprise a "logical" cluster.
//
// It should be treated as opaque by users, and only created/accessed using the
// public methods MakeTenantID, ToUint64, etc.
type TenantID struct {
	// InternalValue should not be set or accessed directly; use ToUint64.
	InternalValue uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *TenantID) Reset()      { *m = TenantID{} }
func (*TenantID) ProtoMessage() {}
func (*TenantID) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{25}
}
func (m *TenantID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantID.Merge(m, src)
}
func (m *TenantID) XXX_Size() int {
	return m.Size()
}
func (m *TenantID) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantID.DiscardUnknown(m)
}

var xxx_messageInfo_TenantID proto.InternalMessageInfo

// RowCount tracks the size and row/index entry counts.
type RowCount struct {
	DataSize     int64 `protobuf:"varint,1,opt,name=data_size,json=dataSize,proto3" json:"data_size,omitempty"`
	Rows         int64 `protobuf:"varint,2,opt,name=rows,proto3" json:"rows,omitempty"`
	IndexEntries int64 `protobuf:"varint,3,opt,name=index_entries,json=indexEntries,proto3" json:"index_entries,omitempty"`
}

func (m *RowCount) Reset()         { *m = RowCount{} }
func (m *RowCount) String() string { return proto.CompactTextString(m) }
func (*RowCount) ProtoMessage()    {}
func (*RowCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{26}
}
func (m *RowCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowCount.Merge(m, src)
}
func (m *RowCount) XXX_Size() int {
	return m.Size()
}
func (m *RowCount) XXX_DiscardUnknown() {
	xxx_messageInfo_RowCount.DiscardUnknown(m)
}

var xxx_messageInfo_RowCount proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.ValueType", ValueType_name, ValueType_value)
	proto.RegisterEnum("cockroach.roachpb.ReplicaChangeType", ReplicaChangeType_name, ReplicaChangeType_value)
	proto.RegisterEnum("cockroach.roachpb.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterEnum("cockroach.roachpb.LeaseAcquisitionType", LeaseAcquisitionType_name, LeaseAcquisitionType_value)
	proto.RegisterEnum("cockroach.roachpb.RangeClosedTimestampPolicy", RangeClosedTimestampPolicy_name, RangeClosedTimestampPolicy_value)
	proto.RegisterType((*Span)(nil), "cockroach.roachpb.Span")
	proto.RegisterType((*Value)(nil), "cockroach.roachpb.Value")
	proto.RegisterType((*KeyValue)(nil), "cockroach.roachpb.KeyValue")
	proto.RegisterType((*StoreIdent)(nil), "cockroach.roachpb.StoreIdent")
	proto.RegisterType((*SplitTrigger)(nil), "cockroach.roachpb.SplitTrigger")
	proto.RegisterType((*MergeTrigger)(nil), "cockroach.roachpb.MergeTrigger")
	proto.RegisterType((*ChangeReplicasTrigger)(nil), "cockroach.roachpb.ChangeReplicasTrigger")
	proto.RegisterType((*ModifiedSpanTrigger)(nil), "cockroach.roachpb.ModifiedSpanTrigger")
	proto.RegisterType((*StickyBitTrigger)(nil), "cockroach.roachpb.StickyBitTrigger")
	proto.RegisterType((*InternalCommitTrigger)(nil), "cockroach.roachpb.InternalCommitTrigger")
	proto.RegisterType((*ObservedTimestamp)(nil), "cockroach.roachpb.ObservedTimestamp")
	proto.RegisterType((*Transaction)(nil), "cockroach.roachpb.Transaction")
	proto.RegisterType((*TransactionRecord)(nil), "cockroach.roachpb.TransactionRecord")
	proto.RegisterType((*Lock)(nil), "cockroach.roachpb.Lock")
	proto.RegisterType((*Lock_SingleKeySpan)(nil), "cockroach.roachpb.Lock.SingleKeySpan")
	proto.RegisterType((*LockAcquisition)(nil), "cockroach.roachpb.LockAcquisition")
	proto.RegisterType((*LockUpdate)(nil), "cockroach.roachpb.LockUpdate")
	proto.RegisterType((*LockStateInfo)(nil), "cockroach.roachpb.LockStateInfo")
	proto.RegisterType((*SequencedWrite)(nil), "cockroach.roachpb.SequencedWrite")
	proto.RegisterType((*Lease)(nil), "cockroach.roachpb.Lease")
	proto.RegisterType((*AbortSpanEntry)(nil), "cockroach.roachpb.AbortSpanEntry")
	proto.RegisterType((*BufferedWrite)(nil), "cockroach.roachpb.BufferedWrite")
	proto.RegisterType((*BufferedWrite_Val)(nil), "cockroach.roachpb.BufferedWrite.Val")
	proto.RegisterType((*LeafTxnInputState)(nil), "cockroach.roachpb.LeafTxnInputState")
	proto.RegisterType((*LeafTxnFinalState)(nil), "cockroach.roachpb.LeafTxnFinalState")
	proto.RegisterType((*ClientRangeInfo)(nil), "cockroach.roachpb.ClientRangeInfo")
	proto.RegisterType((*RangeInfo)(nil), "cockroach.roachpb.RangeInfo")
	proto.RegisterType((*TenantID)(nil), "cockroach.roachpb.TenantID")
	proto.RegisterType((*RowCount)(nil), "cockroach.roachpb.RowCount")
}

func init() { proto.RegisterFile("roachpb/data.proto", fileDescriptor_6493e3a32c32e46b) }

var fileDescriptor_6493e3a32c32e46b = []byte{
	// 3331 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5a, 0xcd, 0x6f, 0x1b, 0x49,
	0x76, 0x57, 0x93, 0x4d, 0xb1, 0xf9, 0x28, 0x52, 0xad, 0xb2, 0x64, 0xd3, 0x9a, 0x44, 0xd4, 0x72,
	0x92, 0xac, 0x61, 0xec, 0x50, 0x33, 0x9a, 0xcd, 0x26, 0x70, 0x9c, 0x20, 0xfc, 0x68, 0xcb, 0x94,
	0x29, 0x52, 0x5b, 0xa4, 0xe4, 0xf1, 0xec, 0x2e, 0x3a, 0xcd, 0xee, 0x22, 0xd5, 0x50, 0xb3, 0x9b,
	0xee, 0x6e, 0xca, 0xa2, 0x6f, 0xb9, 0x04, 0x0b, 0x2c, 0x10, 0x2c, 0x72, 0x1a, 0x20, 0x97, 0x01,
	0x72, 0x48, 0x6e, 0xc9, 0x25, 0x40, 0x90, 0xbf, 0x60, 0x0e, 0x41, 0x30, 0xa7, 0x64, 0x91, 0x0f,
	0x25, 0xd1, 0x5c, 0xf6, 0x10, 0xe4, 0x14, 0xe4, 0xe0, 0x53, 0x50, 0x1f, 0x4d, 0x52, 0x32, 0x25,
	0x53, 0x63, 0xef, 0x66, 0x80, 0x5c, 0x84, 0x66, 0xbd, 0x7a, 0xbf, 0xf7, 0xaa, 0xea, 0x7d, 0x56,
	0x09, 0x90, 0xef, 0x19, 0xe6, 0xd1, 0xa0, 0xb3, 0x65, 0x19, 0xa1, 0x51, 0x1c, 0xf8, 0x5e, 0xe8,
	0xa1, 0x15, 0xd3, 0x33, 0x8f, 0xd9, 0x78, 0x51, 0x50, 0xd7, 0x8b, 0xc7, 0x27, 0x5b, 0xc7, 0x27,
	0x01, 0xf1, 0x4f, 0x88, 0xbf, 0x65, 0x7a, 0xae, 0x39, 0xf4, 0x7d, 0xe2, 0x9a, 0xa3, 0x2d, 0xc7,
	0x33, 0x8f, 0xd9, 0x1f, 0xfd, 0x85, 0x61, 0x87, 0xc4, 0xe7, 0x10, 0xeb, 0xf7, 0xdf, 0x38, 0xdf,
	0x76, 0x7b, 0xb3, 0xe6, 0xfa, 0xc4, 0xb0, 0x82, 0x61, 0xbf, 0x6f, 0xf8, 0xa3, 0x2d, 0x3f, 0x18,
	0x74, 0xb6, 0xc4, 0x0f, 0x31, 0xf7, 0x76, 0xa4, 0x6e, 0x9f, 0x84, 0xc6, 0x44, 0xe5, 0xf5, 0xf7,
	0x82, 0xd0, 0xf3, 0x8d, 0x1e, 0xd9, 0x22, 0x6e, 0xcf, 0x76, 0x09, 0x9d, 0x70, 0x62, 0x9a, 0x82,
	0xf8, 0x2b, 0x33, 0x89, 0x1f, 0x0b, 0x6a, 0x6e, 0x18, 0xda, 0xce, 0xd6, 0x91, 0x63, 0x6e, 0x85,
	0x76, 0x9f, 0x04, 0xa1, 0xd1, 0x1f, 0x08, 0xca, 0x6a, 0xcf, 0xeb, 0x79, 0xec, 0x73, 0x8b, 0x7e,
	0x89, 0xd1, 0x8d, 0x9e, 0xe7, 0xf5, 0x1c, 0xb2, 0xc5, 0x7e, 0x75, 0x86, 0xdd, 0x2d, 0x6b, 0xe8,
	0x1b, 0xa1, 0xed, 0xb9, 0x9c, 0x5e, 0x78, 0x06, 0x72, 0x6b, 0x60, 0xb8, 0xe8, 0x2e, 0xc4, 0x8f,
	0xc9, 0x28, 0x17, 0xdf, 0x94, 0xee, 0x2d, 0x95, 0x93, 0xaf, 0xce, 0xf2, 0xf1, 0x27, 0x64, 0x84,
	0xe9, 0x18, 0xda, 0x84, 0x24, 0x71, 0x2d, 0x9d, 0x92, 0xe5, 0x8b, 0xe4, 0x45, 0xe2, 0x5a, 0x4f,
	0xc8, 0xe8, 0x81, 0xf2, 0xd9, 0xe7, 0xf9, 0x85, 0xbf, 0xf9, 0x3c, 0x2f, 0xed, 0xca, 0x8a, 0xa4,
	0xc6, 0x76, 0x65, 0x25, 0xa6, 0xc6, 0x0b, 0x3d, 0x48, 0x1c, 0x1a, 0xce, 0x90, 0xa0, 0xf7, 0x20,
	0xe5, 0x1b, 0x2f, 0xf4, 0xce, 0x28, 0x24, 0x41, 0x4e, 0xa2, 0x10, 0x58, 0xf1, 0x8d, 0x17, 0x65,
	0xfa, 0x1b, 0x95, 0x20, 0x35, 0x5e, 0x49, 0x2e, 0xb6, 0x29, 0xdd, 0x4b, 0x6f, 0xff, 0x6a, 0x71,
	0x72, 0xa4, 0x74, 0xb9, 0xc5, 0x23, 0xc7, 0x2c, 0xb6, 0xa3, 0x49, 0x65, 0xf9, 0x8b, 0xb3, 0xfc,
	0x02, 0x9e, 0x70, 0x15, 0x7e, 0x00, 0xca, 0x13, 0x32, 0xe2, 0xb2, 0xc4, 0x3a, 0xa4, 0x19, 0xeb,
	0xf8, 0x2e, 0x24, 0x4e, 0xe8, 0x1c, 0x21, 0x25, 0x57, 0x7c, 0xcd, 0x70, 0x8a, 0x0c, 0x43, 0x08,
	0xe0, 0x93, 0x0b, 0xff, 0x28, 0x01, 0xb4, 0x42, 0xcf, 0x27, 0x35, 0x8b, 0xb8, 0x21, 0xea, 0x01,
	0x98, 0xce, 0x30, 0x08, 0x89, 0xaf, 0xdb, 0x96, 0x10, 0xf3, 0x98, 0xce, 0xff, 0xa7, 0xb3, 0xfc,
	0xc7, 0x3d, 0x3b, 0x3c, 0x1a, 0x76, 0x8a, 0xa6, 0xd7, 0xdf, 0x1a, 0x63, 0x5b, 0x9d, 0xc9, 0xf7,
	0xd6, 0xe0, 0xb8, 0xb7, 0xc5, 0x0e, 0x70, 0x38, 0xb4, 0xad, 0xe2, 0xc1, 0x41, 0xad, 0x7a, 0x7e,
	0x96, 0x4f, 0x55, 0x38, 0x60, 0xad, 0x8a, 0x53, 0x02, 0xbb, 0x66, 0xa1, 0x0f, 0x20, 0xe9, 0x7a,
	0x16, 0xa1, 0x52, 0xa8, 0xbe, 0x89, 0xf2, 0xea, 0xf9, 0x59, 0x7e, 0xb1, 0xe1, 0x59, 0xa4, 0x56,
	0x7d, 0x35, 0xfe, 0xc2, 0x8b, 0x74, 0x52, 0xcd, 0x42, 0x1f, 0x81, 0x42, 0xed, 0x86, 0xcd, 0x8f,
	0xb3, 0xf9, 0xb7, 0xcf, 0xcf, 0xf2, 0x49, 0xae, 0x39, 0x65, 0x88, 0x3e, 0x71, 0x32, 0xe0, 0xab,
	0x29, 0xfc, 0x77, 0x1c, 0x96, 0x5a, 0x03, 0xc7, 0x0e, 0xdb, 0xbe, 0xdd, 0xeb, 0x11, 0x1f, 0x69,
	0x90, 0x72, 0x48, 0x37, 0xd4, 0x2d, 0x12, 0x98, 0x6c, 0x69, 0xe9, 0xed, 0xc2, 0x8c, 0x4d, 0xc2,
	0x86, 0xdb, 0x23, 0x55, 0x12, 0x98, 0xbe, 0x3d, 0x08, 0x3d, 0x5f, 0x6c, 0x97, 0x42, 0x59, 0xe9,
	0x28, 0xda, 0x01, 0xf0, 0xed, 0xde, 0x91, 0xc0, 0x89, 0xdd, 0x10, 0x27, 0xc5, 0x78, 0x19, 0x10,
	0x81, 0xbb, 0x03, 0x9f, 0xe8, 0x01, 0xd5, 0x51, 0x67, 0x9a, 0x0d, 0x03, 0xe2, 0xeb, 0x41, 0x68,
	0x84, 0x41, 0x2e, 0xc1, 0x70, 0x7f, 0x7d, 0x0a, 0x57, 0xf8, 0x4d, 0x31, 0xf2, 0x9b, 0xe2, 0xde,
	0x61, 0xa5, 0xd2, 0xa2, 0x93, 0x05, 0xf4, 0xda, 0xc0, 0x27, 0x6c, 0xc1, 0x75, 0xd2, 0x0d, 0x0f,
	0x02, 0xe2, 0x33, 0x22, 0x6a, 0xc1, 0xf2, 0x44, 0x0c, 0x07, 0x5f, 0xbc, 0x39, 0x78, 0x26, 0x02,
	0xe7, 0xa0, 0x16, 0x7c, 0x38, 0x0c, 0x88, 0x4e, 0x82, 0xd0, 0xee, 0x1b, 0x21, 0x09, 0xf4, 0x0e,
	0x31, 0x0d, 0x36, 0x72, 0x1a, 0x12, 0xdf, 0x35, 0x1c, 0xee, 0x0e, 0xba, 0xe1, 0x13, 0x7d, 0xe0,
	0x93, 0x80, 0xb8, 0x61, 0x2e, 0xb9, 0x29, 0xdd, 0x53, 0xf0, 0xfd, 0x61, 0x40, 0xb4, 0x88, 0xad,
	0xcc, 0xb9, 0x34, 0xc1, 0xc4, 0x5c, 0xa6, 0xe4, 0x93, 0x7d, 0xce, 0x81, 0x36, 0x21, 0xdd, 0x37,
	0xdc, 0xa1, 0xe1, 0x30, 0xc9, 0x39, 0x85, 0x01, 0x4c, 0x0f, 0x3d, 0x90, 0x7f, 0xce, 0xdd, 0x32,
	0xae, 0xca, 0xbb, 0xb2, 0x22, 0xab, 0x89, 0xc2, 0x9f, 0x2e, 0xc2, 0xd2, 0x1e, 0xf1, 0x7b, 0xe4,
	0x9b, 0x7a, 0xec, 0x3d, 0x50, 0x39, 0x10, 0x8d, 0x7b, 0xe2, 0x40, 0xe4, 0x9b, 0x1c, 0xc8, 0x6d,
	0x8a, 0x78, 0x7e, 0x96, 0xcf, 0x62, 0x0a, 0x33, 0x1e, 0xc7, 0x59, 0x06, 0xbb, 0x77, 0x62, 0x9a,
	0xfc, 0x8c, 0xfe, 0x58, 0x82, 0x3c, 0x97, 0xe4, 0x53, 0x9d, 0x74, 0xdb, 0xd2, 0x1d, 0xcf, 0x34,
	0x9c, 0x69, 0xc1, 0xa9, 0x9b, 0x08, 0x2e, 0x08, 0xc1, 0xeb, 0x4c, 0x30, 0x5b, 0x68, 0xad, 0x5a,
	0xa7, 0x90, 0x13, 0x25, 0xd6, 0xfd, 0x09, 0xcd, 0xe2, 0xb4, 0xb1, 0x42, 0x7f, 0x24, 0xc1, 0x52,
	0xd7, 0x27, 0xe4, 0x25, 0xa1, 0xd2, 0xfd, 0x50, 0x18, 0xf9, 0x1b, 0xe2, 0x61, 0x95, 0x4a, 0x7d,
	0x75, 0x96, 0x7f, 0x38, 0x7f, 0xf8, 0xa1, 0x00, 0x15, 0x9a, 0xd7, 0xc6, 0x28, 0x38, 0xcd, 0x05,
	0xb7, 0xa8, 0x5c, 0xf4, 0x0c, 0x6e, 0xf3, 0x8d, 0x31, 0x1d, 0x2f, 0x20, 0x96, 0x3e, 0x89, 0xd0,
	0x8b, 0xf3, 0x47, 0xe8, 0x55, 0x06, 0x51, 0x61, 0x08, 0x63, 0x1a, 0xfa, 0x21, 0x20, 0xb1, 0xe7,
	0xc4, 0xb0, 0x74, 0x91, 0x2f, 0x99, 0xe9, 0xa7, 0xb7, 0x8b, 0x53, 0xb0, 0xc7, 0x27, 0xc5, 0x28,
	0xcd, 0x16, 0xa7, 0xd2, 0x6c, 0x11, 0x13, 0xc3, 0x6a, 0xf1, 0x6f, 0xcc, 0xed, 0x64, 0x6a, 0x04,
	0x7d, 0x0c, 0x99, 0x17, 0xbe, 0x1d, 0x12, 0xbd, 0x67, 0xea, 0x47, 0xb6, 0x2b, 0x5c, 0xa2, 0xbc,
	0x7c, 0x7e, 0x96, 0x4f, 0x3f, 0xa5, 0x84, 0x9d, 0xca, 0x63, 0xdb, 0x0d, 0x71, 0x9a, 0xcd, 0xda,
	0x31, 0xe9, 0x8f, 0x69, 0x1f, 0x29, 0xfc, 0x79, 0x0c, 0xd6, 0x2a, 0x47, 0xf4, 0x74, 0x30, 0x19,
	0x38, 0xb6, 0x69, 0x04, 0x91, 0x9b, 0x7c, 0x0f, 0x64, 0x66, 0xd9, 0x89, 0x79, 0x2d, 0x1b, 0xb3,
	0xf9, 0xa8, 0x03, 0x77, 0x6c, 0x57, 0xf8, 0xbc, 0x61, 0x59, 0xc4, 0xd2, 0x7d, 0x81, 0x9c, 0x5b,
	0xdc, 0x8c, 0xdf, 0x4b, 0x6f, 0xff, 0xda, 0x2c, 0x28, 0x3e, 0xe5, 0x35, 0x37, 0x59, 0x8b, 0xa0,
	0x4a, 0x14, 0x29, 0x52, 0x11, 0x75, 0xe1, 0xee, 0x58, 0x86, 0x4f, 0xfa, 0xde, 0xc9, 0xb4, 0x94,
	0xe4, 0x8d, 0xa5, 0x8c, 0x15, 0xc6, 0x1c, 0x2b, 0x92, 0xf3, 0x40, 0xa6, 0x89, 0x9e, 0x25, 0xf9,
	0x44, 0xa1, 0x03, 0xb7, 0xf6, 0x3c, 0xcb, 0xee, 0xda, 0xc4, 0xa2, 0x15, 0xc4, 0x24, 0x9a, 0x20,
	0x96, 0xb7, 0x1c, 0xfb, 0x84, 0xb8, 0x24, 0x08, 0xf4, 0x60, 0x60, 0xb8, 0x22, 0x1c, 0xdc, 0x99,
	0xa1, 0x03, 0xe5, 0xc5, 0x2a, 0x65, 0xa9, 0x0b, 0x0e, 0x3a, 0xc2, 0x0b, 0x89, 0xc2, 0x21, 0xa8,
	0xad, 0xd0, 0x36, 0x8f, 0x47, 0xe5, 0x49, 0x96, 0x2a, 0x03, 0x04, 0x6c, 0x4c, 0xef, 0xd8, 0xa1,
	0x88, 0x57, 0xf3, 0x55, 0x0c, 0x41, 0x04, 0x55, 0xf8, 0xdb, 0x38, 0xac, 0xd5, 0xc4, 0x1a, 0x2b,
	0x5e, 0xbf, 0x3f, 0x41, 0xaf, 0x42, 0x86, 0x27, 0x82, 0x90, 0x0f, 0x08, 0x01, 0xf9, 0x99, 0x9a,
	0x4f, 0x72, 0x27, 0x5e, 0x0a, 0xa6, 0x33, 0x69, 0x15, 0x32, 0x7d, 0x1a, 0x62, 0xc7, 0x28, 0xb1,
	0x2b, 0x51, 0xa6, 0x43, 0x31, 0x5e, 0xea, 0x4f, 0x07, 0xe6, 0x3f, 0x80, 0x3b, 0x26, 0x33, 0xc5,
	0xf1, 0x59, 0x8e, 0xf1, 0xe2, 0x0c, 0xef, 0xde, 0x0c, 0xbc, 0x99, 0xc6, 0x8b, 0xd7, 0xcc, 0x99,
	0x36, 0xfd, 0x29, 0xac, 0xf5, 0xc5, 0x19, 0xb2, 0x73, 0x1a, 0xe3, 0xf3, 0x78, 0xfb, 0x1b, 0xb3,
	0xf4, 0x7d, 0xfd, 0xcc, 0xf1, 0xad, 0xfe, 0x0c, 0x43, 0xf8, 0x3e, 0xa0, 0xc9, 0x39, 0x8d, 0x81,
	0xb9, 0xf7, 0xbc, 0x3f, 0x6b, 0x3b, 0x2f, 0x1d, 0x34, 0x56, 0x83, 0x4b, 0x23, 0x0f, 0xe4, 0x1f,
	0x7f, 0x9e, 0x97, 0x0a, 0x7f, 0x27, 0xc1, 0x4a, 0xb3, 0xc3, 0x42, 0xc3, 0x54, 0x5c, 0x99, 0xaa,
	0x97, 0xa4, 0x39, 0xea, 0xa5, 0x3f, 0x94, 0x6e, 0x5c, 0x77, 0xbe, 0x9b, 0x38, 0x3b, 0x91, 0xfa,
	0x40, 0xa6, 0x25, 0x73, 0xe1, 0xaf, 0x93, 0x90, 0x6e, 0xfb, 0x86, 0x1b, 0x18, 0x26, 0xad, 0xcb,
	0x51, 0x09, 0x64, 0xda, 0x2e, 0x08, 0xc3, 0x7b, 0xff, 0xba, 0xcc, 0xd3, 0x3e, 0x75, 0xf7, 0x48,
	0x68, 0x94, 0x15, 0xaa, 0xd9, 0x97, 0x67, 0x79, 0x09, 0x33, 0x56, 0x84, 0x40, 0x76, 0x8d, 0x3e,
	0x2f, 0x74, 0x53, 0x98, 0x7d, 0xa3, 0x87, 0xb0, 0x48, 0x33, 0xda, 0x90, 0xe7, 0xd2, 0xec, 0xcc,
	0x78, 0x30, 0xa5, 0x46, 0x8b, 0xcd, 0xc5, 0x82, 0x07, 0xed, 0x42, 0xd6, 0x31, 0x82, 0x50, 0x3f,
	0x22, 0x86, 0x1f, 0x76, 0x88, 0x31, 0x67, 0x6a, 0x12, 0xa5, 0x11, 0x65, 0x7d, 0x1c, 0x71, 0x52,
	0x2c, 0x16, 0xfb, 0x27, 0xdb, 0xbf, 0x7c, 0x03, 0x2c, 0xca, 0x3a, 0x39, 0xf5, 0x0f, 0x61, 0xf5,
	0x22, 0x96, 0xde, 0xb5, 0x4f, 0x89, 0x95, 0x53, 0x59, 0x25, 0x84, 0x2e, 0x4c, 0x7e, 0x44, 0x29,
	0xe8, 0x47, 0x90, 0xeb, 0x39, 0x5e, 0xc7, 0x70, 0xf4, 0xa1, 0x6b, 0x12, 0x3f, 0x34, 0x6c, 0x37,
	0x1c, 0xe9, 0x8e, 0xdd, 0xb7, 0x43, 0x91, 0x85, 0xe6, 0xd2, 0xe3, 0x36, 0x07, 0x39, 0x98, 0x60,
	0xd4, 0x29, 0x04, 0xfa, 0x01, 0xdc, 0xf2, 0x84, 0x6d, 0x4e, 0x94, 0x0a, 0x72, 0xca, 0x95, 0x31,
	0xf8, 0x35, 0x4b, 0x16, 0x02, 0x90, 0x77, 0x99, 0x10, 0xa0, 0x87, 0x00, 0xac, 0x79, 0xa5, 0xae,
	0x1a, 0xe4, 0xd2, 0x0c, 0xf3, 0xaa, 0x98, 0x1a, 0x05, 0x3d, 0xca, 0x40, 0x7f, 0x07, 0xe8, 0xfb,
	0xa0, 0xda, 0xae, 0xde, 0x75, 0x58, 0xf6, 0x65, 0xf9, 0x2f, 0xc8, 0xad, 0x30, 0x8c, 0x6f, 0xcd,
	0xc2, 0x20, 0xcf, 0x87, 0xc4, 0x35, 0x89, 0xc5, 0xd2, 0xa6, 0x40, 0xcb, 0xda, 0xee, 0x23, 0xc6,
	0xcf, 0x06, 0x03, 0xe4, 0xc1, 0xb2, 0xdd, 0x73, 0x3d, 0x9f, 0x86, 0x0f, 0xf2, 0xdc, 0x1d, 0xf6,
	0x83, 0x1c, 0x62, 0x88, 0xc5, 0xeb, 0xcc, 0xb6, 0xc6, 0x59, 0x5a, 0xe4, 0x79, 0x63, 0xd8, 0x67,
	0x49, 0x73, 0x52, 0xb2, 0x5d, 0xa0, 0x05, 0x38, 0x6b, 0x8f, 0x7f, 0x53, 0x74, 0xf4, 0x01, 0x20,
	0xc3, 0xea, 0xdb, 0x41, 0x60, 0x7b, 0xae, 0x3e, 0xf0, 0x6d, 0xcf, 0xb7, 0xc3, 0x51, 0xee, 0xd6,
	0xa6, 0x74, 0x6f, 0x05, 0xaf, 0x8c, 0x29, 0xfb, 0x82, 0x80, 0xbe, 0x03, 0xc8, 0xeb, 0xdb, 0xa1,
	0x6e, 0xbb, 0xbc, 0xc4, 0xeb, 0x12, 0x62, 0x05, 0xb9, 0x55, 0x66, 0x1c, 0x2a, 0xa5, 0xd4, 0x5c,
	0x3c, 0x1e, 0xbf, 0xd0, 0xc6, 0xf2, 0x7a, 0x79, 0x51, 0x4d, 0xee, 0xca, 0x4a, 0x4a, 0x85, 0x5d,
	0x59, 0x59, 0x52, 0x33, 0xbb, 0xb2, 0x92, 0x51, 0xb3, 0xbb, 0xb2, 0x92, 0x55, 0x97, 0x0b, 0x7f,
	0x25, 0xc3, 0xca, 0x94, 0xc3, 0x60, 0x62, 0x7a, 0xbe, 0xf5, 0x2e, 0xbc, 0xf7, 0x9b, 0xe3, 0xa9,
	0xff, 0xef, 0xed, 0x8d, 0x87, 0x68, 0x7e, 0x9f, 0x71, 0xc9, 0x28, 0x92, 0xaa, 0xb2, 0x2b, 0x2b,
	0x8a, 0x9a, 0x1a, 0x1b, 0x08, 0xa8, 0xe9, 0xd7, 0xcd, 0x64, 0x57, 0x56, 0x96, 0x55, 0x75, 0x57,
	0x56, 0x54, 0x75, 0xa5, 0xf0, 0x17, 0x31, 0x90, 0xeb, 0x9e, 0x79, 0x8c, 0x9e, 0xc2, 0x72, 0x60,
	0xbb, 0x3d, 0x87, 0xe8, 0xc7, 0x64, 0xc4, 0x2b, 0x24, 0xe9, 0xb5, 0x46, 0x23, 0xda, 0x19, 0xca,
	0x51, 0x6c, 0xb1, 0xe9, 0x4f, 0xc8, 0x88, 0xed, 0xf5, 0xc4, 0x64, 0x32, 0xc1, 0x34, 0x01, 0xfd,
	0x0e, 0xc4, 0xc3, 0xd3, 0xa8, 0xdc, 0x9a, 0xcb, 0xfa, 0xf8, 0x46, 0x53, 0x2e, 0x54, 0x07, 0x25,
	0x08, 0x7d, 0xe2, 0xf6, 0xc2, 0x23, 0x56, 0x60, 0x64, 0xb7, 0x3f, 0xbc, 0xa2, 0x20, 0x9f, 0xba,
	0x23, 0x2b, 0x3a, 0x4c, 0x3d, 0xc1, 0x87, 0xc7, 0x08, 0xeb, 0x0f, 0x21, 0x73, 0x41, 0xe9, 0x6b,
	0xae, 0x98, 0xa6, 0xaf, 0x8d, 0x44, 0x97, 0xfa, 0x59, 0x1c, 0x96, 0xe9, 0xc2, 0x4b, 0xe6, 0xf3,
	0xa1, 0x1d, 0xd8, 0x2c, 0x33, 0xfe, 0x26, 0xc8, 0x53, 0x5b, 0x75, 0xa5, 0x21, 0x4e, 0xf9, 0x53,
	0xf0, 0xd6, 0x7b, 0x82, 0x01, 0xac, 0xa1, 0x6f, 0x74, 0x6c, 0x87, 0x06, 0x1a, 0xbe, 0x2b, 0xdb,
	0xf3, 0xee, 0x4a, 0x75, 0xcc, 0x89, 0xa7, 0x50, 0x2e, 0xec, 0xb3, 0xfc, 0xb6, 0xfb, 0x3c, 0xcb,
	0x27, 0x12, 0xbf, 0x48, 0x9f, 0x28, 0xfc, 0x24, 0x0e, 0x40, 0x8f, 0xe6, 0x60, 0x60, 0x19, 0x21,
	0xf9, 0x3f, 0x39, 0x95, 0x49, 0x88, 0x8c, 0x7f, 0x8d, 0x10, 0x39, 0x63, 0xc7, 0xe4, 0x5f, 0x68,
	0xd6, 0xfa, 0x14, 0x6e, 0x99, 0xfc, 0xd6, 0xf9, 0xc8, 0x76, 0x88, 0x3e, 0x20, 0xae, 0x65, 0xbb,
	0x3d, 0x11, 0x98, 0x6f, 0x52, 0x14, 0xac, 0x30, 0x98, 0xa7, 0x14, 0x65, 0x9f, 0x83, 0x14, 0xfe,
	0x2b, 0x0e, 0x19, 0x7a, 0x1a, 0x74, 0x8d, 0xa4, 0xe6, 0x76, 0x3d, 0xf4, 0x11, 0x28, 0xd1, 0x7d,
	0x06, 0x3b, 0x94, 0x38, 0xbf, 0x0a, 0x14, 0xd7, 0x11, 0xaf, 0x26, 0x9f, 0x38, 0xe9, 0xf3, 0x6b,
	0x88, 0xc8, 0x35, 0x63, 0x33, 0x6e, 0x4d, 0xab, 0x90, 0x66, 0xaa, 0x1f, 0x79, 0x8e, 0x35, 0x6e,
	0x3c, 0xe6, 0x39, 0x2f, 0xcc, 0x72, 0xc7, 0x63, 0xc6, 0x76, 0xc9, 0x8d, 0xe4, 0x77, 0xe2, 0x46,
	0x8f, 0x21, 0x43, 0x95, 0xd2, 0xa3, 0x1b, 0x6d, 0xb1, 0x9f, 0x77, 0x8b, 0xfc, 0xca, 0xbb, 0x18,
	0x5d, 0x79, 0x33, 0x7e, 0x3a, 0x81, 0xdb, 0xe0, 0x67, 0xff, 0x96, 0x97, 0xf0, 0x12, 0xe5, 0x8c,
	0xc6, 0x51, 0x03, 0x92, 0xfc, 0x3d, 0x20, 0x6a, 0xc9, 0x8b, 0xf3, 0xaa, 0xf6, 0x94, 0xb1, 0x89,
	0xd3, 0x89, 0x40, 0xd0, 0x01, 0x64, 0x78, 0xde, 0x8c, 0xbc, 0x3c, 0xf9, 0x35, 0xbd, 0x7c, 0x89,
	0x65, 0x53, 0xf1, 0x8b, 0x77, 0xdf, 0x85, 0x7f, 0x95, 0x20, 0x7b, 0x31, 0x59, 0x5e, 0x77, 0xe9,
	0xfd, 0x43, 0x50, 0x02, 0x31, 0x59, 0xdc, 0x23, 0xff, 0xfe, 0xdc, 0x2d, 0xcc, 0xe5, 0x87, 0x08,
	0x7a, 0xb2, 0x2d, 0xf2, 0x1c, 0x8f, 0x11, 0xdf, 0x6d, 0xc6, 0x10, 0xfd, 0xd0, 0xff, 0x24, 0x20,
	0x51, 0x27, 0x46, 0x40, 0xd0, 0x08, 0x12, 0xfc, 0x1a, 0x4c, 0xfa, 0xe5, 0xb5, 0x67, 0x5c, 0x22,
	0xfa, 0x5d, 0x00, 0x72, 0x3a, 0xb0, 0x85, 0x61, 0xcd, 0xd3, 0x1e, 0xe2, 0x29, 0x06, 0x54, 0x85,
	0xa4, 0x68, 0xd9, 0x85, 0xc3, 0xdc, 0xe4, 0xf6, 0x25, 0x62, 0x45, 0x07, 0x70, 0xc7, 0x22, 0x03,
	0x9f, 0x98, 0x46, 0x48, 0x43, 0x15, 0x55, 0x8c, 0xfe, 0x0d, 0xec, 0xe8, 0x3e, 0xf4, 0x0d, 0x1a,
	0xad, 0x4d, 0xb8, 0xd9, 0xb5, 0x5e, 0x8b, 0xf1, 0xa2, 0x3f, 0x91, 0x20, 0x3d, 0xf0, 0xbd, 0x01,
	0xbf, 0xd9, 0x0b, 0xe6, 0xab, 0x0f, 0xb1, 0x08, 0x75, 0xb0, 0x2f, 0x38, 0xdb, 0xad, 0xb7, 0xde,
	0x6b, 0x88, 0xb4, 0x68, 0x07, 0x68, 0x15, 0x12, 0x64, 0xe0, 0x99, 0x47, 0xec, 0x82, 0x31, 0x8e,
	0xf9, 0x0f, 0xf4, 0xc1, 0x94, 0xf5, 0x52, 0x1f, 0x92, 0xcb, 0x2b, 0xaf, 0xce, 0xf2, 0x19, 0x66,
	0x1e, 0x91, 0x0f, 0x4c, 0x99, 0x23, 0x06, 0xd5, 0x98, 0xd4, 0x0b, 0x7a, 0x38, 0x1a, 0x10, 0x76,
	0x01, 0x98, 0xdd, 0xfe, 0xf6, 0xac, 0xba, 0x8a, 0xa2, 0x4c, 0xd5, 0x17, 0xed, 0xd1, 0x80, 0xe0,
	0x65, 0xe3, 0xe2, 0x00, 0xad, 0xa7, 0xfb, 0xb6, 0xab, 0x4f, 0x59, 0x43, 0xea, 0x06, 0xf5, 0x74,
	0xdf, 0x76, 0xb5, 0x89, 0x59, 0x20, 0x90, 0x43, 0xe2, 0xf7, 0x73, 0x40, 0x97, 0x82, 0xd9, 0xf7,
	0xa4, 0xe9, 0x28, 0xfc, 0xb3, 0x04, 0xd9, 0x52, 0xc7, 0xf3, 0x43, 0x9a, 0x2f, 0x35, 0x37, 0xf4,
	0x47, 0xd7, 0x39, 0xf6, 0xdb, 0xbf, 0x9b, 0x21, 0x03, 0x94, 0x71, 0x0b, 0xc5, 0xdf, 0x8c, 0xb4,
	0x57, 0x67, 0xf9, 0xd2, 0xd7, 0x8e, 0x0d, 0x51, 0xdb, 0x85, 0xc7, 0xb0, 0x0f, 0x14, 0xba, 0xb2,
	0x9f, 0xd3, 0xd5, 0xfd, 0x34, 0x06, 0x99, 0xf2, 0xb0, 0xdb, 0x25, 0x7e, 0x14, 0xb5, 0x6e, 0x43,
	0x4c, 0x64, 0x28, 0xb9, 0xbc, 0x78, 0x7e, 0x96, 0x8f, 0xd5, 0xaa, 0x38, 0x66, 0x5f, 0x9b, 0x8c,
	0x7e, 0x0f, 0xe4, 0x13, 0xc3, 0xa1, 0x59, 0xff, 0xaa, 0x76, 0xfa, 0x82, 0x88, 0xe2, 0xa1, 0xe1,
	0x88, 0x65, 0x33, 0xbe, 0xf5, 0x9f, 0x48, 0x10, 0x3f, 0x34, 0x1c, 0xf4, 0x21, 0xc4, 0x4f, 0x0c,
	0x47, 0xc4, 0x95, 0x37, 0x3d, 0x04, 0xd2, 0xa9, 0x08, 0x43, 0x3c, 0x20, 0xcf, 0xdf, 0x59, 0x08,
	0xa5, 0x60, 0x85, 0xbf, 0x8f, 0xc3, 0x4a, 0x9d, 0x18, 0xdd, 0xf6, 0xa9, 0x5b, 0x73, 0x07, 0x43,
	0xf6, 0x72, 0x44, 0xd0, 0xf7, 0x78, 0x61, 0xc4, 0x75, 0xdb, 0xb8, 0xbe, 0xb0, 0x99, 0xae, 0x89,
	0xbe, 0x0d, 0xcb, 0x3e, 0xe9, 0xfa, 0x24, 0x38, 0xd2, 0x6d, 0xf7, 0xc4, 0x70, 0x6c, 0x4b, 0x3c,
	0x28, 0x65, 0xc5, 0x70, 0x8d, 0x8f, 0xce, 0xec, 0xcb, 0x94, 0xb7, 0xeb, 0xcb, 0xb6, 0x61, 0x2d,
	0x08, 0xc9, 0x60, 0x60, 0xbb, 0x3d, 0xbd, 0xef, 0x59, 0x44, 0x27, 0xae, 0xd1, 0x71, 0x88, 0xc5,
	0x7c, 0x45, 0xc1, 0xb7, 0x22, 0xe2, 0x9e, 0x67, 0x11, 0x8d, 0x93, 0x50, 0x07, 0x96, 0xf8, 0x13,
	0x00, 0x79, 0xae, 0xbb, 0x43, 0xee, 0x14, 0xef, 0x62, 0x6b, 0x81, 0xa2, 0xf2, 0x4a, 0x0c, 0x35,
	0x61, 0xb9, 0x23, 0x0c, 0x22, 0x5a, 0x29, 0xef, 0x62, 0x37, 0xdf, 0x64, 0x3a, 0xd1, 0x42, 0x3b,
	0xd3, 0x83, 0xc1, 0xa5, 0x4e, 0x50, 0x56, 0x13, 0xbb, 0xb2, 0x92, 0x50, 0x17, 0x79, 0x57, 0x58,
	0xf8, 0x07, 0x69, 0x7c, 0xa0, 0x8f, 0x6c, 0xd7, 0x70, 0xde, 0xee, 0x40, 0xcb, 0x90, 0x89, 0x0e,
	0x94, 0x37, 0xe0, 0xf2, 0x3c, 0x0d, 0xf8, 0x92, 0xe0, 0xe1, 0x3d, 0xf8, 0xbc, 0x46, 0x71, 0x69,
	0x61, 0xe3, 0x25, 0xf1, 0x16, 0xb7, 0xf0, 0x97, 0x31, 0x58, 0xae, 0x38, 0x36, 0x71, 0xc5, 0xc3,
	0x15, 0x2d, 0x33, 0x1f, 0xc3, 0x9a, 0x35, 0x4e, 0x5d, 0x7a, 0x8f, 0xb8, 0x44, 0xc4, 0x47, 0x5e,
	0x73, 0xde, 0x7a, 0x75, 0x96, 0x5f, 0x66, 0xb3, 0x77, 0xc6, 0x24, 0xbc, 0x3a, 0xe1, 0x98, 0x8c,
	0xa2, 0xdf, 0x86, 0xac, 0x43, 0x63, 0xb1, 0x7e, 0xa1, 0x52, 0x89, 0xcf, 0x8a, 0xf5, 0x19, 0x67,
	0xfa, 0x27, 0x22, 0x70, 0xe7, 0xf2, 0x0b, 0x95, 0x3e, 0xf0, 0x1c, 0xdb, 0x8c, 0x5a, 0xb5, 0x0f,
	0xae, 0x7a, 0xa6, 0xb9, 0xf4, 0x2c, 0xb5, 0xcf, 0x98, 0xf0, 0x9a, 0x39, 0x6b, 0x18, 0x7d, 0x04,
	0xab, 0xe4, 0x94, 0xe6, 0x64, 0x3b, 0x74, 0x46, 0xba, 0x4f, 0xa5, 0x07, 0x21, 0xb1, 0x58, 0x16,
	0x56, 0xf0, 0xad, 0x09, 0x0d, 0x47, 0xa4, 0xc2, 0x7f, 0x4a, 0x90, 0x9a, 0xec, 0xd5, 0x43, 0xf1,
	0x76, 0x74, 0xd3, 0xd7, 0x55, 0xfe, 0x82, 0xf4, 0x5d, 0x48, 0xb0, 0x65, 0x5f, 0xf3, 0x8f, 0x0b,
	0x6c, 0x97, 0xa2, 0x7f, 0x5c, 0x60, 0x93, 0x7f, 0x49, 0x7b, 0x23, 0x8a, 0xd2, 0xdf, 0x02, 0xa5,
	0x4d, 0x5c, 0xc3, 0x0d, 0x6b, 0x55, 0xf4, 0xad, 0xa9, 0xb8, 0xbe, 0x72, 0x7e, 0x96, 0xcf, 0x44,
	0x2f, 0x2d, 0x2c, 0xa8, 0xd2, 0x10, 0xcf, 0x93, 0x1e, 0x4b, 0x0b, 0x5d, 0x50, 0xb0, 0xf7, 0xa2,
	0xe2, 0x0d, 0xdd, 0x10, 0xbd, 0x07, 0x29, 0xcb, 0x08, 0x0d, 0x3d, 0xb0, 0x5f, 0x12, 0x6e, 0x45,
	0x58, 0xa1, 0x03, 0x2d, 0xfb, 0x25, 0xa1, 0xb9, 0xd3, 0xf7, 0x5e, 0x04, 0xdc, 0x34, 0x30, 0xfb,
	0x46, 0xef, 0x43, 0xc6, 0x76, 0x2d, 0x72, 0xaa, 0x13, 0x37, 0xf4, 0x6d, 0xc2, 0xbb, 0xc1, 0x38,
	0x5e, 0x62, 0x83, 0x1a, 0x1f, 0xe3, 0x6e, 0x7a, 0xff, 0x5f, 0x24, 0x48, 0x31, 0xf9, 0x2c, 0xa9,
	0xa7, 0x21, 0x79, 0xd0, 0x78, 0xd2, 0x68, 0x3e, 0x6d, 0xa8, 0x0b, 0x28, 0x09, 0xf1, 0x5a, 0xa3,
	0xad, 0x4a, 0x28, 0x05, 0x89, 0x47, 0xf5, 0x66, 0xa9, 0xad, 0xc6, 0xe8, 0x67, 0xf9, 0x59, 0x5b,
	0x6b, 0xa9, 0x71, 0xa4, 0x80, 0xdc, 0xae, 0xed, 0x69, 0xaa, 0x4c, 0xb9, 0xaa, 0x5a, 0xa5, 0xb6,
	0x57, 0xaa, 0xab, 0x09, 0xb4, 0x04, 0x4a, 0xf5, 0x00, 0x97, 0xda, 0xb5, 0x66, 0x43, 0x5d, 0x44,
	0x00, 0x8b, 0x74, 0x52, 0xfb, 0x53, 0x75, 0x89, 0xe2, 0xed, 0x68, 0x4d, 0x35, 0xc3, 0x40, 0x9a,
	0x9f, 0x6c, 0x57, 0xd5, 0x2c, 0xfd, 0x6c, 0x1f, 0xec, 0xd7, 0x35, 0x15, 0x28, 0x63, 0xb9, 0xd6,
	0x2e, 0x61, 0x5c, 0x7a, 0xa6, 0xa6, 0x51, 0x16, 0x80, 0x32, 0xb6, 0x34, 0x5c, 0xd3, 0x5a, 0xaa,
	0x85, 0xde, 0x87, 0xfc, 0xde, 0x61, 0xa5, 0xa2, 0x6b, 0x9f, 0xb4, 0xb5, 0x46, 0x55, 0xab, 0xea,
	0x5a, 0xa3, 0xd2, 0xac, 0xd6, 0x1a, 0x3b, 0x7a, 0x4b, 0x6b, 0xb4, 0x6b, 0x0d, 0xad, 0xae, 0x92,
	0x82, 0xac, 0x24, 0xd5, 0x64, 0x81, 0xba, 0xa6, 0x52, 0x90, 0x95, 0x94, 0x9a, 0xba, 0x6f, 0xc2,
	0x8a, 0x28, 0x27, 0xf9, 0xfb, 0x0f, 0x5b, 0x65, 0x06, 0x52, 0xa5, 0x6a, 0x55, 0x3f, 0x6c, 0xb6,
	0x35, 0xac, 0x2e, 0x20, 0x15, 0x96, 0xb0, 0xb6, 0xd7, 0x3c, 0xd4, 0xc4, 0x88, 0x84, 0x56, 0x20,
	0x43, 0x27, 0x34, 0x9a, 0x0d, 0x31, 0x14, 0x43, 0xab, 0xa0, 0x8a, 0x49, 0x93, 0xd1, 0xf8, 0xba,
	0xfc, 0xe3, 0x3f, 0xdb, 0x58, 0xb8, 0xff, 0xa3, 0x0b, 0x17, 0x9e, 0xbc, 0xa9, 0xa6, 0x9b, 0xb2,
	0xaf, 0x35, 0xa8, 0x86, 0xea, 0x02, 0x5d, 0xdb, 0x3e, 0xd6, 0xf6, 0x4b, 0x58, 0xab, 0xf2, 0xfd,
	0x6a, 0xb5, 0x4b, 0x3b, 0x94, 0x14, 0xa7, 0xca, 0x54, 0x9a, 0x7b, 0x7b, 0xb5, 0x76, 0x5b, 0xab,
	0xaa, 0x12, 0xa5, 0x95, 0xca, 0x4d, 0x4c, 0x7f, 0xc4, 0x04, 0x7c, 0x19, 0x56, 0x67, 0x95, 0x64,
	0x68, 0x19, 0xd2, 0x07, 0x6e, 0x30, 0x20, 0x26, 0x7b, 0x62, 0xe2, 0x52, 0x98, 0x1e, 0x5d, 0xe2,
	0x73, 0x24, 0xe1, 0x76, 0x6a, 0xec, 0xfe, 0x4b, 0x58, 0xbf, 0xda, 0x84, 0xd1, 0x3a, 0xdc, 0xae,
	0x97, 0x76, 0xf4, 0xf2, 0x33, 0xbd, 0x52, 0x3f, 0x68, 0xb5, 0x35, 0xac, 0xb7, 0xb4, 0x76, 0x9b,
	0xab, 0x7e, 0x17, 0xd6, 0xea, 0x5a, 0xa9, 0xaa, 0x3f, 0x6a, 0x62, 0x7d, 0xa7, 0xde, 0x2c, 0x97,
	0xea, 0x3a, 0xd6, 0x4a, 0xd5, 0x96, 0x2a, 0xa1, 0x3c, 0xbc, 0xb7, 0x57, 0xfa, 0x44, 0xaf, 0xd4,
	0x9b, 0x2d, 0xad, 0xaa, 0xb3, 0xe3, 0x6a, 0x97, 0xf6, 0xf6, 0xf5, 0xfd, 0x66, 0xbd, 0x56, 0x79,
	0x16, 0xe9, 0x5f, 0x6e, 0x7c, 0xf1, 0x1f, 0x1b, 0x0b, 0x5f, 0x9c, 0x6f, 0x48, 0x5f, 0x9e, 0x6f,
	0x48, 0x3f, 0x3b, 0xdf, 0x90, 0xfe, 0xfd, 0x7c, 0x43, 0xfa, 0xe9, 0x57, 0x1b, 0x0b, 0x5f, 0x7e,
	0xb5, 0xb1, 0xf0, 0xb3, 0xaf, 0x36, 0x16, 0x3e, 0xfd, 0xce, 0x5c, 0x89, 0x4d, 0xf8, 0x62, 0x67,
	0x91, 0x35, 0xb0, 0x1f, 0xff, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x97, 0xf0, 0xac, 0xf5,
	0x26, 0x00, 0x00,
}

func (this *SplitTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SplitTrigger)
	if !ok {
		that2, ok := that.(SplitTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeftDesc.Equal(&that1.LeftDesc) {
		return false
	}
	if !this.RightDesc.Equal(&that1.RightDesc) {
		return false
	}
	if !this.PreSplitLeftUserStats.Equal(&that1.PreSplitLeftUserStats) {
		return false
	}
	if !this.PreSplitStats.Equal(&that1.PreSplitStats) {
		return false
	}
	if this.UseEstimatesBecauseExternalBytesArePresent != that1.UseEstimatesBecauseExternalBytesArePresent {
		return false
	}
	if this.ManualSplit != that1.ManualSplit {
		return false
	}
	return true
}
func (this *MergeTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MergeTrigger)
	if !ok {
		that2, ok := that.(MergeTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeftDesc.Equal(&that1.LeftDesc) {
		return false
	}
	if !this.RightDesc.Equal(&that1.RightDesc) {
		return false
	}
	if !this.RightMVCCStats.Equal(&that1.RightMVCCStats) {
		return false
	}
	if !this.RightRangeIDLocalMVCCStats.Equal(&that1.RightRangeIDLocalMVCCStats) {
		return false
	}
	if !this.FreezeStart.Equal(&that1.FreezeStart) {
		return false
	}
	if !this.RightClosedTimestamp.Equal(&that1.RightClosedTimestamp) {
		return false
	}
	if !this.RightReadSummary.Equal(that1.RightReadSummary) {
		return false
	}
	if this.WriteGCHint != that1.WriteGCHint {
		return false
	}
	return true
}
func (this *AbortSpanEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AbortSpanEntry)
	if !ok {
		that2, ok := that.(AbortSpanEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (this *TenantID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TenantID)
	if !ok {
		that2, ok := that.(TenantID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InternalValue != that1.InternalValue {
		return false
	}
	return true
}
func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintData(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RawBytes) > 0 {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintData(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreIdent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreIdent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreIdent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ClusterID.Size()
		i -= size
		if _, err := m.ClusterID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SplitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManualSplit {
		i--
		if m.ManualSplit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.UseEstimatesBecauseExternalBytesArePresent {
		i--
		if m.UseEstimatesBecauseExternalBytesArePresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.PreSplitStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.PreSplitLeftUserStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.RightDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LeftDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MergeTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RightRangeIDLocalMVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.WriteGCHint {
		i--
		if m.WriteGCHint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RightReadSummary != nil {
		{
			size, err := m.RightReadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.RightClosedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.FreezeStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.RightMVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.RightDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LeftDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChangeReplicasTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeReplicasTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeReplicasTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalRemovedReplicas) > 0 {
		for iNdEx := len(m.InternalRemovedReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalRemovedReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.InternalAddedReplicas) > 0 {
		for iNdEx := len(m.InternalAddedReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalAddedReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *ModifiedSpanTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifiedSpanTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifiedSpanTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeLivenessSpan != nil {
		{
			size, err := m.NodeLivenessSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *StickyBitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickyBitTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StickyBitTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StickyBit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InternalCommitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalCommitTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalCommitTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StickyBitTrigger != nil {
		{
			size, err := m.StickyBitTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ModifiedSpanTrigger != nil {
		{
			size, err := m.ModifiedSpanTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ChangeReplicasTrigger != nil {
		{
			size, err := m.ChangeReplicasTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MergeTrigger != nil {
		{
			size, err := m.MergeTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SplitTrigger != nil {
		{
			size, err := m.SplitTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObservedTimestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObservedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObservedTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NodeID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OmitInRangefeeds {
		i--
		if m.OmitInRangefeeds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AdmissionPriority != 0 {
		i = encodeVarintData(dAtA, i, uint64((uint32(m.AdmissionPriority)<<1)^uint32((m.AdmissionPriority>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.ReadTimestampFixed {
		i--
		if m.ReadTimestampFixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.ReadTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if len(m.LockSpans) > 0 {
		for iNdEx := len(m.LockSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ObservedTimestamps) > 0 {
		for iNdEx := len(m.ObservedTimestamps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObservedTimestamps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.GlobalUncertaintyLimit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.LastHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Status != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.TxnMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransactionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.LockSpans) > 0 {
		for iNdEx := len(m.LockSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	{
		size, err := m.LastHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Status != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.TxnMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Lock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Strength != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Lock_SingleKeySpan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Lock_SingleKeySpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lock_SingleKeySpan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lock_SingleKeySpan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *LockAcquisition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockAcquisition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockAcquisition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Strength != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x20
	}
	if m.Durability != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Durability))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClockWhilePending.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Status != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockStateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockStateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LockStrength != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LockStrength))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Waiters) > 0 {
		for iNdEx := len(m.Waiters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Waiters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.HoldDuration != 0 {
		n36, err36 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.HoldDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.HoldDuration):])
		if err36 != nil {
			return 0, err36
		}
		i -= n36
		i = encodeVarintData(dAtA, i, uint64(n36))
		i--
		dAtA[i] = 0x2a
	}
	if m.Durability != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Durability))
		i--
		dAtA[i] = 0x20
	}
	if m.LockHolder != nil {
		{
			size, err := m.LockHolder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequencedWrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequencedWrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequencedWrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Strength != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x18
	}
	if m.Sequence != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.MinExpiration.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.AcquisitionType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AcquisitionType))
		i--
		dAtA[i] = 0x40
	}
	if m.Sequence != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.ProposedTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.DeprecatedStartStasis != nil {
		{
			size, err := m.DeprecatedStartStasis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AbortSpanEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbortSpanEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AbortSpanEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BufferedWrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferedWrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferedWrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vals) > 0 {
		for iNdEx := len(m.Vals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BufferedWrite_Val) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferedWrite_Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferedWrite_Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeafTxnInputState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafTxnInputState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafTxnInputState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BufferedWrites) > 0 {
		for iNdEx := len(m.BufferedWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BufferedWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ReadSeqNum != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReadSeqNum))
		i--
		dAtA[i] = 0x50
	}
	if m.SteppingModeEnabled {
		i--
		if m.SteppingModeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.RefreshInvalid {
		i--
		if m.RefreshInvalid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeafTxnFinalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafTxnFinalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafTxnFinalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefreshInvalid {
		i--
		if m.RefreshInvalid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RefreshSpans) > 0 {
		for iNdEx := len(m.RefreshSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RefreshSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClientRangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientRangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientRangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExplicitlyRequested {
		i--
		if m.ExplicitlyRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ClosedTimestampPolicy != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ClosedTimestampPolicy))
		i--
		dAtA[i] = 0x18
	}
	if m.LeaseSequence != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LeaseSequence))
		i--
		dAtA[i] = 0x10
	}
	if m.DescriptorGeneration != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DescriptorGeneration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClosedTimestampPolicy != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ClosedTimestampPolicy))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TenantID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InternalValue != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.InternalValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexEntries != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.IndexEntries))
		i--
		dAtA[i] = 0x18
	}
	if m.Rows != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Rows))
		i--
		dAtA[i] = 0x10
	}
	if m.DataSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DataSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	offset -= sovData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedSpan(r randyData, easy bool) *Span {
	this := &Span{}
	v1 := r.Intn(100)
	this.Key = make(Key, v1)
	for i := 0; i < v1; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v2 := r.Intn(100)
	this.EndKey = make(Key, v2)
	for i := 0; i < v2; i++ {
		this.EndKey[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObservedTimestamp(r randyData, easy bool) *ObservedTimestamp {
	this := &ObservedTimestamp{}
	this.NodeID = NodeID(r.Int31())
	if r.Intn(2) == 0 {
		this.NodeID *= -1
	}
	v3 := github_com_cockroachdb_cockroach_pkg_util_hlc.NewPopulatedClockTimestamp(r, easy)
	this.Timestamp = *v3
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTransaction(r randyData, easy bool) *Transaction {
	this := &Transaction{}
	v4 := enginepb.NewPopulatedTxnMeta(r, easy)
	this.TxnMeta = *v4
	this.Name = string(randStringData(r))
	this.Status = TransactionStatus([]int32{0, 4, 3, 1, 2}[r.Intn(5)])
	v5 := hlc.NewPopulatedTimestamp(r, easy)
	this.LastHeartbeat = *v5
	v6 := hlc.NewPopulatedTimestamp(r, easy)
	this.GlobalUncertaintyLimit = *v6
	if r.Intn(5) != 0 {
		v7 := r.Intn(5)
		this.ObservedTimestamps = make([]ObservedTimestamp, v7)
		for i := 0; i < v7; i++ {
			v8 := NewPopulatedObservedTimestamp(r, easy)
			this.ObservedTimestamps[i] = *v8
		}
	}
	if r.Intn(5) != 0 {
		v9 := r.Intn(5)
		this.LockSpans = make([]Span, v9)
		for i := 0; i < v9; i++ {
			v10 := NewPopulatedSpan(r, easy)
			this.LockSpans[i] = *v10
		}
	}
	v11 := hlc.NewPopulatedTimestamp(r, easy)
	this.ReadTimestamp = *v11
	this.ReadTimestampFixed = bool(bool(r.Intn(2) == 0))
	if r.Intn(5) != 0 {
		v12 := r.Intn(5)
		this.InFlightWrites = make([]SequencedWrite, v12)
		for i := 0; i < v12; i++ {
			v13 := NewPopulatedSequencedWrite(r, easy)
			this.InFlightWrites[i] = *v13
		}
	}
	if r.Intn(5) != 0 {
		v14 := r.Intn(5)
		this.IgnoredSeqNums = make([]enginepb.IgnoredSeqNumRange, v14)
		for i := 0; i < v14; i++ {
			v15 := enginepb.NewPopulatedIgnoredSeqNumRange(r, easy)
			this.IgnoredSeqNums[i] = *v15
		}
	}
	this.AdmissionPriority = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.AdmissionPriority *= -1
	}
	this.OmitInRangefeeds = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTransactionRecord(r randyData, easy bool) *TransactionRecord {
	this := &TransactionRecord{}
	v16 := enginepb.NewPopulatedTxnMeta(r, easy)
	this.TxnMeta = *v16
	this.Status = TransactionStatus([]int32{0, 4, 3, 1, 2}[r.Intn(5)])
	v17 := hlc.NewPopulatedTimestamp(r, easy)
	this.LastHeartbeat = *v17
	if r.Intn(5) != 0 {
		v18 := r.Intn(5)
		this.LockSpans = make([]Span, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedSpan(r, easy)
			this.LockSpans[i] = *v19
		}
	}
	if r.Intn(5) != 0 {
		v20 := r.Intn(5)
		this.InFlightWrites = make([]SequencedWrite, v20)
		for i := 0; i < v20; i++ {
			v21 := NewPopulatedSequencedWrite(r, easy)
			this.InFlightWrites[i] = *v21
		}
	}
	if r.Intn(5) != 0 {
		v22 := r.Intn(5)
		this.IgnoredSeqNums = make([]enginepb.IgnoredSeqNumRange, v22)
		for i := 0; i < v22; i++ {
			v23 := enginepb.NewPopulatedIgnoredSeqNumRange(r, easy)
			this.IgnoredSeqNums[i] = *v23
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSequencedWrite(r randyData, easy bool) *SequencedWrite {
	this := &SequencedWrite{}
	v24 := r.Intn(100)
	this.Key = make(Key, v24)
	for i := 0; i < v24; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	this.Sequence = github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(r.Int31())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	this.Strength = lock.Strength([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLease(r randyData, easy bool) *Lease {
	this := &Lease{}
	v25 := github_com_cockroachdb_cockroach_pkg_util_hlc.NewPopulatedClockTimestamp(r, easy)
	this.Start = *v25
	if r.Intn(5) != 0 {
		this.Expiration = hlc.NewPopulatedTimestamp(r, easy)
	}
	v26 := NewPopulatedReplicaDescriptor(r, easy)
	this.Replica = *v26
	if r.Intn(5) != 0 {
		this.DeprecatedStartStasis = hlc.NewPopulatedTimestamp(r, easy)
	}
	v27 := github_com_cockroachdb_cockroach_pkg_util_hlc.NewPopulatedClockTimestamp(r, easy)
	this.ProposedTS = *v27
	this.Epoch = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Epoch *= -1
	}
	this.Sequence = LeaseSequence(uint64(r.Uint32()))
	this.AcquisitionType = LeaseAcquisitionType([]int32{0, 1, 2}[r.Intn(3)])
	v28 := hlc.NewPopulatedTimestamp(r, easy)
	this.MinExpiration = *v28
	this.Term = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAbortSpanEntry(r randyData, easy bool) *AbortSpanEntry {
	this := &AbortSpanEntry{}
	v29 := r.Intn(100)
	this.Key = make(Key, v29)
	for i := 0; i < v29; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v30 := hlc.NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v30
	this.Priority = github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnPriority(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyData interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneData(r randyData) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringData(r randyData) string {
	v31 := r.Intn(100)
	tmps := make([]rune, v31)
	for i := 0; i < v31; i++ {
		tmps[i] = randUTF8RuneData(r)
	}
	return string(tmps)
}
func randUnrecognizedData(r randyData, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldData(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldData(dAtA []byte, r randyData, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		v32 := r.Int63()
		if r.Intn(2) == 0 {
			v32 *= -1
		}
		dAtA = encodeVarintPopulateData(dAtA, uint64(v32))
	case 1:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateData(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateData(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *StoreIdent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterID.Size()
	n += 1 + l + sovData(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovData(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovData(uint64(m.StoreID))
	}
	return n
}

func (m *SplitTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.PreSplitLeftUserStats.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.PreSplitStats.Size()
	n += 1 + l + sovData(uint64(l))
	if m.UseEstimatesBecauseExternalBytesArePresent {
		n += 2
	}
	if m.ManualSplit {
		n += 2
	}
	return n
}

func (m *MergeTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightMVCCStats.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.FreezeStart.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightClosedTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.RightReadSummary != nil {
		l = m.RightReadSummary.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.WriteGCHint {
		n += 2
	}
	l = m.RightRangeIDLocalMVCCStats.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *ChangeReplicasTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.InternalAddedReplicas) > 0 {
		for _, e := range m.InternalAddedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.InternalRemovedReplicas) > 0 {
		for _, e := range m.InternalRemovedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *ModifiedSpanTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeLivenessSpan != nil {
		l = m.NodeLivenessSpan.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *StickyBitTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StickyBit.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *InternalCommitTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SplitTrigger != nil {
		l = m.SplitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MergeTrigger != nil {
		l = m.MergeTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ChangeReplicasTrigger != nil {
		l = m.ChangeReplicasTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ModifiedSpanTrigger != nil {
		l = m.ModifiedSpanTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.StickyBitTrigger != nil {
		l = m.StickyBitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ObservedTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovData(uint64(m.NodeID))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovData(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	l = m.LastHeartbeat.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.GlobalUncertaintyLimit.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.ObservedTimestamps) > 0 {
		for _, e := range m.ObservedTimestamps {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.LockSpans) > 0 {
		for _, e := range m.LockSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	l = m.ReadTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.ReadTimestampFixed {
		n += 3
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	if m.AdmissionPriority != 0 {
		n += 2 + sozData(uint64(m.AdmissionPriority))
	}
	if m.OmitInRangefeeds {
		n += 3
	}
	return n
}

func (m *TransactionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	l = m.LastHeartbeat.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.LockSpans) > 0 {
		for _, e := range m.LockSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *Lock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Lock_SingleKeySpan.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Strength != 0 {
		n += 1 + sovData(uint64(m.Strength))
	}
	return n
}

func (m *Lock_SingleKeySpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *LockAcquisition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Durability != 0 {
		n += 1 + sovData(uint64(m.Durability))
	}
	if m.Strength != 0 {
		n += 1 + sovData(uint64(m.Strength))
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *LockUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	l = m.ClockWhilePending.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *LockStateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovData(uint64(m.RangeID))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.LockHolder != nil {
		l = m.LockHolder.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Durability != 0 {
		n += 1 + sovData(uint64(m.Durability))
	}
	if m.HoldDuration != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.HoldDuration)
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Waiters) > 0 {
		for _, e := range m.Waiters {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.LockStrength != 0 {
		n += 1 + sovData(uint64(m.LockStrength))
	}
	return n
}

func (m *SequencedWrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovData(uint64(m.Sequence))
	}
	if m.Strength != 0 {
		n += 1 + sovData(uint64(m.Strength))
	}
	return n
}

func (m *Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Replica.Size()
	n += 1 + l + sovData(uint64(l))
	if m.DeprecatedStartStasis != nil {
		l = m.DeprecatedStartStasis.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.ProposedTS.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Epoch != 0 {
		n += 1 + sovData(uint64(m.Epoch))
	}
	if m.Sequence != 0 {
		n += 1 + sovData(uint64(m.Sequence))
	}
	if m.AcquisitionType != 0 {
		n += 1 + sovData(uint64(m.AcquisitionType))
	}
	l = m.MinExpiration.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Term != 0 {
		n += 1 + sovData(uint64(m.Term))
	}
	return n
}

func (m *AbortSpanEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Priority != 0 {
		n += 1 + sovData(uint64(m.Priority))
	}
	return n
}

func (m *BufferedWrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovData(uint64(m.ID))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Vals) > 0 {
		for _, e := range m.Vals {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *BufferedWrite_Val) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Val.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Seq != 0 {
		n += 1 + sovData(uint64(m.Seq))
	}
	return n
}

func (m *LeafTxnInputState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.RefreshInvalid {
		n += 2
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.SteppingModeEnabled {
		n += 2
	}
	if m.ReadSeqNum != 0 {
		n += 1 + sovData(uint64(m.ReadSeqNum))
	}
	if len(m.BufferedWrites) > 0 {
		for _, e := range m.BufferedWrites {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *LeafTxnFinalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.RefreshSpans) > 0 {
		for _, e := range m.RefreshSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.RefreshInvalid {
		n += 2
	}
	return n
}

func (m *ClientRangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorGeneration != 0 {
		n += 1 + sovData(uint64(m.DescriptorGeneration))
	}
	if m.LeaseSequence != 0 {
		n += 1 + sovData(uint64(m.LeaseSequence))
	}
	if m.ClosedTimestampPolicy != 0 {
		n += 1 + sovData(uint64(m.ClosedTimestampPolicy))
	}
	if m.ExplicitlyRequested {
		n += 2
	}
	return n
}

func (m *RangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovData(uint64(l))
	if m.ClosedTimestampPolicy != 0 {
		n += 1 + sovData(uint64(m.ClosedTimestampPolicy))
	}
	return n
}

func (m *TenantID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalValue != 0 {
		n += 1 + sovData(uint64(m.InternalValue))
	}
	return n
}

func (m *RowCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataSize != 0 {
		n += 1 + sovData(uint64(m.DataSize))
	}
	if m.Rows != 0 {
		n += 1 + sovData(uint64(m.Rows))
	}
	if m.IndexEntries != 0 {
		n += 1 + sovData(uint64(m.IndexEntries))
	}
	return n
}

func sovData(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreIdent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreIdent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreIdent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSplitLeftUserStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreSplitLeftUserStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSplitStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreSplitStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseEstimatesBecauseExternalBytesArePresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseEstimatesBecauseExternalBytesArePresent = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualSplit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ManualSplit = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightMVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightMVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreezeStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FreezeStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightClosedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightClosedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightReadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightReadSummary == nil {
				m.RightReadSummary = &rspb.ReadSummary{}
			}
			if err := m.RightReadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteGCHint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteGCHint = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightRangeIDLocalMVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightRangeIDLocalMVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeReplicasTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &RangeDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalAddedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalAddedReplicas = append(m.InternalAddedReplicas, ReplicaDescriptor{})
			if err := m.InternalAddedReplicas[len(m.InternalAddedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalRemovedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalRemovedReplicas = append(m.InternalRemovedReplicas, ReplicaDescriptor{})
			if err := m.InternalRemovedReplicas[len(m.InternalRemovedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifiedSpanTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLivenessSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeLivenessSpan == nil {
				m.NodeLivenessSpan = &Span{}
			}
			if err := m.NodeLivenessSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickyBitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickyBitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickyBitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickyBit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StickyBit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalCommitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalCommitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalCommitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitTrigger == nil {
				m.SplitTrigger = &SplitTrigger{}
			}
			if err := m.SplitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeTrigger == nil {
				m.MergeTrigger = &MergeTrigger{}
			}
			if err := m.MergeTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicasTrigger == nil {
				m.ChangeReplicasTrigger = &ChangeReplicasTrigger{}
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedSpanTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedSpanTrigger == nil {
				m.ModifiedSpanTrigger = &ModifiedSpanTrigger{}
			}
			if err := m.ModifiedSpanTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickyBitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StickyBitTrigger == nil {
				m.StickyBitTrigger = &StickyBitTrigger{}
			}
			if err := m.StickyBitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObservedTimestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObservedTimestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObservedTimestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalUncertaintyLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalUncertaintyLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedTimestamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedTimestamps = append(m.ObservedTimestamps, ObservedTimestamp{})
			if err := m.ObservedTimestamps[len(m.ObservedTimestamps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockSpans = append(m.LockSpans, Span{})
			if err := m.LockSpans[len(m.LockSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimestampFixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadTimestampFixed = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionPriority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AdmissionPriority = v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OmitInRangefeeds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OmitInRangefeeds = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockSpans = append(m.LockSpans, Span{})
			if err := m.LockSpans[len(m.LockSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock_SingleKeySpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lock_SingleKeySpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lock_SingleKeySpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleKeySpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleKeySpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockAcquisition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockAcquisition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockAcquisition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durability", wireType)
			}
			m.Durability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Durability |= lock.Durability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockWhilePending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClockWhilePending.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockHolder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockHolder == nil {
				m.LockHolder = &enginepb.TxnMeta{}
			}
			if err := m.LockHolder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durability", wireType)
			}
			m.Durability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Durability |= lock.Durability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.HoldDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waiters = append(m.Waiters, lock.Waiter{})
			if err := m.Waiters[len(m.Waiters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockStrength", wireType)
			}
			m.LockStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockStrength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequencedWrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequencedWrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequencedWrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &hlc.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedStartStasis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedStartStasis == nil {
				m.DeprecatedStartStasis = &hlc.Timestamp{}
			}
			if err := m.DeprecatedStartStasis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProposedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= LeaseSequence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcquisitionType", wireType)
			}
			m.AcquisitionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcquisitionType |= LeaseAcquisitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinExpiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinExpiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbortSpanEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbortSpanEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbortSpanEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferedWrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferedWrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferedWrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vals = append(m.Vals, BufferedWrite_Val{})
			if err := m.Vals[len(m.Vals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferedWrite_Val) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Val: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Val: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafTxnInputState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafTxnInputState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafTxnInputState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInvalid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshInvalid = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteppingModeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SteppingModeEnabled = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSeqNum", wireType)
			}
			m.ReadSeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSeqNum |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferedWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufferedWrites = append(m.BufferedWrites, BufferedWrite{})
			if err := m.BufferedWrites[len(m.BufferedWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafTxnFinalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafTxnFinalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafTxnFinalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshSpans = append(m.RefreshSpans, Span{})
			if err := m.RefreshSpans[len(m.RefreshSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInvalid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshInvalid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorGeneration", wireType)
			}
			m.DescriptorGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorGeneration |= RangeGeneration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseSequence", wireType)
			}
			m.LeaseSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseSequence |= LeaseSequence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestampPolicy", wireType)
			}
			m.ClosedTimestampPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedTimestampPolicy |= RangeClosedTimestampPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitlyRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExplicitlyRequested = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestampPolicy", wireType)
			}
			m.ClosedTimestampPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedTimestampPolicy |= RangeClosedTimestampPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalValue", wireType)
			}
			m.InternalValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalValue |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSize", wireType)
			}
			m.DataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexEntries", wireType)
			}
			m.IndexEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupData = fmt.Errorf("proto: unexpected end of group")
)

