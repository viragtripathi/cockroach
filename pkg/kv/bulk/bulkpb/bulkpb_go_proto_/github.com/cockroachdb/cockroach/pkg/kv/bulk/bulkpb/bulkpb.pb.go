// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/bulk/bulkpb/bulkpb.proto

package bulkpb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type HistogramData struct {
	DataType              HistogramDataType `protobuf:"varint,5,opt,name=data_type,json=dataType,proto3,casttype=HistogramDataType" json:"data_type,omitempty"`
	LowestTrackableValue  int64             `protobuf:"varint,1,opt,name=lowest_trackable_value,json=lowestTrackableValue,proto3" json:"lowest_trackable_value,omitempty"`
	HighestTrackableValue int64             `protobuf:"varint,2,opt,name=highest_trackable_value,json=highestTrackableValue,proto3" json:"highest_trackable_value,omitempty"`
	SignificantFigures    int64             `protobuf:"varint,3,opt,name=significant_figures,json=significantFigures,proto3" json:"significant_figures,omitempty"`
	Counts                []int64           `protobuf:"varint,4,rep,packed,name=counts,proto3" json:"counts,omitempty"`
}

func (m *HistogramData) Reset()      { *m = HistogramData{} }
func (*HistogramData) ProtoMessage() {}
func (*HistogramData) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cacc7c5400f9db8, []int{0}
}
func (m *HistogramData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistogramData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HistogramData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramData.Merge(m, src)
}
func (m *HistogramData) XXX_Size() int {
	return m.Size()
}
func (m *HistogramData) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramData.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramData proto.InternalMessageInfo

// IngestionPerformanceStats is a message containing information about the
// creation of SSTables by an SSTBatcher or BufferingAdder.
type IngestionPerformanceStats struct {
	// LogicalDataSize is the total byte size of all the KVs ingested.
	LogicalDataSize int64 `protobuf:"varint,1,opt,name=logical_data_size,json=logicalDataSize,proto3" json:"logical_data_size,omitempty"`
	// SSTDataSize is the total byte size of the SSTs sent to KV for ingestion.
	SSTDataSize int64 `protobuf:"varint,23,opt,name=sst_data_size,json=sstDataSize,proto3" json:"sst_data_size,omitempty"`
	// Buffer Flushes is the number of buffer flushes.
	BufferFlushes int64 `protobuf:"varint,2,opt,name=buffer_flushes,json=bufferFlushes,proto3" json:"buffer_flushes,omitempty"`
	// FlushesDueToSize is the number of buffer flushes due to buffer size.
	FlushesDueToSize int64 `protobuf:"varint,3,opt,name=flushes_due_to_size,json=flushesDueToSize,proto3" json:"flushes_due_to_size,omitempty"`
	// Batches is the number of batches (addsstable calls) sent.
	Batches int64 `protobuf:"varint,4,opt,name=batches,proto3" json:"batches,omitempty"`
	// BatchesDueToRange is the number of batches due to range bounds.
	BatchesDueToRange int64 `protobuf:"varint,5,opt,name=batches_due_to_range,json=batchesDueToRange,proto3" json:"batches_due_to_range,omitempty"`
	// BatchesDueToSize is the number of batches due to batch size.
	BatchesDueToSize int64 `protobuf:"varint,6,opt,name=batches_due_to_size,json=batchesDueToSize,proto3" json:"batches_due_to_size,omitempty"`
	// SplitRetries is the number of extra sub-batches created due to unexpected
	// splits.
	SplitRetries int64 `protobuf:"varint,7,opt,name=split_retries,json=splitRetries,proto3" json:"split_retries,omitempty"`
	// Splits is the number of splits sent.
	Splits int64 `protobuf:"varint,8,opt,name=splits,proto3" json:"splits,omitempty"`
	// Scatters is the number of scatters sent.0
	Scatters int64 `protobuf:"varint,9,opt,name=scatters,proto3" json:"scatters,omitempty"`
	// ScatterMoved is the total size in bytes moved by scatter calls.
	ScatterMoved int64 `protobuf:"varint,10,opt,name=scatter_moved,json=scatterMoved,proto3" json:"scatter_moved,omitempty"`
	// FillWait is the time spent between buffer flushes.
	FillWait time.Duration `protobuf:"varint,11,opt,name=fill_wait,json=fillWait,proto3,casttype=time.Duration" json:"fill_wait,omitempty"`
	// SortWait is the time spent sorting buffers.
	SortWait time.Duration `protobuf:"varint,12,opt,name=sort_wait,json=sortWait,proto3,casttype=time.Duration" json:"sort_wait,omitempty"`
	// FlushWait is the time spent flushing buffers.
	FlushWait time.Duration `protobuf:"varint,13,opt,name=flush_wait,json=flushWait,proto3,casttype=time.Duration" json:"flush_wait,omitempty"`
	// BatchWait is the time spent flushing batches (inc split/scatter/send).
	BatchWait time.Duration `protobuf:"varint,14,opt,name=batch_wait,json=batchWait,proto3,casttype=time.Duration" json:"batch_wait,omitempty"`
	// BatchWaitHist is a histogram of the time spent flushing batches.
	BatchWaitHist *HistogramData `protobuf:"bytes,24,opt,name=batch_wait_hist,json=batchWaitHist,proto3" json:"batch_wait_hist,omitempty"`
	// SendWait is the time spent sending batches (addsstable+retries)
	SendWait time.Duration `protobuf:"varint,15,opt,name=send_wait,json=sendWait,proto3,casttype=time.Duration" json:"send_wait,omitempty"`
	// SplitWait is the time spent splitting.
	SplitWait time.Duration `protobuf:"varint,16,opt,name=split_wait,json=splitWait,proto3,casttype=time.Duration" json:"split_wait,omitempty"`
	// ScatterWait is the time spent scattering.
	ScatterWait time.Duration `protobuf:"varint,17,opt,name=scatter_wait,json=scatterWait,proto3,casttype=time.Duration" json:"scatter_wait,omitempty"`
	// CommitWait is the time spent waiting for commit timestamps.
	CommitWait time.Duration `protobuf:"varint,18,opt,name=commit_wait,json=commitWait,proto3,casttype=time.Duration" json:"commit_wait,omitempty"`
	// Duration is the difference between the CurrentFlushTime and the
	// PreviousFlushTime.
	Duration time.Duration `protobuf:"varint,19,opt,name=duration,proto3,casttype=time.Duration" json:"duration,omitempty"`
	// LastFlushTime is the timestamp at which we completed the flush prior to the
	// current flush.
	LastFlushTime hlc.Timestamp `protobuf:"bytes,21,opt,name=last_flush_time,json=lastFlushTime,proto3" json:"last_flush_time"`
	// CurrentFlushTime is the timestamp at which we finished the current flush.
	CurrentFlushTime hlc.Timestamp `protobuf:"bytes,22,opt,name=current_flush_time,json=currentFlushTime,proto3" json:"current_flush_time"`
	// SendWaitByStore is the time spent sending batches to each store.
	SendWaitByStore map[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID]time.Duration `protobuf:"bytes,20,rep,name=send_wait_by_store,json=sendWaitByStore,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID,castvalue=time.Duration" json:"send_wait_by_store,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// AsWrites is the number of AddSSTable requests that are ingested as a write
	// batch.
	AsWrites int64 `protobuf:"varint,25,opt,name=as_writes,json=asWrites,proto3" json:"as_writes,omitempty"`
	// SSTSizeHist is a histogram of the sizes of the SSTs sent to KV for
	// ingestion via AddSSSTable requests.
	SstSizeHist *HistogramData `protobuf:"bytes,26,opt,name=sst_size_hist,json=sstSizeHist,proto3" json:"sst_size_hist,omitempty"`
}

func (m *IngestionPerformanceStats) Reset()      { *m = IngestionPerformanceStats{} }
func (*IngestionPerformanceStats) ProtoMessage() {}
func (*IngestionPerformanceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cacc7c5400f9db8, []int{1}
}
func (m *IngestionPerformanceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestionPerformanceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IngestionPerformanceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestionPerformanceStats.Merge(m, src)
}
func (m *IngestionPerformanceStats) XXX_Size() int {
	return m.Size()
}
func (m *IngestionPerformanceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestionPerformanceStats.DiscardUnknown(m)
}

var xxx_messageInfo_IngestionPerformanceStats proto.InternalMessageInfo

func init() {
	proto.RegisterType((*HistogramData)(nil), "cockroach.kv.bulk.bulkpb.HistogramData")
	proto.RegisterType((*IngestionPerformanceStats)(nil), "cockroach.kv.bulk.bulkpb.IngestionPerformanceStats")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID]time.Duration)(nil), "cockroach.kv.bulk.bulkpb.IngestionPerformanceStats.SendWaitByStoreEntry")
}

func init() { proto.RegisterFile("kv/bulk/bulkpb/bulkpb.proto", fileDescriptor_5cacc7c5400f9db8) }

var fileDescriptor_5cacc7c5400f9db8 = []byte{
	// 913 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x31, 0x6f, 0xdb, 0x46,
	0x14, 0x16, 0x2d, 0xdb, 0xb1, 0x4e, 0x51, 0x64, 0x9d, 0x65, 0x87, 0x51, 0x50, 0x49, 0x48, 0x51,
	0x54, 0x28, 0x10, 0xb2, 0xb0, 0x8d, 0xa2, 0xc8, 0x28, 0xb8, 0x41, 0x8c, 0xa0, 0x68, 0x4b, 0xa9,
	0x0d, 0xd0, 0x85, 0x38, 0x52, 0x27, 0xea, 0x20, 0x8a, 0x27, 0xdc, 0x1d, 0x6d, 0x28, 0x53, 0xd1,
	0xb1, 0x53, 0xc7, 0x8e, 0xfd, 0x29, 0x1d, 0x3d, 0x66, 0xcc, 0xe4, 0xb4, 0xf2, 0x2f, 0xe8, 0x9a,
	0xa9, 0xb8, 0x77, 0xa4, 0x2c, 0x19, 0x21, 0x90, 0x2e, 0xd2, 0xbd, 0xf7, 0x7d, 0xdf, 0x7b, 0x7c,
	0xef, 0xf1, 0x1e, 0xd1, 0xe3, 0xe9, 0x85, 0x1b, 0xa4, 0xf1, 0x14, 0x7e, 0xe6, 0x41, 0xf6, 0xe7,
	0xcc, 0x05, 0x57, 0x1c, 0xdb, 0x21, 0x0f, 0xa7, 0x82, 0x93, 0x70, 0xe2, 0x4c, 0x2f, 0x1c, 0x0d,
	0x39, 0x06, 0x6f, 0x35, 0x23, 0x1e, 0x71, 0x20, 0xb9, 0xfa, 0x64, 0xf8, 0x2d, 0x3b, 0x55, 0x2c,
	0x76, 0x27, 0x71, 0xe8, 0x2a, 0x36, 0xa3, 0x52, 0x91, 0xd9, 0xdc, 0x20, 0x4f, 0x7e, 0xd9, 0x42,
	0xb5, 0x17, 0x4c, 0x2a, 0x1e, 0x09, 0x32, 0x3b, 0x23, 0x8a, 0xe0, 0x63, 0x54, 0x19, 0x11, 0x45,
	0x7c, 0xb5, 0x98, 0x53, 0x7b, 0xa7, 0x6b, 0xf5, 0x76, 0xfa, 0x87, 0xef, 0xaf, 0x3b, 0x8d, 0x0d,
	0xd6, 0x70, 0x31, 0xa7, 0xde, 0xde, 0x28, 0x3b, 0xe1, 0x53, 0x74, 0x14, 0xf3, 0x4b, 0x2a, 0x95,
	0xaf, 0x04, 0x09, 0xa7, 0x24, 0x88, 0xa9, 0x7f, 0x41, 0xe2, 0x94, 0xda, 0x56, 0xd7, 0xea, 0x95,
	0xbd, 0xa6, 0x41, 0x87, 0x39, 0xf8, 0x93, 0xc6, 0xf0, 0x57, 0xe8, 0xe1, 0x84, 0x45, 0x93, 0x0f,
	0xc9, 0xb6, 0x40, 0x76, 0x98, 0xc1, 0x77, 0x74, 0x2e, 0x3a, 0x90, 0x2c, 0x4a, 0xd8, 0x98, 0x85,
	0x24, 0x51, 0xfe, 0x98, 0x45, 0xa9, 0xa0, 0xd2, 0x2e, 0x83, 0x06, 0xaf, 0x41, 0xcf, 0x0d, 0x82,
	0x8f, 0xd0, 0x6e, 0xc8, 0xd3, 0x44, 0x49, 0x7b, 0xbb, 0x5b, 0xee, 0x95, 0xbd, 0xcc, 0x7a, 0xb6,
	0xfd, 0xc7, 0x9f, 0x9d, 0xd2, 0x93, 0x7f, 0xab, 0xe8, 0xd1, 0x79, 0x12, 0x51, 0xa9, 0x18, 0x4f,
	0xbe, 0xa7, 0x62, 0xcc, 0xc5, 0x8c, 0x24, 0x21, 0x1d, 0x28, 0xa2, 0x24, 0xfe, 0x02, 0x35, 0x62,
	0x1e, 0xb1, 0x90, 0xc4, 0x3e, 0xb4, 0x45, 0xb2, 0xd7, 0x79, 0x55, 0xf5, 0x0c, 0xd0, 0x0d, 0x19,
	0xb0, 0xd7, 0x14, 0x9f, 0xa0, 0x9a, 0x94, 0x6a, 0x8d, 0xf7, 0x50, 0xf3, 0xfa, 0xf5, 0xe5, 0x75,
	0xa7, 0x3a, 0x18, 0x0c, 0x73, 0x9e, 0x57, 0x95, 0x52, 0xad, 0x44, 0x9f, 0xa1, 0x07, 0x41, 0x3a,
	0x1e, 0x53, 0xe1, 0x8f, 0xe3, 0x54, 0x4e, 0xa8, 0xcc, 0x8a, 0xaf, 0x19, 0xef, 0x73, 0xe3, 0xc4,
	0x4f, 0xd1, 0x41, 0x86, 0xfb, 0xa3, 0x94, 0xfa, 0x8a, 0x9b, 0x0c, 0xa6, 0xe8, 0xfd, 0x0c, 0x3a,
	0x4b, 0xe9, 0x90, 0x43, 0x54, 0x1b, 0xdd, 0x0b, 0x88, 0x0a, 0x75, 0xb8, 0x6d, 0xa0, 0xe4, 0x26,
	0x76, 0x51, 0x33, 0x3b, 0xe6, 0x81, 0x04, 0x49, 0x22, 0x33, 0xea, 0xb2, 0xd7, 0xc8, 0x30, 0x88,
	0xe4, 0x69, 0x40, 0x67, 0xbe, 0x23, 0x80, 0xcc, 0xbb, 0x26, 0xf3, 0x3a, 0x1f, 0x32, 0x7f, 0x8a,
	0x6a, 0x72, 0x1e, 0x33, 0xe5, 0x0b, 0xaa, 0x04, 0xa3, 0xd2, 0xbe, 0x07, 0xc4, 0xfb, 0xe0, 0xf4,
	0x8c, 0x4f, 0x4f, 0x04, 0x6c, 0x69, 0xef, 0x01, 0x9a, 0x59, 0xb8, 0x85, 0xf6, 0x64, 0x48, 0x94,
	0xa2, 0x42, 0xda, 0x15, 0x40, 0x56, 0x36, 0x04, 0x36, 0x67, 0x7f, 0xc6, 0x2f, 0xe8, 0xc8, 0x46,
	0x59, 0x60, 0xe3, 0xfc, 0x56, 0xfb, 0xb0, 0x83, 0x2a, 0x63, 0x16, 0xc7, 0xfe, 0x25, 0x61, 0xca,
	0xae, 0x42, 0xfb, 0x1b, 0xef, 0xaf, 0x3b, 0x35, 0xfd, 0xde, 0x3b, 0x67, 0xa9, 0x20, 0x7a, 0xc8,
	0xde, 0x9e, 0xe6, 0xbc, 0x22, 0x4c, 0x69, 0xbe, 0xe4, 0x42, 0x19, 0xfe, 0xfd, 0x42, 0xbe, 0xe6,
	0x00, 0xff, 0x4b, 0x84, 0xa0, 0xd7, 0x46, 0x50, 0x2b, 0x12, 0x54, 0x80, 0x94, 0x2b, 0xa0, 0x47,
	0x46, 0xf1, 0xa0, 0x50, 0x01, 0x24, 0x50, 0x7c, 0x87, 0xea, 0xb7, 0x0a, 0x7f, 0xc2, 0xa4, 0xb2,
	0xed, 0xae, 0xd5, 0xab, 0x1e, 0x7f, 0xee, 0x14, 0xdd, 0x7b, 0x67, 0xe3, 0x76, 0x7a, 0xb5, 0x55,
	0x30, 0xed, 0x87, 0x22, 0x69, 0x32, 0x32, 0x4f, 0x50, 0x2f, 0x2e, 0x92, 0x26, 0xa3, 0xfc, 0x91,
	0xcd, 0x08, 0x41, 0xb0, 0x5f, 0xf8, 0xc8, 0x40, 0x02, 0xc5, 0x29, 0xca, 0xc7, 0x60, 0x34, 0x8d,
	0x22, 0x4d, 0x35, 0xa3, 0x81, 0xea, 0x18, 0x55, 0x43, 0x3e, 0x9b, 0xe5, 0x89, 0x70, 0x91, 0x08,
	0x19, 0x16, 0x68, 0x9e, 0xa2, 0xbd, 0x51, 0xe6, 0xb7, 0x0f, 0x0a, 0x4b, 0xc9, 0x29, 0xf8, 0x25,
	0xaa, 0xc7, 0x44, 0x2a, 0x73, 0xb7, 0x7c, 0xcd, 0xb2, 0x0f, 0xa1, 0x97, 0x9f, 0xac, 0xf5, 0x52,
	0x6f, 0x47, 0x67, 0x12, 0x87, 0xce, 0x30, 0xdf, 0x8e, 0xfd, 0xed, 0xab, 0xeb, 0x4e, 0xc9, 0xab,
	0x69, 0x2d, 0xdc, 0x40, 0x8d, 0xe0, 0x1f, 0x10, 0x0e, 0x53, 0x21, 0x68, 0xb2, 0x11, 0xef, 0xe8,
	0xe3, 0xe3, 0xed, 0x67, 0xf2, 0xdb, 0x90, 0x7f, 0x59, 0x08, 0xaf, 0x66, 0xe3, 0x07, 0x0b, 0x5f,
	0x2a, 0x2e, 0xa8, 0xdd, 0xec, 0x96, 0x7b, 0xd5, 0xe3, 0x17, 0xc5, 0xf3, 0x2e, 0x5c, 0x58, 0xce,
	0x20, 0x9b, 0x62, 0x7f, 0x31, 0xd0, 0xa1, 0xbe, 0x49, 0x94, 0x58, 0xf4, 0xcf, 0x7f, 0x7d, 0xd7,
	0x39, 0x8d, 0x98, 0x9a, 0xa4, 0x81, 0x13, 0xf2, 0x99, 0xbb, 0x8a, 0x3b, 0x0a, 0x6e, 0xcf, 0xee,
	0x7c, 0x1a, 0xb9, 0x70, 0x9a, 0x07, 0x0e, 0x88, 0xcf, 0xcf, 0x7e, 0x7b, 0x77, 0xb7, 0xb7, 0x75,
	0xb9, 0x99, 0x00, 0x3f, 0x46, 0x15, 0x22, 0xfd, 0x4b, 0xc1, 0x14, 0x95, 0xf6, 0x23, 0x73, 0x69,
	0x89, 0x7c, 0x05, 0x36, 0x7e, 0x69, 0x56, 0xa2, 0xde, 0x18, 0xe6, 0x4d, 0x6e, 0xfd, 0xbf, 0x37,
	0x59, 0xaf, 0x4a, 0xbd, 0x56, 0xb4, 0xb7, 0xd5, 0x47, 0xcd, 0x0f, 0x55, 0x87, 0xf7, 0x51, 0x79,
	0x4a, 0x17, 0xb0, 0x95, 0x77, 0x3c, 0x7d, 0xc4, 0x4d, 0xb4, 0xb3, 0xfe, 0x21, 0x31, 0xc6, 0xb3,
	0xad, 0xaf, 0x2d, 0xb3, 0xf3, 0xfb, 0x3f, 0x5e, 0xfd, 0xd3, 0x2e, 0x5d, 0x2d, 0xdb, 0xd6, 0x9b,
	0x65, 0xdb, 0x7a, 0xbb, 0x6c, 0x5b, 0x7f, 0x2f, 0xdb, 0xd6, 0xef, 0x37, 0xed, 0xd2, 0x9b, 0x9b,
	0x76, 0xe9, 0xed, 0x4d, 0xbb, 0xf4, 0xf3, 0xc9, 0x47, 0x75, 0x6b, 0xf3, 0x23, 0x1d, 0xec, 0xc2,
	0x47, 0xf5, 0xe4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xca, 0x74, 0xa0, 0xc2, 0xbd, 0x07, 0x00,
	0x00,
}

func (m *HistogramData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistogramData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistogramData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataType != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Counts) > 0 {
		l := 0
		for _, e := range m.Counts {
			l += sovBulkpb(uint64(e))
		}
		i -= l
		if l == len(m.Counts) {
			dest := dAtA[i : i+len(m.Counts)]
			for k, num := range m.Counts {
				dest[k] = uint8(num)
			}
		} else {
			j1 := i
			for _, num1 := range m.Counts {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
		}
		i = encodeVarintBulkpb(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	if m.SignificantFigures != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SignificantFigures))
		i--
		dAtA[i] = 0x18
	}
	if m.HighestTrackableValue != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.HighestTrackableValue))
		i--
		dAtA[i] = 0x10
	}
	if m.LowestTrackableValue != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.LowestTrackableValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IngestionPerformanceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestionPerformanceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestionPerformanceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SstSizeHist != nil {
		{
			size, err := m.SstSizeHist.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBulkpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.AsWrites != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.AsWrites))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.BatchWaitHist != nil {
		{
			size, err := m.BatchWaitHist.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBulkpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SSTDataSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SSTDataSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	{
		size, err := m.CurrentFlushTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBulkpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size, err := m.LastFlushTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBulkpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if len(m.SendWaitByStore) > 0 {
		keysForSendWaitByStore := make([]int32, 0, len(m.SendWaitByStore))
		for k := range m.SendWaitByStore {
			keysForSendWaitByStore = append(keysForSendWaitByStore, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForSendWaitByStore)
		for iNdEx := len(keysForSendWaitByStore) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SendWaitByStore[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(keysForSendWaitByStore[iNdEx])]
			baseI := i
			i = encodeVarintBulkpb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBulkpb(dAtA, i, uint64(keysForSendWaitByStore[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBulkpb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Duration != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.CommitWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.CommitWait))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ScatterWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.ScatterWait))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SplitWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SplitWait))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SendWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SendWait))
		i--
		dAtA[i] = 0x78
	}
	if m.BatchWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BatchWait))
		i--
		dAtA[i] = 0x70
	}
	if m.FlushWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.FlushWait))
		i--
		dAtA[i] = 0x68
	}
	if m.SortWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SortWait))
		i--
		dAtA[i] = 0x60
	}
	if m.FillWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.FillWait))
		i--
		dAtA[i] = 0x58
	}
	if m.ScatterMoved != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.ScatterMoved))
		i--
		dAtA[i] = 0x50
	}
	if m.Scatters != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Scatters))
		i--
		dAtA[i] = 0x48
	}
	if m.Splits != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Splits))
		i--
		dAtA[i] = 0x40
	}
	if m.SplitRetries != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SplitRetries))
		i--
		dAtA[i] = 0x38
	}
	if m.BatchesDueToSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BatchesDueToSize))
		i--
		dAtA[i] = 0x30
	}
	if m.BatchesDueToRange != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BatchesDueToRange))
		i--
		dAtA[i] = 0x28
	}
	if m.Batches != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Batches))
		i--
		dAtA[i] = 0x20
	}
	if m.FlushesDueToSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.FlushesDueToSize))
		i--
		dAtA[i] = 0x18
	}
	if m.BufferFlushes != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BufferFlushes))
		i--
		dAtA[i] = 0x10
	}
	if m.LogicalDataSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.LogicalDataSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBulkpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovBulkpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HistogramData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowestTrackableValue != 0 {
		n += 1 + sovBulkpb(uint64(m.LowestTrackableValue))
	}
	if m.HighestTrackableValue != 0 {
		n += 1 + sovBulkpb(uint64(m.HighestTrackableValue))
	}
	if m.SignificantFigures != 0 {
		n += 1 + sovBulkpb(uint64(m.SignificantFigures))
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovBulkpb(uint64(e))
		}
		n += 1 + sovBulkpb(uint64(l)) + l
	}
	if m.DataType != 0 {
		n += 1 + sovBulkpb(uint64(m.DataType))
	}
	return n
}

func (m *IngestionPerformanceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogicalDataSize != 0 {
		n += 1 + sovBulkpb(uint64(m.LogicalDataSize))
	}
	if m.BufferFlushes != 0 {
		n += 1 + sovBulkpb(uint64(m.BufferFlushes))
	}
	if m.FlushesDueToSize != 0 {
		n += 1 + sovBulkpb(uint64(m.FlushesDueToSize))
	}
	if m.Batches != 0 {
		n += 1 + sovBulkpb(uint64(m.Batches))
	}
	if m.BatchesDueToRange != 0 {
		n += 1 + sovBulkpb(uint64(m.BatchesDueToRange))
	}
	if m.BatchesDueToSize != 0 {
		n += 1 + sovBulkpb(uint64(m.BatchesDueToSize))
	}
	if m.SplitRetries != 0 {
		n += 1 + sovBulkpb(uint64(m.SplitRetries))
	}
	if m.Splits != 0 {
		n += 1 + sovBulkpb(uint64(m.Splits))
	}
	if m.Scatters != 0 {
		n += 1 + sovBulkpb(uint64(m.Scatters))
	}
	if m.ScatterMoved != 0 {
		n += 1 + sovBulkpb(uint64(m.ScatterMoved))
	}
	if m.FillWait != 0 {
		n += 1 + sovBulkpb(uint64(m.FillWait))
	}
	if m.SortWait != 0 {
		n += 1 + sovBulkpb(uint64(m.SortWait))
	}
	if m.FlushWait != 0 {
		n += 1 + sovBulkpb(uint64(m.FlushWait))
	}
	if m.BatchWait != 0 {
		n += 1 + sovBulkpb(uint64(m.BatchWait))
	}
	if m.SendWait != 0 {
		n += 1 + sovBulkpb(uint64(m.SendWait))
	}
	if m.SplitWait != 0 {
		n += 2 + sovBulkpb(uint64(m.SplitWait))
	}
	if m.ScatterWait != 0 {
		n += 2 + sovBulkpb(uint64(m.ScatterWait))
	}
	if m.CommitWait != 0 {
		n += 2 + sovBulkpb(uint64(m.CommitWait))
	}
	if m.Duration != 0 {
		n += 2 + sovBulkpb(uint64(m.Duration))
	}
	if len(m.SendWaitByStore) > 0 {
		for k, v := range m.SendWaitByStore {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBulkpb(uint64(k)) + 1 + sovBulkpb(uint64(v))
			n += mapEntrySize + 2 + sovBulkpb(uint64(mapEntrySize))
		}
	}
	l = m.LastFlushTime.Size()
	n += 2 + l + sovBulkpb(uint64(l))
	l = m.CurrentFlushTime.Size()
	n += 2 + l + sovBulkpb(uint64(l))
	if m.SSTDataSize != 0 {
		n += 2 + sovBulkpb(uint64(m.SSTDataSize))
	}
	if m.BatchWaitHist != nil {
		l = m.BatchWaitHist.Size()
		n += 2 + l + sovBulkpb(uint64(l))
	}
	if m.AsWrites != 0 {
		n += 2 + sovBulkpb(uint64(m.AsWrites))
	}
	if m.SstSizeHist != nil {
		l = m.SstSizeHist.Size()
		n += 2 + l + sovBulkpb(uint64(l))
	}
	return n
}

func sovBulkpb(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozBulkpb(x uint64) (n int) {
	return sovBulkpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HistogramData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulkpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistogramData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistogramData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestTrackableValue", wireType)
			}
			m.LowestTrackableValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowestTrackableValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestTrackableValue", wireType)
			}
			m.HighestTrackableValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestTrackableValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignificantFigures", wireType)
			}
			m.SignificantFigures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignificantFigures |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBulkpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBulkpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBulkpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBulkpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.Counts == nil {
						m.Counts = make([]int64, 0, elementCount)
					} else {
						m.Counts = slices.Grow(m.Counts, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBulkpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= HistogramDataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBulkpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBulkpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestionPerformanceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulkpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestionPerformanceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestionPerformanceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalDataSize", wireType)
			}
			m.LogicalDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicalDataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferFlushes", wireType)
			}
			m.BufferFlushes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferFlushes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushesDueToSize", wireType)
			}
			m.FlushesDueToSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushesDueToSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			m.Batches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batches |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchesDueToRange", wireType)
			}
			m.BatchesDueToRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchesDueToRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchesDueToSize", wireType)
			}
			m.BatchesDueToSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchesDueToSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitRetries", wireType)
			}
			m.SplitRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitRetries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			m.Splits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Splits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scatters", wireType)
			}
			m.Scatters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scatters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterMoved", wireType)
			}
			m.ScatterMoved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScatterMoved |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillWait", wireType)
			}
			m.FillWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortWait", wireType)
			}
			m.SortWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushWait", wireType)
			}
			m.FlushWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchWait", wireType)
			}
			m.BatchWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWait", wireType)
			}
			m.SendWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitWait", wireType)
			}
			m.SplitWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterWait", wireType)
			}
			m.ScatterWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScatterWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitWait", wireType)
			}
			m.CommitWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWaitByStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBulkpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBulkpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendWaitByStore == nil {
				m.SendWaitByStore = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID]time.Duration)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBulkpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBulkpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBulkpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBulkpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBulkpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SendWaitByStore[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(mapkey)] = ((time.Duration)(mapvalue))
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFlushTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBulkpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBulkpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastFlushTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentFlushTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBulkpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBulkpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentFlushTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTDataSize", wireType)
			}
			m.SSTDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSTDataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchWaitHist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBulkpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBulkpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchWaitHist == nil {
				m.BatchWaitHist = &HistogramData{}
			}
			if err := m.BatchWaitHist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsWrites", wireType)
			}
			m.AsWrites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsWrites |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SstSizeHist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBulkpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBulkpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SstSizeHist == nil {
				m.SstSizeHist = &HistogramData{}
			}
			if err := m.SstSizeHist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBulkpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBulkpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBulkpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBulkpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBulkpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBulkpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBulkpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBulkpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBulkpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBulkpb = fmt.Errorf("proto: unexpected end of group")
)

