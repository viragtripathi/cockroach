// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvserver/kvstorage/wag/wagpb/wag.proto

package wagpb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_kv_kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	kvserverpb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/kvserverpb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NodeType defines the type of the WAG node. It corresponds to a replica
// lifecycle event, and specifies how the node is addressed and interpreted.
type NodeType int32

const (
	// NodeEmpty is the "empty" type. Can be used as a nil/no-op indicator. We
	// just have it so that all "real" types are specified explicitly.
	NodeType_NodeEmpty NodeType = 0
	// NodeCreate corresponds to a creation of an uninitialized replica. All
	// replicas on a Store go through this transition.
	NodeType_NodeCreate NodeType = 1
	// NodeSnap corresponds to initializing/resetting a replica state machine with
	// a snapshot. Happens when an uninitialized replica is initialized, or when
	// an initialized replica is caught up on a later applied state. A NodeSnap
	// also subsumes replicas (if any) that overlap with this replica in keyspace.
	NodeType_NodeSnap NodeType = 2
	// NodeApply corresponds to applying a replica's raft log up to a specific
	// committed index.
	NodeType_NodeApply NodeType = 3
	// NodeSplit corresponds to applying a split command on a replica, and
	// creating the replica of the post-split RHS range.
	NodeType_NodeSplit NodeType = 4
	// NodeMerge corresponds to applying a merge command on this replica and its
	// immediate RHS neighbour in the keyspace.
	NodeType_NodeMerge NodeType = 5
	// NodeDestroy correspond to destroying the replica and its state machine.
	NodeType_NodeDestroy NodeType = 6
)

var NodeType_name = map[int32]string{
	0: "NodeEmpty",
	1: "NodeCreate",
	2: "NodeSnap",
	3: "NodeApply",
	4: "NodeSplit",
	5: "NodeMerge",
	6: "NodeDestroy",
}

var NodeType_value = map[string]int32{
	"NodeEmpty":   0,
	"NodeCreate":  1,
	"NodeSnap":    2,
	"NodeApply":   3,
	"NodeSplit":   4,
	"NodeMerge":   5,
	"NodeDestroy": 6,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_350f0ec898a3233e, []int{0}
}

// Addr describes the full address of a WAG node, consisting of RangeID,
// ReplicaID, and index into the raft log.
//
// It establishes "happens before" relationships between WAG nodes of a RangeID.
// For example, when applying a node with Addr.ReplicaID, we know that all nodes
// with lower ReplicaIDs (including their destruction), or same ReplicaID and
// lower Index have been applied.
type Addr struct {
	// RangeID is the ID of the range that the WAG node pertains to.
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// ReplicaID is the ID of the RangeID replica that the WAG node pertains to.
	ReplicaID github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"replica_id,omitempty"`
	// Index identifies the raft log entry associated with this WAG node.
	//  - For NodeCreate, it is 0 and signifies an uninitialized replica.
	//  - For NodeSnap, it is the index of the snapshot, and the index at which
	//  the raft log is initialized.
	//  - For NodeApply, it is the log index identifying a prefix of the raft log.
	//  - For NodeSplit and NodeMerge, it identifies the raft log command
	//  containing the corresponding split/merge trigger.
	//  - For NodeDestroy, it is MaxUint64.
	Index github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex `protobuf:"varint,4,opt,name=index,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftIndex" json:"index,omitempty"`
}

func (m *Addr) Reset()      { *m = Addr{} }
func (*Addr) ProtoMessage() {}
func (*Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_350f0ec898a3233e, []int{0}
}
func (m *Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addr.Merge(m, src)
}
func (m *Addr) XXX_Size() int {
	return m.Size()
}
func (m *Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_Addr.DiscardUnknown(m)
}

var xxx_messageInfo_Addr proto.InternalMessageInfo

// Node describes a node of the WAG.
type Node struct {
	// Addr is the full address of the node, consisting of RangeID, ReplicaID, and
	// index into the raft log.
	Addr Addr `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr"`
	// Type identifies the type of the replica lifecycle event that this node
	// represents, such as replica creation, destruction, split or merge.
	Type NodeType `protobuf:"varint,2,opt,name=type,proto3,enum=wagpb.NodeType" json:"type,omitempty"`
	// Mutation contains the mutation that will be applied to the state machine
	// engine when applying this WAG node.
	Mutation Mutation `protobuf:"bytes,3,opt,name=mutation,proto3" json:"mutation"`
	// Create is the RangeID that this node brings into existence in the state
	// machine, or 0 if the node does not create new ranges. It is non-zero for
	// NodeCreate and NodeSplit.
	Create github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,4,opt,name=create,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"create,omitempty"`
	// Destroy contains the RangeIDs that this node removes from the state
	// machine, because they are known to have been merged.
	// - For NodeMerge, it contains the ID of the RHS range being merged.
	// - For NodeSnap, it contains the list of subsumed ranges.
	Destroy []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,5,rep,packed,name=destroy,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"destroy,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_350f0ec898a3233e, []int{1}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

// Mutation contains a mutation that can be applied to the state machine engine.
// It can be represented by an encoded Pebble write batch or SSTable ingestion.
type Mutation struct {
	// Batch contains an encoded Pebble write batch.
	Batch []byte `protobuf:"bytes,1,opt,name=batch,proto3" json:"batch,omitempty"`
	// Ingestion contains a Pebble ingestion.
	Ingestion *Ingestion `protobuf:"bytes,2,opt,name=ingestion,proto3" json:"ingestion,omitempty"`
}

func (m *Mutation) Reset()         { *m = Mutation{} }
func (m *Mutation) String() string { return proto.CompactTextString(m) }
func (*Mutation) ProtoMessage()    {}
func (*Mutation) Descriptor() ([]byte, []int) {
	return fileDescriptor_350f0ec898a3233e, []int{2}
}
func (m *Mutation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Mutation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutation.Merge(m, src)
}
func (m *Mutation) XXX_Size() int {
	return m.Size()
}
func (m *Mutation) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutation.DiscardUnknown(m)
}

var xxx_messageInfo_Mutation proto.InternalMessageInfo

// Ingestion describes a Pebble ingestion.
type Ingestion struct {
	SSTs           []string                                    `protobuf:"bytes,1,rep,name=SSTs,proto3" json:"SSTs,omitempty"`
	SharedTables   []*kvserverpb.SnapshotRequest_SharedTable   `protobuf:"bytes,2,rep,name=shared_tables,json=sharedTables,proto3" json:"shared_tables,omitempty"`
	ExternalTables []*kvserverpb.SnapshotRequest_ExternalTable `protobuf:"bytes,3,rep,name=external_tables,json=externalTables,proto3" json:"external_tables,omitempty"`
}

func (m *Ingestion) Reset()         { *m = Ingestion{} }
func (m *Ingestion) String() string { return proto.CompactTextString(m) }
func (*Ingestion) ProtoMessage()    {}
func (*Ingestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_350f0ec898a3233e, []int{3}
}
func (m *Ingestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ingestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ingestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingestion.Merge(m, src)
}
func (m *Ingestion) XXX_Size() int {
	return m.Size()
}
func (m *Ingestion) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingestion.DiscardUnknown(m)
}

var xxx_messageInfo_Ingestion proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("wagpb.NodeType", NodeType_name, NodeType_value)
	proto.RegisterType((*Addr)(nil), "wagpb.Addr")
	proto.RegisterType((*Node)(nil), "wagpb.Node")
	proto.RegisterType((*Mutation)(nil), "wagpb.Mutation")
	proto.RegisterType((*Ingestion)(nil), "wagpb.Ingestion")
}

func init() {
	proto.RegisterFile("kv/kvserver/kvstorage/wag/wagpb/wag.proto", fileDescriptor_350f0ec898a3233e)
}

var fileDescriptor_350f0ec898a3233e = []byte{
	// 632 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0x3f, 0x6f, 0xd3, 0x4e,
	0x18, 0xc7, 0xed, 0xd8, 0x69, 0x93, 0x27, 0xfd, 0x63, 0x9d, 0x3a, 0x44, 0x1d, 0x9c, 0xfc, 0xf2,
	0x13, 0x52, 0x60, 0xb0, 0x45, 0x41, 0x08, 0x55, 0x42, 0xa8, 0x69, 0x2b, 0x94, 0xa1, 0xa8, 0xba,
	0x74, 0x62, 0xa0, 0x3a, 0xdb, 0x17, 0xc7, 0x4a, 0x9a, 0x3b, 0xce, 0x97, 0xd0, 0xbc, 0x0b, 0x46,
	0x46, 0x26, 0x16, 0xde, 0x48, 0xc7, 0x8e, 0x9d, 0x22, 0x48, 0x67, 0xde, 0x00, 0x13, 0xba, 0xb3,
	0x9d, 0x20, 0x24, 0xa4, 0x16, 0x86, 0x44, 0xcf, 0x3f, 0x7f, 0xbe, 0x7e, 0x9e, 0xc7, 0x77, 0xf0,
	0x70, 0x38, 0xf5, 0x87, 0xd3, 0x94, 0x8a, 0x29, 0x15, 0xca, 0x90, 0x4c, 0x90, 0x98, 0xfa, 0xef,
	0x49, 0xac, 0x7e, 0x3c, 0x50, 0xff, 0x1e, 0x17, 0x4c, 0x32, 0x54, 0xd6, 0x81, 0xdd, 0x9d, 0x98,
	0xc5, 0x4c, 0x47, 0x7c, 0x65, 0x65, 0xc9, 0xdd, 0xff, 0x7e, 0xe3, 0x68, 0x83, 0x07, 0xbe, 0x20,
	0x7d, 0x99, 0x95, 0xb4, 0x3e, 0x97, 0xc0, 0x3e, 0x88, 0x22, 0x81, 0xde, 0x42, 0x45, 0x90, 0x71,
	0x4c, 0xcf, 0x93, 0xa8, 0x6e, 0x36, 0xcd, 0xb6, 0xd5, 0x39, 0x5c, 0xcc, 0x1b, 0xeb, 0x58, 0xc5,
	0xba, 0x47, 0x3f, 0xe6, 0x8d, 0xa7, 0x71, 0x22, 0x07, 0x93, 0xc0, 0x0b, 0xd9, 0x85, 0x1f, 0xb2,
	0x70, 0x28, 0x18, 0x09, 0x07, 0x51, 0xb0, 0xb2, 0x7d, 0x3e, 0x8c, 0x7d, 0x6d, 0xf1, 0xc0, 0xcb,
	0x9f, 0xc3, 0xeb, 0x1a, 0xda, 0x8d, 0x50, 0x1f, 0x40, 0x50, 0x3e, 0x4a, 0x42, 0xa2, 0x14, 0x4a,
	0x4d, 0xb3, 0x5d, 0xee, 0xbc, 0x5a, 0xcc, 0x1b, 0x55, 0x9c, 0x45, 0xb5, 0xc6, 0xb3, 0xfb, 0x69,
	0x14, 0x4f, 0xe2, 0x6a, 0x8e, 0xee, 0x46, 0xe8, 0x14, 0xca, 0xc9, 0x38, 0xa2, 0x97, 0x75, 0xbb,
	0x69, 0xb6, 0xed, 0xce, 0xfe, 0x9d, 0xa9, 0x7a, 0x56, 0xfa, 0xcd, 0xfb, 0xb2, 0xab, 0x08, 0x38,
	0x03, 0xed, 0xdb, 0x1f, 0x3f, 0x35, 0x8c, 0xd6, 0x97, 0x12, 0xd8, 0xaf, 0x59, 0x44, 0xd1, 0x03,
	0xb0, 0x49, 0x14, 0x09, 0x3d, 0xa4, 0xda, 0x5e, 0xcd, 0xd3, 0x0b, 0xf0, 0xd4, 0x0c, 0x3b, 0xf6,
	0xd5, 0xbc, 0x61, 0x60, 0x9d, 0x46, 0xff, 0x83, 0x2d, 0x67, 0x9c, 0xea, 0x4e, 0xb7, 0xf6, 0xb6,
	0xf3, 0x32, 0x45, 0x38, 0x9b, 0x71, 0x8a, 0x75, 0x12, 0x3d, 0x86, 0xca, 0xc5, 0x44, 0x12, 0x99,
	0xb0, 0x71, 0xdd, 0xd2, 0xbc, 0xa2, 0xf0, 0x24, 0x0f, 0xe7, 0xcc, 0x65, 0x19, 0x3a, 0x85, 0xb5,
	0x50, 0x50, 0x22, 0xa9, 0x6e, 0xd0, 0xea, 0x3c, 0xff, 0xeb, 0xd5, 0xe4, 0x1c, 0x84, 0x61, 0x3d,
	0xa2, 0xa9, 0x14, 0x6c, 0x56, 0x2f, 0x37, 0xad, 0x7f, 0x42, 0x16, 0xa0, 0xd6, 0x29, 0x54, 0x8a,
	0x0e, 0xd0, 0x0e, 0x94, 0x03, 0x22, 0xc3, 0x81, 0x9e, 0xd8, 0x06, 0xce, 0x1c, 0xe4, 0x41, 0x35,
	0x19, 0xc7, 0x34, 0xd5, 0xbd, 0x97, 0x74, 0xef, 0x4e, 0xde, 0x7b, 0xb7, 0x88, 0xe3, 0x55, 0x49,
	0xeb, 0xbb, 0x09, 0xd5, 0x65, 0x02, 0x21, 0xb0, 0x7b, 0xbd, 0xb3, 0xb4, 0x6e, 0x36, 0xad, 0x76,
	0x15, 0x6b, 0x1b, 0x05, 0xb0, 0x99, 0x0e, 0x88, 0xa0, 0xd1, 0xb9, 0x24, 0xc1, 0x88, 0xa6, 0xf5,
	0x52, 0xd3, 0x6a, 0xd7, 0xf6, 0x5e, 0x78, 0xcb, 0x77, 0xf6, 0x86, 0x53, 0xaf, 0x38, 0x06, 0xde,
	0xea, 0x3c, 0x78, 0xbd, 0x31, 0xe1, 0xe9, 0x80, 0x49, 0x4c, 0xdf, 0x4d, 0x68, 0x2a, 0xbd, 0x9e,
	0xc6, 0x9c, 0x29, 0x0a, 0xde, 0x48, 0x57, 0x4e, 0x8a, 0x06, 0xb0, 0x4d, 0x2f, 0x25, 0x15, 0x63,
	0x32, 0x2a, 0x54, 0x2c, 0xad, 0xf2, 0xf2, 0xfe, 0x2a, 0xc7, 0x39, 0x28, 0xd3, 0xd9, 0xa2, 0xbf,
	0xba, 0xe9, 0xa3, 0x09, 0x54, 0x8a, 0x8f, 0x05, 0x6d, 0x42, 0x55, 0xd9, 0xc7, 0x17, 0x5c, 0xce,
	0x1c, 0x03, 0x6d, 0x01, 0x28, 0xf7, 0x50, 0xaf, 0xcf, 0x31, 0xd1, 0x46, 0x56, 0xaa, 0xf8, 0x4e,
	0xa9, 0x28, 0x3e, 0xe0, 0x7c, 0x34, 0x73, 0xac, 0xc2, 0xed, 0xf1, 0x51, 0x22, 0x1d, 0xbb, 0x70,
	0x4f, 0xa8, 0x88, 0xa9, 0x53, 0x46, 0xdb, 0x50, 0x53, 0xee, 0x51, 0xb6, 0x36, 0x67, 0xad, 0xd3,
	0xbf, 0xfa, 0xe6, 0x1a, 0x57, 0x0b, 0xd7, 0xbc, 0x5e, 0xb8, 0xe6, 0xcd, 0xc2, 0x35, 0xbf, 0x2e,
	0x5c, 0xf3, 0xc3, 0xad, 0x6b, 0x5c, 0xdf, 0xba, 0xc6, 0xcd, 0xad, 0x6b, 0xbc, 0x39, 0xba, 0xfb,
	0x69, 0xfa, 0xf3, 0x0d, 0x16, 0xac, 0xe9, 0xeb, 0xe7, 0xc9, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x29, 0x88, 0x6c, 0xf2, 0xeb, 0x04, 0x00, 0x00,
}

func (m *Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintWag(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x20
	}
	if m.ReplicaID != 0 {
		i = encodeVarintWag(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeID != 0 {
		i = encodeVarintWag(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Destroy) > 0 {
		l := 0
		for _, e := range m.Destroy {
			l += sovWag(uint64(e))
		}
		i -= l
		if l == len(m.Destroy) {
			dest := dAtA[i : i+len(m.Destroy)]
			for k, num := range m.Destroy {
				dest[k] = uint8(num)
			}
		} else {
			j1 := i
			for _, num1 := range m.Destroy {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
		}
		i = encodeVarintWag(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Create != 0 {
		i = encodeVarintWag(dAtA, i, uint64(m.Create))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Mutation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintWag(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Type != 0 {
		i = encodeVarintWag(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Addr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintWag(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Mutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mutation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ingestion != nil {
		{
			size, err := m.Ingestion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWag(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Batch) > 0 {
		i -= len(m.Batch)
		copy(dAtA[i:], m.Batch)
		i = encodeVarintWag(dAtA, i, uint64(len(m.Batch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ingestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ingestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ingestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalTables) > 0 {
		for iNdEx := len(m.ExternalTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExternalTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWag(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SharedTables) > 0 {
		for iNdEx := len(m.SharedTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SharedTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWag(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SSTs) > 0 {
		for iNdEx := len(m.SSTs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SSTs[iNdEx])
			copy(dAtA[i:], m.SSTs[iNdEx])
			i = encodeVarintWag(dAtA, i, uint64(len(m.SSTs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintWag(dAtA []byte, offset int, v uint64) int {
	offset -= sovWag(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovWag(uint64(m.RangeID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovWag(uint64(m.ReplicaID))
	}
	if m.Index != 0 {
		n += 1 + sovWag(uint64(m.Index))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Addr.Size()
	n += 1 + l + sovWag(uint64(l))
	if m.Type != 0 {
		n += 1 + sovWag(uint64(m.Type))
	}
	l = m.Mutation.Size()
	n += 1 + l + sovWag(uint64(l))
	if m.Create != 0 {
		n += 1 + sovWag(uint64(m.Create))
	}
	if len(m.Destroy) > 0 {
		l = 0
		for _, e := range m.Destroy {
			l += sovWag(uint64(e))
		}
		n += 1 + sovWag(uint64(l)) + l
	}
	return n
}

func (m *Mutation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Batch)
	if l > 0 {
		n += 1 + l + sovWag(uint64(l))
	}
	if m.Ingestion != nil {
		l = m.Ingestion.Size()
		n += 1 + l + sovWag(uint64(l))
	}
	return n
}

func (m *Ingestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SSTs) > 0 {
		for _, s := range m.SSTs {
			l = len(s)
			n += 1 + l + sovWag(uint64(l))
		}
	}
	if len(m.SharedTables) > 0 {
		for _, e := range m.SharedTables {
			l = e.Size()
			n += 1 + l + sovWag(uint64(l))
		}
	}
	if len(m.ExternalTables) > 0 {
		for _, e := range m.ExternalTables {
			l = e.Size()
			n += 1 + l + sovWag(uint64(l))
		}
	}
	return n
}

func sovWag(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozWag(x uint64) (n int) {
	return sovWag(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWag
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWag(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWag
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWag
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Mutation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			m.Create = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Create |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWag
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Destroy = append(m.Destroy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWag
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWag
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWag
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.Destroy == nil {
						m.Destroy = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
					} else {
						m.Destroy = slices.Grow(m.Destroy, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWag
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Destroy = append(m.Destroy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroy", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWag(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWag
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWag
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batch = append(m.Batch[:0], dAtA[iNdEx:postIndex]...)
			if m.Batch == nil {
				m.Batch = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingestion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ingestion == nil {
				m.Ingestion = &Ingestion{}
			}
			if err := m.Ingestion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWag(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWag
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ingestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWag
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ingestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ingestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSTs = append(m.SSTs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedTables = append(m.SharedTables, &kvserverpb.SnapshotRequest_SharedTable{})
			if err := m.SharedTables[len(m.SharedTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWag
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWag
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWag
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTables = append(m.ExternalTables, &kvserverpb.SnapshotRequest_ExternalTable{})
			if err := m.ExternalTables[len(m.ExternalTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWag(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWag
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWag(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWag
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWag
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWag
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWag
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWag
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWag
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWag        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWag          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWag = fmt.Errorf("proto: unexpected end of group")
)

