// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvserver/loqrecovery/loqrecoverypb/recovery.proto

package loqrecoverypb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_kv_kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DescriptorChangeType int32

const (
	DescriptorChangeType_Split         DescriptorChangeType = 0
	DescriptorChangeType_Merge         DescriptorChangeType = 1
	DescriptorChangeType_ReplicaChange DescriptorChangeType = 2
)

var DescriptorChangeType_name = map[int32]string{
	0: "Split",
	1: "Merge",
	2: "ReplicaChange",
}

var DescriptorChangeType_value = map[string]int32{
	"Split":         0,
	"Merge":         1,
	"ReplicaChange": 2,
}

func (x DescriptorChangeType) String() string {
	return proto.EnumName(DescriptorChangeType_name, int32(x))
}

func (DescriptorChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{0}
}

// RangeHealth is a state of a range availability from loss of quorum recovery
// perspective.
type RangeHealth int32

const (
	RangeHealth_UNKNOWN RangeHealth = 0
	// Healthy indicates that range is available.
	RangeHealth_HEALTHY RangeHealth = 1
	// WaitingForMeta means that range is not yet readable according to meta
	// descriptor, but has a recovered replica that is waiting to be up-replicated.
	RangeHealth_WAITING_FOR_META RangeHealth = 2
	// LossOfQuorum means that range is unavailable because it lost quorum and
	// no replicas are fixed to act as a designated survivor (yet).
	RangeHealth_LOSS_OF_QUORUM RangeHealth = 3
)

var RangeHealth_name = map[int32]string{
	0: "UNKNOWN",
	1: "HEALTHY",
	2: "WAITING_FOR_META",
	3: "LOSS_OF_QUORUM",
}

var RangeHealth_value = map[string]int32{
	"UNKNOWN":          0,
	"HEALTHY":          1,
	"WAITING_FOR_META": 2,
	"LOSS_OF_QUORUM":   3,
}

func (x RangeHealth) String() string {
	return proto.EnumName(RangeHealth_name, int32(x))
}

func (RangeHealth) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{1}
}

// DescriptorChangeInfo future descriptor change info extracted from commit
// triggers in raft log.
type DescriptorChangeInfo struct {
	// Change type.
	ChangeType DescriptorChangeType `protobuf:"varint,1,opt,name=changeType,proto3,enum=cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DescriptorChangeType" json:"changeType,omitempty"`
	// Range descriptor containing new state of for replica change updates and
	// LHS for split and merge operations.
	Desc *roachpb.RangeDescriptor `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	// Optional range descriptor with is populated for split and merge changes
	// and contains RHS descriptor for the operation.
	OtherDesc *roachpb.RangeDescriptor `protobuf:"bytes,3,opt,name=otherDesc,proto3" json:"otherDesc,omitempty"`
}

func (m *DescriptorChangeInfo) Reset()         { *m = DescriptorChangeInfo{} }
func (m *DescriptorChangeInfo) String() string { return proto.CompactTextString(m) }
func (*DescriptorChangeInfo) ProtoMessage()    {}
func (*DescriptorChangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{0}
}
func (m *DescriptorChangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescriptorChangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DescriptorChangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescriptorChangeInfo.Merge(m, src)
}
func (m *DescriptorChangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *DescriptorChangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DescriptorChangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DescriptorChangeInfo proto.InternalMessageInfo

// ReplicaInfo contains info about state of range replica for the purpose of range
// recovery. This information should be enough for recovery algorithm to pick a
// survivor replica in when not replicas are available.
// Information includes range descriptor as well as parts of raft state.
// When changing this structure, care must be exercised to keep it compatible
// with previous versions when serializing to json. See
// loqrecovery/marshalling.go for details how format is preserved and
// loqrecovery/collect.go on how replica info is generated with respect of
// active cluster version.
type ReplicaInfo struct {
	NodeID                   github_com_cockroachdb_cockroach_pkg_roachpb.NodeID    `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	StoreID                  github_com_cockroachdb_cockroach_pkg_roachpb.StoreID   `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	Desc                     roachpb.RangeDescriptor                                `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc"`
	RaftAppliedIndex         github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex `protobuf:"varint,4,opt,name=raft_applied_index,json=raftAppliedIndex,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftIndex" json:"raft_applied_index,omitempty"`
	RaftCommittedIndex       github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex `protobuf:"varint,5,opt,name=raft_committed_index,json=raftCommittedIndex,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftIndex" json:"raft_committed_index,omitempty"`
	RaftLogDescriptorChanges []DescriptorChangeInfo                                 `protobuf:"bytes,6,rep,name=raft_log_descriptor_changes,json=raftLogDescriptorChanges,proto3" json:"raft_log_descriptor_changes,omitempty"`
	LocalAssumesLeaseholder  bool                                                   `protobuf:"varint,7,opt,name=local_assumes_leaseholder,json=localAssumesLeaseholder,proto3" json:"local_assumes_leaseholder,omitempty"`
}

func (m *ReplicaInfo) Reset()         { *m = ReplicaInfo{} }
func (m *ReplicaInfo) String() string { return proto.CompactTextString(m) }
func (*ReplicaInfo) ProtoMessage()    {}
func (*ReplicaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{1}
}
func (m *ReplicaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaInfo.Merge(m, src)
}
func (m *ReplicaInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaInfo proto.InternalMessageInfo

// ClusterMetadata contains info about cluster that planner can use when
// creating a plan.
type ClusterMetadata struct {
	// ClusterID contains id of the cluster from which info was collected.
	ClusterID string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Version contains effective cluster version of the cluster from which
	// info was collected.
	Version roachpb.Version `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
}

func (m *ClusterMetadata) Reset()         { *m = ClusterMetadata{} }
func (m *ClusterMetadata) String() string { return proto.CompactTextString(m) }
func (*ClusterMetadata) ProtoMessage()    {}
func (*ClusterMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{2}
}
func (m *ClusterMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClusterMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterMetadata.Merge(m, src)
}
func (m *ClusterMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ClusterMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterMetadata proto.InternalMessageInfo

// Collection of replica information gathered in a collect-info run.
// ReplicaInfo in Replicas does not have to be constrained to a single node,
// but in practice info collected from remote cluster will contain info per
// node. In case of offline collection, replicas will belong to all stores
// provided to the command regardless of owning node.
type NodeReplicaInfo struct {
	Replicas []ReplicaInfo `protobuf:"bytes,1,rep,name=replicas,proto3" json:"replicas"`
}

func (m *NodeReplicaInfo) Reset()         { *m = NodeReplicaInfo{} }
func (m *NodeReplicaInfo) String() string { return proto.CompactTextString(m) }
func (*NodeReplicaInfo) ProtoMessage()    {}
func (*NodeReplicaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{3}
}
func (m *NodeReplicaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeReplicaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeReplicaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeReplicaInfo.Merge(m, src)
}
func (m *NodeReplicaInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeReplicaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeReplicaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeReplicaInfo proto.InternalMessageInfo

// Replica info collected from one or more nodes of a cluster.
// When changing this structure, care must be exercised to keep it compatible
// with previous versions when serializing to json. See
// loqrecovery/marshalling.go for details how format is preserved.
type ClusterReplicaInfo struct {
	// ClusterID contains id of the cluster from which info was collected.
	ClusterID string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Descriptors contains range descriptors collected from meta ranges.
	// Descriptors are optional and only present in collected info if system
	// ranges didn't lose quorum. It could also be partial in some cases.
	Descriptors []roachpb.RangeDescriptor `protobuf:"bytes,2,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	// LocalInfo contains one or more NodeReplicaInfo structs each containing a
	// subset of full info. They are not guaranteed to be split by node, each
	// element should contain disjoint subset of replica infos.
	LocalInfo []NodeReplicaInfo `protobuf:"bytes,3,rep,name=local_info,json=localInfo,proto3" json:"local_info"`
	// Version contains effective cluster version of the cluster from which
	// info was collected.
	Version roachpb.Version `protobuf:"bytes,4,opt,name=version,proto3" json:"version"`
}

func (m *ClusterReplicaInfo) Reset()         { *m = ClusterReplicaInfo{} }
func (m *ClusterReplicaInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterReplicaInfo) ProtoMessage()    {}
func (*ClusterReplicaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{4}
}
func (m *ClusterReplicaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterReplicaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClusterReplicaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterReplicaInfo.Merge(m, src)
}
func (m *ClusterReplicaInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterReplicaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterReplicaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterReplicaInfo proto.InternalMessageInfo

// ReplicaUpdate contains information that needs to be updated on replica on the node
// to make it a designated survivor so that replica could act as a source of truth when
// doing loss of quorum recovery.
// When changing this structure, care must be exercised to keep it compatible
// with previous versions when serializing to json. See
// loqrecovery/marshalling.go for details how format is preserved.
type ReplicaUpdate struct {
	RangeID       github_com_cockroachdb_cockroach_pkg_roachpb.RangeID   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty" yaml:"RangeID"`
	StartKey      RecoveryKey                                            `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3,casttype=RecoveryKey" json:"start_key,omitempty" yaml:"StartKey"`
	OldReplicaID  github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,3,opt,name=old_replica_id,json=oldReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"old_replica_id,omitempty" yaml:"OldReplicaID"`
	NewReplica    roachpb.ReplicaDescriptor                              `protobuf:"bytes,4,opt,name=new_replica,json=newReplica,proto3" json:"new_replica" yaml:"NewReplica"`
	NextReplicaID github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,5,opt,name=next_replica_id,json=nextReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"next_replica_id,omitempty" yaml:"NextReplicaID"`
}

func (m *ReplicaUpdate) Reset()      { *m = ReplicaUpdate{} }
func (*ReplicaUpdate) ProtoMessage() {}
func (*ReplicaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{5}
}
func (m *ReplicaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaUpdate.Merge(m, src)
}
func (m *ReplicaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaUpdate proto.InternalMessageInfo

// ReplicaUpdatePlan Collection of updates for all recoverable replicas in the cluster.
// When changing this structure, care must be exercised to keep it compatible
// with previous versions when serializing to json. See
// loqrecovery/marshalling.go for details how format is preserved.
type ReplicaUpdatePlan struct {
	Updates []ReplicaUpdate `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates"`
	// PlanID contains ID generated by cli when generating recovery plan and is subsequently
	// used for status checks and auditing purposes.
	PlanID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,2,opt,name=plan_id,json=planId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"plan_id"`
	// DecommissionedNodeIDs is a set of node IDs that need to be marked as decommissioned as a
	// part of loss of quorum recovery process.
	DecommissionedNodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,3,rep,packed,name=decommissioned_node_ids,json=decommissionedNodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"decommissioned_node_ids,omitempty"`
	// ClusterID contains id of the cluster from which info was collected.
	ClusterID string `protobuf:"bytes,4,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// StaleLeaseholderNodeIDs is a set of node IDs that need to be restarted even
	// they have no scheduled changes. This is needed to get rid of range leases
	// that they hold and that can't be shed because quorum is lost on the ranges.
	StaleLeaseholderNodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,5,rep,packed,name=stale_leaseholder_node_ids,json=staleLeaseholderNodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"stale_leaseholder_node_ids,omitempty"`
	// Version contains version of the plan which is equal to the active cluster
	// version of the data that this plan is based on. Plan could only be applied
	// to the cluster of the same version.
	Version roachpb.Version `protobuf:"bytes,6,opt,name=version,proto3" json:"version"`
}

func (m *ReplicaUpdatePlan) Reset()         { *m = ReplicaUpdatePlan{} }
func (m *ReplicaUpdatePlan) String() string { return proto.CompactTextString(m) }
func (*ReplicaUpdatePlan) ProtoMessage()    {}
func (*ReplicaUpdatePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{6}
}
func (m *ReplicaUpdatePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaUpdatePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaUpdatePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaUpdatePlan.Merge(m, src)
}
func (m *ReplicaUpdatePlan) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaUpdatePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaUpdatePlan.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaUpdatePlan proto.InternalMessageInfo

// ReplicaRecoveryRecord is a struct that loss of quorum recovery commands
// write to the store locally when replicas are rewritten to preserve information
// about changes. This records are then consumed on startup to post data to
// appropriate destinations like log, rangelog etc.
// This struct is a union of all necessary information that is needed by all
// downstream destinations.
type ReplicaRecoveryRecord struct {
	// Timestamp of loss of quorum recovery application phase. Timestamp is chosen by process
	// rewriting changes before any replica is rewritten. All events created by single process
	// will share the same timestamp. Different processes updating different stores will
	// produce different timestamps even if updates originated from the same recovery plan.
	// Expressed as nanoseconds since the Unix epoch.
	Timestamp       int64                                                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RangeID         github_com_cockroachdb_cockroach_pkg_roachpb.RangeID   `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty" yaml:"RangeID"`
	StartKey        RecoveryKey                                            `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3,casttype=RecoveryKey" json:"start_key,omitempty" yaml:"StartKey"`
	EndKey          RecoveryKey                                            `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=RecoveryKey" json:"end_key,omitempty" yaml:"StartKey"`
	OldReplicaID    github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,5,opt,name=old_replica_id,json=oldReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"old_replica_id,omitempty" yaml:"OldReplicaID"`
	NewReplica      roachpb.ReplicaDescriptor                              `protobuf:"bytes,6,opt,name=new_replica,json=newReplica,proto3" json:"new_replica" yaml:"NewReplica"`
	RangeDescriptor roachpb.RangeDescriptor                                `protobuf:"bytes,7,opt,name=range_descriptor,json=rangeDescriptor,proto3" json:"range_descriptor" yaml:"RangeDescriptor"`
}

func (m *ReplicaRecoveryRecord) Reset()         { *m = ReplicaRecoveryRecord{} }
func (m *ReplicaRecoveryRecord) String() string { return proto.CompactTextString(m) }
func (*ReplicaRecoveryRecord) ProtoMessage()    {}
func (*ReplicaRecoveryRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{7}
}
func (m *ReplicaRecoveryRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaRecoveryRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaRecoveryRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaRecoveryRecord.Merge(m, src)
}
func (m *ReplicaRecoveryRecord) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaRecoveryRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaRecoveryRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaRecoveryRecord proto.InternalMessageInfo

// NodeRecoveryStatus contains information about loss of quorum recovery
// operations of a node.
type NodeRecoveryStatus struct {
	// NodeID contains id of the node that status belongs to.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// PendingPlanID contains an ID or recovery plan that is staged on the node for
	// application on the next restart.
	PendingPlanID *github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,2,opt,name=pending_plan_id,json=pendingPlanId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"pending_plan_id,omitempty"`
	// AppliedPlanID contains an ID of recovery plan that was processed last.
	// If plan application succeeded, then ApplyError will be nil, otherwise it will
	// contain an error message.
	AppliedPlanID *github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,3,opt,name=applied_plan_id,json=appliedPlanId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"applied_plan_id,omitempty"`
	// ApplyTimestamp is a node wall clock time when last recovery plan was applied.
	ApplyTimestamp *time.Time `protobuf:"bytes,4,opt,name=apply_timestamp,json=applyTimestamp,proto3,stdtime" json:"apply_timestamp,omitempty"`
	// If most recent recovery plan application failed, Error will contain
	// aggregated error messages containing all encountered errors.
	Error string `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *NodeRecoveryStatus) Reset()         { *m = NodeRecoveryStatus{} }
func (m *NodeRecoveryStatus) String() string { return proto.CompactTextString(m) }
func (*NodeRecoveryStatus) ProtoMessage()    {}
func (*NodeRecoveryStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{8}
}
func (m *NodeRecoveryStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeRecoveryStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeRecoveryStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRecoveryStatus.Merge(m, src)
}
func (m *NodeRecoveryStatus) XXX_Size() int {
	return m.Size()
}
func (m *NodeRecoveryStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRecoveryStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRecoveryStatus proto.InternalMessageInfo

// PlanApplicationResult is a value stored inside node local storage whenever
// loss of quorum recovery plan is applied for the purpose of tracking recovery
// progress.
type PlanApplicationResult struct {
	AppliedPlanID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=applied_plan_id,json=appliedPlanId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"applied_plan_id"`
	// LastProcessingTime is a node wall clock time when last recovery plan was applied.
	ApplyTimestamp time.Time `protobuf:"bytes,2,opt,name=apply_timestamp,json=applyTimestamp,proto3,stdtime" json:"apply_timestamp"`
	// If most recent recovery plan application failed, Error will contain
	// aggregated error messages containing all encountered errors.
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *PlanApplicationResult) Reset()         { *m = PlanApplicationResult{} }
func (m *PlanApplicationResult) String() string { return proto.CompactTextString(m) }
func (*PlanApplicationResult) ProtoMessage()    {}
func (*PlanApplicationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{9}
}
func (m *PlanApplicationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanApplicationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PlanApplicationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanApplicationResult.Merge(m, src)
}
func (m *PlanApplicationResult) XXX_Size() int {
	return m.Size()
}
func (m *PlanApplicationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanApplicationResult.DiscardUnknown(m)
}

var xxx_messageInfo_PlanApplicationResult proto.InternalMessageInfo

// RangeRecoveryStatus contains recovery status of a single range.
type RangeRecoveryStatus struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	Span    roachpb.Span                                         `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
	Health  RangeHealth                                          `protobuf:"varint,3,opt,name=health,proto3,enum=cockroach.kv.kvserver.loqrecovery.loqrecoverypb.RangeHealth" json:"health,omitempty"`
}

func (m *RangeRecoveryStatus) Reset()         { *m = RangeRecoveryStatus{} }
func (m *RangeRecoveryStatus) String() string { return proto.CompactTextString(m) }
func (*RangeRecoveryStatus) ProtoMessage()    {}
func (*RangeRecoveryStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{10}
}
func (m *RangeRecoveryStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeRecoveryStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeRecoveryStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeRecoveryStatus.Merge(m, src)
}
func (m *RangeRecoveryStatus) XXX_Size() int {
	return m.Size()
}
func (m *RangeRecoveryStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeRecoveryStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RangeRecoveryStatus proto.InternalMessageInfo

// DeferredRecoveryActions contains data for recovery actions that need to be
// performed after node restarts if it applied a recovery plan.
type DeferredRecoveryActions struct {
	// DecommissionedNodeIDs is a set of node IDs that need to be decommissioned
	// when a node restarts. Those nodes were marked as decommissioned in the
	// local node tombstone storage as a part of plan application, but are pending
	// liveness info update.
	DecommissionedNodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,rep,packed,name=decommissioned_node_ids,json=decommissionedNodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"decommissioned_node_ids,omitempty"`
}

func (m *DeferredRecoveryActions) Reset()         { *m = DeferredRecoveryActions{} }
func (m *DeferredRecoveryActions) String() string { return proto.CompactTextString(m) }
func (*DeferredRecoveryActions) ProtoMessage()    {}
func (*DeferredRecoveryActions) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{11}
}
func (m *DeferredRecoveryActions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeferredRecoveryActions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeferredRecoveryActions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeferredRecoveryActions.Merge(m, src)
}
func (m *DeferredRecoveryActions) XXX_Size() int {
	return m.Size()
}
func (m *DeferredRecoveryActions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeferredRecoveryActions.DiscardUnknown(m)
}

var xxx_messageInfo_DeferredRecoveryActions proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DescriptorChangeType", DescriptorChangeType_name, DescriptorChangeType_value)
	proto.RegisterEnum("cockroach.kv.kvserver.loqrecovery.loqrecoverypb.RangeHealth", RangeHealth_name, RangeHealth_value)
	proto.RegisterType((*DescriptorChangeInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DescriptorChangeInfo")
	proto.RegisterType((*ReplicaInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaInfo")
	proto.RegisterType((*ClusterMetadata)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ClusterMetadata")
	proto.RegisterType((*NodeReplicaInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.NodeReplicaInfo")
	proto.RegisterType((*ClusterReplicaInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ClusterReplicaInfo")
	proto.RegisterType((*ReplicaUpdate)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaUpdate")
	proto.RegisterType((*ReplicaUpdatePlan)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaUpdatePlan")
	proto.RegisterType((*ReplicaRecoveryRecord)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaRecoveryRecord")
	proto.RegisterType((*NodeRecoveryStatus)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.NodeRecoveryStatus")
	proto.RegisterType((*PlanApplicationResult)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.PlanApplicationResult")
	proto.RegisterType((*RangeRecoveryStatus)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.RangeRecoveryStatus")
	proto.RegisterType((*DeferredRecoveryActions)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DeferredRecoveryActions")
}

func init() {
	proto.RegisterFile("kv/kvserver/loqrecovery/loqrecoverypb/recovery.proto", fileDescriptor_5a2cc96948b3cab0)
}

var fileDescriptor_5a2cc96948b3cab0 = []byte{
	// 1526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6f, 0xdb, 0xb6,
	0x1b, 0xb6, 0xfc, 0x19, 0xd3, 0xf9, 0x70, 0xd9, 0xa4, 0x71, 0xf3, 0xfb, 0xcd, 0x0a, 0xb4, 0x0d,
	0x0b, 0x8a, 0xce, 0xc6, 0xda, 0xa2, 0x87, 0xac, 0x58, 0x1b, 0x27, 0xe9, 0xe2, 0x35, 0x1f, 0xad,
	0x9c, 0xac, 0x58, 0x0f, 0xd1, 0x14, 0x91, 0xb1, 0x85, 0xc8, 0xa2, 0x2a, 0xd1, 0x69, 0x8d, 0x5d,
	0x76, 0xdb, 0x80, 0x1d, 0xd6, 0xe3, 0x8e, 0x3b, 0xec, 0x3f, 0x18, 0xf6, 0x0f, 0xec, 0x54, 0xec,
	0xd4, 0x63, 0xd1, 0x83, 0xb6, 0xb9, 0xb7, 0x1e, 0x73, 0x19, 0xd0, 0xc3, 0x30, 0x90, 0xa2, 0x6c,
	0xe5, 0xa3, 0xa9, 0x9d, 0x74, 0xc5, 0x4e, 0x26, 0xa9, 0xf7, 0x7d, 0x5e, 0x3e, 0x2f, 0x5f, 0x3e,
	0x24, 0x0d, 0xae, 0xec, 0xec, 0x96, 0x77, 0x76, 0x3d, 0xec, 0xee, 0x62, 0xb7, 0x6c, 0x91, 0xfb,
	0x2e, 0x36, 0xc8, 0x2e, 0x76, 0xdb, 0xd1, 0xb6, 0xb3, 0x55, 0x0e, 0x9b, 0x25, 0xc7, 0x25, 0x94,
	0xc0, 0xb2, 0x41, 0x8c, 0x1d, 0x97, 0xe8, 0x46, 0xa3, 0xb4, 0xb3, 0x5b, 0x0a, 0xfd, 0x4b, 0x11,
	0x9f, 0xd2, 0x3e, 0xff, 0x29, 0xc8, 0x8d, 0x9d, 0xad, 0x32, 0xd2, 0xa9, 0x1e, 0x80, 0x4c, 0x9d,
	0x0b, 0xc7, 0x9a, 0x98, 0xea, 0x91, 0xf1, 0xf1, 0x3a, 0xa9, 0x13, 0xde, 0x2c, 0xb3, 0x96, 0x18,
	0x95, 0xeb, 0x84, 0xd4, 0x2d, 0x5c, 0xe6, 0xbd, 0xad, 0xd6, 0x76, 0x99, 0x9a, 0x4d, 0xec, 0x51,
	0xbd, 0xe9, 0x04, 0x06, 0xca, 0x5f, 0x12, 0x18, 0x5f, 0xc0, 0x9e, 0xe1, 0x9a, 0x0e, 0x25, 0xee,
	0x7c, 0x43, 0xb7, 0xeb, 0xb8, 0x6a, 0x6f, 0x13, 0x88, 0x01, 0x30, 0x78, 0x6f, 0xbd, 0xed, 0xe0,
	0x82, 0x34, 0x2d, 0xcd, 0x8c, 0x5e, 0x5a, 0x2c, 0x0d, 0xc8, 0xa0, 0x74, 0x10, 0x9a, 0x81, 0xa9,
	0x11, 0x60, 0x78, 0x15, 0x24, 0x11, 0xf6, 0x8c, 0x42, 0x7c, 0x5a, 0x9a, 0xc9, 0x5d, 0x52, 0x22,
	0x01, 0x04, 0xcf, 0x92, 0xca, 0x6c, 0x7b, 0x38, 0x2a, 0xb7, 0x87, 0x37, 0x40, 0x96, 0xd0, 0x06,
	0x76, 0xd9, 0x87, 0x42, 0xa2, 0x6f, 0xe7, 0x9e, 0x93, 0xf2, 0x32, 0x05, 0x72, 0x2a, 0x76, 0x2c,
	0xd3, 0xd0, 0x39, 0xe1, 0x7b, 0x20, 0x63, 0x13, 0x84, 0x35, 0x13, 0x71, 0xb6, 0xa9, 0xca, 0x5c,
	0xc7, 0x97, 0xd3, 0xab, 0x04, 0xe1, 0xea, 0xc2, 0x4b, 0x5f, 0xbe, 0x5c, 0x37, 0x69, 0xa3, 0xb5,
	0x55, 0x32, 0x48, 0xb3, 0xb7, 0x8e, 0x68, 0xab, 0xd7, 0x2e, 0x3b, 0x3b, 0xf5, 0x72, 0x18, 0x37,
	0x70, 0x53, 0xd3, 0x0c, 0xb1, 0x8a, 0xe0, 0x26, 0x18, 0xf2, 0x28, 0x71, 0x39, 0x78, 0x9c, 0x83,
	0xcf, 0x77, 0x7c, 0x39, 0x53, 0x63, 0x63, 0x1c, 0xfd, 0xca, 0x40, 0xe8, 0xc2, 0x4f, 0xcd, 0x70,
	0xd0, 0x2a, 0x82, 0xd7, 0x44, 0x16, 0xfb, 0x4e, 0x44, 0x25, 0xf9, 0xd8, 0x97, 0x63, 0x22, 0x97,
	0x0d, 0x00, 0x5d, 0x7d, 0x9b, 0x6a, 0xba, 0xe3, 0x58, 0x26, 0x46, 0x9a, 0x69, 0x23, 0xfc, 0xb0,
	0x90, 0x9c, 0x96, 0x66, 0x92, 0x95, 0xd9, 0x97, 0xbe, 0x7c, 0xb5, 0xaf, 0xc9, 0xf1, 0x2d, 0xc1,
	0x23, 0x6d, 0xd3, 0x2a, 0x43, 0x50, 0xf3, 0x0c, 0x75, 0x2e, 0x00, 0xe5, 0x23, 0xd0, 0x02, 0xe3,
	0x3c, 0x92, 0x41, 0x9a, 0x4d, 0x93, 0xd2, 0x6e, 0xac, 0xd4, 0xa9, 0x63, 0x71, 0x06, 0xf3, 0x21,
	0x6c, 0x10, 0xed, 0x67, 0x09, 0xfc, 0x8f, 0x87, 0xb3, 0x48, 0x5d, 0x43, 0x5d, 0xee, 0x5a, 0x50,
	0x7e, 0x5e, 0x21, 0x3d, 0x9d, 0x98, 0xc9, 0xbd, 0x81, 0xa2, 0x66, 0xe5, 0x53, 0xf9, 0x90, 0x25,
	0xf4, 0x85, 0x2f, 0xbf, 0x7f, 0x4c, 0xc4, 0x8b, 0xa4, 0x69, 0x52, 0xdc, 0x74, 0x68, 0x5b, 0x2d,
	0x30, 0xb3, 0x65, 0x52, 0x3f, 0x88, 0xe5, 0x41, 0x03, 0x9c, 0xb7, 0x88, 0xa1, 0x5b, 0x9a, 0xee,
	0x79, 0xad, 0x26, 0xf6, 0x34, 0x0b, 0xeb, 0x1e, 0x6e, 0x10, 0x0b, 0x61, 0xb7, 0x90, 0x99, 0x96,
	0x66, 0x86, 0x2a, 0x1f, 0xbc, 0xf0, 0xe5, 0x77, 0x5f, 0x69, 0x14, 0x89, 0x32, 0xc9, 0x8d, 0xe6,
	0x02, 0x9b, 0xe5, 0x9e, 0x89, 0xf2, 0x15, 0x18, 0x9b, 0xb7, 0x5a, 0x1e, 0xc5, 0xee, 0x8a, 0x90,
	0x11, 0x78, 0x11, 0x00, 0x23, 0x18, 0x0a, 0xb7, 0x40, 0xb6, 0x32, 0xd2, 0xf1, 0xe5, 0xac, 0x30,
	0xac, 0x2e, 0xa8, 0x59, 0x61, 0x50, 0x45, 0x70, 0x16, 0x64, 0x76, 0xb1, 0xeb, 0x99, 0xc4, 0x16,
	0x5b, 0x77, 0xea, 0x88, 0xa2, 0xfb, 0x3c, 0xb0, 0x10, 0xc5, 0x16, 0x3a, 0x28, 0xf7, 0xc1, 0x18,
	0xdb, 0x1f, 0xd1, 0xcd, 0xb7, 0x09, 0x86, 0xdc, 0xa0, 0xeb, 0x15, 0x24, 0xbe, 0x2c, 0xd7, 0x06,
	0x5e, 0x96, 0x08, 0x9e, 0x88, 0xd8, 0xc5, 0x54, 0x7e, 0x8b, 0x03, 0x28, 0x78, 0x44, 0xc3, 0x0e,
	0xc6, 0xd9, 0x00, 0xb9, 0xde, 0x9a, 0x7a, 0x85, 0x38, 0x9f, 0x67, 0x3f, 0x9b, 0xed, 0x1d, 0x51,
	0x1b, 0x13, 0x11, 0xf7, 0xc8, 0x2a, 0x45, 0x51, 0x99, 0xee, 0x06, 0x2b, 0x6b, 0xda, 0xdb, 0xa4,
	0x90, 0xe0, 0x31, 0x6e, 0x0c, 0x9c, 0x8b, 0x03, 0xf9, 0x15, 0xf9, 0xc8, 0x72, 0x64, 0xce, 0x3c,
	0xb2, 0x7e, 0xc9, 0x41, 0xd7, 0xef, 0xd7, 0x24, 0x18, 0x11, 0xe0, 0x1b, 0x0e, 0xd2, 0x29, 0x86,
	0x0e, 0x18, 0x72, 0x19, 0xe7, 0x30, 0x8b, 0x89, 0xca, 0x06, 0xd3, 0x37, 0x9e, 0x87, 0xea, 0xc2,
	0x9e, 0x2f, 0x8f, 0xb6, 0xf5, 0xa6, 0x35, 0xab, 0x88, 0x01, 0x65, 0x60, 0xc5, 0x13, 0x8e, 0x6a,
	0x86, 0x87, 0xa9, 0x22, 0x78, 0x1d, 0x64, 0x3d, 0xaa, 0xbb, 0x54, 0xdb, 0xc1, 0x6d, 0x5e, 0x81,
	0xc3, 0x15, 0x65, 0xcf, 0x97, 0xc7, 0x82, 0x38, 0x35, 0xf6, 0xe9, 0x16, 0x6e, 0xb3, 0x40, 0x39,
	0x55, 0xa4, 0xe5, 0x16, 0x6e, 0xab, 0x43, 0x9e, 0xf8, 0x02, 0xbf, 0x91, 0xc0, 0x28, 0xb1, 0x90,
	0x26, 0x4a, 0x84, 0xcd, 0x3c, 0xc1, 0x95, 0x59, 0xef, 0xf8, 0xf2, 0xf0, 0x9a, 0x85, 0xc2, 0xf4,
	0xb1, 0xe9, 0x9f, 0x0d, 0x60, 0xa3, 0xa3, 0x4a, 0xdf, 0x62, 0xd5, 0xe5, 0x10, 0xba, 0xaa, 0xc3,
	0xa4, 0x07, 0x84, 0xe0, 0x97, 0x20, 0x67, 0xe3, 0x07, 0xe1, 0x44, 0xc4, 0x72, 0xbc, 0x77, 0x54,
	0x59, 0x05, 0x16, 0x91, 0xc2, 0x3a, 0xcf, 0x16, 0x66, 0xcf, 0x97, 0xcf, 0x04, 0xf3, 0x5b, 0xc5,
	0x0f, 0x84, 0x8d, 0xa2, 0x02, 0xbb, 0xdb, 0x81, 0xdf, 0x49, 0x60, 0xcc, 0xc6, 0x0f, 0x69, 0x94,
	0x6c, 0x8a, 0x93, 0x35, 0x3a, 0xbe, 0x3c, 0xb2, 0x8a, 0x1f, 0xd2, 0x28, 0xdb, 0xf1, 0x10, 0x2d,
	0x32, 0x7c, 0x1a, 0xba, 0x23, 0x76, 0x04, 0x09, 0xcd, 0x26, 0x7f, 0xf8, 0x51, 0x8e, 0x29, 0xcf,
	0x92, 0xe0, 0xcc, 0xbe, 0x22, 0xba, 0x6d, 0xe9, 0x36, 0xdc, 0x04, 0x99, 0x16, 0xef, 0x85, 0x32,
	0xf0, 0xc9, 0x49, 0x65, 0x20, 0x00, 0x0d, 0x4b, 0x57, 0x80, 0x32, 0x7c, 0xc7, 0xd2, 0xed, 0xf0,
	0x1c, 0x1e, 0xae, 0x2c, 0xb2, 0xef, 0xcf, 0xfa, 0x3d, 0xde, 0x5b, 0xd4, 0xb4, 0xca, 0xad, 0x96,
	0x89, 0x4a, 0x1b, 0x1b, 0xd5, 0x05, 0x76, 0x3f, 0x60, 0xb3, 0x66, 0x07, 0x3d, 0x43, 0xad, 0x22,
	0xf8, 0xad, 0x04, 0x26, 0x11, 0xe6, 0xc7, 0x9b, 0xc7, 0xf6, 0x0a, 0x46, 0x9a, 0xb8, 0x54, 0x78,
	0x7c, 0x2f, 0xa7, 0x2a, 0xb7, 0x3b, 0xbe, 0x3c, 0xb1, 0xb0, 0xcf, 0x24, 0xb8, 0x2c, 0x78, 0x27,
	0xbd, 0x64, 0x4c, 0xa0, 0xc3, 0x68, 0xc8, 0x3b, 0xa0, 0x6d, 0xc9, 0xd7, 0x68, 0xdb, 0xf7, 0x12,
	0x98, 0xf2, 0xa8, 0x6e, 0xe1, 0xe8, 0x49, 0xd2, 0x9b, 0x7b, 0x8a, 0xcf, 0x5d, 0xed, 0xf8, 0xf2,
	0x64, 0x8d, 0x59, 0x45, 0xce, 0x92, 0x53, 0xce, 0x7e, 0xd2, 0x3b, 0x0a, 0x0f, 0x79, 0x51, 0x85,
	0x4a, 0x0f, 0xaa, 0x50, 0x5f, 0xa7, 0xc0, 0x84, 0xa8, 0x83, 0x70, 0xf7, 0xb3, 0x5f, 0x17, 0xc1,
	0xff, 0x83, 0x6c, 0xf7, 0x0a, 0x1c, 0x48, 0x95, 0xda, 0x1b, 0xd8, 0xa7, 0x63, 0xf1, 0xb7, 0xaf,
	0x63, 0x89, 0x13, 0xe8, 0xd8, 0xc7, 0x20, 0x83, 0x6d, 0xc4, 0xdd, 0x93, 0x7d, 0xbb, 0xa7, 0xb1,
	0x8d, 0x5e, 0x21, 0x82, 0xa9, 0xff, 0x84, 0x08, 0xa6, 0xdf, 0xbc, 0x08, 0x36, 0x41, 0x3e, 0x58,
	0xdb, 0xde, 0x69, 0xcb, 0xaf, 0x53, 0xfd, 0x1d, 0xe1, 0x45, 0x11, 0xe4, 0x5c, 0xa4, 0x00, 0x7a,
	0x9f, 0x15, 0x75, 0xcc, 0x3d, 0x30, 0xf2, 0x4b, 0x02, 0xc0, 0xe0, 0x14, 0x0e, 0xd2, 0x5e, 0xa3,
	0x3a, 0x6d, 0x79, 0xff, 0xea, 0x2b, 0xc3, 0x01, 0x63, 0x0e, 0xb6, 0x91, 0x69, 0xd7, 0xb5, 0xfd,
	0x22, 0xb7, 0x74, 0x72, 0x81, 0x1b, 0xb9, 0x1d, 0x20, 0x0a, 0x9d, 0x1b, 0x71, 0x22, 0x5d, 0x1e,
	0x31, 0x7c, 0x34, 0x84, 0x11, 0x13, 0xa7, 0x8e, 0x28, 0x5e, 0x0c, 0x61, 0x44, 0x3d, 0xd2, 0x45,
	0xb0, 0x1a, 0x44, 0x6c, 0x6b, 0xbd, 0x5d, 0x1c, 0xde, 0x5f, 0x82, 0xa7, 0x6e, 0x29, 0x7c, 0xea,
	0x96, 0xd6, 0x43, 0x8b, 0x4a, 0xf2, 0xd1, 0xef, 0xb2, 0xa4, 0x8e, 0x72, 0xc7, 0xee, 0x28, 0x1c,
	0x07, 0x29, 0xec, 0xba, 0xc4, 0xe5, 0x25, 0x9f, 0x55, 0x83, 0x8e, 0xb2, 0x27, 0x81, 0x09, 0x16,
	0x8b, 0xcf, 0xc2, 0xd0, 0xa9, 0x49, 0x6c, 0x15, 0x7b, 0x2d, 0x8b, 0x42, 0x7a, 0x98, 0xac, 0xc4,
	0xc9, 0x2e, 0x9f, 0xee, 0x0c, 0x39, 0x9e, 0xf0, 0xca, 0x61, 0xc2, 0xf1, 0xd7, 0x12, 0x1e, 0x62,
	0x33, 0x3a, 0x9e, 0x74, 0x22, 0x4a, 0xfa, 0x6f, 0x09, 0x9c, 0xe5, 0x25, 0x7d, 0xa0, 0x5a, 0x37,
	0x0f, 0xdd, 0xeb, 0xe6, 0x23, 0x7a, 0x78, 0x7a, 0xf5, 0xfb, 0x08, 0x24, 0x3d, 0x47, 0x0f, 0x9f,
	0x10, 0x93, 0x47, 0xec, 0xc3, 0x9a, 0xa3, 0x87, 0xea, 0xce, 0x4d, 0xe1, 0x3a, 0x48, 0x37, 0xb0,
	0x6e, 0xd1, 0x06, 0x67, 0x30, 0x7a, 0x92, 0x77, 0x02, 0x0b, 0xbe, 0xc4, 0x31, 0x54, 0x81, 0xa5,
	0xfc, 0x24, 0x81, 0xc9, 0x05, 0xbc, 0x8d, 0x5d, 0x17, 0xa3, 0x30, 0x07, 0x73, 0x06, 0x5b, 0x7c,
	0xef, 0xd8, 0x33, 0x5d, 0x7a, 0xab, 0x67, 0xfa, 0x85, 0xeb, 0x87, 0xff, 0xac, 0xe1, 0xff, 0xa2,
	0x64, 0x41, 0xaa, 0xe6, 0x58, 0x26, 0xcd, 0xc7, 0x58, 0x73, 0x05, 0xbb, 0x75, 0x9c, 0x97, 0xe0,
	0x99, 0xee, 0x35, 0x3d, 0x30, 0xcd, 0xc7, 0x2f, 0xdc, 0x01, 0xb9, 0x08, 0x7d, 0x98, 0x03, 0x99,
	0x8d, 0xd5, 0x5b, 0xab, 0x6b, 0x77, 0x57, 0xf3, 0x31, 0xd6, 0x59, 0x5a, 0x9c, 0x5b, 0x5e, 0x5f,
	0xfa, 0x22, 0x2f, 0xc1, 0x71, 0x90, 0xbf, 0x3b, 0x57, 0x5d, 0xaf, 0xae, 0x7e, 0xaa, 0xdd, 0x5c,
	0x53, 0xb5, 0x95, 0xc5, 0xf5, 0xb9, 0x7c, 0x1c, 0x42, 0x30, 0xba, 0xbc, 0x56, 0xab, 0x69, 0x6b,
	0x37, 0xb5, 0x3b, 0x1b, 0x6b, 0xea, 0xc6, 0x4a, 0x3e, 0x51, 0xb1, 0x1e, 0xff, 0x59, 0x8c, 0x3d,
	0xee, 0x14, 0xa5, 0x27, 0x9d, 0xa2, 0xf4, 0xb4, 0x53, 0x94, 0xfe, 0xe8, 0x14, 0xa5, 0x47, 0xcf,
	0x8b, 0xb1, 0x27, 0xcf, 0x8b, 0xb1, 0xa7, 0xcf, 0x8b, 0xb1, 0x7b, 0x9f, 0xf5, 0xff, 0xa6, 0x7f,
	0xdd, 0x5f, 0x6a, 0x5b, 0x69, 0x5e, 0xed, 0x97, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x5d,
	0x03, 0x68, 0x82, 0x13, 0x00, 0x00,
}

func (m *DescriptorChangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorChangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescriptorChangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OtherDesc != nil {
		{
			size, err := m.OtherDesc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecovery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecovery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ChangeType != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocalAssumesLeaseholder {
		i--
		if m.LocalAssumesLeaseholder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RaftLogDescriptorChanges) > 0 {
		for iNdEx := len(m.RaftLogDescriptorChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RaftLogDescriptorChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RaftCommittedIndex != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RaftCommittedIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.RaftAppliedIndex != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RaftAppliedIndex))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.StoreID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeReplicaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeReplicaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeReplicaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClusterReplicaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterReplicaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterReplicaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.LocalInfo) > 0 {
		for iNdEx := len(m.LocalInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Descriptors) > 0 {
		for iNdEx := len(m.Descriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Descriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextReplicaID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.NextReplicaID))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.NewReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.OldReplicaID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.OldReplicaID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaUpdatePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaUpdatePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaUpdatePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.StaleLeaseholderNodeIDs) > 0 {
		l := 0
		for _, e := range m.StaleLeaseholderNodeIDs {
			l += sovRecovery(uint64(e))
		}
		i -= l
		if l == len(m.StaleLeaseholderNodeIDs) {
			dest := dAtA[i : i+len(m.StaleLeaseholderNodeIDs)]
			for k, num := range m.StaleLeaseholderNodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j8 := i
			for _, num1 := range m.StaleLeaseholderNodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j8] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j8++
				}
				dAtA[j8] = uint8(num)
				j8++
			}
		}
		i = encodeVarintRecovery(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DecommissionedNodeIDs) > 0 {
		l := 0
		for _, e := range m.DecommissionedNodeIDs {
			l += sovRecovery(uint64(e))
		}
		i -= l
		if l == len(m.DecommissionedNodeIDs) {
			dest := dAtA[i : i+len(m.DecommissionedNodeIDs)]
			for k, num := range m.DecommissionedNodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j9 := i
			for _, num1 := range m.DecommissionedNodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j9] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j9++
				}
				dAtA[j9] = uint8(num)
				j9++
			}
		}
		i = encodeVarintRecovery(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.PlanID.Size()
		i -= size
		if _, err := m.PlanID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaRecoveryRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaRecoveryRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaRecoveryRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RangeDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.NewReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.OldReplicaID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.OldReplicaID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RangeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeRecoveryStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeRecoveryStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeRecoveryStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ApplyTimestamp != nil {
		n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ApplyTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ApplyTimestamp):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintRecovery(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0x22
	}
	if m.AppliedPlanID != nil {
		{
			size := m.AppliedPlanID.Size()
			i -= size
			if _, err := m.AppliedPlanID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintRecovery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PendingPlanID != nil {
		{
			size := m.PendingPlanID.Size()
			i -= size
			if _, err := m.PendingPlanID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintRecovery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlanApplicationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanApplicationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanApplicationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	n13, err13 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ApplyTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ApplyTimestamp):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintRecovery(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x12
	{
		size := m.AppliedPlanID.Size()
		i -= size
		if _, err := m.AppliedPlanID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeRecoveryStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeRecoveryStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeRecoveryStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Health != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.Health))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RangeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeferredRecoveryActions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeferredRecoveryActions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeferredRecoveryActions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DecommissionedNodeIDs) > 0 {
		l := 0
		for _, e := range m.DecommissionedNodeIDs {
			l += sovRecovery(uint64(e))
		}
		i -= l
		if l == len(m.DecommissionedNodeIDs) {
			dest := dAtA[i : i+len(m.DecommissionedNodeIDs)]
			for k, num := range m.DecommissionedNodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j15 := i
			for _, num1 := range m.DecommissionedNodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j15] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j15++
				}
				dAtA[j15] = uint8(num)
				j15++
			}
		}
		i = encodeVarintRecovery(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRecovery(dAtA []byte, offset int, v uint64) int {
	offset -= sovRecovery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DescriptorChangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovRecovery(uint64(m.ChangeType))
	}
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.OtherDesc != nil {
		l = m.OtherDesc.Size()
		n += 1 + l + sovRecovery(uint64(l))
	}
	return n
}

func (m *ReplicaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovRecovery(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovRecovery(uint64(m.StoreID))
	}
	l = m.Desc.Size()
	n += 1 + l + sovRecovery(uint64(l))
	if m.RaftAppliedIndex != 0 {
		n += 1 + sovRecovery(uint64(m.RaftAppliedIndex))
	}
	if m.RaftCommittedIndex != 0 {
		n += 1 + sovRecovery(uint64(m.RaftCommittedIndex))
	}
	if len(m.RaftLogDescriptorChanges) > 0 {
		for _, e := range m.RaftLogDescriptorChanges {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	if m.LocalAssumesLeaseholder {
		n += 2
	}
	return n
}

func (m *ClusterMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovRecovery(uint64(l))
	return n
}

func (m *NodeReplicaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	return n
}

func (m *ClusterReplicaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	if len(m.LocalInfo) > 0 {
		for _, e := range m.LocalInfo {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	l = m.Version.Size()
	n += 1 + l + sovRecovery(uint64(l))
	return n
}

func (m *ReplicaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRecovery(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.OldReplicaID != 0 {
		n += 1 + sovRecovery(uint64(m.OldReplicaID))
	}
	l = m.NewReplica.Size()
	n += 1 + l + sovRecovery(uint64(l))
	if m.NextReplicaID != 0 {
		n += 1 + sovRecovery(uint64(m.NextReplicaID))
	}
	return n
}

func (m *ReplicaUpdatePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	l = m.PlanID.Size()
	n += 1 + l + sovRecovery(uint64(l))
	if len(m.DecommissionedNodeIDs) > 0 {
		l = 0
		for _, e := range m.DecommissionedNodeIDs {
			l += sovRecovery(uint64(e))
		}
		n += 1 + sovRecovery(uint64(l)) + l
	}
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	if len(m.StaleLeaseholderNodeIDs) > 0 {
		l = 0
		for _, e := range m.StaleLeaseholderNodeIDs {
			l += sovRecovery(uint64(e))
		}
		n += 1 + sovRecovery(uint64(l)) + l
	}
	l = m.Version.Size()
	n += 1 + l + sovRecovery(uint64(l))
	return n
}

func (m *ReplicaRecoveryRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovRecovery(uint64(m.Timestamp))
	}
	if m.RangeID != 0 {
		n += 1 + sovRecovery(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.OldReplicaID != 0 {
		n += 1 + sovRecovery(uint64(m.OldReplicaID))
	}
	l = m.NewReplica.Size()
	n += 1 + l + sovRecovery(uint64(l))
	l = m.RangeDescriptor.Size()
	n += 1 + l + sovRecovery(uint64(l))
	return n
}

func (m *NodeRecoveryStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovRecovery(uint64(m.NodeID))
	}
	if m.PendingPlanID != nil {
		l = m.PendingPlanID.Size()
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.AppliedPlanID != nil {
		l = m.AppliedPlanID.Size()
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.ApplyTimestamp != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ApplyTimestamp)
		n += 1 + l + sovRecovery(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	return n
}

func (m *PlanApplicationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppliedPlanID.Size()
	n += 1 + l + sovRecovery(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ApplyTimestamp)
	n += 1 + l + sovRecovery(uint64(l))
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	return n
}

func (m *RangeRecoveryStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRecovery(uint64(m.RangeID))
	}
	l = m.Span.Size()
	n += 1 + l + sovRecovery(uint64(l))
	if m.Health != 0 {
		n += 1 + sovRecovery(uint64(m.Health))
	}
	return n
}

func (m *DeferredRecoveryActions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DecommissionedNodeIDs) > 0 {
		l = 0
		for _, e := range m.DecommissionedNodeIDs {
			l += sovRecovery(uint64(e))
		}
		n += 1 + sovRecovery(uint64(l)) + l
	}
	return n
}

func sovRecovery(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozRecovery(x uint64) (n int) {
	return sovRecovery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DescriptorChangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorChangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorChangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= DescriptorChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &roachpb.RangeDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherDesc == nil {
				m.OtherDesc = &roachpb.RangeDescriptor{}
			}
			if err := m.OtherDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAppliedIndex", wireType)
			}
			m.RaftAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftAppliedIndex |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftCommittedIndex", wireType)
			}
			m.RaftCommittedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftCommittedIndex |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogDescriptorChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftLogDescriptorChanges = append(m.RaftLogDescriptorChanges, DescriptorChangeInfo{})
			if err := m.RaftLogDescriptorChanges[len(m.RaftLogDescriptorChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAssumesLeaseholder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalAssumesLeaseholder = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeReplicaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeReplicaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeReplicaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, ReplicaInfo{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterReplicaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterReplicaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterReplicaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, roachpb.RangeDescriptor{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalInfo = append(m.LocalInfo, NodeReplicaInfo{})
			if err := m.LocalInfo[len(m.LocalInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldReplicaID", wireType)
			}
			m.OldReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReplicaID", wireType)
			}
			m.NextReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaUpdatePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaUpdatePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaUpdatePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, ReplicaUpdate{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PlanID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DecommissionedNodeIDs = append(m.DecommissionedNodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecovery
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRecovery
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.DecommissionedNodeIDs == nil {
						m.DecommissionedNodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.DecommissionedNodeIDs = slices.Grow(m.DecommissionedNodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DecommissionedNodeIDs = append(m.DecommissionedNodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DecommissionedNodeIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StaleLeaseholderNodeIDs = append(m.StaleLeaseholderNodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecovery
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRecovery
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.StaleLeaseholderNodeIDs == nil {
						m.StaleLeaseholderNodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.StaleLeaseholderNodeIDs = slices.Grow(m.StaleLeaseholderNodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StaleLeaseholderNodeIDs = append(m.StaleLeaseholderNodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleLeaseholderNodeIDs", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaRecoveryRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaRecoveryRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaRecoveryRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldReplicaID", wireType)
			}
			m.OldReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeRecoveryStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeRecoveryStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeRecoveryStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPlanID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.PendingPlanID = &v
			if err := m.PendingPlanID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedPlanID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.AppliedPlanID = &v
			if err := m.AppliedPlanID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyTimestamp == nil {
				m.ApplyTimestamp = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ApplyTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanApplicationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanApplicationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanApplicationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedPlanID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedPlanID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ApplyTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeRecoveryStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeRecoveryStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeRecoveryStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Health |= RangeHealth(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeferredRecoveryActions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeferredRecoveryActions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeferredRecoveryActions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DecommissionedNodeIDs = append(m.DecommissionedNodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecovery
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRecovery
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.DecommissionedNodeIDs == nil {
						m.DecommissionedNodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.DecommissionedNodeIDs = slices.Grow(m.DecommissionedNodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DecommissionedNodeIDs = append(m.DecommissionedNodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DecommissionedNodeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRecovery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRecovery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRecovery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRecovery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRecovery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRecovery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRecovery = fmt.Errorf("proto: unexpected end of group")
)

