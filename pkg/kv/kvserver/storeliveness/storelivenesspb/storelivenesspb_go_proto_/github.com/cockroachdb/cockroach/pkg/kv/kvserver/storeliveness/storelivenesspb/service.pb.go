// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvserver/storeliveness/storelivenesspb/service.proto

package storelivenesspb

import (
	context "context"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MessageType lists the possible types of Store Liveness messages. This allows
// for a single Message proto to be used for all types of communication,
// similarly to Raft.
type MessageType int32

const (
	MsgHeartbeat     MessageType = 0
	MsgHeartbeatResp MessageType = 1
)

var MessageType_name = map[int32]string{
	0: "MsgHeartbeat",
	1: "MsgHeartbeatResp",
}

var MessageType_value = map[string]int32{
	"MsgHeartbeat":     0,
	"MsgHeartbeatResp": 1,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{0}
}

// StoreIdent includes all necessary info for a store to identify and
// communicate with another store for the purposes of Store Liveness.
type StoreIdent struct {
	NodeID  github_com_cockroachdb_cockroach_pkg_roachpb.NodeID  `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}
func (*StoreIdent) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{0}
}
func (m *StoreIdent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreIdent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreIdent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreIdent.Merge(m, src)
}
func (m *StoreIdent) XXX_Size() int {
	return m.Size()
}
func (m *StoreIdent) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreIdent.DiscardUnknown(m)
}

var xxx_messageInfo_StoreIdent proto.InternalMessageInfo

// Message is the single message proto used for Store Liveness communication.
type Message struct {
	Type MessageType `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.kv.kvserver.storeliveness.storelivenesspb.MessageType" json:"type,omitempty"`
	// From is the identity of the store providing support.
	From StoreIdent `protobuf:"bytes,2,opt,name=from,proto3" json:"from"`
	// To is the identity of the store requesting support.
	To StoreIdent `protobuf:"bytes,3,opt,name=to,proto3" json:"to"`
	// Epoch is the epoch for which support is requested/provided.
	Epoch Epoch `protobuf:"varint,4,opt,name=epoch,proto3,casttype=Epoch" json:"epoch,omitempty"`
	// Expiration is the timestamp of the requested/provided support for the
	// given epoch; it is drawn from the support requester's clock. An empty
	// Expiration implies that support for the epoch is not provided.
	Expiration hlc.Timestamp `protobuf:"bytes,5,opt,name=expiration,proto3" json:"expiration"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{1}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

// MessageBatch is a collection of Messages and a timestamp. It is used in the
// streaming Store Liveness RPC service.
type MessageBatch struct {
	Messages []Message `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages"`
	// Now is used to update the HLC clock of the message recipient. This is
	// necessary to ensure the Support Disjointness Invariant of Store Liveness.
	// Without propagating this timestamp, the following scenario is possible:
	// - At time 5, according to its own clock, store A has support from store B
	//   with epoch 1 and expiration 10.
	// - Store B withdraws support when its clock reaches time 10 and bumps store
	//   A's epoch to 2.
	// - Store A's clock is still at time 6, and it requests to extend support
	//   for epoch 1 until time 12.
	// - Store B responds with the bumped epoch 2 (essentially a nack).
	// - Store A, whose clock is at time 7, receives that message (does not update
	//   its clock to match store B's) and requests support for epoch 2 and
	//   expiration 13.
	// - Store B agrees and store A receives that response at time 8.
	// Now Store A has two overlapping periods of support for epochs 1 and 2:
	// [5, 10) and [8, 12).
	//
	// Keeping the stores' clocks more tightly synchronized also allows them to
	// provide/withdraw support promptly.
	Now github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,2,opt,name=now,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"now"`
}

func (m *MessageBatch) Reset()         { *m = MessageBatch{} }
func (m *MessageBatch) String() string { return proto.CompactTextString(m) }
func (*MessageBatch) ProtoMessage()    {}
func (*MessageBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{2}
}
func (m *MessageBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MessageBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageBatch.Merge(m, src)
}
func (m *MessageBatch) XXX_Size() int {
	return m.Size()
}
func (m *MessageBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageBatch.DiscardUnknown(m)
}

var xxx_messageInfo_MessageBatch proto.InternalMessageInfo

type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{3}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// RequesterMeta includes all metadata pertaining to a support requester that
// needs to be persisted to disk to ensure the Store Liveness algorithm remains
// correct across restarts.
type RequesterMeta struct {
	// MaxEpoch is the maximum epoch for which the local store has requested
	// support from any remote store. A local store's epoch is incremented when
	// it restarts, and it can increase when it loses support from a remote store.
	//
	// MaxEpoch needs to be persisted (before requesting support for that epoch)
	// to ensure that, if the local store restarts, it will not try to
	// re-establish support for an old no-longer-supported epoch.
	MaxEpoch Epoch `protobuf:"varint,1,opt,name=max_epoch,json=maxEpoch,proto3,casttype=Epoch" json:"max_epoch,omitempty"`
	// MaxRequested is the maximum timestamp at which support was requested by
	// another store. It is persisted to achieve two goals:
	//
	// 1. Ensures that the store's disk is not stalled before requesting support.
	// Receiving support for a store with a stalled disk is not desirable because
	// currently a leader/leaseholder depends on its own disk for availability.
	//
	// 2. Ensures that supported epochs do not overlap in time, and consequently,
	// the lease protocol implemented on top of Store Liveness maintains the Lease
	// Disjointness Invariant.
	//
	// Example: If a store restarts before its supported epoch expires, it could
	// get support for a higher epoch after restarting. This could be an issue if
	// the leaseholder serves a future-time read under the old epoch and a write
	// under the new epoch that invalidates the read.
	//
	// For 2, upon restart, a store must wait until its clock exceeds MaxRequested.
	MaxRequested hlc.Timestamp `protobuf:"bytes,2,opt,name=max_requested,json=maxRequested,proto3" json:"max_requested"`
}

func (m *RequesterMeta) Reset()         { *m = RequesterMeta{} }
func (m *RequesterMeta) String() string { return proto.CompactTextString(m) }
func (*RequesterMeta) ProtoMessage()    {}
func (*RequesterMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{4}
}
func (m *RequesterMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequesterMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequesterMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequesterMeta.Merge(m, src)
}
func (m *RequesterMeta) XXX_Size() int {
	return m.Size()
}
func (m *RequesterMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_RequesterMeta.DiscardUnknown(m)
}

var xxx_messageInfo_RequesterMeta proto.InternalMessageInfo

// SupporterMeta includes all metadata pertaining to a support provider that
// needs to be persisted to disk to ensure the Store Liveness algorithm remains
// correct across restarts.
type SupporterMeta struct {
	// MaxWithdrawn is the maximum timestamp at which support was withdrawn from
	// another store. It needs to be persisted to avoid providing support for that
	// store again after restarting and potentially regressing the HLC. HLCs are
	// usually assumed to be monotonically increasing even across restarts but
	// Store Liveness remains correct without this assumption.
	//
	// Upon restart, a store must forward its clock to MaxWithdrawn.
	MaxWithdrawn github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,1,opt,name=max_withdrawn,json=maxWithdrawn,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"max_withdrawn"`
}

func (m *SupporterMeta) Reset()         { *m = SupporterMeta{} }
func (m *SupporterMeta) String() string { return proto.CompactTextString(m) }
func (*SupporterMeta) ProtoMessage()    {}
func (*SupporterMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{5}
}
func (m *SupporterMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupporterMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SupporterMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupporterMeta.Merge(m, src)
}
func (m *SupporterMeta) XXX_Size() int {
	return m.Size()
}
func (m *SupporterMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SupporterMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SupporterMeta proto.InternalMessageInfo

// SupportState includes all metadata (epoch, expiration) pertaining to either a
// provider of support or requester of support. Each local store maintains two
// SupportState structs for a given remote store: one as a provider of support
// for the remote store, and one as a requester of support from the remote
// store. Only the former is persisted to disk to ensure that the local store
// continues to support the remote store as promised even across restarts. The
// latter is lost across restarts because a store loses all support from other
// stores upon restart.
type SupportState struct {
	// Target is the identify of the store that is being supported by the local
	// store ("support for") or the store that is providing support to the local
	// store ("support from"), depending on the context.
	//
	// For efficiency, Target is unset when writing the proto to disk, and then
	// populated back when the proto is read into memory.
	Target     StoreIdent    `protobuf:"bytes,1,opt,name=target,proto3" json:"target"`
	Epoch      Epoch         `protobuf:"varint,2,opt,name=epoch,proto3,casttype=Epoch" json:"epoch,omitempty"`
	Expiration hlc.Timestamp `protobuf:"bytes,3,opt,name=expiration,proto3" json:"expiration"`
}

func (m *SupportState) Reset()         { *m = SupportState{} }
func (m *SupportState) String() string { return proto.CompactTextString(m) }
func (*SupportState) ProtoMessage()    {}
func (*SupportState) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{6}
}
func (m *SupportState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SupportState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportState.Merge(m, src)
}
func (m *SupportState) XXX_Size() int {
	return m.Size()
}
func (m *SupportState) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportState.DiscardUnknown(m)
}

var xxx_messageInfo_SupportState proto.InternalMessageInfo

// InspectStoreLivenessRequest is used to power the Store Liveness /inspectz
// functionality. The request doesn't take any parameters.
type InspectStoreLivenessRequest struct {
}

func (m *InspectStoreLivenessRequest) Reset()         { *m = InspectStoreLivenessRequest{} }
func (m *InspectStoreLivenessRequest) String() string { return proto.CompactTextString(m) }
func (*InspectStoreLivenessRequest) ProtoMessage()    {}
func (*InspectStoreLivenessRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{7}
}
func (m *InspectStoreLivenessRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectStoreLivenessRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InspectStoreLivenessRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectStoreLivenessRequest.Merge(m, src)
}
func (m *InspectStoreLivenessRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectStoreLivenessRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectStoreLivenessRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectStoreLivenessRequest proto.InternalMessageInfo

// InspectStoreLivenessRequest is used to power the Store Liveness /inspectz
// functionality. The response is a list of SupportStatesPerStore.
type InspectStoreLivenessResponse struct {
	SupportStatesPerStore []SupportStatesPerStore `protobuf:"bytes,1,rep,name=support_states_per_store,json=supportStatesPerStore,proto3" json:"support_states_per_store"`
}

func (m *InspectStoreLivenessResponse) Reset()         { *m = InspectStoreLivenessResponse{} }
func (m *InspectStoreLivenessResponse) String() string { return proto.CompactTextString(m) }
func (*InspectStoreLivenessResponse) ProtoMessage()    {}
func (*InspectStoreLivenessResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{8}
}
func (m *InspectStoreLivenessResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectStoreLivenessResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InspectStoreLivenessResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectStoreLivenessResponse.Merge(m, src)
}
func (m *InspectStoreLivenessResponse) XXX_Size() int {
	return m.Size()
}
func (m *InspectStoreLivenessResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectStoreLivenessResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InspectStoreLivenessResponse proto.InternalMessageInfo

// SupportStatesPerStore includes all SupportStates for a given store; they
// correspond to either the support-from or support-for map of a given store.
type SupportStatesPerStore struct {
	StoreID       StoreIdent     `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id"`
	SupportStates []SupportState `protobuf:"bytes,2,rep,name=support_states,json=supportStates,proto3" json:"support_states"`
}

func (m *SupportStatesPerStore) Reset()         { *m = SupportStatesPerStore{} }
func (m *SupportStatesPerStore) String() string { return proto.CompactTextString(m) }
func (*SupportStatesPerStore) ProtoMessage()    {}
func (*SupportStatesPerStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbef1e027f6fd15a, []int{9}
}
func (m *SupportStatesPerStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportStatesPerStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SupportStatesPerStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportStatesPerStore.Merge(m, src)
}
func (m *SupportStatesPerStore) XXX_Size() int {
	return m.Size()
}
func (m *SupportStatesPerStore) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportStatesPerStore.DiscardUnknown(m)
}

var xxx_messageInfo_SupportStatesPerStore proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.kv.kvserver.storeliveness.storelivenesspb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*StoreIdent)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.StoreIdent")
	proto.RegisterType((*Message)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.Message")
	proto.RegisterType((*MessageBatch)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.MessageBatch")
	proto.RegisterType((*Empty)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.Empty")
	proto.RegisterType((*RequesterMeta)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.RequesterMeta")
	proto.RegisterType((*SupporterMeta)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.SupporterMeta")
	proto.RegisterType((*SupportState)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.SupportState")
	proto.RegisterType((*InspectStoreLivenessRequest)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.InspectStoreLivenessRequest")
	proto.RegisterType((*InspectStoreLivenessResponse)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.InspectStoreLivenessResponse")
	proto.RegisterType((*SupportStatesPerStore)(nil), "cockroach.kv.kvserver.storeliveness.storelivenesspb.SupportStatesPerStore")
}

func init() {
	proto.RegisterFile("kv/kvserver/storeliveness/storelivenesspb/service.proto", fileDescriptor_fbef1e027f6fd15a)
}

var fileDescriptor_fbef1e027f6fd15a = []byte{
	// 790 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x96, 0xcf, 0x6b, 0x33, 0x45,
	0x18, 0xc7, 0x77, 0xf2, 0xf3, 0x7d, 0xa7, 0x49, 0x0d, 0x43, 0x0b, 0x4b, 0xb4, 0x9b, 0xb2, 0x07,
	0x09, 0x1e, 0x76, 0x21, 0x15, 0x04, 0x2d, 0x68, 0xd3, 0x16, 0x1a, 0xb1, 0x45, 0x92, 0x8a, 0x58,
	0xd0, 0xb0, 0xd9, 0x1d, 0x93, 0x25, 0xd9, 0x9d, 0x71, 0x66, 0x92, 0xa6, 0x47, 0x6f, 0x15, 0x2f,
	0x9e, 0x05, 0x4f, 0xde, 0xfc, 0x4b, 0x72, 0x2c, 0x78, 0xe9, 0x29, 0x68, 0x8a, 0xff, 0x81, 0x20,
	0xf4, 0x24, 0x33, 0xbb, 0x49, 0x37, 0xa5, 0x60, 0x4c, 0xcb, 0x7b, 0x9b, 0xec, 0xe6, 0xf9, 0x3c,
	0xdf, 0xe7, 0xfb, 0x3c, 0xf3, 0xb0, 0xf0, 0x83, 0xfe, 0xc8, 0xee, 0x8f, 0x38, 0x66, 0x23, 0xcc,
	0x6c, 0x2e, 0x08, 0xc3, 0x03, 0x7f, 0x84, 0x43, 0xcc, 0xf9, 0xf2, 0x2f, 0xda, 0xb1, 0xe5, 0x9f,
	0x7c, 0x17, 0x5b, 0x94, 0x11, 0x41, 0xd0, 0x9e, 0x4b, 0xdc, 0x3e, 0x23, 0x8e, 0xdb, 0xb3, 0xfa,
	0x23, 0x6b, 0x8e, 0xb0, 0x96, 0x82, 0xac, 0x47, 0x88, 0xf2, 0x56, 0x97, 0x74, 0x89, 0x8a, 0xb7,
	0xe5, 0x29, 0x42, 0x95, 0xf5, 0xa1, 0xf0, 0x07, 0x76, 0x6f, 0xe0, 0xda, 0xc2, 0x0f, 0x30, 0x17,
	0x4e, 0x40, 0xa3, 0x37, 0xe6, 0x04, 0x40, 0xd8, 0x92, 0x8c, 0x86, 0x87, 0x43, 0x81, 0x2e, 0x60,
	0x3e, 0x24, 0x1e, 0x6e, 0xfb, 0x9e, 0x0e, 0x76, 0x41, 0x35, 0x5b, 0x3f, 0x98, 0x4d, 0x2b, 0xb9,
	0x33, 0xe2, 0xe1, 0xc6, 0xd1, 0xfd, 0xb4, 0xb2, 0xd7, 0xf5, 0x45, 0x6f, 0xd8, 0xb1, 0x5c, 0x12,
	0xd8, 0x0b, 0x75, 0x5e, 0xe7, 0xe1, 0x6c, 0xd3, 0x7e, 0xd7, 0x56, 0x27, 0xda, 0xb1, 0xa2, 0xb0,
	0x66, 0x4e, 0x12, 0x1b, 0x1e, 0xfa, 0x06, 0xbe, 0x52, 0x6a, 0x25, 0x3c, 0xa5, 0xe0, 0x87, 0xb3,
	0x69, 0x25, 0x1f, 0x65, 0x97, 0xf4, 0xf7, 0xff, 0x17, 0x3d, 0x8e, 0x6b, 0xe6, 0x79, 0x24, 0xdf,
	0xfc, 0x27, 0x05, 0xf3, 0xa7, 0x98, 0x73, 0xa7, 0x8b, 0xd1, 0x39, 0xcc, 0x88, 0x2b, 0x8a, 0x55,
	0x11, 0x9b, 0xb5, 0x4f, 0xac, 0x35, 0xac, 0xb4, 0x62, 0xd6, 0xf9, 0x15, 0xc5, 0x4d, 0x45, 0x43,
	0x5f, 0xc1, 0xcc, 0xb7, 0x8c, 0x04, 0x4a, 0xfd, 0x46, 0xed, 0xe3, 0xb5, 0xa8, 0x0f, 0x66, 0xd7,
	0x33, 0x93, 0x69, 0x45, 0x6b, 0x2a, 0x24, 0xfa, 0x02, 0xa6, 0x04, 0xd1, 0xd3, 0x2f, 0x09, 0x4e,
	0x09, 0x82, 0x2a, 0x30, 0x8b, 0x29, 0x71, 0x7b, 0x7a, 0x66, 0x17, 0x54, 0xd3, 0xf5, 0xd7, 0xf7,
	0xd3, 0x4a, 0xf6, 0x58, 0x3e, 0x68, 0x46, 0xcf, 0xd1, 0x21, 0x84, 0x78, 0x4c, 0x7d, 0xe6, 0x08,
	0x9f, 0x84, 0x7a, 0x56, 0xe5, 0xdf, 0x49, 0xe4, 0x97, 0x83, 0x63, 0xf5, 0x06, 0xae, 0x75, 0x3e,
	0x1f, 0x9c, 0x98, 0x9e, 0x08, 0x33, 0xff, 0x02, 0xb0, 0x10, 0xbb, 0x55, 0x77, 0x84, 0xdb, 0x93,
	0xad, 0x0e, 0xa2, 0xdf, 0x5c, 0x07, 0xbb, 0xe9, 0xea, 0x46, 0x6d, 0xff, 0x39, 0x2d, 0x88, 0x53,
	0x2e, 0x98, 0x68, 0x08, 0xd3, 0x21, 0xb9, 0x8c, 0xfb, 0xf0, 0x1f, 0x72, 0x8f, 0x64, 0xec, 0xfd,
	0xb4, 0xb2, 0xbf, 0xd2, 0x74, 0xcd, 0x2f, 0x8a, 0x75, 0x38, 0x20, 0x6e, 0x7f, 0x41, 0x69, 0xca,
	0x7c, 0x66, 0x1e, 0x66, 0x8f, 0x03, 0x2a, 0xae, 0xcc, 0xef, 0x01, 0x2c, 0x36, 0xf1, 0x77, 0x43,
	0xcc, 0x05, 0x66, 0xa7, 0x58, 0x38, 0xe8, 0x5d, 0xf8, 0x3a, 0x70, 0xc6, 0xed, 0xc8, 0x6c, 0xf0,
	0xd8, 0xec, 0x57, 0x81, 0x33, 0x56, 0x27, 0x74, 0x02, 0x8b, 0xf2, 0x7f, 0x2c, 0x0e, 0xf6, 0x56,
	0xab, 0x21, 0xaa, 0xbf, 0x10, 0x38, 0xe3, 0x79, 0x56, 0xcf, 0xfc, 0x19, 0xc0, 0x62, 0x6b, 0x48,
	0x29, 0x61, 0x73, 0x0d, 0xd7, 0x20, 0x82, 0x5f, 0xfa, 0xa2, 0xe7, 0x31, 0xe7, 0x32, 0x54, 0x42,
	0xde, 0x90, 0x41, 0x52, 0xdc, 0x97, 0xf3, 0xc4, 0xe6, 0xef, 0x00, 0x16, 0x62, 0x71, 0x2d, 0xe1,
	0x08, 0x8c, 0xbe, 0x86, 0x39, 0xe1, 0xb0, 0x2e, 0x16, 0xb1, 0xa6, 0x17, 0x9a, 0xf1, 0x18, 0xfa,
	0x30, 0xe7, 0xa9, 0x95, 0xe6, 0x3c, 0xbd, 0xde, 0x9c, 0xef, 0xc0, 0xb7, 0x1b, 0x21, 0xa7, 0xd8,
	0x15, 0x4a, 0xc8, 0x67, 0xb1, 0xb0, 0xb8, 0x27, 0xe6, 0x6f, 0x00, 0xbe, 0xf3, 0xf4, 0x7b, 0x4e,
	0x49, 0xc8, 0x31, 0xfa, 0x01, 0x40, 0x9d, 0x47, 0xae, 0xb4, 0xb9, 0xb4, 0x85, 0xb7, 0x29, 0x66,
	0x6d, 0x55, 0x65, 0x7c, 0x4f, 0x3e, 0x5d, 0xcf, 0x97, 0x84, 0xd5, 0xfc, 0x73, 0xcc, 0x54, 0xfa,
	0xb8, 0x80, 0x6d, 0xfe, 0xd4, 0x4b, 0xf3, 0x6f, 0x00, 0xb7, 0x9f, 0x0c, 0x43, 0xfd, 0xc4, 0x9e,
	0x7e, 0xa1, 0x66, 0xbd, 0x25, 0x95, 0x24, 0x96, 0xfd, 0x62, 0x69, 0xa3, 0x10, 0x6e, 0x2e, 0x3b,
	0xa2, 0xa7, 0x94, 0x0f, 0x07, 0xcf, 0xf6, 0x21, 0x2e, 0xbf, 0xb8, 0x54, 0xfe, 0x7b, 0x1f, 0xc1,
	0x8d, 0xc4, 0x5e, 0x47, 0x25, 0x58, 0x38, 0xe5, 0xdd, 0x13, 0xec, 0x30, 0xd1, 0xc1, 0x8e, 0x28,
	0x69, 0x68, 0x0b, 0x96, 0x92, 0x4f, 0x64, 0xef, 0x4a, 0xa0, 0x9c, 0xb9, 0xfe, 0xd5, 0xd0, 0x6a,
	0xbf, 0xc8, 0x2b, 0x97, 0xec, 0x2c, 0xfa, 0x11, 0xc0, 0x5c, 0x4b, 0x30, 0xec, 0x04, 0xe8, 0xe0,
	0x59, 0x1b, 0x4e, 0xae, 0xcd, 0xf2, 0x87, 0x6b, 0x21, 0xa2, 0x95, 0xa4, 0x55, 0x41, 0x9d, 0x4e,
	0xfe, 0x34, 0xb4, 0xc9, 0xcc, 0x00, 0x37, 0x33, 0x03, 0xdc, 0xce, 0x0c, 0xf0, 0xc7, 0xcc, 0x00,
	0x3f, 0xdd, 0x19, 0xda, 0xcd, 0x9d, 0xa1, 0xdd, 0xde, 0x19, 0xda, 0xc5, 0xd9, 0x4a, 0x77, 0x7c,
	0xe5, 0x2f, 0x96, 0x4e, 0x4e, 0x7d, 0x45, 0xec, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x0c, 0xbf,
	0x16, 0xfc, 0xe5, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StoreLivenessClient is the client API for StoreLiveness service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StoreLivenessClient interface {
	Stream(ctx context.Context, opts ...grpc.CallOption) (StoreLiveness_StreamClient, error)
}

type storeLivenessClient struct {
	cc *grpc.ClientConn
}

func NewStoreLivenessClient(cc *grpc.ClientConn) StoreLivenessClient {
	return &storeLivenessClient{cc}
}

func (c *storeLivenessClient) Stream(ctx context.Context, opts ...grpc.CallOption) (StoreLiveness_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StoreLiveness_serviceDesc.Streams[0], "/cockroach.kv.kvserver.storeliveness.storelivenesspb.StoreLiveness/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &storeLivenessStreamClient{stream}
	return x, nil
}

type StoreLiveness_StreamClient interface {
	Send(*MessageBatch) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type storeLivenessStreamClient struct {
	grpc.ClientStream
}

func (x *storeLivenessStreamClient) Send(m *MessageBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *storeLivenessStreamClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StoreLivenessServer is the server API for StoreLiveness service.
type StoreLivenessServer interface {
	Stream(StoreLiveness_StreamServer) error
}

// UnimplementedStoreLivenessServer can be embedded to have forward compatible implementations.
type UnimplementedStoreLivenessServer struct {
}

func (*UnimplementedStoreLivenessServer) Stream(srv StoreLiveness_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}

func RegisterStoreLivenessServer(s *grpc.Server, srv StoreLivenessServer) {
	s.RegisterService(&_StoreLiveness_serviceDesc, srv)
}

func _StoreLiveness_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StoreLivenessServer).Stream(&storeLivenessStreamServer{stream})
}

type StoreLiveness_StreamServer interface {
	SendAndClose(*Empty) error
	Recv() (*MessageBatch, error)
	grpc.ServerStream
}

type storeLivenessStreamServer struct {
	grpc.ServerStream
}

func (x *storeLivenessStreamServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *storeLivenessStreamServer) Recv() (*MessageBatch, error) {
	m := new(MessageBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StoreLiveness_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.kv.kvserver.storeliveness.storelivenesspb.StoreLiveness",
	HandlerType: (*StoreLivenessServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _StoreLiveness_Stream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "kv/kvserver/storeliveness/storelivenesspb/service.proto",
}

func (m *StoreIdent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreIdent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreIdent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Epoch != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RequesterMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequesterMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequesterMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MaxRequested.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MaxEpoch != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.MaxEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SupporterMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupporterMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupporterMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MaxWithdrawn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SupportState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupportState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Epoch != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InspectStoreLivenessRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectStoreLivenessRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectStoreLivenessRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *InspectStoreLivenessResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectStoreLivenessResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectStoreLivenessResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupportStatesPerStore) > 0 {
		for iNdEx := len(m.SupportStatesPerStore) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupportStatesPerStore[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SupportStatesPerStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportStatesPerStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupportStatesPerStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupportStates) > 0 {
		for iNdEx := len(m.SupportStates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupportStates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.StoreID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	offset -= sovService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StoreIdent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovService(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovService(uint64(m.StoreID))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovService(uint64(m.Type))
	}
	l = m.From.Size()
	n += 1 + l + sovService(uint64(l))
	l = m.To.Size()
	n += 1 + l + sovService(uint64(l))
	if m.Epoch != 0 {
		n += 1 + sovService(uint64(m.Epoch))
	}
	l = m.Expiration.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *MessageBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	l = m.Now.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RequesterMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxEpoch != 0 {
		n += 1 + sovService(uint64(m.MaxEpoch))
	}
	l = m.MaxRequested.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *SupporterMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MaxWithdrawn.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *SupportState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Target.Size()
	n += 1 + l + sovService(uint64(l))
	if m.Epoch != 0 {
		n += 1 + sovService(uint64(m.Epoch))
	}
	l = m.Expiration.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *InspectStoreLivenessRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *InspectStoreLivenessResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupportStatesPerStore) > 0 {
		for _, e := range m.SupportStatesPerStore {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *SupportStatesPerStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StoreID.Size()
	n += 1 + l + sovService(uint64(l))
	if len(m.SupportStates) > 0 {
		for _, e := range m.SupportStates {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func sovService(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StoreIdent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreIdent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreIdent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= Epoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequesterMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequesterMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequesterMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEpoch", wireType)
			}
			m.MaxEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEpoch |= Epoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRequested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupporterMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupporterMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupporterMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWithdrawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= Epoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectStoreLivenessRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectStoreLivenessRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectStoreLivenessRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectStoreLivenessResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectStoreLivenessResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectStoreLivenessResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportStatesPerStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportStatesPerStore = append(m.SupportStatesPerStore, SupportStatesPerStore{})
			if err := m.SupportStatesPerStore[len(m.SupportStatesPerStore)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportStatesPerStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportStatesPerStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportStatesPerStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportStates = append(m.SupportStates, SupportState{})
			if err := m.SupportStates[len(m.SupportStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupService = fmt.Errorf("proto: unexpected end of group")
)

