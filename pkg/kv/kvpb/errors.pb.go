// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvpb/errors.proto

// NB: this file (along with most things in api.proto and metadata.proto)
// really ought to live in a ./pkg/kv/kvpb package. However, moving them
// there is a larger undertaking because import cycles require a large
// amount of refactoring. Essentially, all references to `kvpb` from the
// `roachpb` package will need to be avoided, and it takes time to make
// these changes. Second, proto renames are tricky as the paths leak into
// uses of protobuf.Any.
//
// It is for this second reason that this package was renamed preemptively
// (but not moved yet for the first reason): we use EncodedError in Error,
// and once that is released in even an alpha version, migration concerns
// arise that are not trivial to address. Since the package already has the
// correct name, the files can be moved into a newly created `kvpb` package
// at leisure.

package kvpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_storage_enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	errorspb "github.com/cockroachdb/errors/errorspb"
	github_com_cockroachdb_redact "github.com/cockroachdb/redact"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TransactionAbortedReason specifies what caused a TransactionAbortedError.
// The reasons below are not necessarily disjoint - they describe where the
// error was generated, but generally it's possible that a
// TransactionAbortedError would have been generated somewhere else if the
// client would have performed different operations.
type TransactionAbortedReason int32

const (
	// For backwards compatibility.
	ABORT_REASON_UNKNOWN TransactionAbortedReason = 0
	// A HeartbeatTxn or EndTxn(commit=true) request found an aborted transaction
	// record. Another txn must have written this record - that other txn probably
	// ran into one of our intents and pushed our transaction record successfully.
	// Either a high-priority transaction simply pushed us or we failed to
	// heartbeat for a while and another txn (of any priority) considered us
	// abandoned and pushed us.
	ABORT_REASON_ABORTED_RECORD_FOUND TransactionAbortedReason = 1
	// The client is trying to use a transaction that's already been aborted. The
	// TxnCoordSender detects this. Either the client is misusing a txn, or the
	// TxnCoordSender found out about the transaction being aborted async through
	// the heartbeat loop.
	ABORT_REASON_CLIENT_REJECT TransactionAbortedReason = 3
	// The txn was trying to push another and found out that it itself got aborted
	// somehow while waiting for the push.
	ABORT_REASON_PUSHER_ABORTED TransactionAbortedReason = 4
	// The txn ran into the "abort span" - it was trying to read from a range
	// where it had previously laid down intents that have been cleaned up in the
	// meantime because the transaction was aborted.
	ABORT_REASON_ABORT_SPAN TransactionAbortedReason = 5
	// A request attempting to create a transaction record encountered a write
	// timestamp cache entry for the txn key, and the entry identifies this
	// transaction. This means that the transaction already wrote a transaction
	// record previously, which may or may not have been removed since. So, this
	// request is either a delayed replay of some sort, or it raced with an async
	// abort and lost. If a client gets this TransactionAbortedError (without it
	// being wrapped in an ambiguous error), it must be the latter case, and the
	// transaction can be retried.
	ABORT_REASON_RECORD_ALREADY_WRITTEN_POSSIBLE_REPLAY TransactionAbortedReason = 6
	// A request attempting to create a transaction record is not allowed to
	// proceed by the timestamp cache because it cannot be verified that the
	// respective transaction record did not previously exist. As opposed to the
	// case above, the timestamp cache does not have a txn id in it, but the lease
	// under which the request is evaluated is newer than the transaction's
	// minimum timestamp (see CanCreateTxnRecord()). A new lease wipes the
	// timestamp cache, so transaction record creation is bound to fail for
	// transactions that spanned a lease acquisition.
	// As above, if the error has not been converted by the time it reaches a
	// client, then it's not a replay.
	ABORT_REASON_NEW_LEASE_PREVENTS_TXN TransactionAbortedReason = 8
	// Like the above, the timestamp cache rejects the creation of a transaction
	// record. But there's no txn id in the ts cache, and also the lease is not
	// new. The timestamp cache has lost accuracy because of a range merge or
	// because of its memory limit.
	// As above, if the error has not been converted by the time it reaches a
	// client, then it's not a replay.
	//
	// TODO(andrei): We should be able to identify the range merge case by saving
	// a bit more info in the timestamp cache.
	ABORT_REASON_TIMESTAMP_CACHE_REJECTED TransactionAbortedReason = 7
)

var TransactionAbortedReason_name = map[int32]string{
	0: "ABORT_REASON_UNKNOWN",
	1: "ABORT_REASON_ABORTED_RECORD_FOUND",
	3: "ABORT_REASON_CLIENT_REJECT",
	4: "ABORT_REASON_PUSHER_ABORTED",
	5: "ABORT_REASON_ABORT_SPAN",
	6: "ABORT_REASON_RECORD_ALREADY_WRITTEN_POSSIBLE_REPLAY",
	8: "ABORT_REASON_NEW_LEASE_PREVENTS_TXN",
	7: "ABORT_REASON_TIMESTAMP_CACHE_REJECTED",
}

var TransactionAbortedReason_value = map[string]int32{
	"ABORT_REASON_UNKNOWN":                                0,
	"ABORT_REASON_ABORTED_RECORD_FOUND":                   1,
	"ABORT_REASON_CLIENT_REJECT":                          3,
	"ABORT_REASON_PUSHER_ABORTED":                         4,
	"ABORT_REASON_ABORT_SPAN":                             5,
	"ABORT_REASON_RECORD_ALREADY_WRITTEN_POSSIBLE_REPLAY": 6,
	"ABORT_REASON_NEW_LEASE_PREVENTS_TXN":                 8,
	"ABORT_REASON_TIMESTAMP_CACHE_REJECTED":               7,
}

func (x TransactionAbortedReason) Enum() *TransactionAbortedReason {
	p := new(TransactionAbortedReason)
	*p = x
	return p
}

func (x TransactionAbortedReason) String() string {
	return proto.EnumName(TransactionAbortedReason_name, int32(x))
}

func (x *TransactionAbortedReason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionAbortedReason_value, data, "TransactionAbortedReason")
	if err != nil {
		return err
	}
	*x = TransactionAbortedReason(value)
	return nil
}

func (TransactionAbortedReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{0}
}

// TransactionRetryReason specifies what caused a transaction retry.
type TransactionRetryReason int32

const (
	// For backwards compatibility.
	RETRY_REASON_UNKNOWN TransactionRetryReason = 0
	// A concurrent writer finished first, causing restart.
	RETRY_WRITE_TOO_OLD TransactionRetryReason = 1
	// A SERIALIZABLE transaction had its timestamp moved forward.
	RETRY_SERIALIZABLE TransactionRetryReason = 3
	// An asynchronous write was observed to have failed.
	RETRY_ASYNC_WRITE_FAILURE TransactionRetryReason = 5
	// The transaction exceeded its deadline.
	RETRY_COMMIT_DEADLINE_EXCEEDED TransactionRetryReason = 6
)

var TransactionRetryReason_name = map[int32]string{
	0: "RETRY_REASON_UNKNOWN",
	1: "RETRY_WRITE_TOO_OLD",
	3: "RETRY_SERIALIZABLE",
	5: "RETRY_ASYNC_WRITE_FAILURE",
	6: "RETRY_COMMIT_DEADLINE_EXCEEDED",
}

var TransactionRetryReason_value = map[string]int32{
	"RETRY_REASON_UNKNOWN":           0,
	"RETRY_WRITE_TOO_OLD":            1,
	"RETRY_SERIALIZABLE":             3,
	"RETRY_ASYNC_WRITE_FAILURE":      5,
	"RETRY_COMMIT_DEADLINE_EXCEEDED": 6,
}

func (x TransactionRetryReason) Enum() *TransactionRetryReason {
	p := new(TransactionRetryReason)
	*p = x
	return p
}

func (x TransactionRetryReason) String() string {
	return proto.EnumName(TransactionRetryReason_name, int32(x))
}

func (x *TransactionRetryReason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionRetryReason_value, data, "TransactionRetryReason")
	if err != nil {
		return err
	}
	*x = TransactionRetryReason(value)
	return nil
}

func (TransactionRetryReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{1}
}

// TransactionRestart indicates how an error should be handled in a
// transactional context.
type TransactionRestart int32

const (
	// NONE (the default) is used for errors which have no effect on the
	// transaction state. That is, a transactional operation which receives such
	// an error is still PENDING and does not need to restart (at least not as a
	// result of the error). Examples are a CPut whose condition wasn't met, or
	// a spurious RPC error.
	TransactionRestart_NONE TransactionRestart = 0
	// BACKOFF is for errors that can retried by restarting the transaction
	// after an exponential backoff.
	// Note: Deprecated.
	TransactionRestart_BACKOFF TransactionRestart = 1
	// IMMEDIATE is for errors that can be retried by restarting the
	// transaction immediately.
	TransactionRestart_IMMEDIATE TransactionRestart = 2
)

var TransactionRestart_name = map[int32]string{
	0: "NONE",
	1: "BACKOFF",
	2: "IMMEDIATE",
}

var TransactionRestart_value = map[string]int32{
	"NONE":      0,
	"BACKOFF":   1,
	"IMMEDIATE": 2,
}

func (x TransactionRestart) Enum() *TransactionRestart {
	p := new(TransactionRestart)
	*p = x
	return p
}

func (x TransactionRestart) String() string {
	return proto.EnumName(TransactionRestart_name, int32(x))
}

func (x *TransactionRestart) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionRestart_value, data, "TransactionRestart")
	if err != nil {
		return err
	}
	*x = TransactionRestart(value)
	return nil
}

func (TransactionRestart) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{2}
}

// Reason specifies what caused the error.
type TransactionStatusError_Reason int32

const (
	// For backwards compatibility.
	TransactionStatusError_REASON_UNKNOWN TransactionStatusError_Reason = 0
	// A committed transaction record was found.
	TransactionStatusError_REASON_TXN_COMMITTED TransactionStatusError_Reason = 2
)

var TransactionStatusError_Reason_name = map[int32]string{
	0: "REASON_UNKNOWN",
	2: "REASON_TXN_COMMITTED",
}

var TransactionStatusError_Reason_value = map[string]int32{
	"REASON_UNKNOWN":       0,
	"REASON_TXN_COMMITTED": 2,
}

func (x TransactionStatusError_Reason) Enum() *TransactionStatusError_Reason {
	p := new(TransactionStatusError_Reason)
	*p = x
	return p
}

func (x TransactionStatusError_Reason) String() string {
	return proto.EnumName(TransactionStatusError_Reason_name, int32(x))
}

func (x *TransactionStatusError_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionStatusError_Reason_value, data, "TransactionStatusError_Reason")
	if err != nil {
		return err
	}
	*x = TransactionStatusError_Reason(value)
	return nil
}

func (TransactionStatusError_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{10, 0}
}

type WriteIntentError_Reason int32

const (
	// The reason for the WriteIntentError is unspecified.
	WriteIntentError_REASON_UNSPECIFIED WriteIntentError_Reason = 0
	// The request used an Error wait policy because it did not want to
	// wait on locks and it encountered a conflicting lock.
	WriteIntentError_REASON_WAIT_POLICY WriteIntentError_Reason = 1
	// The request used a Block wait policy and specified a lock timeout
	// which expired while waiting for a conflicting lock.
	WriteIntentError_REASON_LOCK_TIMEOUT WriteIntentError_Reason = 2
	// The request attempted to wait in a lock wait-queue whose length was
	// already equal to or exceeding the configured maximum.
	WriteIntentError_REASON_LOCK_WAIT_QUEUE_MAX_LENGTH_EXCEEDED WriteIntentError_Reason = 3
)

var WriteIntentError_Reason_name = map[int32]string{
	0: "REASON_UNSPECIFIED",
	1: "REASON_WAIT_POLICY",
	2: "REASON_LOCK_TIMEOUT",
	3: "REASON_LOCK_WAIT_QUEUE_MAX_LENGTH_EXCEEDED",
}

var WriteIntentError_Reason_value = map[string]int32{
	"REASON_UNSPECIFIED":                         0,
	"REASON_WAIT_POLICY":                         1,
	"REASON_LOCK_TIMEOUT":                        2,
	"REASON_LOCK_WAIT_QUEUE_MAX_LENGTH_EXCEEDED": 3,
}

func (x WriteIntentError_Reason) Enum() *WriteIntentError_Reason {
	p := new(WriteIntentError_Reason)
	*p = x
	return p
}

func (x WriteIntentError_Reason) String() string {
	return proto.EnumName(WriteIntentError_Reason_name, int32(x))
}

func (x *WriteIntentError_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WriteIntentError_Reason_value, data, "WriteIntentError_Reason")
	if err != nil {
		return err
	}
	*x = WriteIntentError_Reason(value)
	return nil
}

func (WriteIntentError_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{12, 0}
}

// Reason specifies what caused the error.
// NB: reason names should be stable because they are
// exposed as rangefeed error counters.
// NB: *never* delete enum values; if retry reason needs to be retired,
// reserve reason value.
type RangeFeedRetryError_Reason int32

const (
	// The replica was removed from its store.
	RangeFeedRetryError_REASON_REPLICA_REMOVED RangeFeedRetryError_Reason = 0
	// The range was split in two.
	RangeFeedRetryError_REASON_RANGE_SPLIT RangeFeedRetryError_Reason = 1
	// The range was merged into another.
	RangeFeedRetryError_REASON_RANGE_MERGED RangeFeedRetryError_Reason = 2
	// A Raft snapshot applied on the replica.
	RangeFeedRetryError_REASON_RAFT_SNAPSHOT RangeFeedRetryError_Reason = 3
	// A Raft command was missing a logical operation log.
	RangeFeedRetryError_REASON_LOGICAL_OPS_MISSING RangeFeedRetryError_Reason = 4
	// The consumer was processing events too slowly to keep up with live raft
	// events.
	RangeFeedRetryError_REASON_SLOW_CONSUMER RangeFeedRetryError_Reason = 5
	// No leaseholder exists or could be created, so closed timestamps won't be emitted.
	RangeFeedRetryError_REASON_NO_LEASEHOLDER RangeFeedRetryError_Reason = 6
	// Replica decided that rangefeed is no longer used and closed it. This
	// should not happen unless it was explicitly requested by client and in
	// that case client is free not to retry.
	RangeFeedRetryError_REASON_RANGEFEED_CLOSED RangeFeedRetryError_Reason = 7
	// The range was manually split in two.
	RangeFeedRetryError_REASON_MANUAL_RANGE_SPLIT RangeFeedRetryError_Reason = 8
)

var RangeFeedRetryError_Reason_name = map[int32]string{
	0: "REASON_REPLICA_REMOVED",
	1: "REASON_RANGE_SPLIT",
	2: "REASON_RANGE_MERGED",
	3: "REASON_RAFT_SNAPSHOT",
	4: "REASON_LOGICAL_OPS_MISSING",
	5: "REASON_SLOW_CONSUMER",
	6: "REASON_NO_LEASEHOLDER",
	7: "REASON_RANGEFEED_CLOSED",
	8: "REASON_MANUAL_RANGE_SPLIT",
}

var RangeFeedRetryError_Reason_value = map[string]int32{
	"REASON_REPLICA_REMOVED":     0,
	"REASON_RANGE_SPLIT":         1,
	"REASON_RANGE_MERGED":        2,
	"REASON_RAFT_SNAPSHOT":       3,
	"REASON_LOGICAL_OPS_MISSING": 4,
	"REASON_SLOW_CONSUMER":       5,
	"REASON_NO_LEASEHOLDER":      6,
	"REASON_RANGEFEED_CLOSED":    7,
	"REASON_MANUAL_RANGE_SPLIT":  8,
}

func (x RangeFeedRetryError_Reason) Enum() *RangeFeedRetryError_Reason {
	p := new(RangeFeedRetryError_Reason)
	*p = x
	return p
}

func (x RangeFeedRetryError_Reason) String() string {
	return proto.EnumName(RangeFeedRetryError_Reason_name, int32(x))
}

func (x *RangeFeedRetryError_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RangeFeedRetryError_Reason_value, data, "RangeFeedRetryError_Reason")
	if err != nil {
		return err
	}
	*x = RangeFeedRetryError_Reason(value)
	return nil
}

func (RangeFeedRetryError_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{32, 0}
}

type RefreshFailedError_Reason int32

const (
	RefreshFailedError_REASON_COMMITTED_VALUE RefreshFailedError_Reason = 0
	RefreshFailedError_REASON_INTENT          RefreshFailedError_Reason = 1
)

var RefreshFailedError_Reason_name = map[int32]string{
	0: "REASON_COMMITTED_VALUE",
	1: "REASON_INTENT",
}

var RefreshFailedError_Reason_value = map[string]int32{
	"REASON_COMMITTED_VALUE": 0,
	"REASON_INTENT":          1,
}

func (x RefreshFailedError_Reason) Enum() *RefreshFailedError_Reason {
	p := new(RefreshFailedError_Reason)
	*p = x
	return p
}

func (x RefreshFailedError_Reason) String() string {
	return proto.EnumName(RefreshFailedError_Reason_name, int32(x))
}

func (x *RefreshFailedError_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RefreshFailedError_Reason_value, data, "RefreshFailedError_Reason")
	if err != nil {
		return err
	}
	*x = RefreshFailedError_Reason(value)
	return nil
}

func (RefreshFailedError_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{37, 0}
}

// A NotLeaseHolderError indicates that the current range is not the lease
// holder. If the lease holder is known, its Replica is set in the error.
type NotLeaseHolderError struct {
	// The replica the error originated from. Used in the error's string
	// representation, if known.
	Replica roachpb.ReplicaDescriptor `protobuf:"bytes,1,opt,name=replica" json:"replica"`
	// The current lease, if known.
	//
	// It's possible for leases returned here to represent speculative leases, not
	// actual committed leases. In this case, the lease will not have its Sequence
	// set.
	Lease   *roachpb.Lease                                       `protobuf:"bytes,4,opt,name=lease" json:"lease,omitempty"`
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,3,opt,name=range_id,json=rangeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id"`
	// The range descriptor from the replica the error originated from.
	// The generation of the descriptor is used by the DistSender's RangeCache to
	// determine whether the error was returned because the replica had a stale
	// understanding of who the leaseholder is.
	RangeDesc roachpb.RangeDescriptor `protobuf:"bytes,6,opt,name=range_desc,json=rangeDesc" json:"range_desc"`
	// If set, the Error() method will return this instead of composing its
	// regular spiel. Useful because we reuse this error when rejecting a command
	// because the lease under which its application was attempted is different
	// than the lease under which it had been proposed.
	CustomMsg string `protobuf:"bytes,5,opt,name=custom_msg,json=customMsg" json:"custom_msg"`
}

func (m *NotLeaseHolderError) Reset()         { *m = NotLeaseHolderError{} }
func (m *NotLeaseHolderError) String() string { return proto.CompactTextString(m) }
func (*NotLeaseHolderError) ProtoMessage()    {}
func (*NotLeaseHolderError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{0}
}
func (m *NotLeaseHolderError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotLeaseHolderError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotLeaseHolderError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotLeaseHolderError.Merge(m, src)
}
func (m *NotLeaseHolderError) XXX_Size() int {
	return m.Size()
}
func (m *NotLeaseHolderError) XXX_DiscardUnknown() {
	xxx_messageInfo_NotLeaseHolderError.DiscardUnknown(m)
}

var xxx_messageInfo_NotLeaseHolderError proto.InternalMessageInfo

// A NodeUnavailableError indicates that the sending gateway can
// not process requests at the time, and that the client should
// retry the request with another peer.
type NodeUnavailableError struct {
}

func (m *NodeUnavailableError) Reset()         { *m = NodeUnavailableError{} }
func (m *NodeUnavailableError) String() string { return proto.CompactTextString(m) }
func (*NodeUnavailableError) ProtoMessage()    {}
func (*NodeUnavailableError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{1}
}
func (m *NodeUnavailableError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeUnavailableError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeUnavailableError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeUnavailableError.Merge(m, src)
}
func (m *NodeUnavailableError) XXX_Size() int {
	return m.Size()
}
func (m *NodeUnavailableError) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeUnavailableError.DiscardUnknown(m)
}

var xxx_messageInfo_NodeUnavailableError proto.InternalMessageInfo

// A NodeDecommissionedError is returned when trying to connect from or to a
// peer that is known to have been decommissioned.
type NodeDecommissionedError struct {
}

func (m *NodeDecommissionedError) Reset()         { *m = NodeDecommissionedError{} }
func (m *NodeDecommissionedError) String() string { return proto.CompactTextString(m) }
func (*NodeDecommissionedError) ProtoMessage()    {}
func (*NodeDecommissionedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{2}
}
func (m *NodeDecommissionedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeDecommissionedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeDecommissionedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeDecommissionedError.Merge(m, src)
}
func (m *NodeDecommissionedError) XXX_Size() int {
	return m.Size()
}
func (m *NodeDecommissionedError) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeDecommissionedError.DiscardUnknown(m)
}

var xxx_messageInfo_NodeDecommissionedError proto.InternalMessageInfo

// An UnsupportedRequestError indicates that the recipient node
// does not know how to handle the type of request received.
type UnsupportedRequestError struct {
}

func (m *UnsupportedRequestError) Reset()         { *m = UnsupportedRequestError{} }
func (m *UnsupportedRequestError) String() string { return proto.CompactTextString(m) }
func (*UnsupportedRequestError) ProtoMessage()    {}
func (*UnsupportedRequestError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{3}
}
func (m *UnsupportedRequestError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsupportedRequestError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UnsupportedRequestError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsupportedRequestError.Merge(m, src)
}
func (m *UnsupportedRequestError) XXX_Size() int {
	return m.Size()
}
func (m *UnsupportedRequestError) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsupportedRequestError.DiscardUnknown(m)
}

var xxx_messageInfo_UnsupportedRequestError proto.InternalMessageInfo

// A RangeNotFoundError indicates that a command was sent to a range
// which is not hosted on this store.
type RangeNotFoundError struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id"`
	// store_id is nonzero only if the error originated on a Store.
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,2,opt,name=store_id,json=storeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id"`
}

func (m *RangeNotFoundError) Reset()         { *m = RangeNotFoundError{} }
func (m *RangeNotFoundError) String() string { return proto.CompactTextString(m) }
func (*RangeNotFoundError) ProtoMessage()    {}
func (*RangeNotFoundError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{4}
}
func (m *RangeNotFoundError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeNotFoundError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeNotFoundError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeNotFoundError.Merge(m, src)
}
func (m *RangeNotFoundError) XXX_Size() int {
	return m.Size()
}
func (m *RangeNotFoundError) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeNotFoundError.DiscardUnknown(m)
}

var xxx_messageInfo_RangeNotFoundError proto.InternalMessageInfo

// A RangeKeyMismatchError indicates that a command was sent to a
// range which did not contain the key(s) specified by the command.
type RangeKeyMismatchError struct {
	RequestStartKey github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=request_start_key,json=requestStartKey,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"request_start_key,omitempty"`
	RequestEndKey   github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=request_end_key,json=requestEndKey,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"request_end_key,omitempty"`
	// Ranges contains information intended for the client's range cache. The
	// server populates it with info on the range with the ID addressed by the
	// client (always the first in the array) and then all other ranges
	// overlapping the requested key range, or in between the addressed range and
	// the requested key range.
	//
	// The slice should always have a length of at least 1. However, users should
	// call MismatchedRange instead of relying on this in cases where they require
	// at least one entry.
	Ranges []roachpb.RangeInfo `protobuf:"bytes,5,rep,name=ranges" json:"ranges"`
}

func (m *RangeKeyMismatchError) Reset()         { *m = RangeKeyMismatchError{} }
func (m *RangeKeyMismatchError) String() string { return proto.CompactTextString(m) }
func (*RangeKeyMismatchError) ProtoMessage()    {}
func (*RangeKeyMismatchError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{5}
}
func (m *RangeKeyMismatchError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeKeyMismatchError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeKeyMismatchError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeKeyMismatchError.Merge(m, src)
}
func (m *RangeKeyMismatchError) XXX_Size() int {
	return m.Size()
}
func (m *RangeKeyMismatchError) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeKeyMismatchError.DiscardUnknown(m)
}

var xxx_messageInfo_RangeKeyMismatchError proto.InternalMessageInfo

// A ReadWithinUncertaintyIntervalError indicates that a read at timestamp
// encountered a write within the uncertainty interval of the reader.
// The read should be retried at a higher timestamp; the timestamps contained
// within are purely informational, though typically value_timestamp is a
// lower bound for a new timestamp at which at least the read producing
// this error would succeed on retry.
type ReadWithinUncertaintyIntervalError struct {
	// Information about the reader.
	ReadTimestamp          hlc.Timestamp                                                `protobuf:"bytes,1,opt,name=read_timestamp,json=readTimestamp" json:"read_timestamp"`
	LocalUncertaintyLimit  github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=local_uncertainty_limit,json=localUncertaintyLimit,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"local_uncertainty_limit"`
	GlobalUncertaintyLimit hlc.Timestamp                                                `protobuf:"bytes,3,opt,name=global_uncertainty_limit,json=globalUncertaintyLimit" json:"global_uncertainty_limit"`
	ObservedTimestamps     []roachpb.ObservedTimestamp                                  `protobuf:"bytes,4,rep,name=observed_timestamps,json=observedTimestamps" json:"observed_timestamps"`
	// Information about the uncertain value.
	ValueTimestamp hlc.Timestamp                                                `protobuf:"bytes,2,opt,name=value_timestamp,json=valueTimestamp" json:"value_timestamp"`
	LocalTimestamp github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,6,opt,name=local_timestamp,json=localTimestamp,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"local_timestamp"`
}

func (m *ReadWithinUncertaintyIntervalError) Reset()      { *m = ReadWithinUncertaintyIntervalError{} }
func (*ReadWithinUncertaintyIntervalError) ProtoMessage() {}
func (*ReadWithinUncertaintyIntervalError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{6}
}
func (m *ReadWithinUncertaintyIntervalError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadWithinUncertaintyIntervalError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadWithinUncertaintyIntervalError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadWithinUncertaintyIntervalError.Merge(m, src)
}
func (m *ReadWithinUncertaintyIntervalError) XXX_Size() int {
	return m.Size()
}
func (m *ReadWithinUncertaintyIntervalError) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadWithinUncertaintyIntervalError.DiscardUnknown(m)
}

var xxx_messageInfo_ReadWithinUncertaintyIntervalError proto.InternalMessageInfo

// A TransactionAbortedError indicates that the client should retry the
// transaction (and use a different txn id, as opposed to
// TransactionRetryError). This most often happens when the transaction was
// aborted by another concurrent transaction. Upon seeing this error, the client
// is supposed to reset its Transaction proto and try the transaction again.
//
// In contrast with other errors, the Transaction that the client gets in the
// pErr carrying this ErrorDetail is not supposed to be used as is by the
// client; the ID should be checked and then attributes like the timestamp
// should be used in creating a new txn.
type TransactionAbortedError struct {
	Reason TransactionAbortedReason `protobuf:"varint,1,opt,name=reason,enum=cockroach.kv.kvpb.TransactionAbortedReason" json:"reason"`
}

func (m *TransactionAbortedError) Reset()         { *m = TransactionAbortedError{} }
func (m *TransactionAbortedError) String() string { return proto.CompactTextString(m) }
func (*TransactionAbortedError) ProtoMessage()    {}
func (*TransactionAbortedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{7}
}
func (m *TransactionAbortedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionAbortedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionAbortedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionAbortedError.Merge(m, src)
}
func (m *TransactionAbortedError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionAbortedError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionAbortedError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionAbortedError proto.InternalMessageInfo

// A TransactionPushError indicates that the transaction could not
// continue because it encountered a write intent from another
// transaction which it was unable to push.
type TransactionPushError struct {
	PusheeTxn roachpb.Transaction `protobuf:"bytes,1,opt,name=pushee_txn,json=pusheeTxn" json:"pushee_txn"`
}

func (m *TransactionPushError) Reset()         { *m = TransactionPushError{} }
func (m *TransactionPushError) String() string { return proto.CompactTextString(m) }
func (*TransactionPushError) ProtoMessage()    {}
func (*TransactionPushError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{8}
}
func (m *TransactionPushError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPushError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionPushError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPushError.Merge(m, src)
}
func (m *TransactionPushError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPushError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPushError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPushError proto.InternalMessageInfo

// A TransactionRetryError indicates that the transaction must be
// retried, usually with an increased transaction timestamp.
type TransactionRetryError struct {
	Reason TransactionRetryReason `protobuf:"varint,1,opt,name=reason,enum=cockroach.kv.kvpb.TransactionRetryReason" json:"reason"`
	// Note: Deprecated. `extra_msg_redactable` takes precedence if present.
	// Both fields will be populated in 23.1.
	// TODO(davidh): Remove in 23.2
	ExtraMsg           string                                         `protobuf:"bytes,2,opt,name=extra_msg,json=extraMsg" json:"extra_msg"`
	ExtraMsgRedactable github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,3,opt,name=extra_msg_redactable,json=extraMsgRedactable,customtype=github.com/cockroachdb/redact.RedactableString" json:"extra_msg_redactable"`
	// The conflicting transaction's TxnMeta. This is bubbled up from a
	// RefreshFailedError. This field is only set if the retry error is
	// constructed in response to a RefreshFailedError. In all other cases, or if
	// the RefreshFailedError does not contain conflicting transaction
	// information, this field is unset.
	ConflictingTxn *enginepb.TxnMeta `protobuf:"bytes,4,opt,name=conflicting_txn,json=conflictingTxn" json:"conflicting_txn,omitempty"`
}

func (m *TransactionRetryError) Reset()         { *m = TransactionRetryError{} }
func (m *TransactionRetryError) String() string { return proto.CompactTextString(m) }
func (*TransactionRetryError) ProtoMessage()    {}
func (*TransactionRetryError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{9}
}
func (m *TransactionRetryError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionRetryError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionRetryError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRetryError.Merge(m, src)
}
func (m *TransactionRetryError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionRetryError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRetryError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRetryError proto.InternalMessageInfo

// A TransactionStatusError indicates that the transaction status is
// incompatible with the requested operation. This might mean the
// transaction has already been committed. It might also be the case
// that the request to modify the transaction failed due to a
// regression in transaction epoch or timestamp, both of which may
// only monotonically increase.
type TransactionStatusError struct {
	// Note: Deprecated. `msg_redactable` takes precedence if present.
	// Both fields will be populated in 23.1.
	// TODO(davidh): Remove in 23.2
	Msg           string                                         `protobuf:"bytes,1,opt,name=msg" json:"msg"`
	Reason        TransactionStatusError_Reason                  `protobuf:"varint,2,opt,name=reason,enum=cockroach.kv.kvpb.TransactionStatusError_Reason" json:"reason"`
	MsgRedactable github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,3,opt,name=msg_redactable,json=msgRedactable,customtype=github.com/cockroachdb/redact.RedactableString" json:"msg_redactable"`
}

func (m *TransactionStatusError) Reset()         { *m = TransactionStatusError{} }
func (m *TransactionStatusError) String() string { return proto.CompactTextString(m) }
func (*TransactionStatusError) ProtoMessage()    {}
func (*TransactionStatusError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{10}
}
func (m *TransactionStatusError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionStatusError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionStatusError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionStatusError.Merge(m, src)
}
func (m *TransactionStatusError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionStatusError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionStatusError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionStatusError proto.InternalMessageInfo

// A LockConflictError indicates that one or more locks belonging to
// another transaction were encountered, leading to a read/write or
// write/write lock conflict which prevented kvserver-local request
// evaluation from completing. The keys at which the locks were
// encountered are set, as are the txn metas for the locks'
// transactions.
//
// LockConflictErrors are returned from MVCC during request evaluation
// when a request finds a conflicting lock. A LockConflictError is
// propagated up through the Replica to the corresponding lock table and
// passed to its AddDiscoveredLock method. This informs the lock table
// about the lock(s) and allows the request to handle the conflicts
// through a combination of waiting and pushing in the concurrency
// manager. See concurrency_control.go for an explanation and diagram of
// the flow.
//
// Unlike WriteIntentError, LockConflictError is never returned from the
// kvserver. Instead, it is only used internally by concurrency control.
type LockConflictError struct {
	Locks []roachpb.Lock `protobuf:"bytes,1,rep,name=locks" json:"locks"`
	// The sequence of the lease that the operation which hit this error was
	// operating under. Used on the server to avoid adding discovered locks
	// which were discovered under old leases to the lock table.
	LeaseSequence github_com_cockroachdb_cockroach_pkg_roachpb.LeaseSequence `protobuf:"varint,3,opt,name=lease_sequence,json=leaseSequence,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.LeaseSequence" json:"lease_sequence"`
}

func (m *LockConflictError) Reset()         { *m = LockConflictError{} }
func (m *LockConflictError) String() string { return proto.CompactTextString(m) }
func (*LockConflictError) ProtoMessage()    {}
func (*LockConflictError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{11}
}
func (m *LockConflictError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockConflictError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockConflictError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockConflictError.Merge(m, src)
}
func (m *LockConflictError) XXX_Size() int {
	return m.Size()
}
func (m *LockConflictError) XXX_DiscardUnknown() {
	xxx_messageInfo_LockConflictError.DiscardUnknown(m)
}

var xxx_messageInfo_LockConflictError proto.InternalMessageInfo

// A WriteIntentError indicates that one or more locks belonging to
// another transaction were encountered, leading to a read/write or
// write/write lock conflict which prevented the kvserver from handling
// a request and returning a response to the kvclient. The keys at which
// the locks were encountered are set, as are the txn metas for the
// locks' transactions.
//
// WriteIntentErrors are returned from the concurrency manager to the
// kvclient for intents/locks that conflict with a request and are not
// handled by the kvserver. This is typically because the request was
// configured with an Error wait policy instead of a Block wait policy,
// so it is opting to fail fast on conflicting locks instead of waiting
// for a lock to be released. Alternatively, the error may be because of
// a lock timeout or a lock wait-queue length limit. These errors make
// their way back up from KV to SQL, where they are converted to a
// LockNotAvailable error.
//
// Note that the KV client is free to send more requests after a
// WriteIntentError. This is not generally allowed after other errors
// because of fears over the ambiguity of the side-effects of failed
// requests (in particular, the timestamps at which intents might have
// been written). WriteIntentError is a special case as we ensure
// there's no ambiguity; the error carries a WriteTimestamp that's the
// upper bound of the timestamps intents were written at.
//
// NOTE: the name of the error refers to "intents", but the error is
// returned for any conflicting lock, regardless of locking strength.
// The naming is an artifact of a time when intents were the only form
// of lock, and renames have proven difficult (see #113271). One day
// we'll be smart enough to pull it off.
type WriteIntentError struct {
	Locks []roachpb.Lock `protobuf:"bytes,1,rep,name=locks" json:"locks"`
	// The reason for the error.
	Reason WriteIntentError_Reason `protobuf:"varint,4,opt,name=reason,enum=cockroach.kv.kvpb.WriteIntentError_Reason" json:"reason"`
}

func (m *WriteIntentError) Reset()         { *m = WriteIntentError{} }
func (m *WriteIntentError) String() string { return proto.CompactTextString(m) }
func (*WriteIntentError) ProtoMessage()    {}
func (*WriteIntentError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{12}
}
func (m *WriteIntentError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteIntentError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WriteIntentError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteIntentError.Merge(m, src)
}
func (m *WriteIntentError) XXX_Size() int {
	return m.Size()
}
func (m *WriteIntentError) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteIntentError.DiscardUnknown(m)
}

var xxx_messageInfo_WriteIntentError proto.InternalMessageInfo

// A WriteTooOldError indicates that a write encountered a versioned
// value newer than its timestamp, making it impossible to rewrite
// history. The write must instead be done at or later than actual
// timestamp, which is the timestamp of the existing version+1.
type WriteTooOldError struct {
	Timestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	// TODO(nvanbenschoten): now that WriteTooOld errors no longer accompany
	// successful writes, this name is confusing. Rename the field.
	ActualTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=actual_timestamp,json=actualTimestamp" json:"actual_timestamp"`
	// One of the keys at which this error was encountered. There's
	// no need to return new WriteTooOldErrors for each colliding key; the key
	// is just present for investigation / logging purposes, and is not expected
	// to be used in any transaction logic. As a result, it's not even necessary
	// for this key to be at actual_timestamp; it could be at any timestamp in
	// between timestamp and actual_timestamp.
	Key github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,3,opt,name=key,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
}

func (m *WriteTooOldError) Reset()         { *m = WriteTooOldError{} }
func (m *WriteTooOldError) String() string { return proto.CompactTextString(m) }
func (*WriteTooOldError) ProtoMessage()    {}
func (*WriteTooOldError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{13}
}
func (m *WriteTooOldError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteTooOldError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WriteTooOldError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteTooOldError.Merge(m, src)
}
func (m *WriteTooOldError) XXX_Size() int {
	return m.Size()
}
func (m *WriteTooOldError) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteTooOldError.DiscardUnknown(m)
}

var xxx_messageInfo_WriteTooOldError proto.InternalMessageInfo

// An OpRequiresTxnError indicates that a command required to be
// carried out in a transactional context but was not.
// For example, a Scan which spans ranges requires a transaction.
// The operation should be retried inside of a transaction.
type OpRequiresTxnError struct {
}

func (m *OpRequiresTxnError) Reset()         { *m = OpRequiresTxnError{} }
func (m *OpRequiresTxnError) String() string { return proto.CompactTextString(m) }
func (*OpRequiresTxnError) ProtoMessage()    {}
func (*OpRequiresTxnError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{14}
}
func (m *OpRequiresTxnError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpRequiresTxnError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OpRequiresTxnError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpRequiresTxnError.Merge(m, src)
}
func (m *OpRequiresTxnError) XXX_Size() int {
	return m.Size()
}
func (m *OpRequiresTxnError) XXX_DiscardUnknown() {
	xxx_messageInfo_OpRequiresTxnError.DiscardUnknown(m)
}

var xxx_messageInfo_OpRequiresTxnError proto.InternalMessageInfo

// A ConditionFailedError indicates that the expected value
// of a ConditionalPutRequest was not found, either
// because it was missing or was not equal. The error will
// contain the actual value found.
type ConditionFailedError struct {
	ActualValue *roachpb.Value `protobuf:"bytes,1,opt,name=actual_value,json=actualValue" json:"actual_value,omitempty"`
	// HadNewerOriginTimestamp is returned when an OriginTimestamp was
	// sent in the conditional put, the origin timestamp was newer than
	// the existing value's "comparison timestamp" (see comment for
	// OriginTimestampOlderThan) but the expected value was
	// mismatched. The caller may choose to try again using the returned
	// ActualValue as the expected value.
	HadNewerOriginTimestamp bool `protobuf:"varint,2,opt,name=had_newer_origin_timestamp,json=hadNewerOriginTimestamp" json:"had_newer_origin_timestamp"`
	// OriginTimestampOlderThan is returned when an OriginTimestamp was
	// sent in the conditional put and it was older than the existing
	// value's OriginTimestamp (if it exists) or MVCC timestamp.
	//
	// See the comment on the OriginTimestamp field of
	// kvpb.ConditionalPutRequest for more details.
	OriginTimestampOlderThan hlc.Timestamp `protobuf:"bytes,3,opt,name=origin_timestamp_older_than,json=originTimestampOlderThan" json:"origin_timestamp_older_than"`
}

func (m *ConditionFailedError) Reset()         { *m = ConditionFailedError{} }
func (m *ConditionFailedError) String() string { return proto.CompactTextString(m) }
func (*ConditionFailedError) ProtoMessage()    {}
func (*ConditionFailedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{15}
}
func (m *ConditionFailedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionFailedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionFailedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionFailedError.Merge(m, src)
}
func (m *ConditionFailedError) XXX_Size() int {
	return m.Size()
}
func (m *ConditionFailedError) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionFailedError.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionFailedError proto.InternalMessageInfo

// A LeaseRejectedError indicates that the requested replica could
// not acquire the desired lease because of an existing range lease.
type LeaseRejectedError struct {
	Message   string        `protobuf:"bytes,1,opt,name=message" json:"message"`
	Requested roachpb.Lease `protobuf:"bytes,2,opt,name=requested" json:"requested"`
	Existing  roachpb.Lease `protobuf:"bytes,3,opt,name=existing" json:"existing"`
}

func (m *LeaseRejectedError) Reset()         { *m = LeaseRejectedError{} }
func (m *LeaseRejectedError) String() string { return proto.CompactTextString(m) }
func (*LeaseRejectedError) ProtoMessage()    {}
func (*LeaseRejectedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{16}
}
func (m *LeaseRejectedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseRejectedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeaseRejectedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseRejectedError.Merge(m, src)
}
func (m *LeaseRejectedError) XXX_Size() int {
	return m.Size()
}
func (m *LeaseRejectedError) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseRejectedError.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseRejectedError proto.InternalMessageInfo

// An AmbiguousResultError indicates that a request may have succeeded or
// failed, but the response was not received and the final result is ambiguous.
type AmbiguousResultError struct {
	// The error that caused the ambiguous result.
	EncodedError errorspb.EncodedError `protobuf:"bytes,3,opt,name=encoded_error,json=encodedError" json:"encoded_error"`
}

func (m *AmbiguousResultError) Reset()         { *m = AmbiguousResultError{} }
func (m *AmbiguousResultError) String() string { return proto.CompactTextString(m) }
func (*AmbiguousResultError) ProtoMessage()    {}
func (*AmbiguousResultError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{17}
}
func (m *AmbiguousResultError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AmbiguousResultError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AmbiguousResultError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmbiguousResultError.Merge(m, src)
}
func (m *AmbiguousResultError) XXX_Size() int {
	return m.Size()
}
func (m *AmbiguousResultError) XXX_DiscardUnknown() {
	xxx_messageInfo_AmbiguousResultError.DiscardUnknown(m)
}

var xxx_messageInfo_AmbiguousResultError proto.InternalMessageInfo

// A ProxyFailedError is used to transmit a send error over the wire between a
// proxy node and its final destination. The originator needs to handle
// different types of SendErrors differently depending on both the type of the
// error (specifically whether the error happened after the request started but
// before we received a response) and the type of request (specifically whether
// the request included a commit).
type ProxyFailedError struct {
	// The error that caused the proxy failure.
	Cause errorspb.EncodedError `protobuf:"bytes,1,opt,name=cause" json:"cause"`
}

func (m *ProxyFailedError) Reset()         { *m = ProxyFailedError{} }
func (m *ProxyFailedError) String() string { return proto.CompactTextString(m) }
func (*ProxyFailedError) ProtoMessage()    {}
func (*ProxyFailedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{18}
}
func (m *ProxyFailedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyFailedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProxyFailedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyFailedError.Merge(m, src)
}
func (m *ProxyFailedError) XXX_Size() int {
	return m.Size()
}
func (m *ProxyFailedError) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyFailedError.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyFailedError proto.InternalMessageInfo

type ReplicaUnavailableError struct {
	Desc    roachpb.RangeDescriptor   `protobuf:"bytes,2,opt,name=desc" json:"desc"`
	Replica roachpb.ReplicaDescriptor `protobuf:"bytes,4,opt,name=replica" json:"replica"`
	Cause   errorspb.EncodedError     `protobuf:"bytes,5,opt,name=cause" json:"cause"`
}

func (m *ReplicaUnavailableError) Reset()         { *m = ReplicaUnavailableError{} }
func (m *ReplicaUnavailableError) String() string { return proto.CompactTextString(m) }
func (*ReplicaUnavailableError) ProtoMessage()    {}
func (*ReplicaUnavailableError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{19}
}
func (m *ReplicaUnavailableError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaUnavailableError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaUnavailableError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaUnavailableError.Merge(m, src)
}
func (m *ReplicaUnavailableError) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaUnavailableError) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaUnavailableError.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaUnavailableError proto.InternalMessageInfo

// A RaftGroupDeletedError indicates a raft group has been deleted for
// the replica.
type RaftGroupDeletedError struct {
}

func (m *RaftGroupDeletedError) Reset()         { *m = RaftGroupDeletedError{} }
func (m *RaftGroupDeletedError) String() string { return proto.CompactTextString(m) }
func (*RaftGroupDeletedError) ProtoMessage()    {}
func (*RaftGroupDeletedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{20}
}
func (m *RaftGroupDeletedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftGroupDeletedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftGroupDeletedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftGroupDeletedError.Merge(m, src)
}
func (m *RaftGroupDeletedError) XXX_Size() int {
	return m.Size()
}
func (m *RaftGroupDeletedError) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftGroupDeletedError.DiscardUnknown(m)
}

var xxx_messageInfo_RaftGroupDeletedError proto.InternalMessageInfo

// A ReplicaCorruptionError indicates that the replica has experienced
// an error which puts its integrity at risk.
type ReplicaCorruptionError struct {
	ErrorMsg string `protobuf:"bytes,1,opt,name=error_msg,json=errorMsg" json:"error_msg"`
	// processed indicates that the error has been taken into account and
	// necessary steps will be taken. For now, required for testing.
	Processed bool `protobuf:"varint,2,opt,name=processed" json:"processed"`
}

func (m *ReplicaCorruptionError) Reset()         { *m = ReplicaCorruptionError{} }
func (m *ReplicaCorruptionError) String() string { return proto.CompactTextString(m) }
func (*ReplicaCorruptionError) ProtoMessage()    {}
func (*ReplicaCorruptionError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{21}
}
func (m *ReplicaCorruptionError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaCorruptionError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaCorruptionError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaCorruptionError.Merge(m, src)
}
func (m *ReplicaCorruptionError) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaCorruptionError) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaCorruptionError.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaCorruptionError proto.InternalMessageInfo

// ReplicaTooOldError is sent in response to a raft message when the
// recipient of the raft message believes the sender of the raft
// message to have been removed from the raft group
type ReplicaTooOldError struct {
	// replica_id is the ID of the replica that is too old.
	ReplicaID github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,1,opt,name=replica_id,json=replicaId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"replica_id"`
}

func (m *ReplicaTooOldError) Reset()         { *m = ReplicaTooOldError{} }
func (m *ReplicaTooOldError) String() string { return proto.CompactTextString(m) }
func (*ReplicaTooOldError) ProtoMessage()    {}
func (*ReplicaTooOldError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{22}
}
func (m *ReplicaTooOldError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaTooOldError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaTooOldError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaTooOldError.Merge(m, src)
}
func (m *ReplicaTooOldError) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaTooOldError) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaTooOldError.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaTooOldError proto.InternalMessageInfo

// A StoreNotFoundError indicates that a command was sent to a store
// which is not hosted on this node.
type StoreNotFoundError struct {
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id"`
}

func (m *StoreNotFoundError) Reset()         { *m = StoreNotFoundError{} }
func (m *StoreNotFoundError) String() string { return proto.CompactTextString(m) }
func (*StoreNotFoundError) ProtoMessage()    {}
func (*StoreNotFoundError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{23}
}
func (m *StoreNotFoundError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreNotFoundError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreNotFoundError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreNotFoundError.Merge(m, src)
}
func (m *StoreNotFoundError) XXX_Size() int {
	return m.Size()
}
func (m *StoreNotFoundError) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreNotFoundError.DiscardUnknown(m)
}

var xxx_messageInfo_StoreNotFoundError proto.InternalMessageInfo

// UnhandledRetryableError tells the recipient that a KV request must be
// retried. In case the request was transactional, the whole transaction needs
// to be retried. This is returned generally as a result of a transaction
// conflict.
//
// This error is generated by pErr.GoError() in case of a retryable
// error (other than TransactionRetryWithProtoRefreshError). For transactional
// requests, the TxnCoordSender handles retryable pErrs and transforms
// them into TransactionRetryWithProtoRefreshError. For non-transactional requests,
// this error will be observed by layers above the TxnCoordSender.
type UnhandledRetryableError struct {
	// The underlying storage error that is being marshaled.
	// pErr.TransactionRestart is expected to be set, and the error
	// detail is one of the retryable ones.
	PErr Error `protobuf:"bytes,1,opt,name=pErr" json:"pErr"`
}

func (m *UnhandledRetryableError) Reset()      { *m = UnhandledRetryableError{} }
func (*UnhandledRetryableError) ProtoMessage() {}
func (*UnhandledRetryableError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{24}
}
func (m *UnhandledRetryableError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnhandledRetryableError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UnhandledRetryableError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnhandledRetryableError.Merge(m, src)
}
func (m *UnhandledRetryableError) XXX_Size() int {
	return m.Size()
}
func (m *UnhandledRetryableError) XXX_DiscardUnknown() {
	xxx_messageInfo_UnhandledRetryableError.DiscardUnknown(m)
}

var xxx_messageInfo_UnhandledRetryableError proto.InternalMessageInfo

// TransactionRetryWithProtoRefreshError is an error detail representing a retryable error
// that has been "handled" by the TxnCoordSender. This error is produced by the
// TxnCoordSender and is only produced for transactional requests.
//
// It contains the final form of the Transaction proto that should be used on
// next attempts. After being produced by the TxnCoordSender, this error is
// handled first by the kv.Txn, which uses the Transaction inside to update
// its state, and then passed along to SQL in a pErr (through the
// client.Sender() interface).
type TransactionRetryWithProtoRefreshError struct {
	// A user-readable message.
	// Note: Deprecated in favor of `msg_redactable` below. Both fields will be
	// populated in 23.1. Presence of `msg_redactable` will take precedence.
	// TODO(davidh): Remove in 23.2
	Msg string `protobuf:"bytes,1,opt,name=msg" json:"msg"`
	// The ID of the transaction being retried. The client can compare this ID
	// that of the new transaction (below) to check whether the transaction was
	// aborted and will restart from the beginning with a new identity.
	PrevTxnID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,2,opt,name=prev_txn_id,json=prevTxnId,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"prev_txn_id"`
	// The epoch of the transaction being retried. The client can compare this
	// epoch that of the new transaction (below) to check whether the transaction
	// is being restarted from the beginning with all writes discarded.
	PrevTxnEpoch github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnEpoch `protobuf:"varint,5,opt,name=prev_txn_epoch,json=prevTxnEpoch,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnEpoch" json:"prev_txn_epoch"`
	// The Transaction that should be used by next attempts. Depending on the
	// original cause of this method and the isolation level of the transaction,
	// this can be:
	//
	// - the same Transaction as before (same ID), but with an incremented epoch
	// and read timestamp. The transaction must start again from the beginning,
	// with all writes discarded. This case applies to isolation levels that do
	// not use a per-statement read snapshot, and must therefore start from the
	// beginning if the read snapshot must be adjusted.
	//
	// - the same Transaction as before (same ID) with the same epoch as before,
	// but with an incremented read timestamp. The transaction can proceed without
	// the loss of any of its writes, although clients may employ savepoints to
	// selectively discard the writes from the read snapshot scope (i.e. the
	// statement) being retried. This case applies to isolation levels that use a
	// per-statement read snapshot, and can therefore retry select portions of the
	// transaction if the read snapshot must be adjusted, without starting from
	// the beginning.
	//
	// - a completely new Transaction (different ID). The transaction must start
	// again from the beginning with all writes discarded and with a new identity.
	// This case applies to all isolation levels. Transaction aborts are typically
	// associated with locking deadlocks where the previous transaction's locks
	// were discarded to break a deadlock between transactions and also with cases
	// where the kv layer determines that it has lost information cannot process a
	// certain transaction.
	NextTransaction roachpb.Transaction `protobuf:"bytes,3,opt,name=next_transaction,json=nextTransaction" json:"next_transaction"`
	// A user-readable message containing redaction markers.
	MsgRedactable github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,4,opt,name=msg_redactable,json=msgRedactable,customtype=github.com/cockroachdb/redact.RedactableString" json:"msg_redactable"`
	// The conflicting transaction's TxnMeta. This field is bubbled up from a
	// RefreshFailedError. This field is only set when a
	// TransactionRetryWithProtoRefreshError is constructed in response to a
	// RefreshFailedError which includes information about the conflicting
	// transaction that caused the refresh to fail. In all other cases this field
	// is unset
	ConflictingTxn *enginepb.TxnMeta `protobuf:"bytes,6,opt,name=conflicting_txn,json=conflictingTxn" json:"conflicting_txn,omitempty"`
}

func (m *TransactionRetryWithProtoRefreshError) Reset()         { *m = TransactionRetryWithProtoRefreshError{} }
func (m *TransactionRetryWithProtoRefreshError) String() string { return proto.CompactTextString(m) }
func (*TransactionRetryWithProtoRefreshError) ProtoMessage()    {}
func (*TransactionRetryWithProtoRefreshError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{25}
}
func (m *TransactionRetryWithProtoRefreshError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionRetryWithProtoRefreshError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionRetryWithProtoRefreshError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRetryWithProtoRefreshError.Merge(m, src)
}
func (m *TransactionRetryWithProtoRefreshError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionRetryWithProtoRefreshError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRetryWithProtoRefreshError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRetryWithProtoRefreshError proto.InternalMessageInfo

// TxnAlreadyEncounteredErrorError indicates that an operation tried to use a
// transaction that already received an error from a previous request. Once that
// happens, kv.Txn rejects future requests.
type TxnAlreadyEncounteredErrorError struct {
	// prev_error is the message from the error that the txn encountered
	// previously.
	PrevError github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,1,opt,name=prev_error,json=prevError,customtype=github.com/cockroachdb/redact.RedactableString" json:"prev_error"`
}

func (m *TxnAlreadyEncounteredErrorError) Reset()         { *m = TxnAlreadyEncounteredErrorError{} }
func (m *TxnAlreadyEncounteredErrorError) String() string { return proto.CompactTextString(m) }
func (*TxnAlreadyEncounteredErrorError) ProtoMessage()    {}
func (*TxnAlreadyEncounteredErrorError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{26}
}
func (m *TxnAlreadyEncounteredErrorError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnAlreadyEncounteredErrorError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TxnAlreadyEncounteredErrorError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnAlreadyEncounteredErrorError.Merge(m, src)
}
func (m *TxnAlreadyEncounteredErrorError) XXX_Size() int {
	return m.Size()
}
func (m *TxnAlreadyEncounteredErrorError) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnAlreadyEncounteredErrorError.DiscardUnknown(m)
}

var xxx_messageInfo_TxnAlreadyEncounteredErrorError proto.InternalMessageInfo

// An IntegerOverflowError indicates that an operation was aborted because
// it would have caused an integer overflow.
type IntegerOverflowError struct {
	Key            github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=key,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	CurrentValue   int64                                            `protobuf:"varint,2,opt,name=current_value,json=currentValue" json:"current_value"`
	IncrementValue int64                                            `protobuf:"varint,3,opt,name=increment_value,json=incrementValue" json:"increment_value"`
}

func (m *IntegerOverflowError) Reset()         { *m = IntegerOverflowError{} }
func (m *IntegerOverflowError) String() string { return proto.CompactTextString(m) }
func (*IntegerOverflowError) ProtoMessage()    {}
func (*IntegerOverflowError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{27}
}
func (m *IntegerOverflowError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegerOverflowError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IntegerOverflowError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegerOverflowError.Merge(m, src)
}
func (m *IntegerOverflowError) XXX_Size() int {
	return m.Size()
}
func (m *IntegerOverflowError) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegerOverflowError.DiscardUnknown(m)
}

var xxx_messageInfo_IntegerOverflowError proto.InternalMessageInfo

// A BatchTimestampBeforeGCError indicates that a request's timestamp was
// before the GC threshold.
type BatchTimestampBeforeGCError struct {
	Timestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=Timestamp" json:"Timestamp"`
	Threshold hlc.Timestamp `protobuf:"bytes,2,opt,name=Threshold" json:"Threshold"`
	// DataExcludedFromBackup is set to true if the request is targeting a range
	// that has been marked as excluded from a backup via
	// `ALTER TABLE ... SET (exclude_data_from_backup = true)`.
	DataExcludedFromBackup bool                                                 `protobuf:"varint,3,opt,name=data_excluded_from_backup,json=dataExcludedFromBackup" json:"data_excluded_from_backup"`
	RangeID                github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,4,opt,name=range_id,json=rangeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id"`
	StartKey               github_com_cockroachdb_cockroach_pkg_roachpb.Key     `protobuf:"bytes,5,opt,name=start_key,json=startKey,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"start_key,omitempty"`
	EndKey                 github_com_cockroachdb_cockroach_pkg_roachpb.Key     `protobuf:"bytes,6,opt,name=end_key,json=endKey,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"end_key,omitempty"`
}

func (m *BatchTimestampBeforeGCError) Reset()         { *m = BatchTimestampBeforeGCError{} }
func (m *BatchTimestampBeforeGCError) String() string { return proto.CompactTextString(m) }
func (*BatchTimestampBeforeGCError) ProtoMessage()    {}
func (*BatchTimestampBeforeGCError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{28}
}
func (m *BatchTimestampBeforeGCError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchTimestampBeforeGCError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchTimestampBeforeGCError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchTimestampBeforeGCError.Merge(m, src)
}
func (m *BatchTimestampBeforeGCError) XXX_Size() int {
	return m.Size()
}
func (m *BatchTimestampBeforeGCError) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchTimestampBeforeGCError.DiscardUnknown(m)
}

var xxx_messageInfo_BatchTimestampBeforeGCError proto.InternalMessageInfo

// A MVCCHistoryMutationError indicates that MVCC history was unexpectedly
// mutated.
type MVCCHistoryMutationError struct {
	Span roachpb.Span `protobuf:"bytes,1,opt,name=span" json:"span"`
}

func (m *MVCCHistoryMutationError) Reset()         { *m = MVCCHistoryMutationError{} }
func (m *MVCCHistoryMutationError) String() string { return proto.CompactTextString(m) }
func (*MVCCHistoryMutationError) ProtoMessage()    {}
func (*MVCCHistoryMutationError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{29}
}
func (m *MVCCHistoryMutationError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCHistoryMutationError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MVCCHistoryMutationError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCHistoryMutationError.Merge(m, src)
}
func (m *MVCCHistoryMutationError) XXX_Size() int {
	return m.Size()
}
func (m *MVCCHistoryMutationError) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCHistoryMutationError.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCHistoryMutationError proto.InternalMessageInfo

// An IntentMissingError indicates that a QueryIntent request expected
// an intent to be present at its specified key but the intent was
// not there.
type IntentMissingError struct {
	// The non-matching intent that was found at that key, if any.
	WrongIntent *roachpb.Lock `protobuf:"bytes,1,opt,name=wrong_intent,json=wrongIntent" json:"wrong_intent,omitempty"`
	// The key where the intent was expected.
	Key github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=key,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
}

func (m *IntentMissingError) Reset()         { *m = IntentMissingError{} }
func (m *IntentMissingError) String() string { return proto.CompactTextString(m) }
func (*IntentMissingError) ProtoMessage()    {}
func (*IntentMissingError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{30}
}
func (m *IntentMissingError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntentMissingError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IntentMissingError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntentMissingError.Merge(m, src)
}
func (m *IntentMissingError) XXX_Size() int {
	return m.Size()
}
func (m *IntentMissingError) XXX_DiscardUnknown() {
	xxx_messageInfo_IntentMissingError.DiscardUnknown(m)
}

var xxx_messageInfo_IntentMissingError proto.InternalMessageInfo

// A MergeInProgressError indicates that the request could not be completed
// because the replica is being merged into its left-hand neighbor. The request
// should be resubmitted after the merge completes.
//
// This error is handled by the Store and should not escape to higher levels.
type MergeInProgressError struct {
}

func (m *MergeInProgressError) Reset()         { *m = MergeInProgressError{} }
func (m *MergeInProgressError) String() string { return proto.CompactTextString(m) }
func (*MergeInProgressError) ProtoMessage()    {}
func (*MergeInProgressError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{31}
}
func (m *MergeInProgressError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeInProgressError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeInProgressError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeInProgressError.Merge(m, src)
}
func (m *MergeInProgressError) XXX_Size() int {
	return m.Size()
}
func (m *MergeInProgressError) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeInProgressError.DiscardUnknown(m)
}

var xxx_messageInfo_MergeInProgressError proto.InternalMessageInfo

// A RangeFeedRetryError indicates that a rangefeed was disconnected, often
// because of a range lifecycle event, and can be retried.
type RangeFeedRetryError struct {
	Reason RangeFeedRetryError_Reason `protobuf:"varint,1,opt,name=reason,enum=cockroach.kv.kvpb.RangeFeedRetryError_Reason" json:"reason"`
}

func (m *RangeFeedRetryError) Reset()         { *m = RangeFeedRetryError{} }
func (m *RangeFeedRetryError) String() string { return proto.CompactTextString(m) }
func (*RangeFeedRetryError) ProtoMessage()    {}
func (*RangeFeedRetryError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{32}
}
func (m *RangeFeedRetryError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedRetryError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedRetryError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedRetryError.Merge(m, src)
}
func (m *RangeFeedRetryError) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedRetryError) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedRetryError.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedRetryError proto.InternalMessageInfo

// A IndeterminateCommitError indicates that a transaction was encountered with
// a STAGING status. In this state, it is unclear by observing the transaction
// record alone whether the transaction should be committed or aborted. To make
// this determination, the transaction recovery process must be initiated. This
// process makes a ruling on the final state of the transaction based on the
// outcome of its in-flight writes at the time of staging.
type IndeterminateCommitError struct {
	StagingTxn roachpb.Transaction `protobuf:"bytes,1,opt,name=staging_txn,json=stagingTxn" json:"staging_txn"`
}

func (m *IndeterminateCommitError) Reset()         { *m = IndeterminateCommitError{} }
func (m *IndeterminateCommitError) String() string { return proto.CompactTextString(m) }
func (*IndeterminateCommitError) ProtoMessage()    {}
func (*IndeterminateCommitError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{33}
}
func (m *IndeterminateCommitError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndeterminateCommitError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndeterminateCommitError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndeterminateCommitError.Merge(m, src)
}
func (m *IndeterminateCommitError) XXX_Size() int {
	return m.Size()
}
func (m *IndeterminateCommitError) XXX_DiscardUnknown() {
	xxx_messageInfo_IndeterminateCommitError.DiscardUnknown(m)
}

var xxx_messageInfo_IndeterminateCommitError proto.InternalMessageInfo

// An InvalidLeaseError indicates that the request could not be completed
// because the replica does not have a valid lease. The request should be
// resubmitted on the current replica after a lease is acquired or should be
// redirected (using a NotLeaseHolderError) to the current leaseholder if one
// already exists.
//
// This error is handled by the Store and should not escape to higher levels.
type InvalidLeaseError struct {
}

func (m *InvalidLeaseError) Reset()         { *m = InvalidLeaseError{} }
func (m *InvalidLeaseError) String() string { return proto.CompactTextString(m) }
func (*InvalidLeaseError) ProtoMessage()    {}
func (*InvalidLeaseError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{34}
}
func (m *InvalidLeaseError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvalidLeaseError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InvalidLeaseError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidLeaseError.Merge(m, src)
}
func (m *InvalidLeaseError) XXX_Size() int {
	return m.Size()
}
func (m *InvalidLeaseError) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidLeaseError.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidLeaseError proto.InternalMessageInfo

// OptimisticEvalConflictsError indicates that the optimistic evaluation of a
// BatchRequest failed when checking locks or latches after evaluation. This
// is never sent over-the-wire, and is a proto only to fit the existing
// plumbing that passes a roachpb.Error.
type OptimisticEvalConflictsError struct {
}

func (m *OptimisticEvalConflictsError) Reset()         { *m = OptimisticEvalConflictsError{} }
func (m *OptimisticEvalConflictsError) String() string { return proto.CompactTextString(m) }
func (*OptimisticEvalConflictsError) ProtoMessage()    {}
func (*OptimisticEvalConflictsError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{35}
}
func (m *OptimisticEvalConflictsError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptimisticEvalConflictsError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OptimisticEvalConflictsError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptimisticEvalConflictsError.Merge(m, src)
}
func (m *OptimisticEvalConflictsError) XXX_Size() int {
	return m.Size()
}
func (m *OptimisticEvalConflictsError) XXX_DiscardUnknown() {
	xxx_messageInfo_OptimisticEvalConflictsError.DiscardUnknown(m)
}

var xxx_messageInfo_OptimisticEvalConflictsError proto.InternalMessageInfo

// MinTimestampBoundUnsatisfiableError indicates that a bounded staleness read
// could not be satisfied because the latest timestamp at which it could have
// been evaluated (the resolved timestamp over its key span) was below the
// read's minimum timestamp bound.
type MinTimestampBoundUnsatisfiableError struct {
	MinTimestampBound hlc.Timestamp `protobuf:"bytes,1,opt,name=min_timestamp_bound,json=minTimestampBound" json:"min_timestamp_bound"`
	ResolvedTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=resolved_timestamp,json=resolvedTimestamp" json:"resolved_timestamp"`
}

func (m *MinTimestampBoundUnsatisfiableError) Reset()         { *m = MinTimestampBoundUnsatisfiableError{} }
func (m *MinTimestampBoundUnsatisfiableError) String() string { return proto.CompactTextString(m) }
func (*MinTimestampBoundUnsatisfiableError) ProtoMessage()    {}
func (*MinTimestampBoundUnsatisfiableError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{36}
}
func (m *MinTimestampBoundUnsatisfiableError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinTimestampBoundUnsatisfiableError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MinTimestampBoundUnsatisfiableError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinTimestampBoundUnsatisfiableError.Merge(m, src)
}
func (m *MinTimestampBoundUnsatisfiableError) XXX_Size() int {
	return m.Size()
}
func (m *MinTimestampBoundUnsatisfiableError) XXX_DiscardUnknown() {
	xxx_messageInfo_MinTimestampBoundUnsatisfiableError.DiscardUnknown(m)
}

var xxx_messageInfo_MinTimestampBoundUnsatisfiableError proto.InternalMessageInfo

// A RefreshFailedError indicates that a refresh or a range refresh failed because
// of a recently written key or intent.
type RefreshFailedError struct {
	Reason RefreshFailedError_Reason                        `protobuf:"varint,1,opt,name=reason,enum=cockroach.kv.kvpb.RefreshFailedError_Reason" json:"reason"`
	Key    github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=key,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	// The timestamp the key was last updated.
	Timestamp hlc.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp"`
	// The conflicting transaction's TxnMeta, if available. This field is used
	// when the refresh fails with REASON_INTENT and is bubbled up for
	// observability purposes to track the conflicting transaction. This field is
	// not set if the refresh fails because of REASON_COMMITTED_VALUE.
	ConflictingTxn *enginepb.TxnMeta `protobuf:"bytes,4,opt,name=conflicting_txn,json=conflictingTxn" json:"conflicting_txn,omitempty"`
}

func (m *RefreshFailedError) Reset()         { *m = RefreshFailedError{} }
func (m *RefreshFailedError) String() string { return proto.CompactTextString(m) }
func (*RefreshFailedError) ProtoMessage()    {}
func (*RefreshFailedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{37}
}
func (m *RefreshFailedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshFailedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshFailedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshFailedError.Merge(m, src)
}
func (m *RefreshFailedError) XXX_Size() int {
	return m.Size()
}
func (m *RefreshFailedError) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshFailedError.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshFailedError proto.InternalMessageInfo

// ErrPosition describes the position of an error in a Batch. A simple nullable
// primitive field would break compatibility with proto3, where primitive fields
// are no longer allowed to be nullable.
type ErrPosition struct {
	Index int32 `protobuf:"varint,1,opt,name=index" json:"index"`
}

func (m *ErrPosition) Reset()         { *m = ErrPosition{} }
func (m *ErrPosition) String() string { return proto.CompactTextString(m) }
func (*ErrPosition) ProtoMessage()    {}
func (*ErrPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{38}
}
func (m *ErrPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ErrPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrPosition.Merge(m, src)
}
func (m *ErrPosition) XXX_Size() int {
	return m.Size()
}
func (m *ErrPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrPosition.DiscardUnknown(m)
}

var xxx_messageInfo_ErrPosition proto.InternalMessageInfo

// Error is a generic representation including a string message
// and information about retryability.
type Error struct {
	// An optional updated transaction. This is to be used by the client in case
	// of retryable errors.
	//
	// Not to be accessed directly - use Error.GetTxn() and Error.SetTxn().
	UnexposedTxn *roachpb.Transaction `protobuf:"bytes,4,opt,name=unexposed_txn,json=unexposedTxn" json:"unexposed_txn,omitempty"`
	// Node at which the error was generated (zero if does not apply).
	OriginNode github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,5,opt,name=origin_node,json=originNode,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"origin_node"`
	// encoded_error is the Go error that caused this Error.
	EncodedError errorspb.EncodedError `protobuf:"bytes,9,opt,name=encoded_error,json=encodedError" json:"encoded_error"`
	// The index, if given, contains the index of the request (in the batch)
	// whose execution caused the error.
	Index *ErrPosition `protobuf:"bytes,7,opt,name=index" json:"index,omitempty"`
	// now is the current time at the node sending the response,
	// which can be used by the receiver to update its local HLC.
	Now github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,8,opt,name=now,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"now"`
}

func (m *Error) Reset()      { *m = Error{} }
func (*Error) ProtoMessage() {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{39}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

// InsufficientSpaceError is an error due to insufficient space remaining.
type InsufficientSpaceError struct {
	// StoreID is the store that had insufficient space.
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id"`
	// Op is the operaton that was unable to be performed.
	Op string `protobuf:"bytes,2,opt,name=op" json:"op"`
	// Available is remaining capacity.
	Available int64 `protobuf:"varint,3,opt,name=available" json:"available"`
	// Capacity is total capacity.
	Capacity int64 `protobuf:"varint,4,opt,name=capacity" json:"capacity"`
	// RequiredFraction is the required remaining capacity fraction.
	Required float64 `protobuf:"fixed64,5,opt,name=required" json:"required"`
}

func (m *InsufficientSpaceError) Reset()         { *m = InsufficientSpaceError{} }
func (m *InsufficientSpaceError) String() string { return proto.CompactTextString(m) }
func (*InsufficientSpaceError) ProtoMessage()    {}
func (*InsufficientSpaceError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{40}
}
func (m *InsufficientSpaceError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsufficientSpaceError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InsufficientSpaceError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsufficientSpaceError.Merge(m, src)
}
func (m *InsufficientSpaceError) XXX_Size() int {
	return m.Size()
}
func (m *InsufficientSpaceError) XXX_DiscardUnknown() {
	xxx_messageInfo_InsufficientSpaceError.DiscardUnknown(m)
}

var xxx_messageInfo_InsufficientSpaceError proto.InternalMessageInfo

// PebbleCorruptionError indicates that pebble thinks that there is a data
// corruption.
type PebbleCorruptionError struct {
	StoreID  github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id"`
	Path     string                                               `protobuf:"bytes,2,opt,name=path" json:"path"`
	IsRemote bool                                                 `protobuf:"varint,3,opt,name=is_remote,json=isRemote" json:"is_remote"`
	ExtraMsg string                                               `protobuf:"bytes,4,opt,name=extra_msg,json=extraMsg" json:"extra_msg"`
}

func (m *PebbleCorruptionError) Reset()         { *m = PebbleCorruptionError{} }
func (m *PebbleCorruptionError) String() string { return proto.CompactTextString(m) }
func (*PebbleCorruptionError) ProtoMessage()    {}
func (*PebbleCorruptionError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{41}
}
func (m *PebbleCorruptionError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PebbleCorruptionError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PebbleCorruptionError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PebbleCorruptionError.Merge(m, src)
}
func (m *PebbleCorruptionError) XXX_Size() int {
	return m.Size()
}
func (m *PebbleCorruptionError) XXX_DiscardUnknown() {
	xxx_messageInfo_PebbleCorruptionError.DiscardUnknown(m)
}

var xxx_messageInfo_PebbleCorruptionError proto.InternalMessageInfo

// ExclusionViolationError indicates that a key was written to at a timestamp at
// which a caller assumed it had an exclusive lock on the key.
type ExclusionViolationError struct {
	// ExclusionTimestamp is the timestamp at which the request expected its
	// exclusive access started.
	ExpectedExclusionSinceTimestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=expected_exclusion_since_timestamp,json=expectedExclusionSinceTimestamp" json:"expected_exclusion_since_timestamp"`
	// ViolationTimestamp is the timestamp at which the request found a write that
	// violated its exclusive access.
	ViolationTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=violation_timestamp,json=violationTimestamp" json:"violation_timestamp"`
	// Key is the key on which exclusion was violated.
	Key github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,3,opt,name=key,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
}

func (m *ExclusionViolationError) Reset()         { *m = ExclusionViolationError{} }
func (m *ExclusionViolationError) String() string { return proto.CompactTextString(m) }
func (*ExclusionViolationError) ProtoMessage()    {}
func (*ExclusionViolationError) Descriptor() ([]byte, []int) {
	return fileDescriptor_83411c0a161f9e6d, []int{42}
}
func (m *ExclusionViolationError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExclusionViolationError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExclusionViolationError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExclusionViolationError.Merge(m, src)
}
func (m *ExclusionViolationError) XXX_Size() int {
	return m.Size()
}
func (m *ExclusionViolationError) XXX_DiscardUnknown() {
	xxx_messageInfo_ExclusionViolationError.DiscardUnknown(m)
}

var xxx_messageInfo_ExclusionViolationError proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.kv.kvpb.TransactionAbortedReason", TransactionAbortedReason_name, TransactionAbortedReason_value)
	proto.RegisterEnum("cockroach.kv.kvpb.TransactionRetryReason", TransactionRetryReason_name, TransactionRetryReason_value)
	proto.RegisterEnum("cockroach.kv.kvpb.TransactionRestart", TransactionRestart_name, TransactionRestart_value)
	proto.RegisterEnum("cockroach.kv.kvpb.TransactionStatusError_Reason", TransactionStatusError_Reason_name, TransactionStatusError_Reason_value)
	proto.RegisterEnum("cockroach.kv.kvpb.WriteIntentError_Reason", WriteIntentError_Reason_name, WriteIntentError_Reason_value)
	proto.RegisterEnum("cockroach.kv.kvpb.RangeFeedRetryError_Reason", RangeFeedRetryError_Reason_name, RangeFeedRetryError_Reason_value)
	proto.RegisterEnum("cockroach.kv.kvpb.RefreshFailedError_Reason", RefreshFailedError_Reason_name, RefreshFailedError_Reason_value)
	proto.RegisterType((*NotLeaseHolderError)(nil), "cockroach.kv.kvpb.NotLeaseHolderError")
	proto.RegisterType((*NodeUnavailableError)(nil), "cockroach.kv.kvpb.NodeUnavailableError")
	proto.RegisterType((*NodeDecommissionedError)(nil), "cockroach.kv.kvpb.NodeDecommissionedError")
	proto.RegisterType((*UnsupportedRequestError)(nil), "cockroach.kv.kvpb.UnsupportedRequestError")
	proto.RegisterType((*RangeNotFoundError)(nil), "cockroach.kv.kvpb.RangeNotFoundError")
	proto.RegisterType((*RangeKeyMismatchError)(nil), "cockroach.kv.kvpb.RangeKeyMismatchError")
	proto.RegisterType((*ReadWithinUncertaintyIntervalError)(nil), "cockroach.kv.kvpb.ReadWithinUncertaintyIntervalError")
	proto.RegisterType((*TransactionAbortedError)(nil), "cockroach.kv.kvpb.TransactionAbortedError")
	proto.RegisterType((*TransactionPushError)(nil), "cockroach.kv.kvpb.TransactionPushError")
	proto.RegisterType((*TransactionRetryError)(nil), "cockroach.kv.kvpb.TransactionRetryError")
	proto.RegisterType((*TransactionStatusError)(nil), "cockroach.kv.kvpb.TransactionStatusError")
	proto.RegisterType((*LockConflictError)(nil), "cockroach.kv.kvpb.LockConflictError")
	proto.RegisterType((*WriteIntentError)(nil), "cockroach.kv.kvpb.WriteIntentError")
	proto.RegisterType((*WriteTooOldError)(nil), "cockroach.kv.kvpb.WriteTooOldError")
	proto.RegisterType((*OpRequiresTxnError)(nil), "cockroach.kv.kvpb.OpRequiresTxnError")
	proto.RegisterType((*ConditionFailedError)(nil), "cockroach.kv.kvpb.ConditionFailedError")
	proto.RegisterType((*LeaseRejectedError)(nil), "cockroach.kv.kvpb.LeaseRejectedError")
	proto.RegisterType((*AmbiguousResultError)(nil), "cockroach.kv.kvpb.AmbiguousResultError")
	proto.RegisterType((*ProxyFailedError)(nil), "cockroach.kv.kvpb.ProxyFailedError")
	proto.RegisterType((*ReplicaUnavailableError)(nil), "cockroach.kv.kvpb.ReplicaUnavailableError")
	proto.RegisterType((*RaftGroupDeletedError)(nil), "cockroach.kv.kvpb.RaftGroupDeletedError")
	proto.RegisterType((*ReplicaCorruptionError)(nil), "cockroach.kv.kvpb.ReplicaCorruptionError")
	proto.RegisterType((*ReplicaTooOldError)(nil), "cockroach.kv.kvpb.ReplicaTooOldError")
	proto.RegisterType((*StoreNotFoundError)(nil), "cockroach.kv.kvpb.StoreNotFoundError")
	proto.RegisterType((*UnhandledRetryableError)(nil), "cockroach.kv.kvpb.UnhandledRetryableError")
	proto.RegisterType((*TransactionRetryWithProtoRefreshError)(nil), "cockroach.kv.kvpb.TransactionRetryWithProtoRefreshError")
	proto.RegisterType((*TxnAlreadyEncounteredErrorError)(nil), "cockroach.kv.kvpb.TxnAlreadyEncounteredErrorError")
	proto.RegisterType((*IntegerOverflowError)(nil), "cockroach.kv.kvpb.IntegerOverflowError")
	proto.RegisterType((*BatchTimestampBeforeGCError)(nil), "cockroach.kv.kvpb.BatchTimestampBeforeGCError")
	proto.RegisterType((*MVCCHistoryMutationError)(nil), "cockroach.kv.kvpb.MVCCHistoryMutationError")
	proto.RegisterType((*IntentMissingError)(nil), "cockroach.kv.kvpb.IntentMissingError")
	proto.RegisterType((*MergeInProgressError)(nil), "cockroach.kv.kvpb.MergeInProgressError")
	proto.RegisterType((*RangeFeedRetryError)(nil), "cockroach.kv.kvpb.RangeFeedRetryError")
	proto.RegisterType((*IndeterminateCommitError)(nil), "cockroach.kv.kvpb.IndeterminateCommitError")
	proto.RegisterType((*InvalidLeaseError)(nil), "cockroach.kv.kvpb.InvalidLeaseError")
	proto.RegisterType((*OptimisticEvalConflictsError)(nil), "cockroach.kv.kvpb.OptimisticEvalConflictsError")
	proto.RegisterType((*MinTimestampBoundUnsatisfiableError)(nil), "cockroach.kv.kvpb.MinTimestampBoundUnsatisfiableError")
	proto.RegisterType((*RefreshFailedError)(nil), "cockroach.kv.kvpb.RefreshFailedError")
	proto.RegisterType((*ErrPosition)(nil), "cockroach.kv.kvpb.ErrPosition")
	proto.RegisterType((*Error)(nil), "cockroach.kv.kvpb.Error")
	proto.RegisterType((*InsufficientSpaceError)(nil), "cockroach.kv.kvpb.InsufficientSpaceError")
	proto.RegisterType((*PebbleCorruptionError)(nil), "cockroach.kv.kvpb.PebbleCorruptionError")
	proto.RegisterType((*ExclusionViolationError)(nil), "cockroach.kv.kvpb.ExclusionViolationError")
}

func init() { proto.RegisterFile("kv/kvpb/errors.proto", fileDescriptor_83411c0a161f9e6d) }

var fileDescriptor_83411c0a161f9e6d = []byte{
	// 3123 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0x4d, 0x6c, 0xdc, 0xd6,
	0x76, 0x16, 0xe7, 0x47, 0x1a, 0x1d, 0x59, 0x32, 0x4d, 0xcb, 0xd2, 0xd8, 0x4e, 0x24, 0x87, 0x6e,
	0x50, 0xdb, 0x4d, 0x46, 0xa9, 0x1d, 0x24, 0x80, 0x63, 0xb4, 0x98, 0x1f, 0x4a, 0xa2, 0x34, 0x43,
	0x4e, 0x38, 0x1c, 0xff, 0xe4, 0x07, 0x2c, 0x87, 0xbc, 0x9a, 0x61, 0xc4, 0xe1, 0x9d, 0x92, 0x1c,
	0x79, 0xb4, 0x4b, 0x77, 0x5d, 0x74, 0xd1, 0x4d, 0x81, 0x00, 0x45, 0xd1, 0x16, 0x5d, 0x15, 0x68,
	0xbb, 0x2e, 0xd0, 0x45, 0x81, 0xae, 0xb2, 0x2a, 0x82, 0xb7, 0x0a, 0x5e, 0x1e, 0x8c, 0xf7, 0x6c,
	0xbc, 0xcd, 0x03, 0xde, 0xe6, 0x2d, 0xbd, 0x7a, 0xb8, 0x97, 0x97, 0x1c, 0x8e, 0x34, 0x4e, 0xf4,
	0xe3, 0x78, 0x27, 0x9e, 0x7b, 0xce, 0xb9, 0xf7, 0x9c, 0x7b, 0xef, 0x39, 0xdf, 0x77, 0x47, 0xb0,
	0xbc, 0x7f, 0xb0, 0xb1, 0x7f, 0x30, 0xe8, 0x6c, 0x20, 0xdf, 0xc7, 0x7e, 0x50, 0x1a, 0xf8, 0x38,
	0xc4, 0xc2, 0x25, 0x0b, 0x5b, 0xfb, 0x3e, 0x36, 0xad, 0x5e, 0x69, 0xff, 0xa0, 0x44, 0xc6, 0xaf,
	0x5d, 0x89, 0x14, 0x8e, 0x68, 0x5e, 0x13, 0xa8, 0xd6, 0xa0, 0xb3, 0x61, 0x9b, 0xa1, 0xc9, 0x64,
	0x2b, 0xb1, 0xac, 0x8f, 0x42, 0x33, 0x25, 0x7f, 0x2b, 0x08, 0xb1, 0x6f, 0x76, 0xd1, 0x06, 0xf2,
	0xba, 0x8e, 0x87, 0x88, 0xc2, 0x81, 0x65, 0xdd, 0x63, 0xa3, 0xc5, 0x61, 0xe8, 0xb8, 0x1b, 0x3d,
	0xd7, 0xda, 0x08, 0x9d, 0x3e, 0x0a, 0x42, 0xb3, 0x3f, 0x60, 0x23, 0xcb, 0x5d, 0xdc, 0xc5, 0xf4,
	0xcf, 0x0d, 0xf2, 0x57, 0x24, 0x15, 0x5f, 0x64, 0xe0, 0xb2, 0x82, 0xc3, 0x3a, 0x32, 0x03, 0xb4,
	0x8d, 0x5d, 0x1b, 0xf9, 0x12, 0x59, 0x98, 0x50, 0x83, 0x39, 0x1f, 0x0d, 0x5c, 0xc7, 0x32, 0x8b,
	0xdc, 0x0d, 0xee, 0xd6, 0xc2, 0xdd, 0x3f, 0x29, 0x8d, 0xa3, 0x61, 0x2b, 0x2b, 0x69, 0x91, 0x46,
	0x0d, 0x05, 0x96, 0xef, 0x0c, 0x42, 0xec, 0x57, 0x72, 0xdf, 0x3e, 0x5b, 0x9f, 0xd1, 0x62, 0x53,
	0xa1, 0x04, 0x79, 0x97, 0x78, 0x2e, 0xe6, 0xa8, 0x8f, 0xe2, 0x14, 0x1f, 0x74, 0x66, 0x2d, 0x52,
	0x13, 0x3a, 0x50, 0xf0, 0x4d, 0xaf, 0x8b, 0x0c, 0xc7, 0x2e, 0x66, 0x6f, 0x70, 0xb7, 0xb2, 0x95,
	0x2d, 0xe2, 0xf0, 0xf9, 0xb3, 0xf5, 0x39, 0x8d, 0xc8, 0xe5, 0xda, 0xcb, 0x67, 0xeb, 0x1f, 0x76,
	0x9d, 0xb0, 0x37, 0xec, 0x94, 0x2c, 0xdc, 0xdf, 0x48, 0xfc, 0xd9, 0x9d, 0xf1, 0xdf, 0x1b, 0x83,
	0xfd, 0xee, 0x46, 0xb2, 0xc6, 0xc8, 0x4e, 0x9b, 0xa3, 0x8e, 0x65, 0x5b, 0xd8, 0x02, 0x88, 0xe6,
	0xb0, 0x51, 0x60, 0x15, 0x67, 0xe9, 0xc2, 0xc4, 0x69, 0xc1, 0x11, 0xa5, 0x63, 0xa1, 0xcd, 0xfb,
	0xb1, 0x58, 0xb8, 0x09, 0x60, 0x0d, 0x83, 0x10, 0xf7, 0x8d, 0x7e, 0xd0, 0x2d, 0xe6, 0x6f, 0x70,
	0xb7, 0xe6, 0x63, 0xa5, 0x48, 0xde, 0x08, 0xba, 0x3b, 0xb9, 0x42, 0x86, 0xcf, 0x8a, 0x2b, 0xb0,
	0xac, 0x60, 0x1b, 0xb5, 0x3d, 0xf3, 0xc0, 0x74, 0x5c, 0xb3, 0xe3, 0x22, 0x9a, 0x65, 0xf1, 0x2a,
	0xac, 0x12, 0x79, 0x0d, 0x59, 0xb8, 0xdf, 0x77, 0x82, 0xc0, 0xc1, 0x1e, 0xb2, 0x93, 0xa1, 0xb6,
	0x17, 0x0c, 0x07, 0x03, 0xec, 0x87, 0xc8, 0xd6, 0xd0, 0x5f, 0x0f, 0x51, 0x10, 0x46, 0x43, 0xbf,
	0xe2, 0x40, 0xa0, 0xab, 0x53, 0x70, 0xb8, 0x89, 0x87, 0x5e, 0x64, 0x31, 0x91, 0x3c, 0xee, 0x67,
	0x4a, 0x5e, 0x07, 0x0a, 0xe4, 0xf8, 0xd1, 0x39, 0x32, 0x93, 0x73, 0xb4, 0x88, 0xfc, 0x0c, 0x73,
	0x30, 0x3b, 0x6d, 0x8e, 0x3a, 0x96, 0x6d, 0xf1, 0x9f, 0x33, 0x70, 0x85, 0x4e, 0xbc, 0x8b, 0x0e,
	0x1b, 0x4e, 0xd0, 0x37, 0x43, 0xab, 0x17, 0x45, 0xf8, 0x57, 0x70, 0xc9, 0x8f, 0x12, 0x61, 0x04,
	0xa1, 0xe9, 0x87, 0xc6, 0x3e, 0x3a, 0xa4, 0xa1, 0x5e, 0xa8, 0x7c, 0xf8, 0xf2, 0xd9, 0xfa, 0x07,
	0xa7, 0x9a, 0x77, 0x17, 0x1d, 0x6a, 0x17, 0x99, 0xbb, 0x16, 0xf1, 0xb6, 0x8b, 0x0e, 0x85, 0x2f,
	0x20, 0x16, 0x19, 0xc8, 0xb3, 0xa9, 0xff, 0xcc, 0x39, 0xfc, 0x2f, 0x32, 0x67, 0x92, 0x67, 0x13,
	0xef, 0xf7, 0x61, 0x96, 0x26, 0x32, 0x28, 0xe6, 0x6f, 0x64, 0x6f, 0x2d, 0xdc, 0x7d, 0xeb, 0x55,
	0xc7, 0x4e, 0xf6, 0xf6, 0x30, 0x3b, 0x4b, 0xcc, 0x62, 0x27, 0x57, 0xc8, 0xf2, 0xb9, 0x9d, 0x5c,
	0x21, 0xc7, 0xe7, 0xc5, 0xff, 0xcc, 0x83, 0xa8, 0x21, 0xd3, 0x7e, 0xe4, 0x84, 0x3d, 0xc7, 0x6b,
	0x7b, 0x16, 0xf2, 0x43, 0xd3, 0xf1, 0xc2, 0x43, 0xd9, 0x0b, 0x91, 0x7f, 0x60, 0xba, 0x51, 0xba,
	0x76, 0x60, 0xc9, 0x47, 0xa6, 0x6d, 0x24, 0x95, 0x80, 0x5d, 0xe5, 0xb7, 0x53, 0xd3, 0x92, 0x72,
	0x51, 0xea, 0xb9, 0x56, 0x49, 0x8f, 0x95, 0xd8, 0xbc, 0x8b, 0xc4, 0x34, 0x11, 0x0a, 0xff, 0xc8,
	0xc1, 0xaa, 0x8b, 0x2d, 0xd3, 0x35, 0x86, 0xe3, 0xe9, 0x0c, 0xd7, 0xe9, 0x3b, 0x21, 0x3d, 0xfa,
	0x3f, 0xe9, 0xb5, 0x46, 0xbc, 0xbe, 0x7c, 0xb6, 0xfe, 0xe0, 0x44, 0x49, 0x8c, 0xab, 0x58, 0xa9,
	0xea, 0x62, 0x6b, 0x3f, 0xf1, 0xa2, 0x5d, 0xa1, 0x6b, 0x48, 0x45, 0x5c, 0x27, 0x2b, 0x10, 0xbe,
	0x84, 0x62, 0xd7, 0xc5, 0x9d, 0xa9, 0xab, 0xcb, 0x9e, 0x3c, 0xe6, 0x95, 0xc8, 0xc9, 0x31, 0xf7,
	0x9f, 0xc3, 0x65, 0xdc, 0x09, 0x90, 0x7f, 0x80, 0x52, 0xc9, 0x0c, 0x8a, 0x39, 0xba, 0x89, 0xd3,
	0x0a, 0xa3, 0xca, 0xb4, 0x8f, 0x4e, 0x20, 0xe0, 0xa3, 0x03, 0x81, 0x50, 0x87, 0x8b, 0x07, 0xa6,
	0x3b, 0x44, 0xa9, 0x6d, 0xca, 0x9c, 0x7c, 0xc9, 0x4b, 0xd4, 0x76, 0xbc, 0x4f, 0x7f, 0xc7, 0xc1,
	0xc5, 0x68, 0x9f, 0xc6, 0xee, 0x66, 0xdf, 0xdc, 0xfe, 0x2c, 0xd1, 0xb9, 0x93, 0xef, 0xfb, 0xb9,
	0x6f, 0xfe, 0x65, 0x7d, 0x46, 0xb4, 0x61, 0x55, 0xf7, 0x4d, 0x2f, 0x30, 0xad, 0xd0, 0xc1, 0x5e,
	0xb9, 0x43, 0x4b, 0x5a, 0x74, 0x46, 0x65, 0x98, 0xf5, 0x91, 0x19, 0x60, 0x8f, 0x9e, 0xcd, 0xa5,
	0xbb, 0x7f, 0x56, 0x3a, 0xd6, 0x34, 0x4b, 0xc7, 0x6d, 0x35, 0x6a, 0x92, 0xdc, 0x10, 0xfa, 0x25,
	0x7e, 0x0e, 0xcb, 0x29, 0xcd, 0xe6, 0x30, 0x60, 0x55, 0xa3, 0x0a, 0x30, 0x18, 0x06, 0x3d, 0x84,
	0x8c, 0x70, 0xe4, 0xb1, 0x2b, 0xb0, 0x36, 0x65, 0xd3, 0x52, 0xc6, 0x71, 0x1d, 0x8f, 0xec, 0xf4,
	0x91, 0x27, 0xfe, 0x4f, 0x06, 0xae, 0xa4, 0x14, 0x34, 0x14, 0xfa, 0x87, 0x91, 0xfb, 0xad, 0x23,
	0x11, 0xdc, 0xfe, 0xf1, 0x08, 0xa8, 0xe5, 0xb4, 0xf5, 0x0b, 0xef, 0xc0, 0x3c, 0x1a, 0x85, 0xbe,
	0x49, 0xdb, 0x49, 0x26, 0xd5, 0x4e, 0x0a, 0x54, 0xdc, 0x08, 0xba, 0x42, 0x0f, 0x96, 0x13, 0x15,
	0xc3, 0x47, 0xb6, 0x69, 0x85, 0xa4, 0x99, 0xd0, 0x33, 0x3e, 0x5f, 0xf9, 0x88, 0x68, 0xff, 0xf2,
	0xd9, 0x7a, 0xe9, 0x15, 0x5b, 0x18, 0x19, 0x94, 0xb4, 0xc4, 0xae, 0x15, 0xfa, 0x8e, 0xd7, 0xd5,
	0x84, 0xd8, 0xff, 0x78, 0x84, 0x9c, 0x4a, 0x0b, 0x7b, 0x7b, 0xae, 0x63, 0x85, 0x8e, 0xd7, 0xa5,
	0x99, 0x8b, 0x7a, 0xf8, 0xcd, 0x54, 0x78, 0x0c, 0x89, 0x94, 0x62, 0x24, 0x52, 0xd2, 0x47, 0x5e,
	0x03, 0x85, 0xa6, 0xb6, 0x94, 0xb2, 0x25, 0xd9, 0xfb, 0xa7, 0x0c, 0xac, 0xa4, 0x72, 0xd0, 0x0a,
	0xcd, 0x70, 0x18, 0x44, 0xe9, 0x5b, 0x81, 0x2c, 0x89, 0x97, 0x4b, 0xc5, 0x4b, 0x04, 0x82, 0x92,
	0xa4, 0x35, 0x43, 0xd3, 0xfa, 0xc1, 0x8f, 0xa7, 0x35, 0xe5, 0xb2, 0x34, 0x35, 0xbb, 0x5f, 0xc2,
	0xd2, 0x6b, 0x4d, 0xda, 0x62, 0x3f, 0x9d, 0x2f, 0xf1, 0x01, 0xcc, 0x46, 0xd3, 0x0a, 0x02, 0x2c,
	0x69, 0x52, 0xb9, 0xa5, 0x2a, 0x46, 0x5b, 0xd9, 0x55, 0xd4, 0x47, 0x0a, 0x3f, 0x23, 0x14, 0x61,
	0x99, 0xc9, 0xf4, 0xc7, 0x8a, 0x51, 0x55, 0x1b, 0x0d, 0x59, 0xd7, 0xa5, 0x1a, 0x9f, 0x11, 0x73,
	0x05, 0x8e, 0xe7, 0xc4, 0xff, 0xe5, 0xe0, 0x52, 0x1d, 0x5b, 0xfb, 0x55, 0x96, 0xb6, 0x28, 0x35,
	0xf7, 0x20, 0x4f, 0x6e, 0x57, 0x50, 0xe4, 0x68, 0xa1, 0x59, 0x9d, 0x86, 0x9e, 0xb0, 0xb5, 0xcf,
	0x02, 0x8d, 0x74, 0x05, 0x07, 0x96, 0x28, 0x96, 0x32, 0x02, 0xd2, 0x7a, 0x3c, 0x0b, 0x31, 0x20,
	0x55, 0x61, 0xf7, 0xfb, 0xfe, 0xa9, 0x9a, 0x18, 0x45, 0x67, 0x2d, 0xe6, 0x49, 0x5b, 0x74, 0xd3,
	0x9f, 0x11, 0xb6, 0x61, 0x2d, 0xe9, 0x5f, 0x33, 0xc0, 0x3f, 0xf2, 0x9d, 0x10, 0x91, 0x16, 0xe4,
	0x9d, 0x27, 0x80, 0xed, 0x64, 0xe3, 0x73, 0x74, 0xe3, 0xef, 0x4c, 0xd9, 0xf8, 0xa3, 0x33, 0x4d,
	0xdd, 0x72, 0xf1, 0x6f, 0xb8, 0x64, 0x53, 0x56, 0x40, 0x48, 0x36, 0xa5, 0xd5, 0x94, 0xaa, 0xf2,
	0xa6, 0x2c, 0xd5, 0xf8, 0x99, 0x94, 0xfc, 0x51, 0x59, 0xd6, 0x8d, 0xa6, 0x5a, 0x97, 0xab, 0x4f,
	0x78, 0x4e, 0x58, 0x85, 0xcb, 0x4c, 0x5e, 0x57, 0xab, 0xbb, 0x86, 0x2e, 0x37, 0x24, 0xb5, 0xad,
	0xf3, 0x19, 0xa1, 0x04, 0x77, 0xd2, 0x03, 0xd4, 0xea, 0xd3, 0xb6, 0xd4, 0x96, 0x8c, 0x46, 0xf9,
	0xb1, 0x51, 0x97, 0x94, 0x2d, 0x7d, 0xdb, 0x90, 0x1e, 0x57, 0x25, 0xa9, 0x26, 0xd5, 0x68, 0x76,
	0xa2, 0x1c, 0x65, 0xf9, 0x9c, 0xf8, 0x7b, 0x8e, 0xe5, 0x48, 0xc7, 0x58, 0x75, 0x59, 0x01, 0x2c,
	0xc3, 0xfc, 0x99, 0xfa, 0xf3, 0xd8, 0x4a, 0x50, 0x80, 0x37, 0xad, 0x70, 0x38, 0x51, 0xf3, 0x4f,
	0xd1, 0x42, 0x2e, 0x46, 0xc6, 0xe3, 0x1e, 0xb2, 0x09, 0x59, 0x02, 0x7c, 0xb2, 0xe7, 0x00, 0x3e,
	0xc4, 0x81, 0xb8, 0x0c, 0x82, 0x3a, 0x20, 0xc8, 0xd5, 0xf1, 0x51, 0xa0, 0x8f, 0xbc, 0x08, 0xbd,
	0xbe, 0xe4, 0x60, 0xb9, 0x8a, 0x3d, 0xdb, 0x21, 0xd7, 0x76, 0xd3, 0x74, 0xdc, 0xb8, 0x15, 0x7c,
	0x02, 0x17, 0x58, 0x18, 0xb4, 0xa7, 0xb1, 0x64, 0x4c, 0xe3, 0x0c, 0x0f, 0xc9, 0xb8, 0xb6, 0x10,
	0x69, 0xd3, 0x0f, 0xa1, 0x0c, 0xd7, 0x7a, 0xa6, 0x6d, 0x78, 0xe8, 0x29, 0xf2, 0x0d, 0xec, 0x3b,
	0x5d, 0xc7, 0x3b, 0x92, 0x8d, 0x02, 0x0b, 0x77, 0xb5, 0x67, 0xda, 0x0a, 0x51, 0x53, 0xa9, 0xd6,
	0x38, 0xec, 0x0e, 0x5c, 0x3f, 0x6a, 0x68, 0x50, 0x46, 0x64, 0x84, 0x3d, 0xd3, 0x3b, 0x0d, 0x8e,
	0x28, 0xe2, 0x49, 0xd7, 0x2a, 0xf1, 0xa2, 0xf7, 0x4c, 0x4f, 0xfc, 0x2f, 0x0e, 0x84, 0x88, 0xf1,
	0xa0, 0xaf, 0x90, 0x95, 0x74, 0xc1, 0x35, 0x98, 0xeb, 0xa3, 0x20, 0x30, 0xbb, 0x68, 0xa2, 0x10,
	0xc6, 0x42, 0xe1, 0x01, 0xcc, 0x33, 0x24, 0x89, 0x6c, 0xb6, 0xb5, 0xaf, 0xe4, 0x52, 0x09, 0x51,
	0x89, 0x0d, 0x84, 0xfb, 0x50, 0x40, 0x23, 0x27, 0x20, 0xc5, 0x98, 0x45, 0xf1, 0x53, 0xc6, 0x89,
	0xbe, 0xe8, 0xc0, 0x72, 0xb9, 0xdf, 0x71, 0xba, 0x43, 0x3c, 0x0c, 0x34, 0x14, 0x0c, 0x5d, 0x76,
	0xb5, 0x77, 0x61, 0x11, 0x79, 0x16, 0xb6, 0x91, 0x6d, 0x50, 0x26, 0xcb, 0x1c, 0xdf, 0x48, 0x39,
	0x8e, 0xa9, 0x6e, 0x49, 0x8a, 0x14, 0xa9, 0x21, 0x9b, 0xe0, 0x02, 0x4a, 0xc9, 0x18, 0x49, 0x6a,
	0x02, 0xdf, 0xf4, 0xf1, 0xe8, 0x30, 0x7d, 0x26, 0x1e, 0x40, 0xde, 0x32, 0x87, 0x41, 0x7c, 0x18,
	0x4e, 0xea, 0x3e, 0x32, 0x12, 0x7f, 0xe0, 0x60, 0x95, 0x71, 0xd4, 0xa3, 0xd4, 0x4b, 0x78, 0x00,
	0x39, 0x4a, 0x00, 0x33, 0xa7, 0x24, 0x80, 0xd4, 0x2a, 0x4d, 0x8f, 0x73, 0x67, 0xa7, 0xc7, 0x49,
	0x74, 0xf9, 0xb3, 0x44, 0xb7, 0x4a, 0x68, 0xd2, 0x5e, 0xb8, 0xe5, 0xe3, 0xe1, 0xa0, 0x86, 0x5c,
	0x14, 0x9f, 0x26, 0xd1, 0x80, 0x15, 0x36, 0x75, 0x15, 0xfb, 0xfe, 0x70, 0x40, 0x2e, 0x5a, 0x14,
	0x34, 0x81, 0x18, 0xe4, 0x0f, 0xe3, 0x68, 0xcb, 0x2d, 0x50, 0x31, 0x81, 0x18, 0x22, 0xcc, 0x0f,
	0x7c, 0x6c, 0xa1, 0x20, 0x60, 0x47, 0xad, 0x90, 0x80, 0xa1, 0x58, 0x2c, 0x7e, 0x4d, 0x08, 0x68,
	0x34, 0x43, 0xba, 0x94, 0x7d, 0x05, 0xc0, 0x22, 0x8b, 0x29, 0x68, 0xbe, 0xb2, 0xcb, 0xe8, 0xe1,
	0x3c, 0xd3, 0xa7, 0x04, 0xf1, 0xa3, 0xd3, 0x91, 0xd0, 0xd8, 0x92, 0x9c, 0xe9, 0xe8, 0x4f, 0x5b,
	0x1c, 0x81, 0x40, 0x89, 0xe3, 0x31, 0x0a, 0x9c, 0xd0, 0x53, 0xee, 0x67, 0xa2, 0xa7, 0x2d, 0x42,
	0xcc, 0x7b, 0xa6, 0x67, 0xbb, 0x04, 0x87, 0x86, 0xfe, 0xe1, 0xf8, 0x4c, 0xdd, 0x85, 0xdc, 0x40,
	0xf2, 0xfd, 0x29, 0x95, 0x2b, 0x6e, 0x5c, 0xe9, 0x6d, 0xa4, 0xba, 0x0c, 0x21, 0xff, 0x43, 0x0e,
	0xde, 0x3d, 0x0a, 0x12, 0x09, 0xbb, 0x6b, 0xfa, 0x38, 0xc4, 0x1a, 0xda, 0xf3, 0x51, 0x8c, 0x66,
	0x5f, 0x85, 0x97, 0x7a, 0xb0, 0x30, 0xf0, 0xd1, 0x01, 0x41, 0x6a, 0x31, 0x39, 0xbf, 0x50, 0xd9,
	0x66, 0xe0, 0xe6, 0xde, 0xc9, 0x41, 0xfd, 0x70, 0xe8, 0xd8, 0xa5, 0x76, 0x5b, 0xae, 0x91, 0x4d,
	0x6b, 0xfa, 0xe8, 0x40, 0x1f, 0x79, 0x24, 0xf5, 0x03, 0xf6, 0xa7, 0x2d, 0xb8, 0xb0, 0x94, 0xcc,
	0x84, 0x06, 0xd8, 0xea, 0xd1, 0xe3, 0x9b, 0xaf, 0x6c, 0x32, 0x84, 0xf1, 0x17, 0x27, 0x9a, 0xec,
	0xe8, 0x2b, 0x16, 0xc1, 0x8e, 0x12, 0xf1, 0xa6, 0x5d, 0x60, 0x53, 0xd1, 0x2f, 0x41, 0x05, 0xde,
	0x43, 0xa3, 0xd0, 0x08, 0xc7, 0xd9, 0x61, 0xb5, 0xe6, 0x64, 0x18, 0xfe, 0x22, 0xb1, 0x4e, 0x89,
	0xa7, 0x00, 0xc1, 0xdc, 0x6b, 0x04, 0x82, 0xd3, 0x80, 0xf3, 0xec, 0xd9, 0x81, 0xf3, 0x08, 0xd6,
	0xf5, 0x91, 0x57, 0x76, 0x09, 0x19, 0x3f, 0x24, 0xa5, 0x60, 0x48, 0x18, 0x3e, 0xbb, 0xe8, 0xd1,
	0x81, 0x68, 0x03, 0xd0, 0xed, 0x88, 0xca, 0x30, 0x77, 0xae, 0x58, 0xe8, 0x2e, 0x47, 0x45, 0xe4,
	0xbf, 0x39, 0x58, 0x26, 0x08, 0xab, 0x8b, 0x7c, 0xf5, 0x00, 0xf9, 0x7b, 0x2e, 0x7e, 0x1a, 0xcd,
	0xc7, 0xd0, 0x01, 0x77, 0x4e, 0x74, 0x20, 0xdc, 0x86, 0x45, 0x6b, 0xe8, 0xfb, 0xc8, 0x0b, 0x59,
	0xbf, 0x8f, 0xde, 0x93, 0x58, 0x7f, 0x60, 0x43, 0x51, 0x73, 0x7f, 0x1f, 0x2e, 0x3a, 0x9e, 0xe5,
	0xa3, 0xfe, 0x58, 0x39, 0x9b, 0x52, 0x5e, 0x4a, 0x06, 0xa9, 0xba, 0xf8, 0xbb, 0x2c, 0x5c, 0xaf,
	0x98, 0xa1, 0xd5, 0x1b, 0xf7, 0x65, 0xb4, 0x87, 0x7d, 0xb4, 0x55, 0x4d, 0x20, 0x97, 0x7e, 0x26,
	0xc8, 0x35, 0xc6, 0x0a, 0xc4, 0x45, 0x8f, 0x5c, 0x4a, 0xec, 0xda, 0xa7, 0xc1, 0x5a, 0x63, 0x2b,
	0xe1, 0x2f, 0xe1, 0xaa, 0x6d, 0x86, 0xa6, 0x81, 0x46, 0x96, 0x3b, 0x24, 0x7d, 0x74, 0xcf, 0xc7,
	0x7d, 0xa3, 0x63, 0x5a, 0xfb, 0xc3, 0x01, 0x0d, 0x2f, 0x2e, 0xbc, 0x2b, 0x44, 0x4d, 0x62, 0x5a,
	0x9b, 0x3e, 0xee, 0x57, 0xa8, 0xce, 0xc4, 0x7b, 0x5f, 0xee, 0x67, 0x7a, 0xef, 0xfb, 0x14, 0xe6,
	0xc7, 0x2f, 0x6d, 0xf9, 0x73, 0x6c, 0x79, 0x21, 0x88, 0x9f, 0xd8, 0x1a, 0x30, 0x17, 0x3f, 0xad,
	0xcd, 0x9e, 0xc3, 0xe1, 0x2c, 0xa2, 0x6f, 0x6a, 0x62, 0x03, 0x8a, 0x8d, 0x87, 0xd5, 0xea, 0xb6,
	0x43, 0xee, 0xd4, 0x61, 0x63, 0x18, 0x9a, 0xe3, 0x76, 0xf7, 0xe7, 0x90, 0x0b, 0x06, 0x66, 0xcc,
	0xf9, 0xa7, 0xd1, 0x8f, 0xd6, 0xc0, 0x8c, 0x0b, 0x05, 0x55, 0x15, 0xbf, 0xe1, 0x40, 0x88, 0x88,
	0x45, 0xc3, 0x09, 0x02, 0xc7, 0xeb, 0x46, 0x9e, 0xee, 0xc3, 0x85, 0xa7, 0x3e, 0xf6, 0xba, 0x86,
	0x43, 0xc7, 0x7e, 0xc4, 0x23, 0x21, 0x34, 0xda, 0x02, 0x55, 0x8e, 0xfc, 0xc4, 0x17, 0x26, 0x73,
	0x5e, 0x38, 0xbd, 0x02, 0xcb, 0x0d, 0xe4, 0x77, 0x91, 0xec, 0x35, 0x7d, 0xdc, 0xf5, 0x51, 0x10,
	0xd1, 0x5d, 0xf1, 0xb7, 0x19, 0xb8, 0x4c, 0x37, 0x6e, 0x13, 0xb1, 0x8e, 0x14, 0x43, 0xb4, 0xc9,
	0x87, 0x89, 0xf7, 0xa7, 0xf4, 0xa3, 0x29, 0x76, 0xd3, 0xb9, 0xd4, 0xd7, 0x99, 0x84, 0x4b, 0x5d,
	0x83, 0x15, 0x46, 0x81, 0x34, 0xa9, 0x59, 0x97, 0xab, 0x65, 0x43, 0x93, 0x1a, 0xea, 0xc3, 0x23,
	0x7c, 0x4a, 0x2b, 0x2b, 0x5b, 0x92, 0xd1, 0x6a, 0xd6, 0x65, 0x7d, 0x82, 0x4f, 0x45, 0xf2, 0x86,
	0xa4, 0x6d, 0x11, 0xfe, 0x9b, 0x62, 0xc6, 0x5a, 0x79, 0x53, 0x37, 0x5a, 0x4a, 0xb9, 0xd9, 0xda,
	0x56, 0x75, 0x3e, 0x2b, 0xac, 0xc1, 0xb5, 0x84, 0x69, 0x6d, 0xc9, 0xd5, 0x72, 0xdd, 0x50, 0x9b,
	0x2d, 0xa3, 0x21, 0xb7, 0x5a, 0xb2, 0xb2, 0xc5, 0xe7, 0x52, 0x96, 0xad, 0xba, 0xfa, 0xc8, 0xa8,
	0xaa, 0x4a, 0xab, 0xdd, 0x90, 0x34, 0x3e, 0x2f, 0x5c, 0x85, 0x2b, 0x6c, 0x44, 0x51, 0x8d, 0xba,
	0x54, 0x6e, 0x49, 0xdb, 0x6a, 0xbd, 0x26, 0x69, 0xfc, 0xac, 0x70, 0x1d, 0x56, 0xd3, 0xeb, 0xd8,
	0x94, 0xa4, 0x9a, 0x51, 0xad, 0xab, 0x2d, 0xa9, 0xc6, 0xcf, 0x09, 0x6f, 0xc3, 0x55, 0x36, 0xd8,
	0x28, 0x2b, 0xed, 0x72, 0x7d, 0x22, 0x86, 0x82, 0x68, 0x42, 0x51, 0xf6, 0x6c, 0x14, 0x22, 0xbf,
	0xef, 0x78, 0x66, 0x88, 0xaa, 0xb8, 0xdf, 0x77, 0x18, 0x1c, 0x96, 0x60, 0x21, 0x08, 0xcd, 0x6e,
	0x5c, 0xf1, 0x4f, 0xf3, 0xc8, 0x04, 0xcc, 0x90, 0x94, 0xfb, 0xcb, 0x70, 0x49, 0xf6, 0x0e, 0x4c,
	0xd7, 0xb1, 0x29, 0x1a, 0x8f, 0xf6, 0x77, 0x0d, 0xde, 0x52, 0x07, 0xa1, 0xd3, 0x27, 0x88, 0xdc,
	0x92, 0x0e, 0x4c, 0x37, 0x7e, 0x25, 0x60, 0xfb, 0xff, 0xff, 0x1c, 0xdc, 0x6c, 0xa4, 0xd8, 0x46,
	0x85, 0xe0, 0xa1, 0xb6, 0x17, 0x98, 0xa1, 0x13, 0xec, 0x39, 0x63, 0x74, 0xd2, 0x82, 0xcb, 0xfd,
	0x09, 0x72, 0xd3, 0x21, 0x8a, 0xa7, 0x29, 0x80, 0x97, 0xfa, 0x47, 0xa7, 0x11, 0x34, 0x10, 0x7c,
	0x14, 0x60, 0x77, 0xe2, 0x69, 0xf4, 0x34, 0x15, 0xf1, 0x52, 0x6c, 0x9e, 0x0c, 0x88, 0x7f, 0xc8,
	0x10, 0x78, 0x49, 0x31, 0x4f, 0x9a, 0x0b, 0xec, 0x1c, 0x39, 0xcf, 0xef, 0x4d, 0x3b, 0xcf, 0xc7,
	0xcc, 0xa6, 0xbf, 0x06, 0xbd, 0xa6, 0x3b, 0x39, 0xc9, 0xde, 0xb3, 0x67, 0x62, 0xef, 0xaf, 0xf7,
	0xa5, 0xed, 0xe3, 0x29, 0xd7, 0x34, 0x79, 0x6f, 0x32, 0x1e, 0x96, 0xeb, 0x6d, 0x89, 0x9f, 0x11,
	0x2e, 0xc1, 0x22, 0x1b, 0x93, 0x15, 0x5d, 0x52, 0x74, 0x9e, 0x13, 0x6f, 0xc3, 0x82, 0xe4, 0xfb,
	0x4d, 0x1c, 0x50, 0x5e, 0x2e, 0x5c, 0x83, 0xbc, 0xe3, 0xd9, 0x68, 0xc4, 0x60, 0x3c, 0x23, 0x1e,
	0x54, 0x24, 0xfe, 0x5f, 0x16, 0xf2, 0xf1, 0xd3, 0xea, 0xe2, 0xd0, 0x43, 0xa3, 0x01, 0x0e, 0xc8,
	0xf6, 0x27, 0x2b, 0xff, 0x89, 0x83, 0xaf, 0x5d, 0x48, 0x8c, 0xf4, 0x91, 0x27, 0x7c, 0x01, 0x0b,
	0x8c, 0x77, 0x7b, 0xd8, 0x46, 0x0c, 0x4c, 0x7e, 0xc2, 0xc0, 0xe4, 0xbd, 0x53, 0xed, 0x8b, 0x82,
	0x6d, 0xd2, 0xbe, 0x20, 0xf2, 0x47, 0xbe, 0x8e, 0x13, 0xd5, 0xf9, 0xb3, 0x13, 0x55, 0xe1, 0xc3,
	0x38, 0x2b, 0x73, 0xc7, 0xe2, 0x4c, 0x21, 0xfc, 0x38, 0x89, 0x2c, 0x5f, 0xc2, 0x10, 0xb2, 0x1e,
	0x7e, 0x5a, 0x2c, 0xbc, 0xb9, 0x67, 0x78, 0x32, 0x5f, 0xc4, 0x2c, 0x76, 0x72, 0x05, 0x8e, 0xcf,
	0xa4, 0x9f, 0xa1, 0x76, 0x72, 0x85, 0x59, 0x7e, 0x4e, 0x7c, 0xc9, 0xc1, 0x8a, 0xec, 0x05, 0xc3,
	0xbd, 0x3d, 0xc7, 0x72, 0x90, 0x17, 0xb6, 0x06, 0xa6, 0x85, 0xde, 0x18, 0x8b, 0x12, 0x96, 0x21,
	0x83, 0x07, 0x13, 0xaf, 0xdc, 0x19, 0x3c, 0x20, 0xe4, 0x33, 0xa1, 0xe9, 0x13, 0x10, 0x6f, 0x2c,
	0x16, 0x6e, 0x40, 0xc1, 0x32, 0x07, 0xa6, 0xe5, 0x84, 0x87, 0x0c, 0xf6, 0x30, 0x0a, 0x1b, 0x4b,
	0x89, 0x86, 0x1f, 0xbd, 0x3a, 0xd9, 0xf4, 0x34, 0x71, 0xb1, 0x46, 0x2c, 0x15, 0x7f, 0xe0, 0xe0,
	0x4a, 0x13, 0x75, 0x3a, 0x2e, 0x3a, 0xca, 0x90, 0xdf, 0x44, 0xec, 0x45, 0xc8, 0x0d, 0xcc, 0xb0,
	0x37, 0x11, 0x3d, 0x95, 0x10, 0x7e, 0xee, 0x04, 0x86, 0x8f, 0xfa, 0x38, 0x44, 0x13, 0x18, 0xb0,
	0xe0, 0x04, 0x1a, 0x95, 0x4e, 0xfe, 0x4a, 0x90, 0x9b, 0xf6, 0x2b, 0x81, 0xf8, 0xef, 0x19, 0x58,
	0xa5, 0x78, 0x31, 0x70, 0xb0, 0xf7, 0xd0, 0xc1, 0x6e, 0x0a, 0x12, 0x0d, 0x40, 0x44, 0xa3, 0x01,
	0x7d, 0x7a, 0x8a, 0x90, 0x27, 0xd1, 0x31, 0x02, 0xc7, 0xb3, 0xd0, 0xd9, 0x7e, 0x27, 0x5c, 0x8f,
	0xdd, 0x25, 0x33, 0xb6, 0x88, 0xb3, 0x31, 0x54, 0xd6, 0xe1, 0xf2, 0x41, 0xbc, 0x86, 0xb3, 0xb5,
	0x08, 0x21, 0xb1, 0x7f, 0xed, 0x6f, 0x94, 0x77, 0x7e, 0x91, 0x81, 0xe2, 0xab, 0x7e, 0x5f, 0x22,
	0x10, 0xa3, 0x5c, 0x51, 0x35, 0xdd, 0x38, 0xf6, 0xa0, 0xff, 0x2e, 0xbc, 0x33, 0x31, 0x42, 0x3f,
	0xa4, 0x9a, 0xa1, 0x49, 0x55, 0x55, 0xab, 0x19, 0x9b, 0x6a, 0x5b, 0xa9, 0xf1, 0x1c, 0xc1, 0x30,
	0x13, 0x6a, 0xd5, 0xba, 0x2c, 0x29, 0xe4, 0x6b, 0x47, 0xaa, 0x12, 0x8c, 0xb3, 0x0e, 0xd7, 0x27,
	0xc6, 0x9b, 0xed, 0xd6, 0xb6, 0xa4, 0xc5, 0xde, 0xf8, 0x1c, 0xc1, 0x2b, 0xc7, 0xe7, 0x31, 0x5a,
	0xcd, 0xb2, 0xc2, 0xe7, 0x85, 0x8f, 0xe1, 0xde, 0xc4, 0x20, 0x9b, 0xbc, 0x5c, 0xd7, 0xa4, 0x72,
	0xed, 0x89, 0xf1, 0x48, 0x23, 0x45, 0x5f, 0x31, 0x9a, 0x6a, 0xab, 0x25, 0x57, 0xea, 0x12, 0x85,
	0x6b, 0xe5, 0x27, 0xfc, 0xac, 0xf0, 0xa7, 0x70, 0x73, 0xc2, 0x50, 0x91, 0x1e, 0x45, 0x38, 0xc9,
	0x68, 0x6a, 0xd2, 0x43, 0x49, 0xd1, 0x5b, 0x86, 0xfe, 0x58, 0xe1, 0x0b, 0xc2, 0x6d, 0x78, 0x77,
	0x42, 0x51, 0x97, 0x1b, 0x52, 0x4b, 0x2f, 0x37, 0x9a, 0x46, 0xb5, 0x5c, 0xdd, 0x96, 0x58, 0x20,
	0x04, 0x3c, 0x5d, 0xcb, 0xfd, 0xed, 0xbf, 0xad, 0xcd, 0x88, 0xa4, 0xce, 0x64, 0xee, 0xfc, 0x07,
	0x37, 0xf1, 0x73, 0x4f, 0xea, 0x27, 0xaf, 0x08, 0xb5, 0xe9, 0xda, 0x93, 0xe3, 0x29, 0xa5, 0x10,
	0x91, 0x8c, 0x90, 0x75, 0x4b, 0x86, 0xae, 0xaa, 0x86, 0x5a, 0x27, 0x49, 0xa4, 0x98, 0x92, 0x0c,
	0xb4, 0x24, 0x4d, 0x2e, 0xd7, 0xe5, 0xcf, 0xca, 0x95, 0xba, 0xc4, 0x67, 0x23, 0xb8, 0x46, 0xe4,
	0xe5, 0xd6, 0x13, 0xa5, 0xca, 0xcc, 0x36, 0xcb, 0x72, 0xbd, 0xad, 0x49, 0x7c, 0x5e, 0x10, 0x61,
	0x2d, 0x1a, 0x8e, 0xda, 0x9f, 0x51, 0x93, 0xca, 0xb5, 0xba, 0xac, 0x48, 0xe3, 0xd7, 0xf9, 0xd9,
	0x68, 0xd1, 0x77, 0xee, 0x83, 0x30, 0xb1, 0x5a, 0x4a, 0x55, 0x84, 0x02, 0xe4, 0x14, 0x55, 0x21,
	0xdd, 0x72, 0x01, 0xe6, 0x2a, 0xe5, 0xea, 0xae, 0xba, 0xb9, 0xc9, 0x73, 0xc2, 0x22, 0xcc, 0xcb,
	0x8d, 0x86, 0x54, 0x93, 0xcb, 0xba, 0xc4, 0x67, 0x2a, 0xca, 0xb7, 0xbf, 0x59, 0x9b, 0xf9, 0xf6,
	0xf9, 0x1a, 0xf7, 0xdd, 0xf3, 0x35, 0xee, 0xfb, 0xe7, 0x6b, 0xdc, 0xaf, 0x9f, 0xaf, 0x71, 0x7f,
	0xff, 0x62, 0x6d, 0xe6, 0xbb, 0x17, 0x6b, 0x33, 0xdf, 0xbf, 0x58, 0x9b, 0xf9, 0xec, 0xbd, 0x13,
	0x1d, 0x4c, 0xf6, 0x0f, 0x44, 0x7f, 0x0c, 0x00, 0x00, 0xff, 0xff, 0xe6, 0x13, 0x3e, 0xc1, 0x4a,
	0x24, 0x00, 0x00,
}

func (m *NotLeaseHolderError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotLeaseHolderError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotLeaseHolderError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RangeDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i -= len(m.CustomMsg)
	copy(dAtA[i:], m.CustomMsg)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.CustomMsg)))
	i--
	dAtA[i] = 0x2a
	if m.Lease != nil {
		{
			size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintErrors(dAtA, i, uint64(m.RangeID))
	i--
	dAtA[i] = 0x18
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NodeUnavailableError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeUnavailableError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeUnavailableError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NodeDecommissionedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeDecommissionedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeDecommissionedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UnsupportedRequestError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsupportedRequestError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsupportedRequestError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RangeNotFoundError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeNotFoundError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeNotFoundError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.StoreID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintErrors(dAtA, i, uint64(m.RangeID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RangeKeyMismatchError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeKeyMismatchError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeKeyMismatchError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintErrors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RequestEndKey != nil {
		i -= len(m.RequestEndKey)
		copy(dAtA[i:], m.RequestEndKey)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.RequestEndKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.RequestStartKey != nil {
		i -= len(m.RequestStartKey)
		copy(dAtA[i:], m.RequestStartKey)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.RequestStartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadWithinUncertaintyIntervalError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadWithinUncertaintyIntervalError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadWithinUncertaintyIntervalError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LocalTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.LocalUncertaintyLimit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.ObservedTimestamps) > 0 {
		for iNdEx := len(m.ObservedTimestamps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObservedTimestamps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintErrors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.GlobalUncertaintyLimit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ValueTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReadTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransactionAbortedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionAbortedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionAbortedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.Reason))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TransactionPushError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPushError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPushError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PusheeTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransactionRetryError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionRetryError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionRetryError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConflictingTxn != nil {
		{
			size, err := m.ConflictingTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.ExtraMsgRedactable)
	copy(dAtA[i:], m.ExtraMsgRedactable)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.ExtraMsgRedactable)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ExtraMsg)
	copy(dAtA[i:], m.ExtraMsg)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.ExtraMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintErrors(dAtA, i, uint64(m.Reason))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TransactionStatusError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionStatusError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionStatusError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.MsgRedactable)
	copy(dAtA[i:], m.MsgRedactable)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.MsgRedactable)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintErrors(dAtA, i, uint64(m.Reason))
	i--
	dAtA[i] = 0x10
	i -= len(m.Msg)
	copy(dAtA[i:], m.Msg)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockConflictError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockConflictError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockConflictError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.LeaseSequence))
	i--
	dAtA[i] = 0x18
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintErrors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WriteIntentError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteIntentError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteIntentError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.Reason))
	i--
	dAtA[i] = 0x20
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintErrors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WriteTooOldError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteTooOldError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteTooOldError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.ActualTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OpRequiresTxnError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpRequiresTxnError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpRequiresTxnError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ConditionFailedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionFailedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionFailedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OriginTimestampOlderThan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i--
	if m.HadNewerOriginTimestamp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	if m.ActualValue != nil {
		{
			size, err := m.ActualValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeaseRejectedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRejectedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseRejectedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Existing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Requested.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AmbiguousResultError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmbiguousResultError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AmbiguousResultError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EncodedError.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}

func (m *ProxyFailedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyFailedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyFailedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Cause.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReplicaUnavailableError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaUnavailableError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaUnavailableError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Cause.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *RaftGroupDeletedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftGroupDeletedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftGroupDeletedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ReplicaCorruptionError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaCorruptionError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaCorruptionError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Processed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.ErrorMsg)
	copy(dAtA[i:], m.ErrorMsg)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.ErrorMsg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReplicaTooOldError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaTooOldError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaTooOldError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.ReplicaID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *StoreNotFoundError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreNotFoundError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreNotFoundError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.StoreID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UnhandledRetryableError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnhandledRetryableError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnhandledRetryableError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PErr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransactionRetryWithProtoRefreshError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionRetryWithProtoRefreshError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionRetryWithProtoRefreshError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConflictingTxn != nil {
		{
			size, err := m.ConflictingTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintErrors(dAtA, i, uint64(m.PrevTxnEpoch))
	i--
	dAtA[i] = 0x28
	i -= len(m.MsgRedactable)
	copy(dAtA[i:], m.MsgRedactable)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.MsgRedactable)))
	i--
	dAtA[i] = 0x22
	{
		size, err := m.NextTransaction.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PrevTxnID.Size()
		i -= size
		if _, err := m.PrevTxnID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i -= len(m.Msg)
	copy(dAtA[i:], m.Msg)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnAlreadyEncounteredErrorError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnAlreadyEncounteredErrorError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnAlreadyEncounteredErrorError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.PrevError)
	copy(dAtA[i:], m.PrevError)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.PrevError)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IntegerOverflowError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegerOverflowError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegerOverflowError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.IncrementValue))
	i--
	dAtA[i] = 0x18
	i = encodeVarintErrors(dAtA, i, uint64(m.CurrentValue))
	i--
	dAtA[i] = 0x10
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchTimestampBeforeGCError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchTimestampBeforeGCError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchTimestampBeforeGCError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndKey != nil {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.StartKey != nil {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x2a
	}
	i = encodeVarintErrors(dAtA, i, uint64(m.RangeID))
	i--
	dAtA[i] = 0x20
	i--
	if m.DataExcludedFromBackup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	{
		size, err := m.Threshold.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MVCCHistoryMutationError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCHistoryMutationError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MVCCHistoryMutationError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IntentMissingError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntentMissingError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntentMissingError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.WrongIntent != nil {
		{
			size, err := m.WrongIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MergeInProgressError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeInProgressError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeInProgressError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RangeFeedRetryError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedRetryError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedRetryError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.Reason))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndeterminateCommitError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndeterminateCommitError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndeterminateCommitError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StagingTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InvalidLeaseError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidLeaseError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvalidLeaseError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OptimisticEvalConflictsError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptimisticEvalConflictsError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimisticEvalConflictsError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MinTimestampBoundUnsatisfiableError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinTimestampBoundUnsatisfiableError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinTimestampBoundUnsatisfiableError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResolvedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.MinTimestampBound.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshFailedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshFailedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshFailedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConflictingTxn != nil {
		{
			size, err := m.ConflictingTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintErrors(dAtA, i, uint64(m.Reason))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ErrPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintErrors(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EncodedError.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintErrors(dAtA, i, uint64(m.OriginNode))
	i--
	dAtA[i] = 0x28
	if m.UnexposedTxn != nil {
		{
			size, err := m.UnexposedTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintErrors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *InsufficientSpaceError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsufficientSpaceError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsufficientSpaceError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Required))))
	i--
	dAtA[i] = 0x29
	i = encodeVarintErrors(dAtA, i, uint64(m.Capacity))
	i--
	dAtA[i] = 0x20
	i = encodeVarintErrors(dAtA, i, uint64(m.Available))
	i--
	dAtA[i] = 0x18
	i -= len(m.Op)
	copy(dAtA[i:], m.Op)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.Op)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintErrors(dAtA, i, uint64(m.StoreID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PebbleCorruptionError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PebbleCorruptionError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PebbleCorruptionError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ExtraMsg)
	copy(dAtA[i:], m.ExtraMsg)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.ExtraMsg)))
	i--
	dAtA[i] = 0x22
	i--
	if m.IsRemote {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintErrors(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintErrors(dAtA, i, uint64(m.StoreID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExclusionViolationError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExclusionViolationError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExclusionViolationError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.ViolationTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ExpectedExclusionSinceTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintErrors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintErrors(dAtA []byte, offset int, v uint64) int {
	offset -= sovErrors(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NotLeaseHolderError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovErrors(uint64(l))
	n += 1 + sovErrors(uint64(m.RangeID))
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.CustomMsg)
	n += 1 + l + sovErrors(uint64(l))
	l = m.RangeDesc.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *NodeUnavailableError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NodeDecommissionedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UnsupportedRequestError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RangeNotFoundError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.RangeID))
	n += 1 + sovErrors(uint64(m.StoreID))
	return n
}

func (m *RangeKeyMismatchError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestStartKey != nil {
		l = len(m.RequestStartKey)
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.RequestEndKey != nil {
		l = len(m.RequestEndKey)
		n += 1 + l + sovErrors(uint64(l))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovErrors(uint64(l))
		}
	}
	return n
}

func (m *ReadWithinUncertaintyIntervalError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReadTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ValueTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.GlobalUncertaintyLimit.Size()
	n += 1 + l + sovErrors(uint64(l))
	if len(m.ObservedTimestamps) > 0 {
		for _, e := range m.ObservedTimestamps {
			l = e.Size()
			n += 1 + l + sovErrors(uint64(l))
		}
	}
	l = m.LocalUncertaintyLimit.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.LocalTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *TransactionAbortedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.Reason))
	return n
}

func (m *TransactionPushError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PusheeTxn.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *TransactionRetryError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.Reason))
	l = len(m.ExtraMsg)
	n += 1 + l + sovErrors(uint64(l))
	l = len(m.ExtraMsgRedactable)
	n += 1 + l + sovErrors(uint64(l))
	if m.ConflictingTxn != nil {
		l = m.ConflictingTxn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func (m *TransactionStatusError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	n += 1 + l + sovErrors(uint64(l))
	n += 1 + sovErrors(uint64(m.Reason))
	l = len(m.MsgRedactable)
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *LockConflictError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovErrors(uint64(l))
		}
	}
	n += 1 + sovErrors(uint64(m.LeaseSequence))
	return n
}

func (m *WriteIntentError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovErrors(uint64(l))
		}
	}
	n += 1 + sovErrors(uint64(m.Reason))
	return n
}

func (m *WriteTooOldError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ActualTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func (m *OpRequiresTxnError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ConditionFailedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActualValue != nil {
		l = m.ActualValue.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	n += 2
	l = m.OriginTimestampOlderThan.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *LeaseRejectedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	n += 1 + l + sovErrors(uint64(l))
	l = m.Requested.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.Existing.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *AmbiguousResultError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.EncodedError.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *ProxyFailedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Cause.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *ReplicaUnavailableError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.Replica.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.Cause.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *RaftGroupDeletedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ReplicaCorruptionError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMsg)
	n += 1 + l + sovErrors(uint64(l))
	n += 2
	return n
}

func (m *ReplicaTooOldError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.ReplicaID))
	return n
}

func (m *StoreNotFoundError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.StoreID))
	return n
}

func (m *UnhandledRetryableError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PErr.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *TransactionRetryWithProtoRefreshError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	n += 1 + l + sovErrors(uint64(l))
	l = m.PrevTxnID.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.NextTransaction.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = len(m.MsgRedactable)
	n += 1 + l + sovErrors(uint64(l))
	n += 1 + sovErrors(uint64(m.PrevTxnEpoch))
	if m.ConflictingTxn != nil {
		l = m.ConflictingTxn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func (m *TxnAlreadyEncounteredErrorError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrevError)
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *IntegerOverflowError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovErrors(uint64(l))
	}
	n += 1 + sovErrors(uint64(m.CurrentValue))
	n += 1 + sovErrors(uint64(m.IncrementValue))
	return n
}

func (m *BatchTimestampBeforeGCError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.Threshold.Size()
	n += 1 + l + sovErrors(uint64(l))
	n += 2
	n += 1 + sovErrors(uint64(m.RangeID))
	if m.StartKey != nil {
		l = len(m.StartKey)
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.EndKey != nil {
		l = len(m.EndKey)
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func (m *MVCCHistoryMutationError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *IntentMissingError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WrongIntent != nil {
		l = m.WrongIntent.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func (m *MergeInProgressError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RangeFeedRetryError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.Reason))
	return n
}

func (m *IndeterminateCommitError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StagingTxn.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *InvalidLeaseError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OptimisticEvalConflictsError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MinTimestampBoundUnsatisfiableError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MinTimestampBound.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ResolvedTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *RefreshFailedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.Reason))
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovErrors(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.ConflictingTxn != nil {
		l = m.ConflictingTxn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func (m *ErrPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.Index))
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnexposedTxn != nil {
		l = m.UnexposedTxn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	n += 1 + sovErrors(uint64(m.OriginNode))
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	l = m.Now.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.EncodedError.Size()
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *InsufficientSpaceError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.StoreID))
	l = len(m.Op)
	n += 1 + l + sovErrors(uint64(l))
	n += 1 + sovErrors(uint64(m.Available))
	n += 1 + sovErrors(uint64(m.Capacity))
	n += 9
	return n
}

func (m *PebbleCorruptionError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.StoreID))
	l = len(m.Path)
	n += 1 + l + sovErrors(uint64(l))
	n += 2
	l = len(m.ExtraMsg)
	n += 1 + l + sovErrors(uint64(l))
	return n
}

func (m *ExclusionViolationError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ExpectedExclusionSinceTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ViolationTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovErrors(uint64(l))
	}
	return n
}

func sovErrors(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozErrors(x uint64) (n int) {
	return sovErrors(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NotLeaseHolderError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotLeaseHolderError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotLeaseHolderError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &roachpb.Lease{}
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeUnavailableError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeUnavailableError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeUnavailableError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeDecommissionedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeDecommissionedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeDecommissionedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsupportedRequestError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsupportedRequestError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsupportedRequestError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeNotFoundError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeNotFoundError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeNotFoundError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeKeyMismatchError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeKeyMismatchError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeKeyMismatchError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestStartKey = append(m.RequestStartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RequestStartKey == nil {
				m.RequestStartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestEndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestEndKey = append(m.RequestEndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RequestEndKey == nil {
				m.RequestEndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, roachpb.RangeInfo{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadWithinUncertaintyIntervalError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadWithinUncertaintyIntervalError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadWithinUncertaintyIntervalError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValueTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalUncertaintyLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalUncertaintyLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedTimestamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedTimestamps = append(m.ObservedTimestamps, roachpb.ObservedTimestamp{})
			if err := m.ObservedTimestamps[len(m.ObservedTimestamps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalUncertaintyLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LocalUncertaintyLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LocalTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionAbortedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionAbortedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionAbortedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= TransactionAbortedReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPushError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPushError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPushError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionRetryError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionRetryError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionRetryError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= TransactionRetryReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraMsgRedactable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraMsgRedactable = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictingTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConflictingTxn == nil {
				m.ConflictingTxn = &enginepb.TxnMeta{}
			}
			if err := m.ConflictingTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionStatusError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionStatusError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionStatusError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= TransactionStatusError_Reason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRedactable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgRedactable = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockConflictError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockConflictError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockConflictError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, roachpb.Lock{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseSequence", wireType)
			}
			m.LeaseSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseSequence |= github_com_cockroachdb_cockroach_pkg_roachpb.LeaseSequence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteIntentError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteIntentError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteIntentError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, roachpb.Lock{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= WriteIntentError_Reason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteTooOldError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteTooOldError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteTooOldError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ActualTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpRequiresTxnError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpRequiresTxnError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpRequiresTxnError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionFailedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionFailedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionFailedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActualValue == nil {
				m.ActualValue = &roachpb.Value{}
			}
			if err := m.ActualValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HadNewerOriginTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HadNewerOriginTimestamp = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTimestampOlderThan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginTimestampOlderThan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRejectedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRejectedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRejectedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Existing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Existing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmbiguousResultError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmbiguousResultError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmbiguousResultError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncodedError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyFailedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyFailedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyFailedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaUnavailableError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaUnavailableError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaUnavailableError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftGroupDeletedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftGroupDeletedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftGroupDeletedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaCorruptionError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaCorruptionError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaCorruptionError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaTooOldError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaTooOldError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaTooOldError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreNotFoundError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreNotFoundError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreNotFoundError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnhandledRetryableError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnhandledRetryableError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnhandledRetryableError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionRetryWithProtoRefreshError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionRetryWithProtoRefreshError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionRetryWithProtoRefreshError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevTxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevTxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRedactable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgRedactable = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevTxnEpoch", wireType)
			}
			m.PrevTxnEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevTxnEpoch |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnEpoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictingTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConflictingTxn == nil {
				m.ConflictingTxn = &enginepb.TxnMeta{}
			}
			if err := m.ConflictingTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnAlreadyEncounteredErrorError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnAlreadyEncounteredErrorError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnAlreadyEncounteredErrorError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevError = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegerOverflowError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegerOverflowError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegerOverflowError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentValue", wireType)
			}
			m.CurrentValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementValue", wireType)
			}
			m.IncrementValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncrementValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchTimestampBeforeGCError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchTimestampBeforeGCError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchTimestampBeforeGCError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataExcludedFromBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataExcludedFromBackup = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCHistoryMutationError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCHistoryMutationError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCHistoryMutationError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntentMissingError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntentMissingError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntentMissingError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrongIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WrongIntent == nil {
				m.WrongIntent = &roachpb.Lock{}
			}
			if err := m.WrongIntent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeInProgressError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeInProgressError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeInProgressError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedRetryError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedRetryError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedRetryError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= RangeFeedRetryError_Reason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndeterminateCommitError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndeterminateCommitError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndeterminateCommitError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StagingTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StagingTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidLeaseError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidLeaseError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidLeaseError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptimisticEvalConflictsError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimisticEvalConflictsError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimisticEvalConflictsError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinTimestampBoundUnsatisfiableError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinTimestampBoundUnsatisfiableError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinTimestampBoundUnsatisfiableError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestampBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinTimestampBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolvedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshFailedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshFailedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshFailedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= RefreshFailedError_Reason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictingTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConflictingTxn == nil {
				m.ConflictingTxn = &enginepb.TxnMeta{}
			}
			if err := m.ConflictingTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnexposedTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnexposedTxn == nil {
				m.UnexposedTxn = &roachpb.Transaction{}
			}
			if err := m.UnexposedTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginNode", wireType)
			}
			m.OriginNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginNode |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &ErrPosition{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncodedError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsufficientSpaceError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsufficientSpaceError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsufficientSpaceError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Required = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PebbleCorruptionError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PebbleCorruptionError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PebbleCorruptionError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRemote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRemote = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExclusionViolationError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExclusionViolationError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExclusionViolationError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedExclusionSinceTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedExclusionSinceTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViolationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ViolationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipErrors(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthErrors
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupErrors
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthErrors
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthErrors        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowErrors          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupErrors = fmt.Errorf("proto: unexpected end of group")
)

