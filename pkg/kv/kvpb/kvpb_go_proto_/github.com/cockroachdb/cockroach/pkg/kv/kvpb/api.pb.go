// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvpb/api.proto

package kvpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_col_coldata "github.com/cockroachdb/cockroach/pkg/col/coldata"
	github_com_cockroachdb_cockroach_pkg_kv_kvnemesis_kvnemesisutil "github.com/cockroachdb/cockroach/pkg/kv/kvnemesis/kvnemesisutil"
	lock "github.com/cockroachdb/cockroach/pkg/kv/kvserver/concurrency/lock"
	rspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/readsummary/rspb"
	tenantcapabilitiespb "github.com/cockroachdb/cockroach/pkg/multitenant/tenantcapabilitiespb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	rpcpb "github.com/cockroachdb/cockroach/pkg/rpc/rpcpb"
	github_com_cockroachdb_cockroach_pkg_settings "github.com/cockroachdb/cockroach/pkg/settings"
	settings "github.com/cockroachdb/cockroach/pkg/settings"
	fetchpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/fetchpb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_storage_enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	tracingpb "github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	errorspb "github.com/cockroachdb/errors/errorspb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReadConsistencyType specifies what type of consistency is observed
// during read operations.
type ReadConsistencyType int32

const (
	// CONSISTENT reads are guaranteed to read committed data; the
	// mechanism relies on clocks to determine lease expirations.
	CONSISTENT ReadConsistencyType = 0
	// READ_UNCOMMITTED reads return both committed and uncommitted data.
	// The consistency type is similar to INCONSISTENT in that using it
	// can result in dirty reads. However, like the CONSISTENT type, it
	// requires the replica performing the read to hold a valid read lease,
	// meaning that it can't return arbitrarily stale data. Note that
	// read-committed does not imply any real-time constraints. If process A
	// completes write w, then process B begins a read r, r is not necessarily
	// guaranteed to observe w even if they are from the same client. This can
	// occur due to the unbounded time delay between Raft appends and state
	// machine application.
	// TODO(baptist): Should we remove this level as it is virtually identical to
	// INCONSISTENT. See #98862 as we may change the behavior to give stronger
	// guarantees.
	READ_UNCOMMITTED ReadConsistencyType = 1
	// INCONSISTENT reads return the latest available, committed values.
	// They are more efficient, but may read stale values as pending
	// intents are ignored.
	INCONSISTENT ReadConsistencyType = 2
)

var ReadConsistencyType_name = map[int32]string{
	0: "CONSISTENT",
	1: "READ_UNCOMMITTED",
	2: "INCONSISTENT",
}

var ReadConsistencyType_value = map[string]int32{
	"CONSISTENT":       0,
	"READ_UNCOMMITTED": 1,
	"INCONSISTENT":     2,
}

func (x ReadConsistencyType) String() string {
	return proto.EnumName(ReadConsistencyType_name, int32(x))
}

func (ReadConsistencyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{0}
}

// RoutingPolicy specifies how a request should be routed to the
// replicas of its target range(s) by the DistSender. Policies can
// dictate which replicas are considered to be targets and in which
// order.
type RoutingPolicy int32

const (
	// LEASEHOLDER means that the DistSender should route the request to the
	// leaseholder replica(s) of its target range(s).
	RoutingPolicy_LEASEHOLDER RoutingPolicy = 0
	// NEAREST means that the DistSender should route the request to the
	// nearest replica(s) of its target range(s).
	RoutingPolicy_NEAREST RoutingPolicy = 1
)

var RoutingPolicy_name = map[int32]string{
	0: "LEASEHOLDER",
	1: "NEAREST",
}

var RoutingPolicy_value = map[string]int32{
	"LEASEHOLDER": 0,
	"NEAREST":     1,
}

func (x RoutingPolicy) String() string {
	return proto.EnumName(RoutingPolicy_name, int32(x))
}

func (RoutingPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{1}
}

// ResumeReason specifies why a ResumeSpan was generated instead of a
// complete result.
type ResumeReason int32

const (
	// Zero value; no resume, or an unknown reason from a future or past cockroachdb version.
	RESUME_UNKNOWN ResumeReason = 0
	// A key limit was exceeded, i.e. MaxSpanRequestKeys.
	RESUME_KEY_LIMIT ResumeReason = 1
	// A byte limit was exceeded, i.e. TargetBytes.
	// NB: 21.2 and below will return RESUME_KEY_LIMIT instead.
	RESUME_BYTE_LIMIT ResumeReason = 2
	// An intent limit was exceeded. This is currently never returned to clients,
	// since MVCCScan converts the result into a LockConflictError.
	// NB: 21.2 and below will return RESUME_KEY_LIMIT instead.
	RESUME_INTENT_LIMIT ResumeReason = 3
	// The ElasticCPUHandle signalled that the command evaluation exceeded its
	// allotted CPU time. It is the callers responsibility to resume from the
	// returned resume key.
	RESUME_ELASTIC_CPU_LIMIT ResumeReason = 5
)

var ResumeReason_name = map[int32]string{
	0: "RESUME_UNKNOWN",
	1: "RESUME_KEY_LIMIT",
	2: "RESUME_BYTE_LIMIT",
	3: "RESUME_INTENT_LIMIT",
	5: "RESUME_ELASTIC_CPU_LIMIT",
}

var ResumeReason_value = map[string]int32{
	"RESUME_UNKNOWN":           0,
	"RESUME_KEY_LIMIT":         1,
	"RESUME_BYTE_LIMIT":        2,
	"RESUME_INTENT_LIMIT":      3,
	"RESUME_ELASTIC_CPU_LIMIT": 5,
}

func (x ResumeReason) String() string {
	return proto.EnumName(ResumeReason_name, int32(x))
}

func (ResumeReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{2}
}

// ScanFormat is an enumeration of the available response formats for MVCCScan
// operations.
type ScanFormat int32

const (
	// The standard MVCCScan format: a slice of KeyValue messages.
	KEY_VALUES ScanFormat = 0
	// The batch_response format: a byte slice of alternating keys and values,
	// each prefixed by their length as a varint.
	BATCH_RESPONSE ScanFormat = 1
	// The coldata.Batch response format: only necessary (according to the
	// fetchpb.IndexFetchSpec) columns are populated in the coldata.Batch'es which
	// are either serialized (in the Apache Arrow format) in the batch_responses
	// field or passed as is in the col_batches field of the response,
	// respectively.
	COL_BATCH_RESPONSE ScanFormat = 2
)

var ScanFormat_name = map[int32]string{
	0: "KEY_VALUES",
	1: "BATCH_RESPONSE",
	2: "COL_BATCH_RESPONSE",
}

var ScanFormat_value = map[string]int32{
	"KEY_VALUES":         0,
	"BATCH_RESPONSE":     1,
	"COL_BATCH_RESPONSE": 2,
}

func (x ScanFormat) String() string {
	return proto.EnumName(ScanFormat_name, int32(x))
}

func (ScanFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{3}
}

type ChecksumMode int32

const (
	// CHECK_VIA_QUEUE is set for requests made from the consistency queue. In
	// this mode, a full check is carried out, and depending on the result a
	// recursive consistency check is triggered:
	//
	// 1. no inconsistency found: if recomputed stats don't match persisted stats,
	//    trigger a RecomputeStatsRequest.
	// 2. inconsistency found: if a diff is available, print it and trigger fatal
	//    error. If no diff found, trigger recursive check with diff requested
	//    (which then triggers fatal error).
	//
	// TODO(tbg): these semantics are an artifact of how consistency checks were
	// first implemented. The extra behavior here should move to the consistency
	// check queue instead and this option dropped from the enum.
	ChecksumMode_CHECK_VIA_QUEUE ChecksumMode = 0
	// CHECK_FULL recomputes the hash of the replicate data in all replicas and
	// uses this to determine whether there is an inconsistency.
	ChecksumMode_CHECK_FULL ChecksumMode = 1
	// CHECK_STATS only hashes the persisted lease applied state (which notably
	// includes the persisted MVCCStats) only. This catches a large class of
	// replica inconsistencies observed in the wild (where replicas apply a
	// nonidentical log of commands, and as a result almost always have
	// divergent stats), while doing work independent of the size of the data
	// contained in the replicas.
	ChecksumMode_CHECK_STATS ChecksumMode = 2
)

var ChecksumMode_name = map[int32]string{
	0: "CHECK_VIA_QUEUE",
	1: "CHECK_FULL",
	2: "CHECK_STATS",
}

var ChecksumMode_value = map[string]int32{
	"CHECK_VIA_QUEUE": 0,
	"CHECK_FULL":      1,
	"CHECK_STATS":     2,
}

func (x ChecksumMode) String() string {
	return proto.EnumName(ChecksumMode_name, int32(x))
}

func (ChecksumMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{4}
}

// PushTxnType determines what action to take when pushing a transaction.
type PushTxnType int32

const (
	// Push the timestamp forward if possible to accommodate a concurrent reader.
	PUSH_TIMESTAMP PushTxnType = 0
	// Abort the transaction if possible to accommodate a concurrent writer.
	PUSH_ABORT PushTxnType = 1
	// Abort the transaction if it's abandoned, but don't attempt to mutate it
	// otherwise.
	PUSH_TOUCH PushTxnType = 2
)

var PushTxnType_name = map[int32]string{
	0: "PUSH_TIMESTAMP",
	1: "PUSH_ABORT",
	2: "PUSH_TOUCH",
}

var PushTxnType_value = map[string]int32{
	"PUSH_TIMESTAMP": 0,
	"PUSH_ABORT":     1,
	"PUSH_TOUCH":     2,
}

func (x PushTxnType) String() string {
	return proto.EnumName(PushTxnType_name, int32(x))
}

func (PushTxnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{5}
}

type MVCCFilter int32

const (
	MVCCFilter_Latest MVCCFilter = 0
	MVCCFilter_All    MVCCFilter = 1
)

var MVCCFilter_name = map[int32]string{
	0: "Latest",
	1: "All",
}

var MVCCFilter_value = map[string]int32{
	"Latest": 0,
	"All":    1,
}

func (x MVCCFilter) String() string {
	return proto.EnumName(MVCCFilter_name, int32(x))
}

func (MVCCFilter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{6}
}

type CheckConsistencyResponse_Status int32

const (
	// No inconsistency was detected, but not all replicas returned a checksum.
	CheckConsistencyResponse_RANGE_INDETERMINATE CheckConsistencyResponse_Status = 0
	// A definite inconsistency was detected.
	CheckConsistencyResponse_RANGE_INCONSISTENT CheckConsistencyResponse_Status = 1
	// All replicas of the range agreed on the checksum.
	CheckConsistencyResponse_RANGE_CONSISTENT CheckConsistencyResponse_Status = 2
	// Like RANGE_CONSISTENT, but the recomputed stats disagreed with the
	// persisted stats. The persisted stats indicates estimates, so this is
	// expected.
	CheckConsistencyResponse_RANGE_CONSISTENT_STATS_ESTIMATED CheckConsistencyResponse_Status = 3
	// Like RANGE_CONSISTENT_STATS_ESTIMATED, but the mismatch occurred with
	// persisted stats that claimed to be accurate. This is unexpected and
	// likely indicates a bug in our logic to incrementally update the stats
	// as commands are evaluated and applied.
	CheckConsistencyResponse_RANGE_CONSISTENT_STATS_INCORRECT CheckConsistencyResponse_Status = 4
)

var CheckConsistencyResponse_Status_name = map[int32]string{
	0: "RANGE_INDETERMINATE",
	1: "RANGE_INCONSISTENT",
	2: "RANGE_CONSISTENT",
	3: "RANGE_CONSISTENT_STATS_ESTIMATED",
	4: "RANGE_CONSISTENT_STATS_INCORRECT",
}

var CheckConsistencyResponse_Status_value = map[string]int32{
	"RANGE_INDETERMINATE":              0,
	"RANGE_INCONSISTENT":               1,
	"RANGE_CONSISTENT":                 2,
	"RANGE_CONSISTENT_STATS_ESTIMATED": 3,
	"RANGE_CONSISTENT_STATS_INCORRECT": 4,
}

func (x CheckConsistencyResponse_Status) String() string {
	return proto.EnumName(CheckConsistencyResponse_Status_name, int32(x))
}

func (CheckConsistencyResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{31, 0}
}

// Source represents the immediate source of a request. FROM_SQL represents
// a KV request originating in SQL, and ROOT_KV represents a request
// originating within KV, but at the root of the tree of requests.
// BatchRequests can cause other BatchRequests (e.g. to PushTransaction),
// which may result in yet more BatchRequests (e.g. to
// ResolveIndeterminateCommit). These can cause a deadlock when using slot
// based admission control. Only FROM_SQL and ROOT_KV requests are subject
// to admission control. This behavior errs on the side of no deadlock, if
// we overlooked an instrumentation point, since the default value of OTHER
// bypasses admission control.
type AdmissionHeader_Source int32

const (
	AdmissionHeader_OTHER    AdmissionHeader_Source = 0
	AdmissionHeader_FROM_SQL AdmissionHeader_Source = 1
	AdmissionHeader_ROOT_KV  AdmissionHeader_Source = 2
)

var AdmissionHeader_Source_name = map[int32]string{
	0: "OTHER",
	1: "FROM_SQL",
	2: "ROOT_KV",
}

var AdmissionHeader_Source_value = map[string]int32{
	"OTHER":    0,
	"FROM_SQL": 1,
	"ROOT_KV":  2,
}

func (x AdmissionHeader_Source) String() string {
	return proto.EnumName(AdmissionHeader_Source_name, int32(x))
}

func (AdmissionHeader_Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{111, 0}
}

// SourceLocation specifies physically where the call originated. LOCAL
// means the client is collocated on the same node as the server. It is set
// on codepaths that use internalClientAdapter which avoids using gRPC for
// local calls to the KV API.
type AdmissionHeader_SourceLocation int32

const (
	AdmissionHeader_REMOTE AdmissionHeader_SourceLocation = 0
	AdmissionHeader_LOCAL  AdmissionHeader_SourceLocation = 1
)

var AdmissionHeader_SourceLocation_name = map[int32]string{
	0: "REMOTE",
	1: "LOCAL",
}

var AdmissionHeader_SourceLocation_value = map[string]int32{
	"REMOTE": 0,
	"LOCAL":  1,
}

func (x AdmissionHeader_SourceLocation) String() string {
	return proto.EnumName(AdmissionHeader_SourceLocation_name, int32(x))
}

func (AdmissionHeader_SourceLocation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{111, 1}
}

type TenantSettingsEvent_EventType int32

const (
	// The event is about an update to cluster setting overrides.
	// This must be zero for backward-compatibility with pre-v23.1
	// CockroachDB.
	TenantSettingsEvent_SETTING_EVENT TenantSettingsEvent_EventType = 0
	// The event is about an update to the tenant's metadata.
	TenantSettingsEvent_METADATA_EVENT TenantSettingsEvent_EventType = 1
)

var TenantSettingsEvent_EventType_name = map[int32]string{
	0: "SETTING_EVENT",
	1: "METADATA_EVENT",
}

var TenantSettingsEvent_EventType_value = map[string]int32{
	"SETTING_EVENT":  0,
	"METADATA_EVENT": 1,
}

func (x TenantSettingsEvent_EventType) String() string {
	return proto.EnumName(TenantSettingsEvent_EventType_name, int32(x))
}

func (TenantSettingsEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{131, 0}
}

type TenantSettingsEvent_Precedence int32

const (
	// Sentinel value to ensure that the 0 value is not a valid precedence.
	TenantSettingsEvent_INVALID TenantSettingsEvent_Precedence = 0
	// Setting overrides specific to 1 tenant.
	TenantSettingsEvent_TENANT_SPECIFIC_OVERRIDES TenantSettingsEvent_Precedence = 1
	// Setting overrides applied to all tenants.
	TenantSettingsEvent_ALL_TENANTS_OVERRIDES TenantSettingsEvent_Precedence = 2
)

var TenantSettingsEvent_Precedence_name = map[int32]string{
	0: "INVALID",
	1: "TENANT_SPECIFIC_OVERRIDES",
	2: "ALL_TENANTS_OVERRIDES",
}

var TenantSettingsEvent_Precedence_value = map[string]int32{
	"INVALID":                   0,
	"TENANT_SPECIFIC_OVERRIDES": 1,
	"ALL_TENANTS_OVERRIDES":     2,
}

func (x TenantSettingsEvent_Precedence) String() string {
	return proto.EnumName(TenantSettingsEvent_Precedence_name, int32(x))
}

func (TenantSettingsEvent_Precedence) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{131, 1}
}

// RequestHeader is supplied with every storage node request.
type RequestHeader struct {
	// Empty is zero-size in production and doesn't generate any encoded bytes
	// (thanks to gogoproto.omitempty). It's an int64 under the crdb_test build
	// tag. This is used to enable kvnemesis testing, which builds on uniqueness
	// of values in the MVCC history. Deletions don't have a user-definable value,
	// so we need an extra identifier, which is provided by this field.
	//
	// NB: it's important that this isn't at the end of the message, see:
	// https://dave.cheney.net/2015/10/09/padding-is-hard
	KVNemesisSeq github_com_cockroachdb_cockroach_pkg_kv_kvnemesis_kvnemesisutil.Container `protobuf:"bytes,6,opt,name=kvnemesis_seq,json=kvnemesisSeq,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvnemesis/kvnemesisutil.Container" json:"kvnemesis_seq"`
	// The key for request. If the request operates on a range, this
	// represents the starting key for the range.
	Key github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	// The end key is empty if the request spans only a single key. Otherwise,
	// it must order strictly after Key. In such a case, the header indicates
	// that the operation takes place on the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"end_key,omitempty"`
	// A zero-indexed transactional sequence number.
	Sequence github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,5,opt,name=sequence,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"sequence,omitempty"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{0}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(m, src)
}
func (m *RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

type RequestHeader_Empty struct {
}

func (m *RequestHeader_Empty) Reset()         { *m = RequestHeader_Empty{} }
func (m *RequestHeader_Empty) String() string { return proto.CompactTextString(m) }
func (*RequestHeader_Empty) ProtoMessage()    {}
func (*RequestHeader_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{0, 0}
}
func (m *RequestHeader_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestHeader_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader_Empty.Merge(m, src)
}
func (m *RequestHeader_Empty) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader_Empty proto.InternalMessageInfo

// ResponseHeader is returned with every storage node response. Note that this is
// different from a BatchResponse's header.
type ResponseHeader struct {
	// txn is non-nil if the request specified a non-nil transaction.
	// The transaction timestamp and/or priority may have been updated,
	// depending on the outcome of the request.
	//
	// Once txn is merged into the BatchResponse_Header.Txn, it will be
	// reset to nil to avoid sending superfluous information over the
	// network.
	Txn *roachpb.Transaction `protobuf:"bytes,3,opt,name=txn,proto3" json:"txn,omitempty"`
	// The next span to resume from when the response doesn't cover the full span
	// requested. This can happen when a bound on the result size is set through
	// max_span_request_keys or target_bytes in the batch header or when a scan
	// has been stopped before covering the requested data because of
	// scan_options.
	//
	// ResumeSpan is unset when the entire span of keys have been
	// operated on. The span is set to the original span if the request
	// was ignored because max_span_request_keys was hit due to another
	// request in the batch. For a reverse scan the end_key is updated.
	ResumeSpan *roachpb.Span `protobuf:"bytes,4,opt,name=resume_span,json=resumeSpan,proto3" json:"resume_span,omitempty"`
	// When resume_span is populated, this specifies the reason why the operation
	// wasn't completed and needs to be resumed.
	ResumeReason ResumeReason `protobuf:"varint,7,opt,name=resume_reason,json=resumeReason,proto3,enum=cockroach.roachpb.ResumeReason" json:"resume_reason,omitempty"`
	// When resume_reason is RESUME_BYTE_LIMIT, this may contain the size of the
	// next result entry which caused the limit to be exceeded, i.e. the size of
	// the first entry when reading from the resume span. It is only supported by
	// Get and Scan. In a batch, this will only be set on the first response that
	// exceeds the limit.
	//
	// NB: This is best-effort, and may be 0 in some rare cases. Specifically, if
	// TargetBytes is exactly satisfied by a result that exhausted a range scan,
	// or by a response from a multi-request batch, we won't do additional work
	// (e.g. send another RPC to the next range) only to obtain resume_next_bytes.
	//
	// Also note that this is unaffected by whole_rows_of_size. The client may
	// care about whole rows, but we'll only return the size of the next KV pair
	// (which may just be part of the row), to avoid the cost of additional IO.
	ResumeNextBytes int64 `protobuf:"varint,9,opt,name=resume_next_bytes,json=resumeNextBytes,proto3" json:"resume_next_bytes,omitempty"`
	// The number of keys operated on.
	NumKeys int64 `protobuf:"varint,5,opt,name=num_keys,json=numKeys,proto3" json:"num_keys,omitempty"`
	// The number of bytes returned. Only populated for requests that support it
	// (at the time of writing, Scan, ReverseScan and ExportRequest). The number
	// returned here corresponds to the (Header).TargetBytes field and loosely
	// measures the bytes in the timestamps, keys, and values of the returned
	// rows.
	NumBytes int64 `protobuf:"varint,8,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{1}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

// A GetRequest is the argument for the Get() method.
type GetRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The desired key-level locking mode used during this get. When set to None
	// (the default), no key-level locking mode is used - meaning that the get
	// does not acquire a lock. When set to any other strength, a lock of that
	// strength is acquired with the associated durability guarantees on the key,
	// if it exists.
	KeyLockingStrength lock.Strength `protobuf:"varint,2,opt,name=key_locking_strength,json=keyLockingStrength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"key_locking_strength,omitempty"`
	// KeyLockingDurability denotes the durability with which locks, if any are
	// acquired, should be acquired with. It should only be set in conjunction
	// with a non-None KeyLockingStrength.
	//
	// Unreplicated locks are kept in-memory on the leaseholder of the locked key.
	// As such, their existence until a transaction commits is best-effort. They
	// are susceptible to things like lease transfers and node crashes. However,
	// they are faster to acquire and resolve when compared to replicated locks.
	// This makes them an appealing choice when locks are not required for
	// correctness. This includes things like (non-exhaustive list):
	// 1. Transactions that run under serializable isolation level.
	// 2. Implicit SFU for weaker isolation levels, where we know we will
	// subsequently perform a (replicated) intent write on the key being locked.
	//
	// Replicated locks on the other hand, once acquired, are guaranteed to exist
	// until the transaction finalizes (commits or aborts). They are not
	// susceptible to things like lease transfers, range {splits,merges}, memory
	// limits, node crashes etc. Replication adds a performance penalty for lock
	// acquisition and resolution; as such, they should only be used by
	// transactions that need guaranteed locks for correctness (read:
	// read-committed or snapshot isolation transactions).
	KeyLockingDurability lock.Durability `protobuf:"varint,3,opt,name=key_locking_durability,json=keyLockingDurability,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Durability" json:"key_locking_durability,omitempty"`
	// ReturnRawMVCCValues indicates that the returned roachpb.Values
	// should contain the full bytes of the underlying MVCCValue,
	// including the MVCCValueHeader. If the MVCCValueHeader is
	// non-empty, the returned value will be encoded using the extended
	// encoding with MVCC_EXTENDED_ENCODING_SENTINEL value type as its
	// tag. If the MVCCValueHeader is empty, the default, simple
	// encoding will be used.
	//
	// This option is not compatible for reads over inline values (see
	// https://github.com/cockroachdb/cockroach/issues/131667)
	ReturnRawMVCCValues bool `protobuf:"varint,4,opt,name=return_raw_mvcc_values,json=returnRawMvccValues,proto3" json:"return_raw_mvcc_values,omitempty"`
	// LockNonExisting indicates whether the Get request should acquire a lock
	// on keys that don't exist.
	LockNonExisting bool `protobuf:"varint,5,opt,name=lock_non_existing,json=lockNonExisting,proto3" json:"lock_non_existing,omitempty"`
	// ExpectExclusionSince, if set, indicates that the request should return an
	// error if this key has been written to at a timestamp at or after the given
	// timestamp. This allows the request to verify that a previously acquired
	// unreplicated lock has provided the required protection. Note that it does
	// not check for the existence of the lock. It checks for a write that the
	// lock should have prevented. If such a write is found an
	// ExclusionViolationError is returned.
	ExpectExclusionSince hlc.Timestamp `protobuf:"bytes,6,opt,name=expect_exclusion_since,json=expectExclusionSince,proto3" json:"expect_exclusion_since"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{2}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

// A GetResponse is the return value from the Get() method.
// If the key doesn't exist, Value will be nil.
type GetResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value          *roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The intent seen, if any, when using the READ_UNCOMMITTED consistency level.
	//
	// NOTE: this field is not currently populated with intents for deletion
	// tombstones. It probably should be because the value field may contain a
	// value that is being deleted by a corresponding intent. We should revisit
	// this decision if this ever becomes a problem.
	IntentValue *roachpb.Value `protobuf:"bytes,3,opt,name=intent_value,json=intentValue,proto3" json:"intent_value,omitempty"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{3}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

// A ProbeRequest is an internal request type used to send a replicated no-op
// through a Range as a means of probing write availability. The request does
// not take any latches or locks and thus is not serialized like a regular
// write. This is because we want the probe to bypass as much of the above-raft
// machinery as possible so that it gives us a signal on the replication layer
// alone.
//
// ProbeRequest can be served by any Replica including followers, i.e. it can be
// used to verify that a given Replica is able to access the replication layer.
type ProbeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ProbeRequest) Reset()         { *m = ProbeRequest{} }
func (m *ProbeRequest) String() string { return proto.CompactTextString(m) }
func (*ProbeRequest) ProtoMessage()    {}
func (*ProbeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{4}
}
func (m *ProbeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProbeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProbeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeRequest.Merge(m, src)
}
func (m *ProbeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProbeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeRequest proto.InternalMessageInfo

// A ProbeResponse is the response to a ProbeRequest.
type ProbeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ProbeResponse) Reset()         { *m = ProbeResponse{} }
func (m *ProbeResponse) String() string { return proto.CompactTextString(m) }
func (*ProbeResponse) ProtoMessage()    {}
func (*ProbeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{5}
}
func (m *ProbeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProbeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProbeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeResponse.Merge(m, src)
}
func (m *ProbeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProbeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeResponse proto.InternalMessageInfo

// IsSpanEmptyRequest is used to determine whether a span contains any keys,
// garbage or otherwise. It is used to determine whether data deleted by a
// DeleteRange tombstone has been fully removed.
//
// Generally, the caller should set the MaxSpanKeys header on the BatchRequest
// to 1 so that the DistSender will process the overlapping ranges sequentially
// and stop after the first non-empty range.
type IsSpanEmptyRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *IsSpanEmptyRequest) Reset()         { *m = IsSpanEmptyRequest{} }
func (m *IsSpanEmptyRequest) String() string { return proto.CompactTextString(m) }
func (*IsSpanEmptyRequest) ProtoMessage()    {}
func (*IsSpanEmptyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{6}
}
func (m *IsSpanEmptyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsSpanEmptyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IsSpanEmptyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsSpanEmptyRequest.Merge(m, src)
}
func (m *IsSpanEmptyRequest) XXX_Size() int {
	return m.Size()
}
func (m *IsSpanEmptyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IsSpanEmptyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IsSpanEmptyRequest proto.InternalMessageInfo

// IsSpanEmptyResponse is the response to an IsSpanEmptyRequest.
// If there is any data in the queried span, the NumKeys field of the
// ResponseHeader will have a positive value; if NumKeys is zero, then the
// span is empty.
type IsSpanEmptyResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *IsSpanEmptyResponse) Reset()         { *m = IsSpanEmptyResponse{} }
func (m *IsSpanEmptyResponse) String() string { return proto.CompactTextString(m) }
func (*IsSpanEmptyResponse) ProtoMessage()    {}
func (*IsSpanEmptyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{7}
}
func (m *IsSpanEmptyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsSpanEmptyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IsSpanEmptyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsSpanEmptyResponse.Merge(m, src)
}
func (m *IsSpanEmptyResponse) XXX_Size() int {
	return m.Size()
}
func (m *IsSpanEmptyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsSpanEmptyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsSpanEmptyResponse proto.InternalMessageInfo

// A PutRequest is the argument to the Put() method.
type PutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value         roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// Specify as true to put the value without a corresponding
	// timestamp. This option should be used with care as it precludes
	// the use of this value with transactions.
	Inline bool `protobuf:"varint,3,opt,name=inline,proto3" json:"inline,omitempty"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind bool `protobuf:"varint,4,opt,name=blind,proto3" json:"blind,omitempty"`
	// MustAcquireExclusiveLock, if set, indicates that a lock with the strength
	// no lower than "exclusive" needs to be acquired on the key, even if it
	// doesn't exist.
	MustAcquireExclusiveLock bool `protobuf:"varint,5,opt,name=must_acquire_exclusive_lock,json=mustAcquireExclusiveLock,proto3" json:"must_acquire_exclusive_lock,omitempty"`
	// ExpectExclusionSince, if set, indicates that the request should return an
	// error if this key has been written to at a timestamp at or after the given
	// timestamp. This is different from the ReadTimestamp of the transaction in
	// that it allows a writer to verify an unreplicated lock acquired at an
	// earlier timestamp has provided the required protection.
	ExpectExclusionSince hlc.Timestamp `protobuf:"bytes,6,opt,name=expect_exclusion_since,json=expectExclusionSince,proto3" json:"expect_exclusion_since"`
}

func (m *PutRequest) Reset()         { *m = PutRequest{} }
func (m *PutRequest) String() string { return proto.CompactTextString(m) }
func (*PutRequest) ProtoMessage()    {}
func (*PutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{8}
}
func (m *PutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutRequest.Merge(m, src)
}
func (m *PutRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutRequest proto.InternalMessageInfo

// A PutResponse is the return value from the Put() method.
type PutResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *PutResponse) Reset()         { *m = PutResponse{} }
func (m *PutResponse) String() string { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()    {}
func (*PutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{9}
}
func (m *PutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutResponse.Merge(m, src)
}
func (m *PutResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutResponse proto.InternalMessageInfo

// A ConditionalPutRequest is the argument to the ConditionalPut() method.
//
// - Returns true and sets value if exp_bytes equals existing value.
// - If key doesn't exist and exp_bytes is empty, sets value.
// - Otherwise, returns a ConditionFailedError containing the actual value of the key.
//
// Note that the client is free to send more requests after a
// ConditionFailedError. This is not generally allowed after other errors
// because of fears over the ambiguity of the side-effects of failed requests
// (in particular, the timestamps at which intents might have been written).
// ConditionFailedError is a special case as we ensure there's no ambiguity; the
// error carries a WriteTimestamp that's the upper bound of the timestamps
// intents were written at.
type ConditionalPutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The value to put.
	Value roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// exp_bytes represents the expected existing value for the key. If empty, the
	// key is expected to not exist. If not empty, these bytes are expected to
	// contain the tag and data of the existing value (without the existing
	// value's checksum; the byte array is expected to come from
	// Value.TagAndDataBytes()). A value's checksum covers the key in addition to
	// covering the value, so not including a checksum here makes for a easier to
	// use API - the creator of the ConditionalPutRequest can simply put in bytes
	// coming from a different key.
	// Note that there's no such thing as expecting a key to exist, but have an
	// empty value. Such key-values don't exist.
	//
	// Note that the existing value's timestamp doesn't matter, only its data. So,
	// the CPut will succeed in ABA situations (if a reader got value A and checks
	// against it later, the check will succeed even if, in the meantime, there's
	// been a subsequent write of value B and another one back to value A).
	ExpBytes []byte `protobuf:"bytes,6,opt,name=exp_bytes,json=expBytes,proto3" json:"exp_bytes,omitempty"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind bool `protobuf:"varint,4,opt,name=blind,proto3" json:"blind,omitempty"`
	// Typically if a specific, non-empty expected value is supplied, it *must*
	// exist with that value. Passing this indicates that it is also OK if the key
	// does not exist. This is useful when a given value is expected but it is
	// possible it has not yet been written.
	AllowIfDoesNotExist bool `protobuf:"varint,5,opt,name=allow_if_does_not_exist,json=allowIfDoesNotExist,proto3" json:"allow_if_does_not_exist,omitempty"`
	// Specify as true to put the value without a corresponding
	// timestamp. This option should be used with care as it precludes
	// the use of this value with transactions.
	Inline bool `protobuf:"varint,7,opt,name=inline,proto3" json:"inline,omitempty"`
	// OriginTimestamp, if set, indicates that the ConditionalPut should
	// only succeed if the provided timestamp is greater than the
	// OriginTimestamp field in the MVCCValueHeader of the existing
	// value (if the value has a non-zero OriginTimestamp) or the MVCC
	// timestamp of the existing value. If there is no existing value,
	// the timestamp check succeeds.
	//
	// The conditional put request will only succeed if this timestamp
	// comparison is successful and the expected bytes matches the
	// actual bytes.
	//
	// On success, this timestamp will also be stored in the
	// OriginTimestamp field of the the MVCCValueHeader for the newly
	// written value.
	//
	// In the proposed use case, the OriginTimestamp is the MVCC version
	// timestamp of the row on the source cluster and the semantics lead
	// to idempotent last-write-wins semantics against the "original
	// MVCC timestamp" of the value on the destination, which is its
	// MVCC timestamp or, if set, the OriginTimestamp (reflecting that
	// this value originated from the source cluster).
	//
	// Used by logical data replication.
	OriginTimestamp hlc.Timestamp `protobuf:"bytes,8,opt,name=origin_timestamp,json=originTimestamp,proto3" json:"origin_timestamp"`
}

func (m *ConditionalPutRequest) Reset()         { *m = ConditionalPutRequest{} }
func (m *ConditionalPutRequest) String() string { return proto.CompactTextString(m) }
func (*ConditionalPutRequest) ProtoMessage()    {}
func (*ConditionalPutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{10}
}
func (m *ConditionalPutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalPutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionalPutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalPutRequest.Merge(m, src)
}
func (m *ConditionalPutRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalPutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalPutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalPutRequest proto.InternalMessageInfo

// A ConditionalPutResponse is the return value from the
// ConditionalPut() method.
type ConditionalPutResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ConditionalPutResponse) Reset()         { *m = ConditionalPutResponse{} }
func (m *ConditionalPutResponse) String() string { return proto.CompactTextString(m) }
func (*ConditionalPutResponse) ProtoMessage()    {}
func (*ConditionalPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{11}
}
func (m *ConditionalPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionalPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalPutResponse.Merge(m, src)
}
func (m *ConditionalPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalPutResponse proto.InternalMessageInfo

// An IncrementRequest is the argument to the Increment() method. It
// increments the value for key, and returns the new value. If no
// value exists for a key, incrementing by 0 is not a noop, but will
// create a zero value. IncrementRequest cannot be called on a key set
// by Put() or ConditionalPut(). Similarly, Put() and ConditionalPut()
// cannot be invoked on an incremented key.
type IncrementRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Increment     int64 `protobuf:"varint,2,opt,name=increment,proto3" json:"increment,omitempty"`
}

func (m *IncrementRequest) Reset()         { *m = IncrementRequest{} }
func (m *IncrementRequest) String() string { return proto.CompactTextString(m) }
func (*IncrementRequest) ProtoMessage()    {}
func (*IncrementRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{12}
}
func (m *IncrementRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IncrementRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementRequest.Merge(m, src)
}
func (m *IncrementRequest) XXX_Size() int {
	return m.Size()
}
func (m *IncrementRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementRequest proto.InternalMessageInfo

// An IncrementResponse is the return value from the Increment
// method. The new value after increment is specified in NewValue. If
// the value could not be decoded as specified, Error will be set.
type IncrementResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	NewValue       int64 `protobuf:"varint,2,opt,name=new_value,json=newValue,proto3" json:"new_value,omitempty"`
}

func (m *IncrementResponse) Reset()         { *m = IncrementResponse{} }
func (m *IncrementResponse) String() string { return proto.CompactTextString(m) }
func (*IncrementResponse) ProtoMessage()    {}
func (*IncrementResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{13}
}
func (m *IncrementResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IncrementResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementResponse.Merge(m, src)
}
func (m *IncrementResponse) XXX_Size() int {
	return m.Size()
}
func (m *IncrementResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementResponse proto.InternalMessageInfo

// A DeleteRequest is the argument to the Delete() method.
type DeleteRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// MustAcquireExclusiveLock, if set, indicates that a lock with the strength
	// no lower than "exclusive" needs to be acquired on the key, even if it
	// doesn't exist. Note that when MustAcquireExclusiveLock is false, the
	// FoundKey field in the DeleteResponse may be incorrect when the kvclient has
	// been configured to buffer writes.
	//
	// TODO(ssd): Separate the behaviour of FoundKey to not depend on this flag.
	MustAcquireExclusiveLock bool `protobuf:"varint,2,opt,name=must_acquire_exclusive_lock,json=mustAcquireExclusiveLock,proto3" json:"must_acquire_exclusive_lock,omitempty"`
	// ExpectExclusionSince, if set, indicates that the request should return an
	// error if this key has been written to at a timestamp at or after the given
	// timestamp. This is different from the ReadTimestamp of the transaction in
	// that it allows a writer to verify an unreplicated lock acquired at an
	// earlier timestamp has provided the require protection.
	ExpectExclusionSince hlc.Timestamp `protobuf:"bytes,3,opt,name=expect_exclusion_since,json=expectExclusionSince,proto3" json:"expect_exclusion_since"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{14}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(m, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

// A DeleteResponse is the return value from the Delete() method.
type DeleteResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// True if there was a key that got deleted. A tombstone is written
	// unconditionally, regardless of whether the key is found.
	FoundKey bool `protobuf:"varint,2,opt,name=found_key,json=foundKey,proto3" json:"found_key,omitempty"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{15}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(m, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

// A DeleteRangeRequest is the argument to the DeleteRange() method. It
// specifies the range of keys to delete.
//
// A DeleteRangeRequest populates the timestamp cache and is tracked for
// refreshes.
type DeleteRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// return the keys that are deleted in the response.
	ReturnKeys bool `protobuf:"varint,3,opt,name=return_keys,json=returnKeys,proto3" json:"return_keys,omitempty"`
	// delete "inline" keys which are stored without MVCC timestamps. Note that
	// an "inline" DeleteRange will fail if it attempts to delete any keys which
	// contain timestamped (non-inline) values; this option should only be used on
	// keys which are known to store inline values, such as data in cockroach's
	// time series system.
	//
	// Similarly, attempts to delete keys with inline values will fail unless this
	// flag is set to true; the setting must match the data being deleted.
	//
	// Inline values cannot be deleted transactionally; a DeleteRange with
	// "inline" set to true will fail if it is executed within a transaction.
	Inline bool `protobuf:"varint,4,opt,name=inline,proto3" json:"inline,omitempty"`
	// If enabled, the range is deleted using an MVCC range tombstone, which is a
	// cheaper constant-time write operation (but still requires a scan to check
	// for conflicts and adjust MVCC stats). This option cannot be used in a
	// transaction, and it cannot be combined with Inline or ReturnKeys.
	UseRangeTombstone bool `protobuf:"varint,5,opt,name=use_range_tombstone,json=useRangeTombstone,proto3" json:"use_range_tombstone,omitempty"`
	// If enabled together with UseRangeTombstone, the MVCC range tombstone will
	// only be written if there exists point key/tombstones in the span that
	// aren't already covered by an MVCC range tombstone. As a convenience, it
	// considers empty spans equivalent to being covered by an MVCC range
	// tombstone, so it will omit the write across an entirely empty span too.
	IdempotentTombstone bool `protobuf:"varint,7,opt,name=idempotent_tombstone,json=idempotentTombstone,proto3" json:"idempotent_tombstone,omitempty"`
	// If enabled, and a span is deleted using a range tombstone, then the GCHint
	// on the corresponding Range will be updated. The hint instructs MVCC GC
	// queue to delete this data as soon as it can, and helps optimizing GC for
	// bulk deletions.
	UpdateRangeDeleteGCHint bool                  `protobuf:"varint,8,opt,name=update_range_delete_gc_hint,json=updateRangeDeleteGcHint,proto3" json:"update_range_delete_gc_hint,omitempty"`
	Predicates              DeleteRangePredicates `protobuf:"bytes,6,opt,name=predicates,proto3" json:"predicates"`
}

func (m *DeleteRangeRequest) Reset()         { *m = DeleteRangeRequest{} }
func (m *DeleteRangeRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRangeRequest) ProtoMessage()    {}
func (*DeleteRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{16}
}
func (m *DeleteRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRangeRequest.Merge(m, src)
}
func (m *DeleteRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRangeRequest proto.InternalMessageInfo

// DeleteRangePredicates if specified, will conduct predicate based DeleteRange.
// Predicate based delete range will issue tombstones on live keys that match the
// filters provided by the caller. In particular, long runs of matched keys will
// get deleted with a range tombstone, while smaller runs will get deleted with
// point tombstones. Note that the keyspace across runs does not overlap.
//
// To pass DeleteRangePredicates, the client must also pass UseRangeTombstone.
type DeleteRangePredicates struct {
	// ImportEpoch specifies that all keys with a non-zero
	// MVCCValueHeader.ImportEpoch == ImportEmpoch should be deleted.
	ImportEpoch uint32 `protobuf:"varint,1,opt,name=import_epoch,json=importEpoch,proto3" json:"import_epoch,omitempty"`
	// StartTime specifies an exclusive lower bound to surface keys
	// for deletion. If specified, DeleteRange will only issue tombstones to keys
	// within the span [startKey, endKey) that also have MVCC versions with
	// timestamps between (startTime, endTime), where endTime is the request timestamp.
	//
	// The main application for this is a rollback of IMPORT INTO on a non-empty
	// table. Here, DeleteRange with startTime = ImportStartTime, must only delete
	// keys written by the import. In other words, older, pre-import, data cannot
	// be touched. Because IMPORT INTO takes a table offline and does not allow
	// masking an existing key, this operation will not issue tombstones to
	// pre-import data that were written at or below StartTime.
	//
	// In other words, this operation assumes that for a k@t in the importing table:
	//  - t must be < endTime
	//  - if t in (startTime, endTime), then there is no other k@t' where t' <= startTime.
	StartTime hlc.Timestamp `protobuf:"bytes,6,opt,name=start_time,json=startTime,proto3" json:"start_time"`
}

func (m *DeleteRangePredicates) Reset()         { *m = DeleteRangePredicates{} }
func (m *DeleteRangePredicates) String() string { return proto.CompactTextString(m) }
func (*DeleteRangePredicates) ProtoMessage()    {}
func (*DeleteRangePredicates) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{17}
}
func (m *DeleteRangePredicates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRangePredicates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRangePredicates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRangePredicates.Merge(m, src)
}
func (m *DeleteRangePredicates) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRangePredicates) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRangePredicates.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRangePredicates proto.InternalMessageInfo

// A DeleteRangeResponse is the return value from the DeleteRange()
// method.
type DeleteRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// All the deleted keys if return_keys is set.
	Keys []github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,rep,name=keys,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"keys,omitempty"`
}

func (m *DeleteRangeResponse) Reset()         { *m = DeleteRangeResponse{} }
func (m *DeleteRangeResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteRangeResponse) ProtoMessage()    {}
func (*DeleteRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{18}
}
func (m *DeleteRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRangeResponse.Merge(m, src)
}
func (m *DeleteRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRangeResponse proto.InternalMessageInfo

// A ClearRangeRequest is the argument to the ClearRange() method. It
// specifies a range of keys to clear from the underlying engine. Note
// that this differs from the behavior of DeleteRange, which sets
// transactional intents and writes tombstones to the deleted
// keys. ClearRange is used when permanently dropping or truncating
// table data.
//
// ClearRange also updates the GC threshold for the range to the
// timestamp at which this command executes, to prevent reads at
// earlier timestamps from incorrectly returning empty results.
//
// NOTE: it is important that this method only be invoked on a key
// range which is guaranteed to be both inactive and not see future
// writes (until Deadline, if set, below).
// Ignoring this warning may result in data loss.
type ClearRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Deadline can be set to a time at or after which the server will refuse to
	// execute this ClearRange request, providing a form of replay protection:
	// if a caller sets this to a time in the near future, they can then wait for
	// that time (plus max offset) to have passed at which point they can reuse
	// the span they cleared without fear of this request being replayed later and
	// clearing subsequent writes.
	Deadline hlc.Timestamp `protobuf:"bytes,2,opt,name=deadline,proto3" json:"deadline"`
}

func (m *ClearRangeRequest) Reset()         { *m = ClearRangeRequest{} }
func (m *ClearRangeRequest) String() string { return proto.CompactTextString(m) }
func (*ClearRangeRequest) ProtoMessage()    {}
func (*ClearRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{19}
}
func (m *ClearRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClearRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRangeRequest.Merge(m, src)
}
func (m *ClearRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRangeRequest proto.InternalMessageInfo

// A ClearRangeResponse is the return value from the ClearRange() method.
type ClearRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ClearRangeResponse) Reset()         { *m = ClearRangeResponse{} }
func (m *ClearRangeResponse) String() string { return proto.CompactTextString(m) }
func (*ClearRangeResponse) ProtoMessage()    {}
func (*ClearRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{20}
}
func (m *ClearRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClearRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRangeResponse.Merge(m, src)
}
func (m *ClearRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClearRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRangeResponse proto.InternalMessageInfo

// A RevertRangeRequest specifies a range of keys in which to clear all MVCC
// revisions more recent than some TargetTime from the underlying engine, thus
// reverting the range (from the perspective of an MVCC scan) to that time.
type RevertRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// TargetTime specifies a the time to which to "revert" the range by clearing
	// any MVCC key with a strictly higher timestamp. TargetTime must be higher
	// than the GC Threshold for the replica - so that it is assured that the keys
	// for that time are still there  or the request will fail.
	TargetTime hlc.Timestamp `protobuf:"bytes,2,opt,name=target_time,json=targetTime,proto3" json:"target_time"`
	// IgnoreGcThreshold can be set by a caller to ignore the target-time when
	// checking that the earliest time at which the command operates is above the
	// GC threshold. This is safe to set only in very specific situations, such as
	// when the target span was OFFLINE since the target time as it is during
	// IMPORT INTO. In this case, since the IMPORT knows it is the only writer and
	// it only writes new keys, no keys to which it would need to revert have been
	// shadowed / could have been GC'ed, so it can safely ignore the GC threshold.
	IgnoreGcThreshold bool `protobuf:"varint,4,opt,name=ignore_gc_threshold,json=ignoreGcThreshold,proto3" json:"ignore_gc_threshold,omitempty"`
}

func (m *RevertRangeRequest) Reset()         { *m = RevertRangeRequest{} }
func (m *RevertRangeRequest) String() string { return proto.CompactTextString(m) }
func (*RevertRangeRequest) ProtoMessage()    {}
func (*RevertRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{21}
}
func (m *RevertRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevertRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RevertRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevertRangeRequest.Merge(m, src)
}
func (m *RevertRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RevertRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RevertRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RevertRangeRequest proto.InternalMessageInfo

// A RevertRangeResponse is the return value from the RevertRange() method.
type RevertRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RevertRangeResponse) Reset()         { *m = RevertRangeResponse{} }
func (m *RevertRangeResponse) String() string { return proto.CompactTextString(m) }
func (*RevertRangeResponse) ProtoMessage()    {}
func (*RevertRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{22}
}
func (m *RevertRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevertRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RevertRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevertRangeResponse.Merge(m, src)
}
func (m *RevertRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RevertRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RevertRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RevertRangeResponse proto.InternalMessageInfo

// ColBatches is a way to pass []coldata.Batch without serialization through the
// protobufs for Scans and ReverseScans, when they are executed locally and with
// the COL_BATCH_RESPONSE scan format.
type ColBatches struct {
	ColBatches []github_com_cockroachdb_cockroach_pkg_col_coldata.Batch `protobuf:"bytes,1,rep,name=col_batches,json=colBatches,proto3,customtype=github.com/cockroachdb/cockroach/pkg/col/coldata.Batch" json:"col_batches"`
}

func (m *ColBatches) Reset()      { *m = ColBatches{} }
func (*ColBatches) ProtoMessage() {}
func (*ColBatches) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{23}
}
func (m *ColBatches) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ColBatches.Unmarshal(m, b)
}
func (m *ColBatches) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ColBatches.Marshal(b, m, deterministic)
}
func (m *ColBatches) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColBatches.Merge(m, src)
}
func (m *ColBatches) XXX_Size() int {
	return xxx_messageInfo_ColBatches.Size(m)
}
func (m *ColBatches) XXX_DiscardUnknown() {
	xxx_messageInfo_ColBatches.DiscardUnknown(m)
}

var xxx_messageInfo_ColBatches proto.InternalMessageInfo

// A ScanRequest is the argument to the Scan() method. It specifies the
// start and end keys for an ascending scan of [start,end) and the maximum
// number of results (unbounded if zero).
type ScanRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The desired format for the response. If set to BATCH_RESPONSE or
	// COL_BATCH_RESPONSE, the server will set either the batch_responses field or
	// the col_batches field in the ScanResponse instead of the rows field.
	ScanFormat ScanFormat `protobuf:"varint,4,opt,name=scan_format,json=scanFormat,proto3,enum=cockroach.roachpb.ScanFormat" json:"scan_format,omitempty"`
	// The desired key-level locking mode used during this scan. When set to None
	// (the default), no key-level locking mode is used - meaning that the scan
	// does not acquire any locks. When set to any other strength, a lock of that
	// strength is acquired with the associated durability guarantees on each of
	// the keys scanned by the request, subject to any key limit applied to the
	// batch which limits the number of keys returned.
	//
	// NOTE: the locks acquire with this strength are point locks on each of the
	// keys returned by the request, not a single range lock over the entire span
	// scanned by the request.
	KeyLockingStrength lock.Strength `protobuf:"varint,5,opt,name=key_locking_strength,json=keyLockingStrength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"key_locking_strength,omitempty"`
	// KeyLockingDurability denotes the durability with which locks, if any are
	// acquired, should be acquired with. It should only be set in conjunction
	// with a non-None KeyLockingStrength.
	//
	// Unreplicated locks are kept in-memory on the leaseholder of the locked key.
	// As such, their existence until a transaction commits is best-effort. They
	// are susceptible to things like lease transfers and node crashes. However,
	// they are faster to acquire and resolve when compared to replicated locks.
	// This makes them an appealing choice when locks are not required for
	// correctness. This includes things like (non-exhaustive list):
	// 1. Transactions that run under serializable isolation level.
	// 2. Implicit SFU for weaker isolation levels, where we know we will
	// subsequently perform a (replicated) intent write on the key being locked.
	//
	// Replicated locks on the other hand, once acquired, are guaranteed to exist
	// until the transaction finalizes (commits or aborts). They are not
	// susceptible to things like lease transfers, range {splits,merges}, memory
	// limits, node crashes etc. Replication adds a performance penalty for lock
	// acquisition and resolution; as such, they should only be used by
	// transactions that need guaranteed locks for correctness (read:
	// read-committed or snapshot isolation transactions).
	KeyLockingDurability lock.Durability `protobuf:"varint,6,opt,name=key_locking_durability,json=keyLockingDurability,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Durability" json:"key_locking_durability,omitempty"`
	// ReturnRawMVCCValues indicates that the returned roachpb.Values
	// should contain the full bytes of the underlying MVCCValue,
	// including the MVCCValueHeader. If the MVCCValueHeader is
	// non-empty, the returned value will be encoded using the extended
	// encoding with MVCC_EXTENDED_ENCODING_SENTINEL value type as its
	// tag. If the MVCCValueHeader is empty, the default, simple
	// encoding will be used.
	//
	// This option is not compatible for reads over inline values (see
	// https://github.com/cockroachdb/cockroach/issues/131667)
	ReturnRawMVCCValues bool `protobuf:"varint,7,opt,name=return_raw_mvcc_values,json=returnRawMvccValues,proto3" json:"return_raw_mvcc_values,omitempty"`
}

func (m *ScanRequest) Reset()         { *m = ScanRequest{} }
func (m *ScanRequest) String() string { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()    {}
func (*ScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{24}
}
func (m *ScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanRequest.Merge(m, src)
}
func (m *ScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanRequest proto.InternalMessageInfo

// A ScanResponse is the return value from the Scan() method.
type ScanResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Empty if no rows were scanned or BATCH_RESPONSE / COL_BATCH_RESPONSE scan
	// format was used.
	Rows []roachpb.KeyValue `protobuf:"bytes,2,rep,name=rows,proto3" json:"rows"`
	// The intent rows seen when performing a scan at the READ_UNCOMMITTED
	// consistency level. These rows do not count against the MaxSpanRequestKeys
	// count.
	//
	// NOTE: this field is not currently populated with intents for deletion
	// tombstones. It probably should be because the rows field may contain
	// key-values that are being deleted by corresponding intents. We should
	// revisit this decision if this ever becomes a problem.
	IntentRows []roachpb.KeyValue `protobuf:"bytes,3,rep,name=intent_rows,json=intentRows,proto3" json:"intent_rows"`
	// If set, then depending on the ScanFormat, each item in this repeated bytes
	// field contains part of the results in batch format:
	// - for BATCH_RESPONSE - the key/value pairs are a buffer of varint-prefixed
	// slices, alternating from key to value. Each entry in this field is complete
	// (i.e. there are no key/value pairs that are split across more than one
	// entry). There are num_keys total pairs across all entries, as defined by
	// the ResponseHeader.
	// - for COL_BATCH_RESPONSE - each []byte is a single serialized (in the
	// Apache Arrow format) coldata.Batch. Each SQL row in that coldata.Batch is
	// complete. num_keys total key-value pairs were used to populate all of the
	// coldata.Batch'es in this field.
	//
	// If set, rows and col_batches will not be set.
	BatchResponses [][]byte `protobuf:"bytes,4,rep,name=batch_responses,json=batchResponses,proto3" json:"batch_responses,omitempty"`
	// If set, then each element in the slice is a single non-serialized
	// coldata.Batch. Each SQL row in that coldata.Batch is complete. num_keys
	// total key-value pairs were used to populate all of the coldata.Batch'es in
	// this field.
	//
	// If set, rows and batch_responses will not be set.
	ColBatches ColBatches `protobuf:"bytes,5,opt,name=col_batches,json=colBatches,proto3" json:"col_batches"`
}

func (m *ScanResponse) Reset()         { *m = ScanResponse{} }
func (m *ScanResponse) String() string { return proto.CompactTextString(m) }
func (*ScanResponse) ProtoMessage()    {}
func (*ScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{25}
}
func (m *ScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanResponse.Merge(m, src)
}
func (m *ScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanResponse proto.InternalMessageInfo

// ExciseRequest is the argument to the Excise() method, which ends up calling
// the storage Excise() method. It is used to atomically remove all data in the
// specified key span.
// It's used as a recovery tool in the event of data loss. It's a non-MVCC
// command that will destroy MVCC history, and can result in transactional
// anomalies like lost portions of transactions, uncommiting committed
// transactions, and possible other anomalies. It allows for inconsistent
// follower reads.
// It can not be applied to non-user spans.
type ExciseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ExciseRequest) Reset()         { *m = ExciseRequest{} }
func (m *ExciseRequest) String() string { return proto.CompactTextString(m) }
func (*ExciseRequest) ProtoMessage()    {}
func (*ExciseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{26}
}
func (m *ExciseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExciseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExciseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExciseRequest.Merge(m, src)
}
func (m *ExciseRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExciseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExciseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExciseRequest proto.InternalMessageInfo

// ExciseResponse is the return value from the Excise() method.
type ExciseResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ExciseResponse) Reset()         { *m = ExciseResponse{} }
func (m *ExciseResponse) String() string { return proto.CompactTextString(m) }
func (*ExciseResponse) ProtoMessage()    {}
func (*ExciseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{27}
}
func (m *ExciseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExciseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExciseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExciseResponse.Merge(m, src)
}
func (m *ExciseResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExciseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExciseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExciseResponse proto.InternalMessageInfo

// A ReverseScanRequest is the argument to the ReverseScan() method. It specifies the
// start and end keys for a descending scan of [start,end) and the maximum
// number of results (unbounded if zero).
//
// NB: ReverseScans cannot be put into the same batch as forward requests like
// Scans. IsReverse must be set on the batch header as well.
type ReverseScanRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The desired format for the response. If set to BATCH_RESPONSE or
	// COL_BATCH_RESPONSE, the server will set either the batch_responses field or
	// the col_batches field in the ReverseScanResponse instead of the rows field.
	ScanFormat ScanFormat `protobuf:"varint,4,opt,name=scan_format,json=scanFormat,proto3,enum=cockroach.roachpb.ScanFormat" json:"scan_format,omitempty"`
	// The desired key-level locking mode used during this scan. When set to None
	// (the default), no key-level locking mode is used - meaning that the scan
	// does not acquire any locks. When set to any other strength, a lock of that
	// strength is acquired with the associated durability guarantees on each of
	// the keys scanned by the request, subject to any key limit applied to the
	// batch which limits the number of keys returned.
	//
	// NOTE: the locks acquire with this strength are point locks on each of the
	// keys returned by the request, not a single range lock over the entire span
	// scanned by the request.
	KeyLockingStrength lock.Strength `protobuf:"varint,5,opt,name=key_locking_strength,json=keyLockingStrength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"key_locking_strength,omitempty"`
	// KeyLockingDurability denotes the durability with which locks, if any are
	// acquired, should be acquired with. It should only be set in conjunction
	// with a non-None KeyLockingStrength.
	//
	// Unreplicated locks are kept in-memory on the leaseholder of the locked key.
	// As such, their existence until a transaction commits is best-effort. They
	// are susceptible to things like lease transfers and node crashes. However,
	// they are faster to acquire and resolve when compared to replicated locks.
	// This makes them an appealing choice when locks are not required for
	// correctness. This includes things like (non-exhaustive list):
	// 1. Transactions that run under serializable isolation level.
	// 2. Implicit SFU for weaker isolation levels, where we know we will
	// subsequently perform a (replicated) intent write on the key being locked.
	//
	// Replicated locks on the other hand, once acquired, are guaranteed to exist
	// until the transaction finalizes (commits or aborts). They are not
	// susceptible to things like lease transfers, range {splits,merges}, memory
	// limits, node crashes etc. Replication adds a performance penalty for lock
	// acquisition and resolution; as such, they should only be used by
	// transactions that need guaranteed locks for correctness (read:
	// read-committed or snapshot isolation transactions).
	KeyLockingDurability lock.Durability `protobuf:"varint,6,opt,name=key_locking_durability,json=keyLockingDurability,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Durability" json:"key_locking_durability,omitempty"`
	// ReturnRawMVCCValues indicates that the returned roachpb.Values
	// should contain the full bytes of the underlying MVCCValue,
	// including the MVCCValueHeader. If the MVCCValueHeader is
	// non-empty, the returned value will be encoded using the extended
	// encoding with MVCC_EXTENDED_ENCODING_SENTINEL value type as its
	// tag. If the MVCCValueHeader is empty, the default, simple
	// encoding will be used.
	//
	// This option is not compatible for reads over inline values (see
	// https://github.com/cockroachdb/cockroach/issues/131667)
	ReturnRawMVCCValues bool `protobuf:"varint,7,opt,name=return_raw_mvcc_values,json=returnRawMvccValues,proto3" json:"return_raw_mvcc_values,omitempty"`
}

func (m *ReverseScanRequest) Reset()         { *m = ReverseScanRequest{} }
func (m *ReverseScanRequest) String() string { return proto.CompactTextString(m) }
func (*ReverseScanRequest) ProtoMessage()    {}
func (*ReverseScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{28}
}
func (m *ReverseScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReverseScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReverseScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseScanRequest.Merge(m, src)
}
func (m *ReverseScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReverseScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseScanRequest proto.InternalMessageInfo

// A ReverseScanResponse is the return value from the ReverseScan() method.
type ReverseScanResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Empty if no rows were scanned or BATCH_RESPONSE / COL_BATCH_RESPONSE scan
	// format was used.
	Rows []roachpb.KeyValue `protobuf:"bytes,2,rep,name=rows,proto3" json:"rows"`
	// The intent rows seen when performing a scan at the READ_UNCOMMITTED
	// consistency level. These rows do not count against the MaxSpanRequestKeys
	// count.
	//
	// NOTE: this field is not currently populated with intents for deletion
	// tombstones. It probably should be because the rows field may contain
	// key-values that are being deleted by corresponding intents. We should
	// revisit this decision if this ever becomes a problem.
	IntentRows []roachpb.KeyValue `protobuf:"bytes,3,rep,name=intent_rows,json=intentRows,proto3" json:"intent_rows"`
	// If set, then depending on the ScanFormat, each item in this repeated bytes
	// field contains part of the results in batch format:
	// - for BATCH_RESPONSE - the key/value pairs are a buffer of varint-prefixed
	// slices, alternating from key to value. Each entry in this field is complete
	// (i.e. there are no key/value pairs that are split across more than one
	// entry). There are num_keys total pairs across all entries, as defined by
	// the ResponseHeader.
	// - for COL_BATCH_RESPONSE - each []byte is a single serialized (in the
	// Apache Arrow format) coldata.Batch. Each SQL row in that coldata.Batch is
	// complete. num_keys total key-value pairs were used to populate all of the
	// coldata.Batch'es in this field.
	//
	// If set, rows and col_batches will not be set.
	BatchResponses [][]byte `protobuf:"bytes,4,rep,name=batch_responses,json=batchResponses,proto3" json:"batch_responses,omitempty"`
	// If set, then each element in the slice is a single non-serialized
	// coldata.Batch. Each SQL row in that coldata.Batch is complete. num_keys
	// total key-value pairs were used to populate all of the coldata.Batch'es in
	// this field.
	//
	// If set, rows and batch_responses will not be set.
	ColBatches ColBatches `protobuf:"bytes,5,opt,name=col_batches,json=colBatches,proto3" json:"col_batches"`
}

func (m *ReverseScanResponse) Reset()         { *m = ReverseScanResponse{} }
func (m *ReverseScanResponse) String() string { return proto.CompactTextString(m) }
func (*ReverseScanResponse) ProtoMessage()    {}
func (*ReverseScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{29}
}
func (m *ReverseScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReverseScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReverseScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseScanResponse.Merge(m, src)
}
func (m *ReverseScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReverseScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseScanResponse proto.InternalMessageInfo

// A CheckConsistencyRequest is the argument to the CheckConsistency() method.
// It specifies the start and end keys for a span of ranges to which a
// consistency check should be applied. A consistency check on a range involves
// running a ComputeChecksum on the range followed by a storage.CollectChecksum.
type CheckConsistencyRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Mode          ChecksumMode `protobuf:"varint,3,opt,name=mode,proto3,enum=cockroach.roachpb.ChecksumMode" json:"mode,omitempty"`
}

func (m *CheckConsistencyRequest) Reset()         { *m = CheckConsistencyRequest{} }
func (m *CheckConsistencyRequest) String() string { return proto.CompactTextString(m) }
func (*CheckConsistencyRequest) ProtoMessage()    {}
func (*CheckConsistencyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{30}
}
func (m *CheckConsistencyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConsistencyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConsistencyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConsistencyRequest.Merge(m, src)
}
func (m *CheckConsistencyRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckConsistencyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConsistencyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConsistencyRequest proto.InternalMessageInfo

// A CheckConsistencyResponse is the return value from the CheckConsistency() method.
// It returns the status the range was found in.
type CheckConsistencyResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// result contains a Result for each Range checked, in no particular order.
	Result []CheckConsistencyResponse_Result `protobuf:"bytes,2,rep,name=result,proto3" json:"result"`
}

func (m *CheckConsistencyResponse) Reset()         { *m = CheckConsistencyResponse{} }
func (m *CheckConsistencyResponse) String() string { return proto.CompactTextString(m) }
func (*CheckConsistencyResponse) ProtoMessage()    {}
func (*CheckConsistencyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{31}
}
func (m *CheckConsistencyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConsistencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConsistencyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConsistencyResponse.Merge(m, src)
}
func (m *CheckConsistencyResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckConsistencyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConsistencyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConsistencyResponse proto.InternalMessageInfo

type CheckConsistencyResponse_Result struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// start_key of the range corresponding to range_id (at the time of the
	// check). This is useful to send additional requests to only a subset of
	// ranges contained within a result later, as requests can only be routed by
	// key.
	StartKey []byte                          `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Status   CheckConsistencyResponse_Status `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.CheckConsistencyResponse_Status" json:"status,omitempty"`
	// detail contains information related to the operation. If no inconsistency
	// is found, it contains informational value such as observed stats. If an
	// inconsistency is found, it contains information about that inconsistency
	// including the involved replica and, if requested, the diff.
	Detail string `protobuf:"bytes,4,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *CheckConsistencyResponse_Result) Reset()         { *m = CheckConsistencyResponse_Result{} }
func (m *CheckConsistencyResponse_Result) String() string { return proto.CompactTextString(m) }
func (*CheckConsistencyResponse_Result) ProtoMessage()    {}
func (*CheckConsistencyResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{31, 0}
}
func (m *CheckConsistencyResponse_Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConsistencyResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConsistencyResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConsistencyResponse_Result.Merge(m, src)
}
func (m *CheckConsistencyResponse_Result) XXX_Size() int {
	return m.Size()
}
func (m *CheckConsistencyResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConsistencyResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConsistencyResponse_Result proto.InternalMessageInfo

// An RecomputeStatsRequest triggers a stats recomputation on the Range addressed by
// the request.
//
// An error will be returned if the start key does not match the start key of the
// target Range.
//
// The stats recomputation touches essentially the whole range, but the command
// avoids having to block other commands by taking care to not interleave
// with splits, and by using the commutativity of stats updates. As a result,
// it is safe to invoke at any time, including repeatedly, though it should be
// used conservatively due to performing a full scan of the Range.
type RecomputeStatsRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// When dry_run is true, the stats delta is computed, but no stats adjustment
	// is performed. This isn't useful outside of testing since RecomputeStats is
	// safe and idempotent.
	DryRun bool `protobuf:"varint,2,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (m *RecomputeStatsRequest) Reset()         { *m = RecomputeStatsRequest{} }
func (m *RecomputeStatsRequest) String() string { return proto.CompactTextString(m) }
func (*RecomputeStatsRequest) ProtoMessage()    {}
func (*RecomputeStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{32}
}
func (m *RecomputeStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecomputeStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecomputeStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecomputeStatsRequest.Merge(m, src)
}
func (m *RecomputeStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecomputeStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecomputeStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecomputeStatsRequest proto.InternalMessageInfo

// An RecomputeStatsResponse is the response to an RecomputeStatsRequest.
type RecomputeStatsResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// added_delta is the adjustment made to the range's stats, i.e. `new_stats = old_stats + added_delta`.
	AddedDelta enginepb.MVCCStatsDelta `protobuf:"bytes,2,opt,name=added_delta,json=addedDelta,proto3" json:"added_delta"`
}

func (m *RecomputeStatsResponse) Reset()         { *m = RecomputeStatsResponse{} }
func (m *RecomputeStatsResponse) String() string { return proto.CompactTextString(m) }
func (*RecomputeStatsResponse) ProtoMessage()    {}
func (*RecomputeStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{33}
}
func (m *RecomputeStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecomputeStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecomputeStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecomputeStatsResponse.Merge(m, src)
}
func (m *RecomputeStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecomputeStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecomputeStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecomputeStatsResponse proto.InternalMessageInfo

// An EndTxnRequest is the argument to the EndTxn() method. It specifies
// whether to commit or roll back an extant transaction.
type EndTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// False to abort and rollback.
	Commit bool `protobuf:"varint,2,opt,name=commit,proto3" json:"commit,omitempty"`
	// If set, deadline represents the maximum (exclusive) timestamp at which the
	// transaction can commit (i.e. the maximum timestamp for the txn's reads and
	// writes).
	// If EndTxn(Commit=true) finds that the txn's timestamp has been pushed to or
	// above this deadline, an error will be returned and the client is supposed
	// to rollback the txn.
	Deadline hlc.Timestamp `protobuf:"bytes,3,opt,name=deadline,proto3" json:"deadline"`
	// commit triggers. Note that commit triggers are for
	// internal use only and will cause an error if requested through the
	// external-facing KV API.
	InternalCommitTrigger *roachpb.InternalCommitTrigger `protobuf:"bytes,4,opt,name=internal_commit_trigger,json=internalCommitTrigger,proto3" json:"internal_commit_trigger,omitempty"`
	// Set of spans that the transaction has acquired locks within. These are
	// spans which must be resolved on txn completion. Note that these spans
	// may be condensed to cover aggregate spans if the keys locked by the
	// transaction exceeded a size threshold.
	//
	// The set logically extends to include the keys of all writes in the
	// in-flight write set. However, those keys are not stored in this set
	// to avoid duplication. This means that elements that are removed from
	// that set should be merged into this one.
	//
	// The slice is maintained in sorted order and all spans are maximally
	// merged such that no two spans here overlap each other.
	LockSpans []roachpb.Span `protobuf:"bytes,5,rep,name=lock_spans,json=lockSpans,proto3" json:"lock_spans"`
	// Set of in-flight intent writes that have been issued by the transaction but
	// which may not have succeeded yet. If any promised writes are provided, a
	// committing EndTxn request will move a PENDING transaction to the STAGING
	// status instead of the COMMITTED status. These in-flight writes must then
	// all be confirmed as successful before the transaction can be moved from
	// STAGING to COMMITTED. For more, see txnCommitter.
	//
	// The slice is maintained in sorted order by sequence number. This provides
	// O(log n) access to individual writes in this set based on their sequence
	// number. See SequencedWriteBySeq.Find and its uses. The set can contain
	// multiple SequencedWrites with the same key, but all sequence numbers are
	// unique.
	InFlightWrites []roachpb.SequencedWrite `protobuf:"bytes,17,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	// Requires that the transaction completes as a 1 phase commit. This
	// guarantees that all writes are to the same range and that no
	// intents are left in the event of an error.
	//
	// Note(andrei): Use this flag with care; retriable errors are not generated
	// reliably for these transactions - a TransactionStatusError might be
	// returned instead if 1PC execution fails.
	Require1PC bool `protobuf:"varint,6,opt,name=require_1pc,json=require1pc,proto3" json:"require_1pc,omitempty"`
	// Disables the transaction from attempting 1 phase commit. Cannot be used in
	// conjunction with the Require1PC flag.
	Disable1PC bool `protobuf:"varint,11,opt,name=disable_1pc,json=disable1pc,proto3" json:"disable_1pc,omitempty"`
	// True to indicate that lock spans should be resolved with poison=true.
	// This is used when the transaction is being aborted independently of the
	// main thread of client operation, as in the case of an asynchronous abort
	// from the TxnCoordSender on a failed heartbeat. It should only be set to
	// true when commit=false.
	Poison bool `protobuf:"varint,9,opt,name=poison,proto3" json:"poison,omitempty"`
	// Prepare, if true, causes the end transaction to proceed as though
	// committing, but the transaction state is set to PREPARED instead of
	// COMMITTED on success. If true, commit must be set to true as well.
	//
	// Prepare cannot be used in conjunction with the InFlightWrites field.
	// All in-flight writes must be confirmed to have succeeded before the
	// transaction can be prepared.
	//
	// The field is used to support the XA two-phase commit protocol.
	Prepare bool `protobuf:"varint,12,opt,name=prepare,proto3" json:"prepare,omitempty"`
}

func (m *EndTxnRequest) Reset()         { *m = EndTxnRequest{} }
func (m *EndTxnRequest) String() string { return proto.CompactTextString(m) }
func (*EndTxnRequest) ProtoMessage()    {}
func (*EndTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{34}
}
func (m *EndTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndTxnRequest.Merge(m, src)
}
func (m *EndTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *EndTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EndTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EndTxnRequest proto.InternalMessageInfo

// An EndTxnResponse is the return value from the EndTxn() method. The final
// transaction record is returned as part of the response header. In particular,
// transaction status and timestamp will be updated to reflect final committed
// values. Clients may propagate the transaction timestamp as the final txn
// commit timestamp in order to preserve causal ordering between subsequent
// transactions.
type EndTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// True if the transaction committed on the one phase commit path.
	// This means that all writes which were part of the transaction
	// were written as a single, atomic write batch to just one range.
	OnePhaseCommit bool `protobuf:"varint,4,opt,name=one_phase_commit,json=onePhaseCommit,proto3" json:"one_phase_commit,omitempty"`
	// The commit timestamp of the STAGING transaction record written
	// by the request. Only set if the transaction record was staged.
	StagingTimestamp hlc.Timestamp `protobuf:"bytes,5,opt,name=staging_timestamp,json=stagingTimestamp,proto3" json:"staging_timestamp"`
	// ReplicatedLocalLocksReleasedOnCommit, if non-empty, indicate that
	// replicated locks with strength Shared or Exclusive were released in the
	// referenced key spans when committing this transaction. These locks are
	// local to the range on which the EndTxn request evaluated. Notably, this
	// field is left unset if only write intents were resolved. The field is only
	// set when transactions are explicitly marked as committed.
	//
	// The caller must bump the timestamp cache across these spans to the
	// transaction's commit timestamp. Doing so ensures that the released local[1]
	// locks (acquired by the now committed transaction) continue to provide
	// protection against other writers up to the commit timestamp, even after the
	// locks have been released.
	//
	// [1] Non-local replicated locks provide the same protection, however, the
	// mechanism of bumping the timestamp cache is different there. See the
	// ReplicatedLocksReleasedCommitTimestamp field on
	// ResolveIntent{,Range}Response.
	ReplicatedLocalLocksReleasedOnCommit []roachpb.Span `protobuf:"bytes,6,rep,name=replicated_local_locks_released_on_commit,json=replicatedLocalLocksReleasedOnCommit,proto3" json:"replicated_local_locks_released_on_commit"`
}

func (m *EndTxnResponse) Reset()         { *m = EndTxnResponse{} }
func (m *EndTxnResponse) String() string { return proto.CompactTextString(m) }
func (*EndTxnResponse) ProtoMessage()    {}
func (*EndTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{35}
}
func (m *EndTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndTxnResponse.Merge(m, src)
}
func (m *EndTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *EndTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EndTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EndTxnResponse proto.InternalMessageInfo

// An AdminSplitRequest is the argument to the AdminSplit() method. The
// existing range which contains header.key is split by
// split_key. If split_key is not specified, then this method will
// determine a split key that is roughly halfway through the
// range. The existing range is resized to cover only its start key to
// the split key. The new range created by the split starts at the
// split key and extends to the original range's end key. If split_key
// is known, header.key should also be set to split_key.
//
// New range IDs for each of the split range's replica and a new Raft
// ID are generated by the operation. Split requests are done in the
// context of a distributed transaction which updates range addressing
// records, range metadata and finally, provides a commit trigger to
// update bookkeeping and instantiate the new range on commit.
//
// The new range contains range replicas located on the same stores;
// no range data is moved during this operation. The split can be
// thought of as a mostly logical operation, though some other
// metadata (e.g. abort span and range stats must be copied or
// recomputed).
//
// expiration_time represents the time that this split expires. Any split that
// is not expired will not be considered for automatic merging by the merge
// queue. Any split requested by the split queue will have an expiration time
// of hlc.Timestamp{} (I.E. The zero timestamp so they are always eligible for
// automatic merging).
type AdminSplitRequest struct {
	RequestHeader  `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	SplitKey       github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=split_key,json=splitKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"split_key,omitempty"`
	ExpirationTime hlc.Timestamp                                    `protobuf:"bytes,4,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time"`
	// PredicateKeys specifies keys which if not contained within the range should
	// cause the split to be rejected. This can be used by a caller to effectively
	// send a "conditional split" request, i.e. a split if not already split.
	PredicateKeys []github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,5,rep,name=predicate_keys,json=predicateKeys,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"predicate_keys,omitempty"`
}

func (m *AdminSplitRequest) Reset()         { *m = AdminSplitRequest{} }
func (m *AdminSplitRequest) String() string { return proto.CompactTextString(m) }
func (*AdminSplitRequest) ProtoMessage()    {}
func (*AdminSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{36}
}
func (m *AdminSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminSplitRequest.Merge(m, src)
}
func (m *AdminSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminSplitRequest proto.InternalMessageInfo

// An AdminSplitResponse is the return value from the AdminSplit()
// method.
type AdminSplitResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminSplitResponse) Reset()         { *m = AdminSplitResponse{} }
func (m *AdminSplitResponse) String() string { return proto.CompactTextString(m) }
func (*AdminSplitResponse) ProtoMessage()    {}
func (*AdminSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{37}
}
func (m *AdminSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminSplitResponse.Merge(m, src)
}
func (m *AdminSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminSplitResponse proto.InternalMessageInfo

// An AdminUnsplitRequest is the argument to the AdminUnsplit()
// method. The sticky bit of the existing range whose starting key is
// header.key is removed.
//
// Ranges that do not have the sticky bit set are eligible for
// automatic merging.
type AdminUnsplitRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminUnsplitRequest) Reset()         { *m = AdminUnsplitRequest{} }
func (m *AdminUnsplitRequest) String() string { return proto.CompactTextString(m) }
func (*AdminUnsplitRequest) ProtoMessage()    {}
func (*AdminUnsplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{38}
}
func (m *AdminUnsplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminUnsplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminUnsplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminUnsplitRequest.Merge(m, src)
}
func (m *AdminUnsplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminUnsplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminUnsplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminUnsplitRequest proto.InternalMessageInfo

// An AdminUnsplitResponse is the return value from the
// AdminUnsplit() method.
type AdminUnsplitResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminUnsplitResponse) Reset()         { *m = AdminUnsplitResponse{} }
func (m *AdminUnsplitResponse) String() string { return proto.CompactTextString(m) }
func (*AdminUnsplitResponse) ProtoMessage()    {}
func (*AdminUnsplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{39}
}
func (m *AdminUnsplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminUnsplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminUnsplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminUnsplitResponse.Merge(m, src)
}
func (m *AdminUnsplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminUnsplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminUnsplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminUnsplitResponse proto.InternalMessageInfo

// An AdminMergeRequest is the argument to the AdminMerge() method. A
// merge is performed by calling AdminMerge on the left-hand range of
// two consecutive ranges (i.e. the range which contains keys which
// sort first). This range will be the subsuming range and the right
// hand range will be subsumed. After the merge operation, the
// subsumed range will no longer exist and the subsuming range will
// now encompass all keys from its original start key to the end key
// of the subsumed range. If AdminMerge is called on the final range
// in the key space, it is a noop.
// The request must be addressed to the start key of the left hand side.
type AdminMergeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminMergeRequest) Reset()         { *m = AdminMergeRequest{} }
func (m *AdminMergeRequest) String() string { return proto.CompactTextString(m) }
func (*AdminMergeRequest) ProtoMessage()    {}
func (*AdminMergeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{40}
}
func (m *AdminMergeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminMergeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminMergeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminMergeRequest.Merge(m, src)
}
func (m *AdminMergeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminMergeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminMergeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminMergeRequest proto.InternalMessageInfo

// An AdminMergeResponse is the return value from the AdminMerge()
// method.
type AdminMergeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminMergeResponse) Reset()         { *m = AdminMergeResponse{} }
func (m *AdminMergeResponse) String() string { return proto.CompactTextString(m) }
func (*AdminMergeResponse) ProtoMessage()    {}
func (*AdminMergeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{41}
}
func (m *AdminMergeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminMergeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminMergeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminMergeResponse.Merge(m, src)
}
func (m *AdminMergeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminMergeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminMergeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminMergeResponse proto.InternalMessageInfo

// An AdminTransferLeaseRequest is the argument to the AdminTransferLease()
// method. A lease transfer allows an external entity to control the lease
// holder for a range. The target of the lease transfer needs to be a valid
// replica of the range.
type AdminTransferLeaseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Target        github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,2,opt,name=target,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"target,omitempty"`
	// When set to true, bypass_safety_checks configures the lease transfer to
	// skip safety checks that ensure that the transfer target is known to be
	// (according to the outgoing leaseholder) alive and sufficiently caught up on
	// its log. This option should be used sparingly  typically only by outgoing
	// leaseholders who both have some other reason to believe that the target is
	// alive and caught up on its log (e.g. they just sent it a snapshot) and also
	// can't tolerate rejected lease transfers.
	BypassSafetyChecks bool `protobuf:"varint,3,opt,name=bypass_safety_checks,json=bypassSafetyChecks,proto3" json:"bypass_safety_checks,omitempty"`
}

func (m *AdminTransferLeaseRequest) Reset()         { *m = AdminTransferLeaseRequest{} }
func (m *AdminTransferLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*AdminTransferLeaseRequest) ProtoMessage()    {}
func (*AdminTransferLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{42}
}
func (m *AdminTransferLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminTransferLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminTransferLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminTransferLeaseRequest.Merge(m, src)
}
func (m *AdminTransferLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminTransferLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminTransferLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminTransferLeaseRequest proto.InternalMessageInfo

type AdminTransferLeaseResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminTransferLeaseResponse) Reset()         { *m = AdminTransferLeaseResponse{} }
func (m *AdminTransferLeaseResponse) String() string { return proto.CompactTextString(m) }
func (*AdminTransferLeaseResponse) ProtoMessage()    {}
func (*AdminTransferLeaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{43}
}
func (m *AdminTransferLeaseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminTransferLeaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminTransferLeaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminTransferLeaseResponse.Merge(m, src)
}
func (m *AdminTransferLeaseResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminTransferLeaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminTransferLeaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminTransferLeaseResponse proto.InternalMessageInfo

// A ReplicationChange specifies the type and target of a replication change operation.
type ReplicationChange struct {
	ChangeType roachpb.ReplicaChangeType `protobuf:"varint,1,opt,name=change_type,json=changeType,proto3,enum=cockroach.roachpb.ReplicaChangeType" json:"change_type,omitempty"`
	Target     roachpb.ReplicationTarget `protobuf:"bytes,2,opt,name=target,proto3" json:"target"`
}

func (m *ReplicationChange) Reset()         { *m = ReplicationChange{} }
func (m *ReplicationChange) String() string { return proto.CompactTextString(m) }
func (*ReplicationChange) ProtoMessage()    {}
func (*ReplicationChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{44}
}
func (m *ReplicationChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicationChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicationChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationChange.Merge(m, src)
}
func (m *ReplicationChange) XXX_Size() int {
	return m.Size()
}
func (m *ReplicationChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationChange.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationChange proto.InternalMessageInfo

// An AdminChangeReplicasRequest is the argument to the AdminChangeReplicas()
// method. A change replicas operation allows adding or removing a set of
// replicas for a range.
type AdminChangeReplicasRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Never access directly: use .Changes()
	//
	// TODO(tbg): remove in 20.1
	DeprecatedChangeType roachpb.ReplicaChangeType `protobuf:"varint,2,opt,name=deprecated_change_type,json=deprecatedChangeType,proto3,enum=cockroach.roachpb.ReplicaChangeType" json:"deprecated_change_type,omitempty"`
	// Never access directly: use .Changes()
	//
	// TODO(tbg): remove in 20.1
	DeprecatedTargets []roachpb.ReplicationTarget `protobuf:"bytes,3,rep,name=deprecated_targets,json=deprecatedTargets,proto3" json:"deprecated_targets"`
	// ExpDesc is the expected current range descriptor to modify. If the range
	// descriptor is not identical to ExpDesc for the request will fail.
	//
	// If there is more than one change specified in targets, this expectation
	// will be applied to the first change and subsequent changes will use the
	// resultant descriptor from successfully applying the previous change.
	// If a change with more than one target occurs concurrently with another
	// it is possible that an error will occur after partial application of the
	// change. Changes are applied in the order they appear in the request.
	ExpDesc roachpb.RangeDescriptor `protobuf:"bytes,4,opt,name=exp_desc,json=expDesc,proto3" json:"exp_desc"`
	// The changes to apply to exp_desc. Never access directly: use .Changes().
	//
	// TODO(tbg): rename to 'changes' in 20.1 and remove Changes().
	InternalChanges []ReplicationChange `protobuf:"bytes,5,rep,name=internal_changes,json=internalChanges,proto3" json:"internal_changes"`
}

func (m *AdminChangeReplicasRequest) Reset()         { *m = AdminChangeReplicasRequest{} }
func (m *AdminChangeReplicasRequest) String() string { return proto.CompactTextString(m) }
func (*AdminChangeReplicasRequest) ProtoMessage()    {}
func (*AdminChangeReplicasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{45}
}
func (m *AdminChangeReplicasRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminChangeReplicasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminChangeReplicasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminChangeReplicasRequest.Merge(m, src)
}
func (m *AdminChangeReplicasRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminChangeReplicasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminChangeReplicasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminChangeReplicasRequest proto.InternalMessageInfo

type AdminChangeReplicasResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Desc is the value of the range descriptor upon success.
	Desc roachpb.RangeDescriptor `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc"`
}

func (m *AdminChangeReplicasResponse) Reset()         { *m = AdminChangeReplicasResponse{} }
func (m *AdminChangeReplicasResponse) String() string { return proto.CompactTextString(m) }
func (*AdminChangeReplicasResponse) ProtoMessage()    {}
func (*AdminChangeReplicasResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{46}
}
func (m *AdminChangeReplicasResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminChangeReplicasResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminChangeReplicasResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminChangeReplicasResponse.Merge(m, src)
}
func (m *AdminChangeReplicasResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminChangeReplicasResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminChangeReplicasResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminChangeReplicasResponse proto.InternalMessageInfo

// An AdminRelocateRangeRequest is the argument to the AdminRelocateRange()
// method. Relocates the replicas for a range to the specified target stores.
// The first store in the list of targets becomes the new leaseholder.
type AdminRelocateRangeRequest struct {
	RequestHeader   `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	VoterTargets    []roachpb.ReplicationTarget `protobuf:"bytes,2,rep,name=voter_targets,json=voterTargets,proto3" json:"voter_targets"`
	NonVoterTargets []roachpb.ReplicationTarget `protobuf:"bytes,3,rep,name=non_voter_targets,json=nonVoterTargets,proto3" json:"non_voter_targets"`
	// As of 22.1 (specifically #74077), leaseholder replicas can remove
	// themselves from the range. This means that now, in a joint state, the
	// leaseholder that is removing itself chooses the best target replica to
	// transfer the lease to, all inside of AdminChangeReplicas.
	//
	// This means that the pre-22.1 contract of `AdminRelocateRange` to transfer
	// the lease to the first voter replica isn't required anymore. Only callers
	// that rely on this contract should set this attribute.
	TransferLeaseToFirstVoter bool `protobuf:"varint,4,opt,name=transfer_lease_to_first_voter,json=transferLeaseToFirstVoter,proto3" json:"transfer_lease_to_first_voter,omitempty"`
	// TODO(aayush): Migration path:
	// 22.1: Send and consult the attribute.
	// 22.2: Send but don't consult the attribute.
	// 23.1: Stop sending or consulting the attribute. Remove this field.
	TransferLeaseToFirstVoterAccurate bool `protobuf:"varint,5,opt,name=transfer_lease_to_first_voter_accurate,json=transferLeaseToFirstVoterAccurate,proto3" json:"transfer_lease_to_first_voter_accurate,omitempty"`
}

func (m *AdminRelocateRangeRequest) Reset()         { *m = AdminRelocateRangeRequest{} }
func (m *AdminRelocateRangeRequest) String() string { return proto.CompactTextString(m) }
func (*AdminRelocateRangeRequest) ProtoMessage()    {}
func (*AdminRelocateRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{47}
}
func (m *AdminRelocateRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminRelocateRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminRelocateRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminRelocateRangeRequest.Merge(m, src)
}
func (m *AdminRelocateRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminRelocateRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminRelocateRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminRelocateRangeRequest proto.InternalMessageInfo

type AdminRelocateRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminRelocateRangeResponse) Reset()         { *m = AdminRelocateRangeResponse{} }
func (m *AdminRelocateRangeResponse) String() string { return proto.CompactTextString(m) }
func (*AdminRelocateRangeResponse) ProtoMessage()    {}
func (*AdminRelocateRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{48}
}
func (m *AdminRelocateRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminRelocateRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminRelocateRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminRelocateRangeResponse.Merge(m, src)
}
func (m *AdminRelocateRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminRelocateRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminRelocateRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminRelocateRangeResponse proto.InternalMessageInfo

// A HeartbeatTxnRequest is arguments to the HeartbeatTxn()
// method. It's sent by transaction coordinators to let the system
// know that the transaction is still ongoing. Note that this
// heartbeat message is different from the heartbeat message in the
// gossip protocol.
type HeartbeatTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// NOTE: this could use a ClockTimestamp type, but doing so results in a
	// large diff that doesn't seem worth it, given that we never feed this
	// timestamp back into a clock.
	Now hlc.Timestamp `protobuf:"bytes,2,opt,name=now,proto3" json:"now"`
}

func (m *HeartbeatTxnRequest) Reset()         { *m = HeartbeatTxnRequest{} }
func (m *HeartbeatTxnRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatTxnRequest) ProtoMessage()    {}
func (*HeartbeatTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{49}
}
func (m *HeartbeatTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeartbeatTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatTxnRequest.Merge(m, src)
}
func (m *HeartbeatTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatTxnRequest proto.InternalMessageInfo

// A HeartbeatTxnResponse is the return value from the HeartbeatTxn()
// method. It returns the transaction info in the response header. The
// returned transaction lets the coordinator know the disposition of
// the transaction (i.e. aborted, committed, or pending).
type HeartbeatTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *HeartbeatTxnResponse) Reset()         { *m = HeartbeatTxnResponse{} }
func (m *HeartbeatTxnResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatTxnResponse) ProtoMessage()    {}
func (*HeartbeatTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{50}
}
func (m *HeartbeatTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeartbeatTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatTxnResponse.Merge(m, src)
}
func (m *HeartbeatTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatTxnResponse proto.InternalMessageInfo

// A GCRequest is arguments to the GC() method. It's sent by range
// lease holders after scanning range data to find expired MVCC values.
type GCRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Keys          []GCRequest_GCKey      `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys"`
	RangeKeys     []GCRequest_GCRangeKey `protobuf:"bytes,6,rep,name=range_keys,json=rangeKeys,proto3" json:"range_keys"`
	// Threshold is the expiration timestamp.
	Threshold hlc.Timestamp `protobuf:"bytes,4,opt,name=threshold,proto3" json:"threshold"`
	// GCClearRange specifies a span that will be GCed using a Pebble range
	// tombstone. This is not a generalized operation, it currently only has two
	// very specialized modes:
	//
	// 1. Empty StartKeyTimestamp: used to delete an entire Raft range, both point
	// keys and range keys. StartKey and EndKey must exactly match the Raft range
	// bounds, and all data (including point tombstones) must be covered by
	// an MVCC range tombstone, otherwise an error is returned. This is intended
	// for use with SQL schema GC, which deletes e.g. an entire table using a
	// single MVCC range tombstone.
	//
	// 2. Non-empty StartKeyTimestamp: deletes only point key versions in the span
	// [StartKey@StartKeyTimestamp, EndKey), leaving newer versions of StartKey
	// and all MVCC range keys intact. This is intended for bulk GC of long runs
	// of point key garbage, with range keys GCed separately.
	//
	// In both cases, the request will error if any data is found above the GC
	// threshold.
	// TODO: generalize this to clear both point keys and range keys in an
	// arbitrary key span (with or without a start key timestamp). The GC code
	// currently isn't structured in a way that can easily process point keys and
	// range keys simultaneously.
	ClearRange *GCRequest_GCClearRange `protobuf:"bytes,7,opt,name=clear_range,json=clearRange,proto3" json:"clear_range,omitempty"`
}

func (m *GCRequest) Reset()         { *m = GCRequest{} }
func (m *GCRequest) String() string { return proto.CompactTextString(m) }
func (*GCRequest) ProtoMessage()    {}
func (*GCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{51}
}
func (m *GCRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest.Merge(m, src)
}
func (m *GCRequest) XXX_Size() int {
	return m.Size()
}
func (m *GCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest proto.InternalMessageInfo

type GCRequest_GCKey struct {
	Key       github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	Timestamp hlc.Timestamp                                    `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *GCRequest_GCKey) Reset()         { *m = GCRequest_GCKey{} }
func (m *GCRequest_GCKey) String() string { return proto.CompactTextString(m) }
func (*GCRequest_GCKey) ProtoMessage()    {}
func (*GCRequest_GCKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{51, 0}
}
func (m *GCRequest_GCKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRequest_GCKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCRequest_GCKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest_GCKey.Merge(m, src)
}
func (m *GCRequest_GCKey) XXX_Size() int {
	return m.Size()
}
func (m *GCRequest_GCKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest_GCKey.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest_GCKey proto.InternalMessageInfo

type GCRequest_GCRangeKey struct {
	StartKey  github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"start_key,omitempty"`
	EndKey    github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"end_key,omitempty"`
	Timestamp hlc.Timestamp                                    `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *GCRequest_GCRangeKey) Reset()         { *m = GCRequest_GCRangeKey{} }
func (m *GCRequest_GCRangeKey) String() string { return proto.CompactTextString(m) }
func (*GCRequest_GCRangeKey) ProtoMessage()    {}
func (*GCRequest_GCRangeKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{51, 1}
}
func (m *GCRequest_GCRangeKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRequest_GCRangeKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCRequest_GCRangeKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest_GCRangeKey.Merge(m, src)
}
func (m *GCRequest_GCRangeKey) XXX_Size() int {
	return m.Size()
}
func (m *GCRequest_GCRangeKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest_GCRangeKey.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest_GCRangeKey proto.InternalMessageInfo

// GCClearRange contains a range for GC requests that would use
// pebble range tombstones to delete data.
type GCRequest_GCClearRange struct {
	StartKey          github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"start_key,omitempty"`
	EndKey            github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"end_key,omitempty"`
	StartKeyTimestamp hlc.Timestamp                                    `protobuf:"bytes,3,opt,name=start_key_timestamp,json=startKeyTimestamp,proto3" json:"start_key_timestamp"`
}

func (m *GCRequest_GCClearRange) Reset()         { *m = GCRequest_GCClearRange{} }
func (m *GCRequest_GCClearRange) String() string { return proto.CompactTextString(m) }
func (*GCRequest_GCClearRange) ProtoMessage()    {}
func (*GCRequest_GCClearRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{51, 2}
}
func (m *GCRequest_GCClearRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRequest_GCClearRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCRequest_GCClearRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest_GCClearRange.Merge(m, src)
}
func (m *GCRequest_GCClearRange) XXX_Size() int {
	return m.Size()
}
func (m *GCRequest_GCClearRange) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest_GCClearRange.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest_GCClearRange proto.InternalMessageInfo

// A GCResponse is the return value from the GC() method.
type GCResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *GCResponse) Reset()         { *m = GCResponse{} }
func (m *GCResponse) String() string { return proto.CompactTextString(m) }
func (*GCResponse) ProtoMessage()    {}
func (*GCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{52}
}
func (m *GCResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCResponse.Merge(m, src)
}
func (m *GCResponse) XXX_Size() int {
	return m.Size()
}
func (m *GCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GCResponse proto.InternalMessageInfo

// A PushTxnRequest is arguments to the PushTxn() method. It's sent by
// readers or writers which have encountered an "intent" laid down by
// another transaction. The goal is to resolve the conflict. Note that
// args.Key should be set to the txn ID of args.PusheeTxn, not
// args.PusherTxn. This RPC is addressed to the range which owns the pushee's
// txn record.
//
// Resolution is trivial if the txn which owns the intent has either
// been committed or aborted already. Otherwise, the existing txn can
// either be aborted (for write/write conflicts), or its commit
// timestamp can be moved forward (for read/write conflicts). The
// course of action is determined by the specified push type, and by
// the owning txn's status and priority.
type PushTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Transaction which encountered the intent, if applicable. For a
	// non-transactional pusher, pusher_txn will only have the priority set (in
	// particular, ID won't be set). Used to compare priorities and timestamps if
	// priorities are equal.
	PusherTxn roachpb.Transaction `protobuf:"bytes,2,opt,name=pusher_txn,json=pusherTxn,proto3" json:"pusher_txn"`
	// Transaction to be pushed, as specified at the intent which led to
	// the push transaction request. Note that this may not be the most
	// up-to-date value of the transaction record, but will be set or
	// merged as appropriate.
	PusheeTxn enginepb.TxnMeta `protobuf:"bytes,3,opt,name=pushee_txn,json=pusheeTxn,proto3" json:"pushee_txn"`
	// PushTo is the timestamp which PusheeTxn should be pushed to. During
	// conflict resolution, it should be set just after the timestamp of the
	// conflicting read or write.
	PushTo hlc.Timestamp `protobuf:"bytes,4,opt,name=push_to,json=pushTo,proto3" json:"push_to"`
	// Readers set this to PUSH_TIMESTAMP to move pushee_txn's provisional
	// commit timestamp forward. Writers set this to PUSH_ABORT to request
	// that pushee_txn be aborted if possible. Inconsistent readers set
	// this to PUSH_TOUCH to determine whether the pushee can be aborted
	// due to inactivity (based on the now field).
	PushType PushTxnType `protobuf:"varint,6,opt,name=push_type,json=pushType,proto3,enum=cockroach.roachpb.PushTxnType" json:"push_type,omitempty"`
	// Forces the push by overriding the normal expiration and priority checks
	// in PushTxn to either abort or push the timestamp.
	Force bool `protobuf:"varint,7,opt,name=force,proto3" json:"force,omitempty"`
}

func (m *PushTxnRequest) Reset()         { *m = PushTxnRequest{} }
func (m *PushTxnRequest) String() string { return proto.CompactTextString(m) }
func (*PushTxnRequest) ProtoMessage()    {}
func (*PushTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{53}
}
func (m *PushTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PushTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTxnRequest.Merge(m, src)
}
func (m *PushTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushTxnRequest proto.InternalMessageInfo

// A PushTxnResponse is the return value from the PushTxn() method. It
// returns success and the resulting state of PusheeTxn if the
// conflict was resolved in favor of the caller; the caller should
// subsequently invoke ResolveIntent() on the conflicted key. It
// returns an error otherwise.
type PushTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// pushee_txn is non-nil if the transaction was pushed and contains
	// the current value of the transaction.
	// TODO(tschottdorf): Maybe this can be a TxnMeta instead; probably requires
	// factoring out the new Priority.
	PusheeTxn roachpb.Transaction `protobuf:"bytes,2,opt,name=pushee_txn,json=pusheeTxn,proto3" json:"pushee_txn"`
	// ambiguous_abort is true if pushee_txn has status ABORTED, but the
	// transaction may in fact have been committed and GCed already. Concretely,
	// this means that the transaction record does not exist, but it may have
	// existed in the past (according to the timestamp cache), and we can't know
	// whether it committed or aborted so we pessimistically assume it aborted.
	//
	// NB: this field was added in a patch release, and is not guaranteed to be
	// populated prior to 24.1.
	AmbiguousAbort bool `protobuf:"varint,3,opt,name=ambiguous_abort,json=ambiguousAbort,proto3" json:"ambiguous_abort,omitempty"`
}

func (m *PushTxnResponse) Reset()         { *m = PushTxnResponse{} }
func (m *PushTxnResponse) String() string { return proto.CompactTextString(m) }
func (*PushTxnResponse) ProtoMessage()    {}
func (*PushTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{54}
}
func (m *PushTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PushTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTxnResponse.Merge(m, src)
}
func (m *PushTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *PushTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushTxnResponse proto.InternalMessageInfo

// A RecoverTxnRequest is arguments to the RecoverTxn() method. It is sent
// during the recovery process for a transaction abandoned in the STAGING state.
// The sender is expected to have queried all of the abandoned transaction's
// in-flight writes and determined whether they all succeeded or not. This is
// used to determine whether the result of the recovery should be committing the
// abandoned transaction or aborting it.
type RecoverTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Transaction record to recover.
	Txn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	// Did all of the STAGING transaction's writes succeed? If so, the transaction
	// is implicitly committed and the commit can be made explicit by giving its
	// record a COMMITTED status. If not, the transaction can be aborted as long
	// as a write that was found to have failed was prevented from ever succeeding
	// in the future.
	ImplicitlyCommitted bool `protobuf:"varint,3,opt,name=implicitly_committed,json=implicitlyCommitted,proto3" json:"implicitly_committed,omitempty"`
}

func (m *RecoverTxnRequest) Reset()         { *m = RecoverTxnRequest{} }
func (m *RecoverTxnRequest) String() string { return proto.CompactTextString(m) }
func (*RecoverTxnRequest) ProtoMessage()    {}
func (*RecoverTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{55}
}
func (m *RecoverTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoverTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoverTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoverTxnRequest.Merge(m, src)
}
func (m *RecoverTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoverTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoverTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoverTxnRequest proto.InternalMessageInfo

// A RecoverTxnResponse is the return value from the RecoverTxn() method.
type RecoverTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Contains the finalized state of the recovered transaction.
	RecoveredTxn roachpb.Transaction `protobuf:"bytes,2,opt,name=recovered_txn,json=recoveredTxn,proto3" json:"recovered_txn"`
}

func (m *RecoverTxnResponse) Reset()         { *m = RecoverTxnResponse{} }
func (m *RecoverTxnResponse) String() string { return proto.CompactTextString(m) }
func (*RecoverTxnResponse) ProtoMessage()    {}
func (*RecoverTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{56}
}
func (m *RecoverTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoverTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoverTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoverTxnResponse.Merge(m, src)
}
func (m *RecoverTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoverTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoverTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoverTxnResponse proto.InternalMessageInfo

// A QueryTxnRequest is arguments to the QueryTxn() method. It's sent
// by transactions which are waiting to push another transaction because
// of conflicting write intents to fetch updates to either the pusher's
// or the pushee's transaction records.
type QueryTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Transaction record to query.
	Txn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	// If true, the query will not return until there are changes to either the
	// transaction status or priority -OR- to the set of dependent transactions.
	WaitForUpdate bool `protobuf:"varint,3,opt,name=wait_for_update,json=waitForUpdate,proto3" json:"wait_for_update,omitempty"`
	// Set of known dependent transactions.
	KnownWaitingTxns []github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,4,rep,name=known_waiting_txns,json=knownWaitingTxns,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"known_waiting_txns,omitempty"`
}

func (m *QueryTxnRequest) Reset()         { *m = QueryTxnRequest{} }
func (m *QueryTxnRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTxnRequest) ProtoMessage()    {}
func (*QueryTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{57}
}
func (m *QueryTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTxnRequest.Merge(m, src)
}
func (m *QueryTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTxnRequest proto.InternalMessageInfo

// A QueryTxnResponse is the return value from the QueryTxn() method.
type QueryTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Contains the current state of the queried transaction. If a transaction
	// record is not found, one will be synthesized and returned.
	QueriedTxn roachpb.Transaction `protobuf:"bytes,2,opt,name=queried_txn,json=queriedTxn,proto3" json:"queried_txn"`
	// txn_record_exists is set if the queried_txn comes from a transaction record
	// read from the database. If not set, then the txn record was "synthesized".
	//
	// The field only started being populated in 20.2, so 20.1 nodes never set it.
	TxnRecordExists bool `protobuf:"varint,4,opt,name=txn_record_exists,json=txnRecordExists,proto3" json:"txn_record_exists,omitempty"`
	// Specifies a list of transaction IDs which are waiting on the txn.
	WaitingTxns []github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,3,rep,name=waiting_txns,json=waitingTxns,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"waiting_txns,omitempty"`
}

func (m *QueryTxnResponse) Reset()         { *m = QueryTxnResponse{} }
func (m *QueryTxnResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTxnResponse) ProtoMessage()    {}
func (*QueryTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{58}
}
func (m *QueryTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTxnResponse.Merge(m, src)
}
func (m *QueryTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTxnResponse proto.InternalMessageInfo

// A QueryIntentRequest is arguments to the QueryIntent() method. It visits
// the specified key and checks whether an intent is present for the given
// transaction. If the intent is found, it checks whether the intent has a
// timestamp at or below the given transaction's timestamp to determine full
// vs. partial matches. If, on the other hand, the intent is found to be
// missing then it is prevented from ever being written in the future.
type QueryIntentRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The TxnMeta that the intent is expected to have. Specifically, whether an
	// intent is a match or not is defined as whether an intent exists that could
	// be committed by the provided transaction. If an intent is found at the
	// specified key, the intent is only considered a "full match" if it has the
	// same ID, the same epoch, and a write timestamp that is equal to or less
	// than that in the provided transaction.
	//
	// Additionally, the intent is only considered a "full match" if its sequence
	// number is equal to or greater than the expected txn's sequence number. The
	// requests doesn't require an exact sequence number match because the
	// transaction could have performed overlapping writes, in which case only the
	// latest sequence number will remain. We assume that if a transaction has
	// successfully written an intent at a larger sequence number then it must
	// have succeeded in writing an intent at the smaller sequence number as
	// well.
	//
	// The intent is considered to be "pushed" and a "partial match" if it
	// satisfies all conditions above except the timestamp condition. In these
	// cases, the intent can not be committed by the provided transaction at its
	// current provisional commit timestamp, but it could be committed by that
	// transaction at a later commit timestamp. The intent's value can also be
	// read by the provided transaction, even though it has been pushed.
	//
	// QueryIntentRequests may be issued in non-transactional BatchRequests or in
	// transactional BatchRequests. If issued inside of a transaction, the TxnMeta
	// must be a reference to the same transaction as the batch's transaction, or
	// the request will be rejected. In other words, a transaction can only query
	// its own intents. In these cases where the BatchRequest is transactional,
	// the TxnMeta's write timestamp is forwarded by the write timestamp of the
	// request header transaction for purposes of determining whether a matching
	// intent is found or not (see condition above). This is useful to avoid the
	// need to update each QueryIntentRequest when a transaction is querying its
	// own intent after having successfully refreshed.
	Txn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	// If true, return an IntentMissingError if no matching intent (neither a
	// "partial match" nor a "full match") is found.
	ErrorIfMissing bool `protobuf:"varint,3,opt,name=error_if_missing,json=errorIfMissing,proto3" json:"error_if_missing,omitempty"`
	// The strength with which the lock being queried was acquired at. To ensure
	// the supplied protection was provided, we check whether the lock was held
	// with the supplied lock strength or something stronger at the sequence
	// number.
	Strength lock.Strength `protobuf:"varint,4,opt,name=strength,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"strength,omitempty"`
	// The list of sequence numbers that have been ignored by the transaction that
	// acquired the lock. Any locks found at sequence numbers which are considered
	// ignored will be treated as "not found"; that's because they can be removed
	// at any time.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,5,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *QueryIntentRequest) Reset()         { *m = QueryIntentRequest{} }
func (m *QueryIntentRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIntentRequest) ProtoMessage()    {}
func (*QueryIntentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{59}
}
func (m *QueryIntentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIntentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryIntentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIntentRequest.Merge(m, src)
}
func (m *QueryIntentRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIntentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIntentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIntentRequest proto.InternalMessageInfo

// A QueryIntentResponse is the return value from the QueryIntent() method.
type QueryIntentResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Whether an intent matching the expected transaction was found at the key
	// with a timestamp that is equal to or less than that in the provided
	// transaction - a "full match" as defined above.
	FoundUnpushedIntent bool `protobuf:"varint,2,opt,name=found_unpushed_intent,json=foundUnpushedIntent,proto3" json:"found_unpushed_intent,omitempty"`
	// Whether an intent matching the expected transaction was found at the key,
	// regardless of the intent's timestamp  a "partial match" as defined above.
	// found_unpushed_intent implies found_intent.
	FoundIntent bool `protobuf:"varint,3,opt,name=found_intent,json=foundIntent,proto3" json:"found_intent,omitempty"`
}

func (m *QueryIntentResponse) Reset()         { *m = QueryIntentResponse{} }
func (m *QueryIntentResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIntentResponse) ProtoMessage()    {}
func (*QueryIntentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{60}
}
func (m *QueryIntentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIntentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryIntentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIntentResponse.Merge(m, src)
}
func (m *QueryIntentResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIntentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIntentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIntentResponse proto.InternalMessageInfo

// A QueryLocksRequest is arguments to the QueryLocks() method.  It requests
// the state of the locks tracked in the in-memory lock table over the given
// key span, up to a maximum number of results or byte limit, and is used for
// the purposes of observability. It is worth noting that not all locks are
// tracked by the in-memory lock table, since in-memory representations of
// replicated locks without wait queues are garbage collected in order to save
// memory. For more explanation, please see docs/RFCS/20220104_crdb_locks.md
type QueryLocksRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Whether to include locks that do not have wait queues of readers or writers.
	IncludeUncontended bool `protobuf:"varint,2,opt,name=include_uncontended,json=includeUncontended,proto3" json:"include_uncontended,omitempty"`
}

func (m *QueryLocksRequest) Reset()         { *m = QueryLocksRequest{} }
func (m *QueryLocksRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLocksRequest) ProtoMessage()    {}
func (*QueryLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{61}
}
func (m *QueryLocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryLocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLocksRequest.Merge(m, src)
}
func (m *QueryLocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLocksRequest proto.InternalMessageInfo

// A QueryLocksResponse is the return value from the QueryLocks() method.
type QueryLocksResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Locks          []roachpb.LockStateInfo `protobuf:"bytes,2,rep,name=locks,proto3" json:"locks"`
}

func (m *QueryLocksResponse) Reset()         { *m = QueryLocksResponse{} }
func (m *QueryLocksResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLocksResponse) ProtoMessage()    {}
func (*QueryLocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{62}
}
func (m *QueryLocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryLocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLocksResponse.Merge(m, src)
}
func (m *QueryLocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLocksResponse proto.InternalMessageInfo

// A ResolveIntentRequest is arguments to the ResolveIntent()
// method. It is sent by transaction coordinators after success
// calling PushTxn to clean up write intents: either to remove, commit
// or move them forward in time.
type ResolveIntentRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The transaction whose intent is being resolved.
	IntentTxn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=intent_txn,json=intentTxn,proto3" json:"intent_txn"`
	// The status of the transaction.
	Status roachpb.TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	// Optionally poison the abort span for the transaction on the intent's range.
	// The field is ignored if status != ABORTED (i.e. only intents from ABORTED
	// txns ever poison the abort spans).
	Poison bool `protobuf:"varint,4,opt,name=poison,proto3" json:"poison,omitempty"`
	// The list of ignored seqnum ranges as per the Transaction record.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,5,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
	// An optional clock observation from the intent's leaseholder node that was
	// captured at some point before the intent's transaction was pushed and found
	// to be PENDING. The clock observation is used to forward the intent's local
	// timestamp during intent resolution.
	//
	// If the clock observation was captured from a different node than the node
	// which evaluates the ResolveIntent request, it will be ignored and the
	// intent's local timestamp will not be changed. If the observation was not
	// ignored in these cases then intent resolution could be allowed to push the
	// local timestamp of an intent above the clock on its current leaseholder.
	// This could lead to stale reads if that leaseholder later served an observed
	// timestamp with a clock reading below the intent's local timestamp.
	ClockWhilePending roachpb.ObservedTimestamp `protobuf:"bytes,6,opt,name=clock_while_pending,json=clockWhilePending,proto3" json:"clock_while_pending"`
}

func (m *ResolveIntentRequest) Reset()         { *m = ResolveIntentRequest{} }
func (m *ResolveIntentRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentRequest) ProtoMessage()    {}
func (*ResolveIntentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{63}
}
func (m *ResolveIntentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentRequest.Merge(m, src)
}
func (m *ResolveIntentRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentRequest proto.InternalMessageInfo

// A ResolveIntentResponse is the return value from the
// ResolveIntent() method.
type ResolveIntentResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// ReplicatedLocksReleasedCommitTimestamp, if non-empty, indicates that a
	// replicated lock with strength Shared or Exclusive was released by a
	// transaction who committed at this timestamp. Notably, this field is left
	// unset if only a write intent was resolved. The field is also left unset for
	// transactions that aborted.
	//
	// The caller must bump the timestamp cache across the resolution span to this
	// commit timestamp. Doing so ensures that the released lock (acquired by a
	// now committed transaction) continues to provide protection against other
	// writers up to the commit timestamp, even after the lock has been released.
	ReplicatedLocksReleasedCommitTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=replicated_locks_released_commit_timestamp,json=replicatedLocksReleasedCommitTimestamp,proto3" json:"replicated_locks_released_commit_timestamp"`
}

func (m *ResolveIntentResponse) Reset()         { *m = ResolveIntentResponse{} }
func (m *ResolveIntentResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentResponse) ProtoMessage()    {}
func (*ResolveIntentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{64}
}
func (m *ResolveIntentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentResponse.Merge(m, src)
}
func (m *ResolveIntentResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentResponse proto.InternalMessageInfo

// A ResolveIntentRangeRequest is arguments to the ResolveIntentRange() method.
// It is sent by transaction coordinators after success calling PushTxn to
// clean up write intents: either to remove, commit or move them forward in
// time.
type ResolveIntentRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The transaction whose intents are being resolved.
	IntentTxn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=intent_txn,json=intentTxn,proto3" json:"intent_txn"`
	// The status of the transaction.
	Status roachpb.TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	// Optionally poison the abort span for the transaction on all ranges on which
	// the intents reside. The field is ignored if status != ABORTED (i.e. only
	// intents from ABORTED txns ever poison the abort spans).
	Poison bool `protobuf:"varint,4,opt,name=poison,proto3" json:"poison,omitempty"`
	// The minimum timestamp for any intents written by this
	// transaction. If present, this value can be used to optimize the
	// iteration over the span to find intents to resolve.
	MinTimestamp hlc.Timestamp `protobuf:"bytes,5,opt,name=min_timestamp,json=minTimestamp,proto3" json:"min_timestamp"`
	// The list of ignored seqnum ranges as per the Transaction record.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,6,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
	// An optional clock observation from the intent's leaseholder node that was
	// captured at some point before the intent's transaction was pushed and found
	// to be PENDING. The clock observation is used to forward the intent's local
	// timestamp during intent resolution.
	//
	// If the clock observation was captured from a different node than the node
	// which evaluates the ResolveIntentRange request, it will be ignored and the
	// intent's local timestamp will not be changed. If the observation was not
	// ignored in these cases then intent resolution could be allowed to push the
	// local timestamp of an intent above the clock on its current leaseholder.
	// This could lead to stale reads if that leaseholder later served an observed
	// timestamp with a clock reading below the intent's local timestamp.
	ClockWhilePending roachpb.ObservedTimestamp `protobuf:"bytes,7,opt,name=clock_while_pending,json=clockWhilePending,proto3" json:"clock_while_pending"`
}

func (m *ResolveIntentRangeRequest) Reset()         { *m = ResolveIntentRangeRequest{} }
func (m *ResolveIntentRangeRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentRangeRequest) ProtoMessage()    {}
func (*ResolveIntentRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{65}
}
func (m *ResolveIntentRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentRangeRequest.Merge(m, src)
}
func (m *ResolveIntentRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentRangeRequest proto.InternalMessageInfo

// A ResolveIntentRangeResponse is the return value from the
// ResolveIntent() method.
type ResolveIntentRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// ReplicatedLocksReleasedCommitTimestamp, if non-empty, indicates that at
	// least one replicated lock with strength Shared or Exclusive was released by
	// a transaction who committed at this timestamp. Notably, this field is left
	// unset if only a write intent was resolved. The field is also left unset for
	// transactions that aborted.
	//
	// The caller must bump the timestamp cache across the resolution span to this
	// commit timestamp. Doing so ensures that the released lock (acquired by a
	// now committed transaction) continues to provide protection against other
	// writers up to the commit timestamp, even after the lock has been released.
	ReplicatedLocksReleasedCommitTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=replicated_locks_released_commit_timestamp,json=replicatedLocksReleasedCommitTimestamp,proto3" json:"replicated_locks_released_commit_timestamp"`
}

func (m *ResolveIntentRangeResponse) Reset()         { *m = ResolveIntentRangeResponse{} }
func (m *ResolveIntentRangeResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentRangeResponse) ProtoMessage()    {}
func (*ResolveIntentRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{66}
}
func (m *ResolveIntentRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentRangeResponse.Merge(m, src)
}
func (m *ResolveIntentRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentRangeResponse proto.InternalMessageInfo

// A MergeRequest contains arguments to the Merge() method. It
// specifies a key and a value which should be merged into the
// existing value at that key.
type MergeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value         roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *MergeRequest) Reset()         { *m = MergeRequest{} }
func (m *MergeRequest) String() string { return proto.CompactTextString(m) }
func (*MergeRequest) ProtoMessage()    {}
func (*MergeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{67}
}
func (m *MergeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeRequest.Merge(m, src)
}
func (m *MergeRequest) XXX_Size() int {
	return m.Size()
}
func (m *MergeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MergeRequest proto.InternalMessageInfo

// MergeResponse is the response to a Merge() operation.
type MergeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *MergeResponse) Reset()         { *m = MergeResponse{} }
func (m *MergeResponse) String() string { return proto.CompactTextString(m) }
func (*MergeResponse) ProtoMessage()    {}
func (*MergeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{68}
}
func (m *MergeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeResponse.Merge(m, src)
}
func (m *MergeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MergeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MergeResponse proto.InternalMessageInfo

// TruncateLogRequest is used to remove a prefix of the raft log. While there
// is no requirement for correctness that the raft log truncation be synchronized across
// replicas, it is nice to preserve the property that all replicas of a range are as close
// to identical as possible. The raft leader can also inform decisions about the cutoff point
// with its knowledge of the replicas' acknowledgment status.
type TruncateLogRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Log entries < this index are to be discarded.
	Index RaftIndex `protobuf:"varint,2,opt,name=index,proto3,casttype=RaftIndex" json:"index,omitempty"`
	// RangeID is used to double check that the correct range is being truncated.
	// The header specifies a span, start and end keys, but not the range id
	// itself. The range may have changed from the one specified in the header
	// in the case of a merge.
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,3,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// ExpectedFirstIndex is the expected Index of the last TruncateLogRequest,
	// i.e., we expect that this request will typically be truncating entries
	// [ExpectedFirstIndex, Index).
	//
	// There is no correctness issue if the replica applying this truncation has
	// not seen the preceding TruncateLogRequest or has seen one with an Index
	// that is not equal to ExpectedFirstIndex. This is an optimization that
	// typically allows the potentially expensive computation of the bytes being
	// discarded from the raft log to be performed once, at the leaseholder.
	ExpectedFirstIndex RaftIndex `protobuf:"varint,4,opt,name=expected_first_index,json=expectedFirstIndex,proto3,casttype=RaftIndex" json:"expected_first_index,omitempty"`
}

func (m *TruncateLogRequest) Reset()         { *m = TruncateLogRequest{} }
func (m *TruncateLogRequest) String() string { return proto.CompactTextString(m) }
func (*TruncateLogRequest) ProtoMessage()    {}
func (*TruncateLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{69}
}
func (m *TruncateLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TruncateLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateLogRequest.Merge(m, src)
}
func (m *TruncateLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *TruncateLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateLogRequest proto.InternalMessageInfo

// TruncateLogResponse is the response to a TruncateLog() operation.
type TruncateLogResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *TruncateLogResponse) Reset()         { *m = TruncateLogResponse{} }
func (m *TruncateLogResponse) String() string { return proto.CompactTextString(m) }
func (*TruncateLogResponse) ProtoMessage()    {}
func (*TruncateLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{70}
}
func (m *TruncateLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TruncateLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateLogResponse.Merge(m, src)
}
func (m *TruncateLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *TruncateLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateLogResponse proto.InternalMessageInfo

// A RequestLeaseRequest is arguments to the RequestLease()
// method. It is sent by the store on behalf of one of its ranges upon receipt
// of a command requiring a lease when none is found.
type RequestLeaseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Lease         roachpb.Lease `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	// The previous lease is specified by the caller to verify
	// it has not changed when executing this command.
	PrevLease roachpb.Lease `protobuf:"bytes,3,opt,name=prev_lease,json=prevLease,proto3" json:"prev_lease"`
	// RevokePrevAndForwardExpiration indicates that the previous lease should be
	// explicitly revoked when acquiring the new lease. Then, after doing so, the
	// expiration of the next lease should be forwarded beyond the expiration of
	// the previous lease. This is used to prevent expiration regressions during
	// lease type switches.
	RevokePrevAndForwardExpiration bool `protobuf:"varint,5,opt,name=revoke_prev_and_forward_expiration,json=revokePrevAndForwardExpiration,proto3" json:"revoke_prev_and_forward_expiration,omitempty"`
}

func (m *RequestLeaseRequest) Reset()         { *m = RequestLeaseRequest{} }
func (m *RequestLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*RequestLeaseRequest) ProtoMessage()    {}
func (*RequestLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{71}
}
func (m *RequestLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestLeaseRequest.Merge(m, src)
}
func (m *RequestLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *RequestLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RequestLeaseRequest proto.InternalMessageInfo

// A TransferLeaseRequest represents the arguments to the TransferLease()
// method. It is sent by a replica that currently holds the range lease and
// wants to transfer it away.
//
// Like a RequestLeaseRequest, this request has the effect of instituting a new
// lease. The difference is that the new lease is allowed to overlap the
// existing one. It is a separate request because the RequestLeaseRequest is
// special - it's not subject to the same replay protection restrictions as
// other requests, instead being protected from replays by the fact that leases
// are not generally allowed to overlap. The TransferLeaseRequest is not
// special in this respect (for example, the proposer of this command is
// checked to have been holding the lease when the proposal was made).
type TransferLeaseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Lease         roachpb.Lease `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	// The previous lease is specified by the caller to verify
	// it has not changed when executing this command.
	PrevLease roachpb.Lease `protobuf:"bytes,3,opt,name=prev_lease,json=prevLease,proto3" json:"prev_lease"`
	// When set to true, bypass_safety_checks configures the lease transfer to
	// skip safety checks that ensure that the transfer target is known to be
	// (according to the outgoing leaseholder) alive and sufficiently caught up on
	// its log. This option should be used sparingly  typically only by outgoing
	// leaseholders who both have some other reason to believe that the target is
	// alive and caught up on its log (e.g. they just sent it a snapshot) and also
	// can't tolerate rejected lease transfers.
	BypassSafetyChecks bool `protobuf:"varint,4,opt,name=bypass_safety_checks,json=bypassSafetyChecks,proto3" json:"bypass_safety_checks,omitempty"`
}

func (m *TransferLeaseRequest) Reset()         { *m = TransferLeaseRequest{} }
func (m *TransferLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*TransferLeaseRequest) ProtoMessage()    {}
func (*TransferLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{72}
}
func (m *TransferLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransferLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaseRequest.Merge(m, src)
}
func (m *TransferLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaseRequest proto.InternalMessageInfo

// LeaseInfoRequest is the argument to the LeaseInfo() method, for getting
// information about a range's lease.
// It's a point request, so it addresses one single range, and returns the lease
// currently in effect for that range. This request is commonly set with
// ReadConsistency=INCONSISTENT in order for the request to be served by the
// node to whom the request was sent.
type LeaseInfoRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *LeaseInfoRequest) Reset()         { *m = LeaseInfoRequest{} }
func (m *LeaseInfoRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseInfoRequest) ProtoMessage()    {}
func (*LeaseInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{73}
}
func (m *LeaseInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeaseInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseInfoRequest.Merge(m, src)
}
func (m *LeaseInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseInfoRequest proto.InternalMessageInfo

// LeaseInfoResponse is the response to a LeaseInfo() operation.
type LeaseInfoResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The last lease known by the replica serving the request. It can also be the
	// tentative future lease, if a lease transfer is in progress.
	Lease roachpb.Lease `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	// current_lease is set if `lease` represents a tentative future lease. In
	// that case, current_lease represents the lease that's currently in effect.
	CurrentLease *roachpb.Lease `protobuf:"bytes,3,opt,name=current_lease,json=currentLease,proto3" json:"current_lease,omitempty"`
	// evaluated_by returns the store that evaluated this request. This
	// corresponds to the leaseholder unless ReadConsistency=INCONSISTENT was
	// used. The response reflects the evaluator's view of the lease. When the
	// client cares to see a particular node's view, it can use this field to
	// check whether the node it intended query (by sending the request to that
	// node and using ReadConsistency=INCONSISTENT) indeed served it - it's
	// possible that even if ReadConsistency=INCONSISTENT was used, the request is
	// still not evaluated by the node it was sent to if that node's replica is a
	// learner or the node doesn't have a replica at all.
	EvaluatedBy github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,4,opt,name=evaluated_by,json=evaluatedBy,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"evaluated_by,omitempty"`
}

func (m *LeaseInfoResponse) Reset()         { *m = LeaseInfoResponse{} }
func (m *LeaseInfoResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseInfoResponse) ProtoMessage()    {}
func (*LeaseInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{74}
}
func (m *LeaseInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeaseInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseInfoResponse.Merge(m, src)
}
func (m *LeaseInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseInfoResponse proto.InternalMessageInfo

// A RequestLeaseResponse is the response to a RequestLease() or TransferLease()
// operation.
type RequestLeaseResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RequestLeaseResponse) Reset()         { *m = RequestLeaseResponse{} }
func (m *RequestLeaseResponse) String() string { return proto.CompactTextString(m) }
func (*RequestLeaseResponse) ProtoMessage()    {}
func (*RequestLeaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{75}
}
func (m *RequestLeaseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestLeaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestLeaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestLeaseResponse.Merge(m, src)
}
func (m *RequestLeaseResponse) XXX_Size() int {
	return m.Size()
}
func (m *RequestLeaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestLeaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RequestLeaseResponse proto.InternalMessageInfo

// A ComputeChecksumRequest is arguments to the ComputeChecksum() method, to
// start computing the checksum for the specified range at the snapshot for this
// request command. A response is returned without the checksum. The computed
// checksum is retrieved via a storage.CollectChecksumRequest.
type ComputeChecksumRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The version used to pick the checksum method. It allows us to use a
	// consistent checksumming method across replicas.
	Version uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// The type of checksum to compute. See ChecksumMode.
	Mode ChecksumMode `protobuf:"varint,5,opt,name=mode,proto3,enum=cockroach.roachpb.ChecksumMode" json:"mode,omitempty"`
	// If set, a checkpoint (i.e. cheap backup) of the storage engine will be
	// taken. This is expected to be set only if we already know that there is a
	// problem, and we want to preserve as much state as possible. The checkpoint
	// will be stored in the engine's auxiliary directory, and needs to be removed
	// manually to avoid leaking disk space.
	Checkpoint bool `protobuf:"varint,6,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// If non-empty, specifies the replicas which are the most likely source of
	// the inconsistency. After evaluating the command, they will terminate. This
	// is used together with the Checkpoint field, as part of a second round, when
	// the first round found a divergence. The second round is concerned with
	// damage control, and shuts down the nodes with suspected anomalous data, so
	// that this data isn't served to clients or spread to other replicas.
	Terminate []roachpb.ReplicaDescriptor `protobuf:"bytes,7,rep,name=terminate,proto3" json:"terminate"`
}

func (m *ComputeChecksumRequest) Reset()         { *m = ComputeChecksumRequest{} }
func (m *ComputeChecksumRequest) String() string { return proto.CompactTextString(m) }
func (*ComputeChecksumRequest) ProtoMessage()    {}
func (*ComputeChecksumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{76}
}
func (m *ComputeChecksumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeChecksumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputeChecksumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeChecksumRequest.Merge(m, src)
}
func (m *ComputeChecksumRequest) XXX_Size() int {
	return m.Size()
}
func (m *ComputeChecksumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeChecksumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeChecksumRequest proto.InternalMessageInfo

// A ComputeChecksumResponse is the response to a ComputeChecksum() operation.
type ComputeChecksumResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// ChecksumID is the unique identifier that can be used to get the computed
	// checksum in a future storage.CollectChecksumRequest.
	ChecksumID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,2,opt,name=checksum_id,json=checksumId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"checksum_id"`
}

func (m *ComputeChecksumResponse) Reset()         { *m = ComputeChecksumResponse{} }
func (m *ComputeChecksumResponse) String() string { return proto.CompactTextString(m) }
func (*ComputeChecksumResponse) ProtoMessage()    {}
func (*ComputeChecksumResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{77}
}
func (m *ComputeChecksumResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeChecksumResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputeChecksumResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeChecksumResponse.Merge(m, src)
}
func (m *ComputeChecksumResponse) XXX_Size() int {
	return m.Size()
}
func (m *ComputeChecksumResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeChecksumResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeChecksumResponse proto.InternalMessageInfo

// RetryTracingEvent is the trace recording used to track retries.
//
// TODO(adityamaru): Delete in 23.2 since we have stopped emitting this
// StructuredEvent in 23.1.
type RetryTracingEvent struct {
	Operation     string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	AttemptNumber int32  `protobuf:"varint,2,opt,name=attempt_number,json=attemptNumber,proto3" json:"attempt_number,omitempty"`
	RetryError    string `protobuf:"bytes,3,opt,name=retry_error,json=retryError,proto3" json:"retry_error,omitempty"`
}

func (m *RetryTracingEvent) Reset()         { *m = RetryTracingEvent{} }
func (m *RetryTracingEvent) String() string { return proto.CompactTextString(m) }
func (*RetryTracingEvent) ProtoMessage()    {}
func (*RetryTracingEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{78}
}
func (m *RetryTracingEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryTracingEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RetryTracingEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryTracingEvent.Merge(m, src)
}
func (m *RetryTracingEvent) XXX_Size() int {
	return m.Size()
}
func (m *RetryTracingEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryTracingEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RetryTracingEvent proto.InternalMessageInfo

// FileEncryptionOptions stores information needed by KV level requests (egs:
// ExportRequest) to encrypt or decrypt data.
type FileEncryptionOptions struct {
	// Key specifies the key to use for encryption or decryption.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *FileEncryptionOptions) Reset()         { *m = FileEncryptionOptions{} }
func (m *FileEncryptionOptions) String() string { return proto.CompactTextString(m) }
func (*FileEncryptionOptions) ProtoMessage()    {}
func (*FileEncryptionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{79}
}
func (m *FileEncryptionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileEncryptionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileEncryptionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileEncryptionOptions.Merge(m, src)
}
func (m *FileEncryptionOptions) XXX_Size() int {
	return m.Size()
}
func (m *FileEncryptionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FileEncryptionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FileEncryptionOptions proto.InternalMessageInfo

// ExportRequest is the argument to the Export() method, to dump a keyrange into
// files under a basepath.
type ExportRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// ResumeKeyTS allows export request to resume at arbitrary key timestamp. This
	// value doesn't affect export bounds, but ensures that no keys are skipped or
	// duplicated when previous request doesn't complete fully and returned EndKeyTS
	// together with resume span.
	ResumeKeyTS hlc.Timestamp `protobuf:"bytes,12,opt,name=resume_key_ts,json=resumeKeyTs,proto3" json:"resume_key_ts"`
	// MVCCFilter determines if request exports all data or latest data as of
	// Timestamp specified in request header. If all data is requested StartTime
	// is used as a lower bound and header Timestamp as higher bound or exported
	// entries.
	MVCCFilter MVCCFilter `protobuf:"varint,4,opt,name=mvcc_filter,json=mvccFilter,proto3,enum=cockroach.roachpb.MVCCFilter" json:"mvcc_filter,omitempty"`
	// StartTime is only used when MVCCFilter is set to All.
	StartTime hlc.Timestamp `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	// Split large rows in the middle of key sequence. This option will allow
	// large history being broken up into target_file_size chunks and prevent
	// blowing up on memory usage. This option is only allowed together with
	// return_sst since caller should reconstruct full tables.
	//
	// NB: If the result contains MVCC range tombstones, this can cause MVCC range
	// tombstones in two subsequent SSTs to overlap. For example, given the range
	// tombstone [a-f)@5, if we stop between c@4 and c@2 and return a resume key c@2,
	// then the response will contain a truncated MVCC range tombstone [a-c\0)@5
	// which covers the point key at c, but resuming from c@2 will contain the
	// MVCC range tombstone [c-f)@5 which overlaps with the MVCC range tombstone
	// in the previous response in the interval [c-c\0)@5. This overlap will not
	// cause problems with multiplexed iteration using NewSSTIterator(), nor when
	// ingesting the SSTs via `AddSSTable`.
	SplitMidKey bool                   `protobuf:"varint,13,opt,name=split_mid_key,json=splitMidKey,proto3" json:"split_mid_key,omitempty"`
	Encryption  *FileEncryptionOptions `protobuf:"bytes,9,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// TargetFileSize is the byte size target for individual files in the
	// response. If the MVCCFilter is Latest, the returned files will only be
	// larger than this value if an individual KV pair is larger than this value.
	// If the MVCCFilter is All then the file may exceed this value by at most the
	// size of all versions of a single key. If TargetFileSize is non-positive
	// then there is no limit.
	TargetFileSize int64 `protobuf:"varint,10,opt,name=target_file_size,json=targetFileSize,proto3" json:"target_file_size,omitempty"`
	// ExportFingerprint when set to true will result in ExportRequest command
	// evaluation generating an fnv64 hash for every key/timestamp and value, for
	// point keys encountered in the key/time interval. Each KV hash will be
	// combined via a XOR into a running aggregate that is returned as part of the
	// ExportResponse.
	//
	// Range keys are not fingerprinted but instead written to a pebble SST that
	// is returned to the caller. This is because range keys do not have a stable,
	// discrete identity. A range key can span multiple ranges, or it may be
	// fragmented by range keys outside of the time bounds which are not relevant
	// to the fingerprint. So, we could need multiple export requests to piece
	// together the entire rangekey before fingerprinting it. It is up to the
	// caller to define a deterministic fingerprinting scheme across all returned
	// range keys.
	ExportFingerprint  bool               `protobuf:"varint,14,opt,name=export_fingerprint,json=exportFingerprint,proto3" json:"export_fingerprint,omitempty"`
	FingerprintOptions FingerprintOptions `protobuf:"bytes,15,opt,name=fingerprint_options,json=fingerprintOptions,proto3" json:"fingerprint_options"`
	// IncludeMVCCValueHeader controls whether the MVCCValueHeader is
	// included in exported bytes. Callers should only set this when all
	// readers of the returned SST are prepared to parse full a
	// MVCCValue. Even when set, only fields appropriate for export are
	// included. See storage.EncodeMVCCValueForExport for details.
	IncludeMVCCValueHeader bool `protobuf:"varint,16,opt,name=include_mvcc_value_header,json=includeMvccValueHeader,proto3" json:"include_mvcc_value_header,omitempty"`
}

func (m *ExportRequest) Reset()         { *m = ExportRequest{} }
func (m *ExportRequest) String() string { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()    {}
func (*ExportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{80}
}
func (m *ExportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportRequest.Merge(m, src)
}
func (m *ExportRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportRequest proto.InternalMessageInfo

type FingerprintOptions struct {
	StripIndexPrefixAndTimestamp bool `protobuf:"varint,1,opt,name=strip_index_prefix_and_timestamp,json=stripIndexPrefixAndTimestamp,proto3" json:"strip_index_prefix_and_timestamp,omitempty"`
}

func (m *FingerprintOptions) Reset()         { *m = FingerprintOptions{} }
func (m *FingerprintOptions) String() string { return proto.CompactTextString(m) }
func (*FingerprintOptions) ProtoMessage()    {}
func (*FingerprintOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{81}
}
func (m *FingerprintOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FingerprintOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FingerprintOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FingerprintOptions.Merge(m, src)
}
func (m *FingerprintOptions) XXX_Size() int {
	return m.Size()
}
func (m *FingerprintOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FingerprintOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FingerprintOptions proto.InternalMessageInfo

// BulkOpSummary summarizes the data processed by an operation, counting the
// total size as well as number of entries processed in each index (from which
// row counts can be derived).
type BulkOpSummary struct {
	// DataSize is the sum of key and value lengths.
	DataSize int64 `protobuf:"varint,1,opt,name=data_size,json=dataSize,proto3" json:"data_size,omitempty"`
	// SSTDataSize is the size of the SST, post compression, sent to KV.
	SSTDataSize int64 `protobuf:"varint,6,opt,name=sst_data_size,json=sstDataSize,proto3" json:"sst_data_size,omitempty"`
	// EntryCounts contains the number of keys processed for each tableID/indexID
	// pair, stored under the key (tableID << 32) | indexID. This EntryCount key
	// generation logic is also available in the BulkOpSummaryID helper. It does
	// not take MVCC range tombstones into account.
	EntryCounts map[uint64]int64 `protobuf:"bytes,5,rep,name=entry_counts,json=entryCounts,proto3" json:"entry_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *BulkOpSummary) Reset()         { *m = BulkOpSummary{} }
func (m *BulkOpSummary) String() string { return proto.CompactTextString(m) }
func (*BulkOpSummary) ProtoMessage()    {}
func (*BulkOpSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{82}
}
func (m *BulkOpSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkOpSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BulkOpSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkOpSummary.Merge(m, src)
}
func (m *BulkOpSummary) XXX_Size() int {
	return m.Size()
}
func (m *BulkOpSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkOpSummary.DiscardUnknown(m)
}

var xxx_messageInfo_BulkOpSummary proto.InternalMessageInfo

// ExportResponse is the response to an Export() operation.
type ExportResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Files          []ExportResponse_File `protobuf:"bytes,2,rep,name=files,proto3" json:"files"`
	StartTime      hlc.Timestamp         `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time"`
}

func (m *ExportResponse) Reset()         { *m = ExportResponse{} }
func (m *ExportResponse) String() string { return proto.CompactTextString(m) }
func (*ExportResponse) ProtoMessage()    {}
func (*ExportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{83}
}
func (m *ExportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportResponse.Merge(m, src)
}
func (m *ExportResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportResponse proto.InternalMessageInfo

// File describes a keyrange that has been dumped to a file at the given
// path.
type ExportResponse_File struct {
	Span       roachpb.Span  `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	EndKeyTS   hlc.Timestamp `protobuf:"bytes,9,opt,name=end_key_ts,json=endKeyTs,proto3" json:"end_key_ts"`
	Exported   BulkOpSummary `protobuf:"bytes,6,opt,name=exported,proto3" json:"exported"`
	SST        []byte        `protobuf:"bytes,7,opt,name=sst,proto3" json:"sst,omitempty"`
	LocalityKV string        `protobuf:"bytes,8,opt,name=locality_kv,json=localityKv,proto3" json:"locality_kv,omitempty"`
	// Fingerprint is the XOR aggregate of the fnv64 hash of every point
	// key/timestamp and corresponding value that has been exported as part of
	// the ExportRequest. This field is only set when the request is sent with
	// `ExportFingerprint` set to true.
	//
	// Range keys are not fingerprinted but instead written to the sst above
	// that is returned to the caller. This is because range keys do not have a
	// stable, discrete identity and so it is up to the caller to define a
	// deterministic fingerprinting scheme across all returned range keys.
	Fingerprint uint64 `protobuf:"varint,10,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
}

func (m *ExportResponse_File) Reset()         { *m = ExportResponse_File{} }
func (m *ExportResponse_File) String() string { return proto.CompactTextString(m) }
func (*ExportResponse_File) ProtoMessage()    {}
func (*ExportResponse_File) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{83, 0}
}
func (m *ExportResponse_File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportResponse_File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportResponse_File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportResponse_File.Merge(m, src)
}
func (m *ExportResponse_File) XXX_Size() int {
	return m.Size()
}
func (m *ExportResponse_File) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportResponse_File.DiscardUnknown(m)
}

var xxx_messageInfo_ExportResponse_File proto.InternalMessageInfo

// AdminScatterRequest is the argument to the AdminScatter() method, which moves
// replicas and leaseholders for a selection of ranges. Scatter is best-effort;
// ranges that cannot be moved won't fail the request.
type AdminScatterRequest struct {
	RequestHeader   `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	RandomizeLeases bool `protobuf:"varint,2,opt,name=randomize_leases,json=randomizeLeases,proto3" json:"randomize_leases,omitempty"`
	// max_size, if > 0, specifies a range's size above with it should reject
	// this scatter request, allowing a "scatter-if-not-full" conditional request.
	MaxSize int64 `protobuf:"varint,3,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
}

func (m *AdminScatterRequest) Reset()         { *m = AdminScatterRequest{} }
func (m *AdminScatterRequest) String() string { return proto.CompactTextString(m) }
func (*AdminScatterRequest) ProtoMessage()    {}
func (*AdminScatterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{84}
}
func (m *AdminScatterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminScatterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminScatterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminScatterRequest.Merge(m, src)
}
func (m *AdminScatterRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminScatterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminScatterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminScatterRequest proto.InternalMessageInfo

// ScatterResponse is the response to a Scatter() operation.
type AdminScatterResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	RangeInfos     []roachpb.RangeInfo `protobuf:"bytes,3,rep,name=range_infos,json=rangeInfos,proto3" json:"range_infos"`
	MVCCStats      enginepb.MVCCStats  `protobuf:"bytes,4,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats"`
	// ReplicasScatteredBytes specifies the byte size of the ranges that were
	// scattered
	ReplicasScatteredBytes int64 `protobuf:"varint,5,opt,name=replicas_scattered_bytes,json=replicasScatteredBytes,proto3" json:"replicas_scattered_bytes,omitempty"`
}

func (m *AdminScatterResponse) Reset()         { *m = AdminScatterResponse{} }
func (m *AdminScatterResponse) String() string { return proto.CompactTextString(m) }
func (*AdminScatterResponse) ProtoMessage()    {}
func (*AdminScatterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{85}
}
func (m *AdminScatterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminScatterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminScatterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminScatterResponse.Merge(m, src)
}
func (m *AdminScatterResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminScatterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminScatterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminScatterResponse proto.InternalMessageInfo

type AdminScatterResponse_Range struct {
	Span roachpb.Span `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
}

func (m *AdminScatterResponse_Range) Reset()         { *m = AdminScatterResponse_Range{} }
func (m *AdminScatterResponse_Range) String() string { return proto.CompactTextString(m) }
func (*AdminScatterResponse_Range) ProtoMessage()    {}
func (*AdminScatterResponse_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{85, 0}
}
func (m *AdminScatterResponse_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminScatterResponse_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminScatterResponse_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminScatterResponse_Range.Merge(m, src)
}
func (m *AdminScatterResponse_Range) XXX_Size() int {
	return m.Size()
}
func (m *AdminScatterResponse_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminScatterResponse_Range.DiscardUnknown(m)
}

var xxx_messageInfo_AdminScatterResponse_Range proto.InternalMessageInfo

// AddSSTableRequest contains arguments to the AddSSTable method, which links an
// SST file into the Pebble log-structured merge-tree. The SST must only contain
// committed versioned values with non-zero MVCC timestamps (no intents or
// inline values). It cannot be used in a transaction, cannot be split across
// ranges, and must be alone in a batch.
//
// By default, AddSSTable will blindly write the SST contents into Pebble, with
// fixed MVCC timestamps unaffected by pushes. This can violate many CRDB
// guarantees, including ACID, serializability and single-key linearizability:
// it mutates MVCC history (by replacing existing versions or writing below
// their timestamp) and does not respect the timestamp cache (by writing at
// timestamps that have already been read) nor the closed timestamp (by writing
// at immutable timestamps).
//
// The following parameters can be used to make AddSSTable enforce these
// guarantees, at a performance cost:
//
//   - SSTTimestampToRequestTimestamp: ensures compliance with the timestamp cache
//     and closed timestamp, by rewriting SST timestamps to the request timestamp.
//     Also emits the SST via the range feed.
//
//   - DisallowConflicts, or DisallowShadowingBelow: ensures compliance with MVCC,
//     by checking for conflicting keys in existing data instead of writing
//     blindly.
//
// If the above parameters are not enabled, the caller must make sure these
// guarantees are upheld via other mechanisms. These options are orthogonal,
// providing different guarantees, and neither is sufficient by itself to
// enforce ACID guarantees -- they must both be enabled. See comments on these
// parameters for more details.
//
// AddSSTable always synchronizes with ongoing transactions, by taking out a
// lock span, scanning for separated intents, and resolving them. This is done
// even in the case of blind writes, since the caller is expected to make sure
// there are no ongoing writes to the ingested key span, so there should be few
// or no intents in the common case.
//
// If writing blindly (without e.g. DisallowConflicts), the range's MVCC stats
// may be incorrect as the SST stats are not adjusted for existing keys, so they
// will be marked with ContainsEstimates. The caller should recompute statistics
// after ingestion.
type AddSSTableRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// SSTTimestampToRequestTimestamp gives the timestamp used for all MVCC keys
	// in the provided SST. If this timestamp differs from the request timestamp
	// (e.g. if the request gets pushed) then all MVCC keys in the SST will be
	// rewritten to the request timestamp during request evaluation. This ensures
	// the writes comply with the timestamp cache and closed timestamp. It also
	// causes the AddSSTable to be emitted via the range feed, since it respects
	// the closed timestamp.
	//
	// Callers should always set this, except in very special circumstances when
	// the timestamp cache and closed timestamp can safely be ignored (e.g.
	// streaming replication into an offline tenant).
	//
	// Note that this alone is not sufficient to guarantee MVCC correctness, since
	// it can write below or replace existing committed versions (the tscache is
	// only bumped when the values are subsequently read). Use DisallowConflicts
	// in addition to guarantee MVCC correctness and serializability.
	SSTTimestampToRequestTimestamp hlc.Timestamp `protobuf:"bytes,6,opt,name=sst_timestamp_to_request_timestamp,json=sstTimestampToRequestTimestamp,proto3" json:"sst_timestamp_to_request_timestamp"`
	// DisallowConflicts will check for MVCC conflicts with existing keys, i.e.
	// scan for existing keys with a timestamp at or above the SST key and
	// return WriteTooOldError (possibly retrying). It also ensures MVCC
	// statistics are accurately updated.
	//
	// Note that this alone is not sufficient to guarantee serializability or
	// single-key linearizability, since it can write to a timestamp that another
	// reader has already observed, changing the value at that timestamp and above
	// it. Use with SSTTimestampToRequestTimestamp to guarantee serializability.
	//
	// TODO(erikgrinaker): It might be possible to avoid this parameter if we
	// could pick an MVCC timestamp that's guaranteed to not collide with
	// existing keys, see: https://github.com/cockroachdb/cockroach/issues/73047.
	// However, this would always lead to inaccurate MVCC stats.
	DisallowConflicts bool `protobuf:"varint,7,opt,name=disallow_conflicts,json=disallowConflicts,proto3" json:"disallow_conflicts,omitempty"`
	// DisallowShadowingBelow implies DisallowConflicts, and additionally rejects
	// writing above keys that have an existing/visible value (but will write
	// above tombstones). It allows shadowing keys that have a timestamp at or
	// above the given timestamp as long as the value is identical to the existing
	// value, and also allows idempotent writes (same key/timestamp/value) at or
	// above the given timestamp.
	//
	// This is a specialized method for the IMPORT INTO use-case, where we do not
	// want to shadow existing keys (which could cause them to be GCed before the
	// import finalizes, preventing a rollback), but we need to allow shadowing
	// keys that were previously written by the import itself in the case of a
	// resumption or retry. The equal value requirement is to avoid unique
	// constraint violations.
	DisallowShadowingBelow hlc.Timestamp `protobuf:"bytes,8,opt,name=disallow_shadowing_below,json=disallowShadowingBelow,proto3" json:"disallow_shadowing_below"`
	// MVCCStats, if set, is the MVCCStats for the contents of this SSTable and is
	// used as-is during evaluation of the AddSSTable command to update the range
	// MVCCStats, instead of computing the stats for the SSTable by iterating it.
	// Including these stats can make the evaluation of AddSSTable much cheaper.
	MVCCStats *enginepb.MVCCStats `protobuf:"bytes,4,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats,omitempty"`
	// IngestAsWrites causes the content of the provided SSTable to be ingested in
	// a regular WriteBatch, instead of directly adding the provided SST to the
	// storage engine. This is useful if the data size is so small that the fixed
	// costs of adding an extra file (file IO, triggering a flush, compactions)
	// would be higher than the marginal costs of the amount of data going though
	// the usual write pipeline (on-disk raft log, WAL, etc).
	// TODO(dt): https://github.com/cockroachdb/cockroach/issues/34579#issuecomment-544627193
	IngestAsWrites bool `protobuf:"varint,5,opt,name=ingest_as_writes,json=ingestAsWrites,proto3" json:"ingest_as_writes,omitempty"`
	// ReturnFollowingLikelyNonEmptySpanStart controls whether the request should
	// also find and return the key at which the span after the added file span
	// is likely non-empty. See AddSSTableResponse.FollowingLikelyNonEmptySpanStart.
	ReturnFollowingLikelyNonEmptySpanStart bool `protobuf:"varint,9,opt,name=return_following_likely_non_empty_span_start,json=returnFollowingLikelyNonEmptySpanStart,proto3" json:"return_following_likely_non_empty_span_start,omitempty"`
	// IgnoreKeysAboveTimestamp is used when ingesting an SSTable that contains
	// keys, including mvcc revisions of keys, captured over a time range, to
	// indicate that readers of that sstable should read it "as of" a the fixed
	// time, ignoring any keys with later timestamps.
	//
	// TODO(dt,msbutler,bilal): This is unsupported.
	IgnoreKeysAboveTimestamp hlc.Timestamp `protobuf:"bytes,12,opt,name=ignore_keys_above_timestamp,json=ignoreKeysAboveTimestamp,proto3" json:"ignore_keys_above_timestamp"`
	// ComputeStatsDiff causes the server to compute the effect this
	// SST will have on the range's MVCC stats, even in the presence of
	// overlapping keys. This flag cannot be passed with the MVCCStats,
	// DisallowShadowingBelow, or DisallowShadowing fields.
	//
	// This flag assumes that any key in the sst that is shadowed by a key in the
	// engine is also a duplicate. As an example, accurate stats will be computed
	// here:
	// - sst: a@3,a@2 and eng: a@2,a@1
	//
	// but not for, as a@1 is not a duplicate:
	// - sst: a@1 and eng: a@2
	//
	// In the ladder case, we silently create inaccurate stats currently. A TODO
	// in storage.ComputeSSTStatsDiff is to detect this case and increment
	// ContainsEstimates. At least for PCR, the first client of this flag, we
	// expect the edge case to be quite rare, and would only occur if we're
	// ingesting data older than the ingesting range's GC TTL.
	ComputeStatsDiff bool `protobuf:"varint,13,opt,name=compute_stats_diff,json=computeStatsDiff,proto3" json:"compute_stats_diff,omitempty"`
}

func (m *AddSSTableRequest) Reset()         { *m = AddSSTableRequest{} }
func (m *AddSSTableRequest) String() string { return proto.CompactTextString(m) }
func (*AddSSTableRequest) ProtoMessage()    {}
func (*AddSSTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{86}
}
func (m *AddSSTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddSSTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddSSTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSSTableRequest.Merge(m, src)
}
func (m *AddSSTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddSSTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSSTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddSSTableRequest proto.InternalMessageInfo

// AddSSTableResponse is the response to a AddSSTable() operation.
type AddSSTableResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// RangeSpan is the span of the range which just added this sstable. It is
	// included in the reply along with AvailableBytes so that callers can tell if
	// a file they are about to send would be sent to the same range as a file
	// sent previously (i.e. if it intersects with this span as sent then), and if
	// so, if its size would fit within the size remaining in this range.
	RangeSpan roachpb.Span `protobuf:"bytes,2,opt,name=range_span,json=rangeSpan,proto3" json:"range_span"`
	// AvailableBytes indicates how many bytes remain before the range into which
	// this request added will be considered "full". This is for use by callers to
	// check if they should keep sending additional SSTs to this range or if they
	// should split first. Such callers can use RangeSpan to see if the file they
	// would be sending would also add to this range.
	AvailableBytes int64 `protobuf:"varint,3,opt,name=available_bytes,json=availableBytes,proto3" json:"available_bytes,omitempty"`
	// FollowingLikelyNonEmptySpanStart if requested contains a key that is likely
	// to be the first key greater than the end of the added file at which there
	// is existing data in the range. It is not guarenteed however that there is
	// not data before that key, or that that key actually exists; it may be
	// picked using cheaper, inconsistentent reads so it should be used only for
	// estimations of how ingested data and spans may overlap.
	FollowingLikelyNonEmptySpanStart github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,4,opt,name=following_likely_non_empty_span_start,json=followingLikelyNonEmptySpanStart,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"following_likely_non_empty_span_start,omitempty"`
}

func (m *AddSSTableResponse) Reset()         { *m = AddSSTableResponse{} }
func (m *AddSSTableResponse) String() string { return proto.CompactTextString(m) }
func (*AddSSTableResponse) ProtoMessage()    {}
func (*AddSSTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{87}
}
func (m *AddSSTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddSSTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddSSTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSSTableResponse.Merge(m, src)
}
func (m *AddSSTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddSSTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSSTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddSSTableResponse proto.InternalMessageInfo

// LinkExternalSSTableRequest contains arguments to the LinkExternalSSTable
// method, which links an External SST file into the Pebble log-structured
// merge-tree. The External SST must point to a backup file which contains
// versioned values with non-zero MVCC timestamps (no intents or inline values).
// It cannot be used in a transaction, cannot be split across ranges, and must
// be alone in a batch.
type LinkExternalSSTableRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	ExternalFile  LinkExternalSSTableRequest_ExternalFile `protobuf:"bytes,4,opt,name=external_file,json=externalFile,proto3" json:"external_file"`
}

func (m *LinkExternalSSTableRequest) Reset()         { *m = LinkExternalSSTableRequest{} }
func (m *LinkExternalSSTableRequest) String() string { return proto.CompactTextString(m) }
func (*LinkExternalSSTableRequest) ProtoMessage()    {}
func (*LinkExternalSSTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{88}
}
func (m *LinkExternalSSTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkExternalSSTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LinkExternalSSTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkExternalSSTableRequest.Merge(m, src)
}
func (m *LinkExternalSSTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *LinkExternalSSTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkExternalSSTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LinkExternalSSTableRequest proto.InternalMessageInfo

type LinkExternalSSTableRequest_ExternalFile struct {
	Locator                 string `protobuf:"bytes,1,opt,name=locator,proto3" json:"locator,omitempty"`
	Path                    string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	BackingFileSize         uint64 `protobuf:"varint,3,opt,name=backing_file_size,json=backingFileSize,proto3" json:"backing_file_size,omitempty"`
	ApproximatePhysicalSize uint64 `protobuf:"varint,4,opt,name=approximate_physical_size,json=approximatePhysicalSize,proto3" json:"approximate_physical_size,omitempty"`
	SyntheticPrefix         []byte `protobuf:"bytes,5,opt,name=synthetic_prefix,json=syntheticPrefix,proto3" json:"synthetic_prefix,omitempty"`
	UseSyntheticSuffix      bool   `protobuf:"varint,6,opt,name=use_synthetic_suffix,json=useSyntheticSuffix,proto3" json:"use_synthetic_suffix,omitempty"`
	// MVCCStats are estimated MVCCStats for the contents of this Extrenal SSTable
	// and is used as-is during evaluation of the command to update the range
	// MVCCStats, instead of computing the stats for the SSTable by iterating it.
	MVCCStats *enginepb.MVCCStats `protobuf:"bytes,7,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats,omitempty"`
}

func (m *LinkExternalSSTableRequest_ExternalFile) Reset() {
	*m = LinkExternalSSTableRequest_ExternalFile{}
}
func (m *LinkExternalSSTableRequest_ExternalFile) String() string { return proto.CompactTextString(m) }
func (*LinkExternalSSTableRequest_ExternalFile) ProtoMessage()    {}
func (*LinkExternalSSTableRequest_ExternalFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{88, 0}
}
func (m *LinkExternalSSTableRequest_ExternalFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkExternalSSTableRequest_ExternalFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LinkExternalSSTableRequest_ExternalFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkExternalSSTableRequest_ExternalFile.Merge(m, src)
}
func (m *LinkExternalSSTableRequest_ExternalFile) XXX_Size() int {
	return m.Size()
}
func (m *LinkExternalSSTableRequest_ExternalFile) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkExternalSSTableRequest_ExternalFile.DiscardUnknown(m)
}

var xxx_messageInfo_LinkExternalSSTableRequest_ExternalFile proto.InternalMessageInfo

// LinkExternalSSTableResponse is the response to a LinkExternalSSTable() operation.
type LinkExternalSSTableResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *LinkExternalSSTableResponse) Reset()         { *m = LinkExternalSSTableResponse{} }
func (m *LinkExternalSSTableResponse) String() string { return proto.CompactTextString(m) }
func (*LinkExternalSSTableResponse) ProtoMessage()    {}
func (*LinkExternalSSTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{89}
}
func (m *LinkExternalSSTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkExternalSSTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LinkExternalSSTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkExternalSSTableResponse.Merge(m, src)
}
func (m *LinkExternalSSTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *LinkExternalSSTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkExternalSSTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LinkExternalSSTableResponse proto.InternalMessageInfo

// RefreshRequest is arguments to the Refresh() method, which verifies that no
// write has occurred since the refresh_from timestamp to the specified key.
// The timestamp cache is updated. A transaction must be supplied with this
// request. If the key has been written more recently than the provided txn
// timestamp, an error is returned and the timestamp cache is not updated.
//
// The timestamp cache is updated to txn.read_timestamp, like it is for all
// requests.
type RefreshRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// refresh_from specifies the exclusive lower-bound of the verification. The
	// request verifies that there are no writes (committed or provisional) in the
	// range (refresh_from, txn.read_timestamp].
	RefreshFrom hlc.Timestamp `protobuf:"bytes,3,opt,name=refresh_from,json=refreshFrom,proto3" json:"refresh_from"`
}

func (m *RefreshRequest) Reset()         { *m = RefreshRequest{} }
func (m *RefreshRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshRequest) ProtoMessage()    {}
func (*RefreshRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{90}
}
func (m *RefreshRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRequest.Merge(m, src)
}
func (m *RefreshRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRequest proto.InternalMessageInfo

// RefreshResponse is the response to a Refresh() operation.
type RefreshResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RefreshResponse) Reset()         { *m = RefreshResponse{} }
func (m *RefreshResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshResponse) ProtoMessage()    {}
func (*RefreshResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{91}
}
func (m *RefreshResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshResponse.Merge(m, src)
}
func (m *RefreshResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshResponse proto.InternalMessageInfo

// RefreshRangeRequest is arguments to the RefreshRange() method, which
// is similar to RefreshRequest (see comments above), but operates on
// a key span instead of a single key.
type RefreshRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// refresh_from specifies the exclusive lower-bound of the verification. The
	// request verifies that there are no writes (committed or provisional) in the
	// range (refresh_from, txn.read_timestamp].
	RefreshFrom hlc.Timestamp `protobuf:"bytes,3,opt,name=refresh_from,json=refreshFrom,proto3" json:"refresh_from"`
}

func (m *RefreshRangeRequest) Reset()         { *m = RefreshRangeRequest{} }
func (m *RefreshRangeRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshRangeRequest) ProtoMessage()    {}
func (*RefreshRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{92}
}
func (m *RefreshRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRangeRequest.Merge(m, src)
}
func (m *RefreshRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRangeRequest proto.InternalMessageInfo

// RefreshRangeResponse is the response to a RefreshRange() operation.
type RefreshRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RefreshRangeResponse) Reset()         { *m = RefreshRangeResponse{} }
func (m *RefreshRangeResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshRangeResponse) ProtoMessage()    {}
func (*RefreshRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{93}
}
func (m *RefreshRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRangeResponse.Merge(m, src)
}
func (m *RefreshRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRangeResponse proto.InternalMessageInfo

// SubsumeRequest is the argument to the Subsume() method, which freezes a range
// for merging with its left-hand neighbor.
//
// Subsume, when called correctly, provides important guarantees that ensure
// there is no moment in time where the ranges involved in the merge could both
// process commands for the same keys. See the comment on Subsume for details.
//
// Subsume may return stale MVCC statistics when used outside of a merge
// transaction. As a rule of thumb, it is incorrect to call Subsume, except from
// its carefully-chosen location within a merge transaction.
type SubsumeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The range descriptor for the left-hand side of the merge. Used by the
	// right-hand side to sanity-check the validity of the merge.
	LeftDesc roachpb.RangeDescriptor `protobuf:"bytes,2,opt,name=left_desc,json=leftDesc,proto3" json:"left_desc"`
	// The range descriptor for the right-hand side of the merge. Should match
	// the range descriptor of the range evaluating this request.
	RightDesc roachpb.RangeDescriptor `protobuf:"bytes,3,opt,name=right_desc,json=rightDesc,proto3" json:"right_desc"`
	// PreserveUnreplicatedLocks instructs the Subsume request to flush any unreplicated
	// locks to the replicated lock table before returning.
	PreserveUnreplicatedLocks bool `protobuf:"varint,4,opt,name=preserve_unreplicated_locks,json=preserveUnreplicatedLocks,proto3" json:"preserve_unreplicated_locks,omitempty"`
}

func (m *SubsumeRequest) Reset()         { *m = SubsumeRequest{} }
func (m *SubsumeRequest) String() string { return proto.CompactTextString(m) }
func (*SubsumeRequest) ProtoMessage()    {}
func (*SubsumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{94}
}
func (m *SubsumeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubsumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubsumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsumeRequest.Merge(m, src)
}
func (m *SubsumeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubsumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubsumeRequest proto.InternalMessageInfo

// SubsumeResponse is the response to a SubsumeRequest.
type SubsumeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// MVCCStats are the MVCC statistics for the range.
	MVCCStats enginepb.MVCCStats `protobuf:"bytes,3,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats"`
	// RangeIDLocalMVCCStats are the MVCC statistics for the replicated range
	// ID-local keys. During a merge, these must be subtracted from MVCCStats
	// since they won't be present in the merged range.
	RangeIDLocalMVCCStats enginepb.MVCCStats `protobuf:"bytes,8,opt,name=range_id_local_mvcc_stats,json=rangeIdLocalMvccStats,proto3" json:"range_id_local_mvcc_stats"`
	// LeaseAppliedIndex is the lease applied index of the last applied command
	// at the time that the Subsume request executed. This is NOT intended to be
	// the lease index of the SubsumeRequest itself. Instead, it is intended to
	// provide the sender of the Subsume request with an upper bound on the lease
	// applied index of the CPut that left an intent on the local copy of the
	// right-hand range descriptor.
	LeaseAppliedIndex LeaseAppliedIndex `protobuf:"varint,4,opt,name=lease_applied_index,json=leaseAppliedIndex,proto3,casttype=LeaseAppliedIndex" json:"lease_applied_index,omitempty"`
	// FreezeStart is a timestamp that is guaranteed to be greater than the
	// timestamps at which any requests were serviced by the responding replica
	// before it stopped responding to requests altogether (in anticipation of
	// being subsumed). It is suitable for use as the timestamp cache's low water
	// mark for the keys previously owned by the subsumed range though this role
	// is largely being... subsumed by the RightReadSummary.
	FreezeStart github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=freeze_start,json=freezeStart,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"freeze_start"`
	// closed_timestamp is the range's closed timestamp at the moment of the
	// subsumption. Because the SubsumeRequest synchronizes with all other
	// requests, the range's closed timestamp does not advance past the snapshot
	// captured here.
	//
	// Like the freeze_start, this is used by the merged range to conditionally
	// bump the timestamp cache for the keys previously owned by the subsumed
	// range.
	//
	// Note that the closed timestamp is also reflected in the read_summary.
	// However, we carry it explicitly too because, in case the leaseholders of
	// the two sides are collocated at merge time, we don't need to use the
	// read_summary and simply use this field.
	ClosedTimestamp hlc.Timestamp `protobuf:"bytes,6,opt,name=closed_timestamp,json=closedTimestamp,proto3" json:"closed_timestamp"`
	// ReadSummary is a summary of the reads that have been performed on the range
	// up to the point of the Subsume request, which serializes with past reads
	// and begins blocking future reads. It is suitable for use to update the
	// timestamp cache for the keys previously owned by the subsumed range.
	//
	// ReadSummary can be used in place of FreezeStart, when available. It has two
	// distinct advantages:
	// 1. it can transfer a higher-resolution snapshot of the reads on the range
	//    through a range merge, to make the merge less disruptive to writes on
	//    the post-merge range because the timestamp cache won't be bumped as
	//    high.
	// 2. it can transfer information about reads with future-time timestamps,
	//    which are not otherwise captured by the FreezeStart clock timestamp.
	ReadSummary *rspb.ReadSummary `protobuf:"bytes,7,opt,name=read_summary,json=readSummary,proto3" json:"read_summary,omitempty"`
}

func (m *SubsumeResponse) Reset()         { *m = SubsumeResponse{} }
func (m *SubsumeResponse) String() string { return proto.CompactTextString(m) }
func (*SubsumeResponse) ProtoMessage()    {}
func (*SubsumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{95}
}
func (m *SubsumeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubsumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubsumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsumeResponse.Merge(m, src)
}
func (m *SubsumeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubsumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubsumeResponse proto.InternalMessageInfo

// RangeStatsRequest is the argument to the RangeStats() method. It requests the
// MVCC statistics of the receiving range.
type RangeStatsRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RangeStatsRequest) Reset()         { *m = RangeStatsRequest{} }
func (m *RangeStatsRequest) String() string { return proto.CompactTextString(m) }
func (*RangeStatsRequest) ProtoMessage()    {}
func (*RangeStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{96}
}
func (m *RangeStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeStatsRequest.Merge(m, src)
}
func (m *RangeStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeStatsRequest proto.InternalMessageInfo

// RangeStatsResponse is the response to a RangeStatsRequest.
type RangeStatsResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// MVCCStats are the MVCC statistics for the range that processed the
	// request.
	MVCCStats enginepb.MVCCStats `protobuf:"bytes,2,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats"`
	// MaxQueriesPerSecond is the maximum rate of request/s or QPS that the range
	// has served over a configured measurement period. Set to -1 if the replica
	// serving the RangeStats request has not been the leaseholder long enough to
	// have recorded request rates for at least a full measurement period. In such
	// cases, the recipient should not consider the QPS value reliable enough to
	// base important decisions off of.
	MaxQueriesPerSecond float64 `protobuf:"fixed64,5,opt,name=max_queries_per_second,json=maxQueriesPerSecond,proto3" json:"max_queries_per_second,omitempty"`
	// MaxQueriesPerSecondSet indicates that the MaxQueriesPerSecond field is set
	// by the server. Used to distinguish 0 qps set by a new server from the field
	// not being set at all by an old server.
	//
	// TODO(kvoli): stop setting this field and remove it in v23.2 when
	// no nodes in the cluster consult this field.
	MaxQueriesPerSecondSet bool `protobuf:"varint,6,opt,name=max_queries_per_second_set,json=maxQueriesPerSecondSet,proto3" json:"max_queries_per_second_set,omitempty"`
	// MaxCPUPerSecond is the maximum rate of cpu/s that the range has used at
	// the leaseholder over a configured measurement period. Set to -1 if the
	// replica serving the RangeStats request has not been the leaseholder long
	// enough to have recorded CPU rates for at least a full measurement period.
	// In such cases, the recipient should not consider the CPU value reliable
	// enough to base important decisions off of.
	MaxCPUPerSecond float64 `protobuf:"fixed64,7,opt,name=max_cpu_per_second,json=maxCpuPerSecond,proto3" json:"max_cpu_per_second,omitempty"`
	// range_info contains descriptor and lease information.
	RangeInfo roachpb.RangeInfo `protobuf:"bytes,4,opt,name=range_info,json=rangeInfo,proto3" json:"range_info"`
}

func (m *RangeStatsResponse) Reset()         { *m = RangeStatsResponse{} }
func (m *RangeStatsResponse) String() string { return proto.CompactTextString(m) }
func (*RangeStatsResponse) ProtoMessage()    {}
func (*RangeStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{97}
}
func (m *RangeStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeStatsResponse.Merge(m, src)
}
func (m *RangeStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeStatsResponse proto.InternalMessageInfo

// MigrateRequest is used instruct all ranges overlapping with it to exercise
// any relevant (below-raft) migrations in order for its range state to conform
// to what's needed by the specified version. It's a core primitive used in our
// migrations infrastructure to phase out legacy code below raft.
//
// KV waits for this command to durably apply on all replicas before returning,
// guaranteeing to the caller that all pre-migration state has been completely
// purged from the system.
type MigrateRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Version is used to select the specific migration to exercise.
	Version roachpb.Version `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
}

func (m *MigrateRequest) Reset()         { *m = MigrateRequest{} }
func (m *MigrateRequest) String() string { return proto.CompactTextString(m) }
func (*MigrateRequest) ProtoMessage()    {}
func (*MigrateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{98}
}
func (m *MigrateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MigrateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateRequest.Merge(m, src)
}
func (m *MigrateRequest) XXX_Size() int {
	return m.Size()
}
func (m *MigrateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateRequest proto.InternalMessageInfo

// MigrateResponse is the response to a Migrate operation.
type MigrateResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *MigrateResponse) Reset()         { *m = MigrateResponse{} }
func (m *MigrateResponse) String() string { return proto.CompactTextString(m) }
func (*MigrateResponse) ProtoMessage()    {}
func (*MigrateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{99}
}
func (m *MigrateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MigrateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateResponse.Merge(m, src)
}
func (m *MigrateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MigrateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateResponse proto.InternalMessageInfo

// QueryResolvedTimestampRequest is the argument to the QueryResolvedTimestamp()
// method. It requests a resolved timestamp for the key span it is issued over.
//
// A resolved timestamp for a key span is a timestamp at or below which all
// future reads within the span are guaranteed to produce the same results, i.e.
// at which MVCC history has become immutable. The most up-to-date such bound
// can be computed for a key span contained in a single range by taking the
// minimum of the leaseholder's closed timestamp and the timestamp preceding the
// earliest intent present on the range that overlaps with the key span of
// interest. This optimum timestamp is nondecreasing over time, since the closed
// timestamp will not regress and since it also prevents intents at lower
// timestamps from being created. Follower replicas can also provide a resolved
// timestamp, though it may not be the most recent one due to replication delay.
// However, a given follower replica will similarly produce a nondecreasing
// sequence of resolved timestamps.
//
// QueryResolvedTimestampRequest returns a resolved timestamp for the input key
// span by returning the minimum of all replicas contacted in order to cover the
// key span. This means that repeated invocations of this operation will be
// guaranteed nondecreasing only if routed to the same replicas.
//
// A CONSISTENT read at or below a key span's resolved timestamp will never
// block on replication or on conflicting transactions. However, as can be
// inferred from the previous paragraph, for this to be guaranteed, the read
// must be issued to the same replica or set of replicas (for multi-range reads)
// that were consulted when computing the key span's resolved timestamp.
//
// A resolved timestamp for a key span is a sibling concept a resolved timestamp
// for a rangefeed, which is defined in:
//
//	pkg/kv/kvserver/rangefeed/resolved_timestamp.go
//
// Whereas a resolved timestamp for a rangefeed refers to a timestamp below
// which no future updates will be published on the rangefeed, a resolved
// timestamp for a key span refers to a timestamp below which no future state
// modifications that could change the result of read requests will be made.
// Both concepts rely on some notion of immutability, but the former imparts
// this property on a stream of events while the latter imparts this property
// on materialized state.
type QueryResolvedTimestampRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *QueryResolvedTimestampRequest) Reset()         { *m = QueryResolvedTimestampRequest{} }
func (m *QueryResolvedTimestampRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolvedTimestampRequest) ProtoMessage()    {}
func (*QueryResolvedTimestampRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{100}
}
func (m *QueryResolvedTimestampRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolvedTimestampRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryResolvedTimestampRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolvedTimestampRequest.Merge(m, src)
}
func (m *QueryResolvedTimestampRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolvedTimestampRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolvedTimestampRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolvedTimestampRequest proto.InternalMessageInfo

// QueryResolvedTimestampResponse is the response to a QueryResolvedTimestampRequest.
type QueryResolvedTimestampResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// ResolvedTS is the resolved timestamp of the key span.
	ResolvedTS hlc.Timestamp `protobuf:"bytes,2,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts"`
}

func (m *QueryResolvedTimestampResponse) Reset()         { *m = QueryResolvedTimestampResponse{} }
func (m *QueryResolvedTimestampResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolvedTimestampResponse) ProtoMessage()    {}
func (*QueryResolvedTimestampResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{101}
}
func (m *QueryResolvedTimestampResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolvedTimestampResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryResolvedTimestampResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolvedTimestampResponse.Merge(m, src)
}
func (m *QueryResolvedTimestampResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolvedTimestampResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolvedTimestampResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolvedTimestampResponse proto.InternalMessageInfo

// BarrierRequest is the request for a Barrier operation. This guarantees that
// all past and ongoing writes to a key span have completed and applied on the
// leaseholder. It does this by waiting for all conflicting write latches and
// then submitting a noop write through Raft, waiting for it to apply. Later
// writes are not affected -- in particular, it does not actually take out a
// latch, so writers don't have to wait for it to complete and can write below
// the barrier.
type BarrierRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// WithLeaseAppliedIndex will return the LeaseAppliedIndex of the barrier
	// command in the response, allowing the caller to wait for the barrier to
	// apply on an arbitrary replica. It also returns the range descriptor, so the
	// caller can detect any unexpected range changes.
	//
	// When enabled, the barrier request can no longer span multiple ranges, and
	// will instead return RangeKeyMismatchError. The caller must be prepared to
	// handle this.
	//
	// NB: This field was added in a patch release. Nodes prior to 24.1 are not
	// guaranteed to support it, returning a zero LeaseAppliedIndex instead.
	WithLeaseAppliedIndex bool `protobuf:"varint,2,opt,name=with_lease_applied_index,json=withLeaseAppliedIndex,proto3" json:"with_lease_applied_index,omitempty"`
}

func (m *BarrierRequest) Reset()         { *m = BarrierRequest{} }
func (m *BarrierRequest) String() string { return proto.CompactTextString(m) }
func (*BarrierRequest) ProtoMessage()    {}
func (*BarrierRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{102}
}
func (m *BarrierRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BarrierRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BarrierRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BarrierRequest.Merge(m, src)
}
func (m *BarrierRequest) XXX_Size() int {
	return m.Size()
}
func (m *BarrierRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BarrierRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BarrierRequest proto.InternalMessageInfo

// BarrierResponse is the response for a Barrier operation.
type BarrierResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Timestamp at which this Barrier was evaluated. Can be used to guarantee
	// future operations happen on the same or newer leaseholders.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	// LeaseAppliedIndex at which this Barrier was applied. Only returned when
	// requested via WithLeaseAppliedIndex.
	LeaseAppliedIndex LeaseAppliedIndex `protobuf:"varint,3,opt,name=lease_applied_index,json=leaseAppliedIndex,proto3,casttype=LeaseAppliedIndex" json:"lease_applied_index,omitempty"`
	// RangeDesc at the time the barrier was applied. Only returned when requested
	// via WithLeaseAppliedIndex.
	RangeDesc roachpb.RangeDescriptor `protobuf:"bytes,4,opt,name=range_desc,json=rangeDesc,proto3" json:"range_desc"`
}

func (m *BarrierResponse) Reset()         { *m = BarrierResponse{} }
func (m *BarrierResponse) String() string { return proto.CompactTextString(m) }
func (*BarrierResponse) ProtoMessage()    {}
func (*BarrierResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{103}
}
func (m *BarrierResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BarrierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BarrierResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BarrierResponse.Merge(m, src)
}
func (m *BarrierResponse) XXX_Size() int {
	return m.Size()
}
func (m *BarrierResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BarrierResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BarrierResponse proto.InternalMessageInfo

// FlushLockTableRequest instructs the replica, if it is the leaseholder, to
// flush any in-memory unreplicated locks to the replicated lock table contained
// in the request header's span.
type FlushLockTableRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *FlushLockTableRequest) Reset()         { *m = FlushLockTableRequest{} }
func (m *FlushLockTableRequest) String() string { return proto.CompactTextString(m) }
func (*FlushLockTableRequest) ProtoMessage()    {}
func (*FlushLockTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{104}
}
func (m *FlushLockTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlushLockTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlushLockTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlushLockTableRequest.Merge(m, src)
}
func (m *FlushLockTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlushLockTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlushLockTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlushLockTableRequest proto.InternalMessageInfo

// FlushLockTableResponse is the response for a FlushLockTable operation.
type FlushLockTableResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// LocksWritten is the number of locks written to the replicated lock table as
	// a result of this request.
	LocksWritten uint64 `protobuf:"varint,2,opt,name=locks_written,json=locksWritten,proto3" json:"locks_written,omitempty"`
}

func (m *FlushLockTableResponse) Reset()         { *m = FlushLockTableResponse{} }
func (m *FlushLockTableResponse) String() string { return proto.CompactTextString(m) }
func (*FlushLockTableResponse) ProtoMessage()    {}
func (*FlushLockTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{105}
}
func (m *FlushLockTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlushLockTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlushLockTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlushLockTableResponse.Merge(m, src)
}
func (m *FlushLockTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *FlushLockTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FlushLockTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FlushLockTableResponse proto.InternalMessageInfo

// A RequestUnion contains exactly one of the requests.
// The values added here must match those in ResponseUnion.
//
// Be cautious about deprecating fields as doing so can lead to inconsistencies
// between replicas.
type RequestUnion struct {
	// Types that are valid to be assigned to Value:
	//	*RequestUnion_Get
	//	*RequestUnion_Put
	//	*RequestUnion_ConditionalPut
	//	*RequestUnion_Increment
	//	*RequestUnion_Delete
	//	*RequestUnion_DeleteRange
	//	*RequestUnion_ClearRange
	//	*RequestUnion_RevertRange
	//	*RequestUnion_Scan
	//	*RequestUnion_EndTxn
	//	*RequestUnion_AdminSplit
	//	*RequestUnion_AdminUnsplit
	//	*RequestUnion_AdminMerge
	//	*RequestUnion_AdminTransferLease
	//	*RequestUnion_AdminChangeReplicas
	//	*RequestUnion_AdminRelocateRange
	//	*RequestUnion_HeartbeatTxn
	//	*RequestUnion_Gc
	//	*RequestUnion_PushTxn
	//	*RequestUnion_RecoverTxn
	//	*RequestUnion_ResolveIntent
	//	*RequestUnion_ResolveIntentRange
	//	*RequestUnion_Merge
	//	*RequestUnion_TruncateLog
	//	*RequestUnion_RequestLease
	//	*RequestUnion_ReverseScan
	//	*RequestUnion_ComputeChecksum
	//	*RequestUnion_CheckConsistency
	//	*RequestUnion_TransferLease
	//	*RequestUnion_LeaseInfo
	//	*RequestUnion_Export
	//	*RequestUnion_QueryTxn
	//	*RequestUnion_QueryIntent
	//	*RequestUnion_QueryLocks
	//	*RequestUnion_AdminScatter
	//	*RequestUnion_AddSstable
	//	*RequestUnion_RecomputeStats
	//	*RequestUnion_Refresh
	//	*RequestUnion_RefreshRange
	//	*RequestUnion_Subsume
	//	*RequestUnion_RangeStats
	//	*RequestUnion_Migrate
	//	*RequestUnion_QueryResolvedTimestamp
	//	*RequestUnion_Barrier
	//	*RequestUnion_Probe
	//	*RequestUnion_IsSpanEmpty
	//	*RequestUnion_LinkExternalSstable
	//	*RequestUnion_Excise
	//	*RequestUnion_FlushLockTable
	Value isRequestUnion_Value `protobuf_oneof:"value"`
}

func (m *RequestUnion) Reset()         { *m = RequestUnion{} }
func (m *RequestUnion) String() string { return proto.CompactTextString(m) }
func (*RequestUnion) ProtoMessage()    {}
func (*RequestUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{106}
}
func (m *RequestUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestUnion.Merge(m, src)
}
func (m *RequestUnion) XXX_Size() int {
	return m.Size()
}
func (m *RequestUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestUnion.DiscardUnknown(m)
}

var xxx_messageInfo_RequestUnion proto.InternalMessageInfo

type isRequestUnion_Value interface {
	isRequestUnion_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RequestUnion_Get struct {
	Get *GetRequest `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type RequestUnion_Put struct {
	Put *PutRequest `protobuf:"bytes,2,opt,name=put,proto3,oneof" json:"put,omitempty"`
}
type RequestUnion_ConditionalPut struct {
	ConditionalPut *ConditionalPutRequest `protobuf:"bytes,3,opt,name=conditional_put,json=conditionalPut,proto3,oneof" json:"conditional_put,omitempty"`
}
type RequestUnion_Increment struct {
	Increment *IncrementRequest `protobuf:"bytes,4,opt,name=increment,proto3,oneof" json:"increment,omitempty"`
}
type RequestUnion_Delete struct {
	Delete *DeleteRequest `protobuf:"bytes,5,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type RequestUnion_DeleteRange struct {
	DeleteRange *DeleteRangeRequest `protobuf:"bytes,6,opt,name=delete_range,json=deleteRange,proto3,oneof" json:"delete_range,omitempty"`
}
type RequestUnion_ClearRange struct {
	ClearRange *ClearRangeRequest `protobuf:"bytes,38,opt,name=clear_range,json=clearRange,proto3,oneof" json:"clear_range,omitempty"`
}
type RequestUnion_RevertRange struct {
	RevertRange *RevertRangeRequest `protobuf:"bytes,48,opt,name=revert_range,json=revertRange,proto3,oneof" json:"revert_range,omitempty"`
}
type RequestUnion_Scan struct {
	Scan *ScanRequest `protobuf:"bytes,7,opt,name=scan,proto3,oneof" json:"scan,omitempty"`
}
type RequestUnion_EndTxn struct {
	EndTxn *EndTxnRequest `protobuf:"bytes,9,opt,name=end_txn,json=endTxn,proto3,oneof" json:"end_txn,omitempty"`
}
type RequestUnion_AdminSplit struct {
	AdminSplit *AdminSplitRequest `protobuf:"bytes,10,opt,name=admin_split,json=adminSplit,proto3,oneof" json:"admin_split,omitempty"`
}
type RequestUnion_AdminUnsplit struct {
	AdminUnsplit *AdminUnsplitRequest `protobuf:"bytes,47,opt,name=admin_unsplit,json=adminUnsplit,proto3,oneof" json:"admin_unsplit,omitempty"`
}
type RequestUnion_AdminMerge struct {
	AdminMerge *AdminMergeRequest `protobuf:"bytes,11,opt,name=admin_merge,json=adminMerge,proto3,oneof" json:"admin_merge,omitempty"`
}
type RequestUnion_AdminTransferLease struct {
	AdminTransferLease *AdminTransferLeaseRequest `protobuf:"bytes,29,opt,name=admin_transfer_lease,json=adminTransferLease,proto3,oneof" json:"admin_transfer_lease,omitempty"`
}
type RequestUnion_AdminChangeReplicas struct {
	AdminChangeReplicas *AdminChangeReplicasRequest `protobuf:"bytes,35,opt,name=admin_change_replicas,json=adminChangeReplicas,proto3,oneof" json:"admin_change_replicas,omitempty"`
}
type RequestUnion_AdminRelocateRange struct {
	AdminRelocateRange *AdminRelocateRangeRequest `protobuf:"bytes,45,opt,name=admin_relocate_range,json=adminRelocateRange,proto3,oneof" json:"admin_relocate_range,omitempty"`
}
type RequestUnion_HeartbeatTxn struct {
	HeartbeatTxn *HeartbeatTxnRequest `protobuf:"bytes,12,opt,name=heartbeat_txn,json=heartbeatTxn,proto3,oneof" json:"heartbeat_txn,omitempty"`
}
type RequestUnion_Gc struct {
	Gc *GCRequest `protobuf:"bytes,13,opt,name=gc,proto3,oneof" json:"gc,omitempty"`
}
type RequestUnion_PushTxn struct {
	PushTxn *PushTxnRequest `protobuf:"bytes,14,opt,name=push_txn,json=pushTxn,proto3,oneof" json:"push_txn,omitempty"`
}
type RequestUnion_RecoverTxn struct {
	RecoverTxn *RecoverTxnRequest `protobuf:"bytes,46,opt,name=recover_txn,json=recoverTxn,proto3,oneof" json:"recover_txn,omitempty"`
}
type RequestUnion_ResolveIntent struct {
	ResolveIntent *ResolveIntentRequest `protobuf:"bytes,16,opt,name=resolve_intent,json=resolveIntent,proto3,oneof" json:"resolve_intent,omitempty"`
}
type RequestUnion_ResolveIntentRange struct {
	ResolveIntentRange *ResolveIntentRangeRequest `protobuf:"bytes,17,opt,name=resolve_intent_range,json=resolveIntentRange,proto3,oneof" json:"resolve_intent_range,omitempty"`
}
type RequestUnion_Merge struct {
	Merge *MergeRequest `protobuf:"bytes,18,opt,name=merge,proto3,oneof" json:"merge,omitempty"`
}
type RequestUnion_TruncateLog struct {
	TruncateLog *TruncateLogRequest `protobuf:"bytes,19,opt,name=truncate_log,json=truncateLog,proto3,oneof" json:"truncate_log,omitempty"`
}
type RequestUnion_RequestLease struct {
	RequestLease *RequestLeaseRequest `protobuf:"bytes,20,opt,name=request_lease,json=requestLease,proto3,oneof" json:"request_lease,omitempty"`
}
type RequestUnion_ReverseScan struct {
	ReverseScan *ReverseScanRequest `protobuf:"bytes,21,opt,name=reverse_scan,json=reverseScan,proto3,oneof" json:"reverse_scan,omitempty"`
}
type RequestUnion_ComputeChecksum struct {
	ComputeChecksum *ComputeChecksumRequest `protobuf:"bytes,22,opt,name=compute_checksum,json=computeChecksum,proto3,oneof" json:"compute_checksum,omitempty"`
}
type RequestUnion_CheckConsistency struct {
	CheckConsistency *CheckConsistencyRequest `protobuf:"bytes,24,opt,name=check_consistency,json=checkConsistency,proto3,oneof" json:"check_consistency,omitempty"`
}
type RequestUnion_TransferLease struct {
	TransferLease *TransferLeaseRequest `protobuf:"bytes,28,opt,name=transfer_lease,json=transferLease,proto3,oneof" json:"transfer_lease,omitempty"`
}
type RequestUnion_LeaseInfo struct {
	LeaseInfo *LeaseInfoRequest `protobuf:"bytes,30,opt,name=lease_info,json=leaseInfo,proto3,oneof" json:"lease_info,omitempty"`
}
type RequestUnion_Export struct {
	Export *ExportRequest `protobuf:"bytes,32,opt,name=export,proto3,oneof" json:"export,omitempty"`
}
type RequestUnion_QueryTxn struct {
	QueryTxn *QueryTxnRequest `protobuf:"bytes,33,opt,name=query_txn,json=queryTxn,proto3,oneof" json:"query_txn,omitempty"`
}
type RequestUnion_QueryIntent struct {
	QueryIntent *QueryIntentRequest `protobuf:"bytes,42,opt,name=query_intent,json=queryIntent,proto3,oneof" json:"query_intent,omitempty"`
}
type RequestUnion_QueryLocks struct {
	QueryLocks *QueryLocksRequest `protobuf:"bytes,55,opt,name=query_locks,json=queryLocks,proto3,oneof" json:"query_locks,omitempty"`
}
type RequestUnion_AdminScatter struct {
	AdminScatter *AdminScatterRequest `protobuf:"bytes,36,opt,name=admin_scatter,json=adminScatter,proto3,oneof" json:"admin_scatter,omitempty"`
}
type RequestUnion_AddSstable struct {
	AddSstable *AddSSTableRequest `protobuf:"bytes,37,opt,name=add_sstable,json=addSstable,proto3,oneof" json:"add_sstable,omitempty"`
}
type RequestUnion_RecomputeStats struct {
	RecomputeStats *RecomputeStatsRequest `protobuf:"bytes,39,opt,name=recompute_stats,json=recomputeStats,proto3,oneof" json:"recompute_stats,omitempty"`
}
type RequestUnion_Refresh struct {
	Refresh *RefreshRequest `protobuf:"bytes,40,opt,name=refresh,proto3,oneof" json:"refresh,omitempty"`
}
type RequestUnion_RefreshRange struct {
	RefreshRange *RefreshRangeRequest `protobuf:"bytes,41,opt,name=refresh_range,json=refreshRange,proto3,oneof" json:"refresh_range,omitempty"`
}
type RequestUnion_Subsume struct {
	Subsume *SubsumeRequest `protobuf:"bytes,43,opt,name=subsume,proto3,oneof" json:"subsume,omitempty"`
}
type RequestUnion_RangeStats struct {
	RangeStats *RangeStatsRequest `protobuf:"bytes,44,opt,name=range_stats,json=rangeStats,proto3,oneof" json:"range_stats,omitempty"`
}
type RequestUnion_Migrate struct {
	Migrate *MigrateRequest `protobuf:"bytes,50,opt,name=migrate,proto3,oneof" json:"migrate,omitempty"`
}
type RequestUnion_QueryResolvedTimestamp struct {
	QueryResolvedTimestamp *QueryResolvedTimestampRequest `protobuf:"bytes,51,opt,name=query_resolved_timestamp,json=queryResolvedTimestamp,proto3,oneof" json:"query_resolved_timestamp,omitempty"`
}
type RequestUnion_Barrier struct {
	Barrier *BarrierRequest `protobuf:"bytes,53,opt,name=barrier,proto3,oneof" json:"barrier,omitempty"`
}
type RequestUnion_Probe struct {
	Probe *ProbeRequest `protobuf:"bytes,54,opt,name=probe,proto3,oneof" json:"probe,omitempty"`
}
type RequestUnion_IsSpanEmpty struct {
	IsSpanEmpty *IsSpanEmptyRequest `protobuf:"bytes,56,opt,name=is_span_empty,json=isSpanEmpty,proto3,oneof" json:"is_span_empty,omitempty"`
}
type RequestUnion_LinkExternalSstable struct {
	LinkExternalSstable *LinkExternalSSTableRequest `protobuf:"bytes,57,opt,name=link_external_sstable,json=linkExternalSstable,proto3,oneof" json:"link_external_sstable,omitempty"`
}
type RequestUnion_Excise struct {
	Excise *ExciseRequest `protobuf:"bytes,58,opt,name=excise,proto3,oneof" json:"excise,omitempty"`
}
type RequestUnion_FlushLockTable struct {
	FlushLockTable *FlushLockTableRequest `protobuf:"bytes,59,opt,name=flush_lock_table,json=flushLockTable,proto3,oneof" json:"flush_lock_table,omitempty"`
}

func (*RequestUnion_Get) isRequestUnion_Value()                    {}
func (*RequestUnion_Put) isRequestUnion_Value()                    {}
func (*RequestUnion_ConditionalPut) isRequestUnion_Value()         {}
func (*RequestUnion_Increment) isRequestUnion_Value()              {}
func (*RequestUnion_Delete) isRequestUnion_Value()                 {}
func (*RequestUnion_DeleteRange) isRequestUnion_Value()            {}
func (*RequestUnion_ClearRange) isRequestUnion_Value()             {}
func (*RequestUnion_RevertRange) isRequestUnion_Value()            {}
func (*RequestUnion_Scan) isRequestUnion_Value()                   {}
func (*RequestUnion_EndTxn) isRequestUnion_Value()                 {}
func (*RequestUnion_AdminSplit) isRequestUnion_Value()             {}
func (*RequestUnion_AdminUnsplit) isRequestUnion_Value()           {}
func (*RequestUnion_AdminMerge) isRequestUnion_Value()             {}
func (*RequestUnion_AdminTransferLease) isRequestUnion_Value()     {}
func (*RequestUnion_AdminChangeReplicas) isRequestUnion_Value()    {}
func (*RequestUnion_AdminRelocateRange) isRequestUnion_Value()     {}
func (*RequestUnion_HeartbeatTxn) isRequestUnion_Value()           {}
func (*RequestUnion_Gc) isRequestUnion_Value()                     {}
func (*RequestUnion_PushTxn) isRequestUnion_Value()                {}
func (*RequestUnion_RecoverTxn) isRequestUnion_Value()             {}
func (*RequestUnion_ResolveIntent) isRequestUnion_Value()          {}
func (*RequestUnion_ResolveIntentRange) isRequestUnion_Value()     {}
func (*RequestUnion_Merge) isRequestUnion_Value()                  {}
func (*RequestUnion_TruncateLog) isRequestUnion_Value()            {}
func (*RequestUnion_RequestLease) isRequestUnion_Value()           {}
func (*RequestUnion_ReverseScan) isRequestUnion_Value()            {}
func (*RequestUnion_ComputeChecksum) isRequestUnion_Value()        {}
func (*RequestUnion_CheckConsistency) isRequestUnion_Value()       {}
func (*RequestUnion_TransferLease) isRequestUnion_Value()          {}
func (*RequestUnion_LeaseInfo) isRequestUnion_Value()              {}
func (*RequestUnion_Export) isRequestUnion_Value()                 {}
func (*RequestUnion_QueryTxn) isRequestUnion_Value()               {}
func (*RequestUnion_QueryIntent) isRequestUnion_Value()            {}
func (*RequestUnion_QueryLocks) isRequestUnion_Value()             {}
func (*RequestUnion_AdminScatter) isRequestUnion_Value()           {}
func (*RequestUnion_AddSstable) isRequestUnion_Value()             {}
func (*RequestUnion_RecomputeStats) isRequestUnion_Value()         {}
func (*RequestUnion_Refresh) isRequestUnion_Value()                {}
func (*RequestUnion_RefreshRange) isRequestUnion_Value()           {}
func (*RequestUnion_Subsume) isRequestUnion_Value()                {}
func (*RequestUnion_RangeStats) isRequestUnion_Value()             {}
func (*RequestUnion_Migrate) isRequestUnion_Value()                {}
func (*RequestUnion_QueryResolvedTimestamp) isRequestUnion_Value() {}
func (*RequestUnion_Barrier) isRequestUnion_Value()                {}
func (*RequestUnion_Probe) isRequestUnion_Value()                  {}
func (*RequestUnion_IsSpanEmpty) isRequestUnion_Value()            {}
func (*RequestUnion_LinkExternalSstable) isRequestUnion_Value()    {}
func (*RequestUnion_Excise) isRequestUnion_Value()                 {}
func (*RequestUnion_FlushLockTable) isRequestUnion_Value()         {}

func (m *RequestUnion) GetValue() isRequestUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RequestUnion) GetGet() *GetRequest {
	if x, ok := m.GetValue().(*RequestUnion_Get); ok {
		return x.Get
	}
	return nil
}

func (m *RequestUnion) GetPut() *PutRequest {
	if x, ok := m.GetValue().(*RequestUnion_Put); ok {
		return x.Put
	}
	return nil
}

func (m *RequestUnion) GetConditionalPut() *ConditionalPutRequest {
	if x, ok := m.GetValue().(*RequestUnion_ConditionalPut); ok {
		return x.ConditionalPut
	}
	return nil
}

func (m *RequestUnion) GetIncrement() *IncrementRequest {
	if x, ok := m.GetValue().(*RequestUnion_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *RequestUnion) GetDelete() *DeleteRequest {
	if x, ok := m.GetValue().(*RequestUnion_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *RequestUnion) GetDeleteRange() *DeleteRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_DeleteRange); ok {
		return x.DeleteRange
	}
	return nil
}

func (m *RequestUnion) GetClearRange() *ClearRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_ClearRange); ok {
		return x.ClearRange
	}
	return nil
}

func (m *RequestUnion) GetRevertRange() *RevertRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_RevertRange); ok {
		return x.RevertRange
	}
	return nil
}

func (m *RequestUnion) GetScan() *ScanRequest {
	if x, ok := m.GetValue().(*RequestUnion_Scan); ok {
		return x.Scan
	}
	return nil
}

func (m *RequestUnion) GetEndTxn() *EndTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_EndTxn); ok {
		return x.EndTxn
	}
	return nil
}

func (m *RequestUnion) GetAdminSplit() *AdminSplitRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminSplit); ok {
		return x.AdminSplit
	}
	return nil
}

func (m *RequestUnion) GetAdminUnsplit() *AdminUnsplitRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminUnsplit); ok {
		return x.AdminUnsplit
	}
	return nil
}

func (m *RequestUnion) GetAdminMerge() *AdminMergeRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminMerge); ok {
		return x.AdminMerge
	}
	return nil
}

func (m *RequestUnion) GetAdminTransferLease() *AdminTransferLeaseRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminTransferLease); ok {
		return x.AdminTransferLease
	}
	return nil
}

func (m *RequestUnion) GetAdminChangeReplicas() *AdminChangeReplicasRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminChangeReplicas); ok {
		return x.AdminChangeReplicas
	}
	return nil
}

func (m *RequestUnion) GetAdminRelocateRange() *AdminRelocateRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminRelocateRange); ok {
		return x.AdminRelocateRange
	}
	return nil
}

func (m *RequestUnion) GetHeartbeatTxn() *HeartbeatTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_HeartbeatTxn); ok {
		return x.HeartbeatTxn
	}
	return nil
}

func (m *RequestUnion) GetGc() *GCRequest {
	if x, ok := m.GetValue().(*RequestUnion_Gc); ok {
		return x.Gc
	}
	return nil
}

func (m *RequestUnion) GetPushTxn() *PushTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_PushTxn); ok {
		return x.PushTxn
	}
	return nil
}

func (m *RequestUnion) GetRecoverTxn() *RecoverTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_RecoverTxn); ok {
		return x.RecoverTxn
	}
	return nil
}

func (m *RequestUnion) GetResolveIntent() *ResolveIntentRequest {
	if x, ok := m.GetValue().(*RequestUnion_ResolveIntent); ok {
		return x.ResolveIntent
	}
	return nil
}

func (m *RequestUnion) GetResolveIntentRange() *ResolveIntentRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_ResolveIntentRange); ok {
		return x.ResolveIntentRange
	}
	return nil
}

func (m *RequestUnion) GetMerge() *MergeRequest {
	if x, ok := m.GetValue().(*RequestUnion_Merge); ok {
		return x.Merge
	}
	return nil
}

func (m *RequestUnion) GetTruncateLog() *TruncateLogRequest {
	if x, ok := m.GetValue().(*RequestUnion_TruncateLog); ok {
		return x.TruncateLog
	}
	return nil
}

func (m *RequestUnion) GetRequestLease() *RequestLeaseRequest {
	if x, ok := m.GetValue().(*RequestUnion_RequestLease); ok {
		return x.RequestLease
	}
	return nil
}

func (m *RequestUnion) GetReverseScan() *ReverseScanRequest {
	if x, ok := m.GetValue().(*RequestUnion_ReverseScan); ok {
		return x.ReverseScan
	}
	return nil
}

func (m *RequestUnion) GetComputeChecksum() *ComputeChecksumRequest {
	if x, ok := m.GetValue().(*RequestUnion_ComputeChecksum); ok {
		return x.ComputeChecksum
	}
	return nil
}

func (m *RequestUnion) GetCheckConsistency() *CheckConsistencyRequest {
	if x, ok := m.GetValue().(*RequestUnion_CheckConsistency); ok {
		return x.CheckConsistency
	}
	return nil
}

func (m *RequestUnion) GetTransferLease() *TransferLeaseRequest {
	if x, ok := m.GetValue().(*RequestUnion_TransferLease); ok {
		return x.TransferLease
	}
	return nil
}

func (m *RequestUnion) GetLeaseInfo() *LeaseInfoRequest {
	if x, ok := m.GetValue().(*RequestUnion_LeaseInfo); ok {
		return x.LeaseInfo
	}
	return nil
}

func (m *RequestUnion) GetExport() *ExportRequest {
	if x, ok := m.GetValue().(*RequestUnion_Export); ok {
		return x.Export
	}
	return nil
}

func (m *RequestUnion) GetQueryTxn() *QueryTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_QueryTxn); ok {
		return x.QueryTxn
	}
	return nil
}

func (m *RequestUnion) GetQueryIntent() *QueryIntentRequest {
	if x, ok := m.GetValue().(*RequestUnion_QueryIntent); ok {
		return x.QueryIntent
	}
	return nil
}

func (m *RequestUnion) GetQueryLocks() *QueryLocksRequest {
	if x, ok := m.GetValue().(*RequestUnion_QueryLocks); ok {
		return x.QueryLocks
	}
	return nil
}

func (m *RequestUnion) GetAdminScatter() *AdminScatterRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminScatter); ok {
		return x.AdminScatter
	}
	return nil
}

func (m *RequestUnion) GetAddSstable() *AddSSTableRequest {
	if x, ok := m.GetValue().(*RequestUnion_AddSstable); ok {
		return x.AddSstable
	}
	return nil
}

func (m *RequestUnion) GetRecomputeStats() *RecomputeStatsRequest {
	if x, ok := m.GetValue().(*RequestUnion_RecomputeStats); ok {
		return x.RecomputeStats
	}
	return nil
}

func (m *RequestUnion) GetRefresh() *RefreshRequest {
	if x, ok := m.GetValue().(*RequestUnion_Refresh); ok {
		return x.Refresh
	}
	return nil
}

func (m *RequestUnion) GetRefreshRange() *RefreshRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_RefreshRange); ok {
		return x.RefreshRange
	}
	return nil
}

func (m *RequestUnion) GetSubsume() *SubsumeRequest {
	if x, ok := m.GetValue().(*RequestUnion_Subsume); ok {
		return x.Subsume
	}
	return nil
}

func (m *RequestUnion) GetRangeStats() *RangeStatsRequest {
	if x, ok := m.GetValue().(*RequestUnion_RangeStats); ok {
		return x.RangeStats
	}
	return nil
}

func (m *RequestUnion) GetMigrate() *MigrateRequest {
	if x, ok := m.GetValue().(*RequestUnion_Migrate); ok {
		return x.Migrate
	}
	return nil
}

func (m *RequestUnion) GetQueryResolvedTimestamp() *QueryResolvedTimestampRequest {
	if x, ok := m.GetValue().(*RequestUnion_QueryResolvedTimestamp); ok {
		return x.QueryResolvedTimestamp
	}
	return nil
}

func (m *RequestUnion) GetBarrier() *BarrierRequest {
	if x, ok := m.GetValue().(*RequestUnion_Barrier); ok {
		return x.Barrier
	}
	return nil
}

func (m *RequestUnion) GetProbe() *ProbeRequest {
	if x, ok := m.GetValue().(*RequestUnion_Probe); ok {
		return x.Probe
	}
	return nil
}

func (m *RequestUnion) GetIsSpanEmpty() *IsSpanEmptyRequest {
	if x, ok := m.GetValue().(*RequestUnion_IsSpanEmpty); ok {
		return x.IsSpanEmpty
	}
	return nil
}

func (m *RequestUnion) GetLinkExternalSstable() *LinkExternalSSTableRequest {
	if x, ok := m.GetValue().(*RequestUnion_LinkExternalSstable); ok {
		return x.LinkExternalSstable
	}
	return nil
}

func (m *RequestUnion) GetExcise() *ExciseRequest {
	if x, ok := m.GetValue().(*RequestUnion_Excise); ok {
		return x.Excise
	}
	return nil
}

func (m *RequestUnion) GetFlushLockTable() *FlushLockTableRequest {
	if x, ok := m.GetValue().(*RequestUnion_FlushLockTable); ok {
		return x.FlushLockTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RequestUnion) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RequestUnion_Get)(nil),
		(*RequestUnion_Put)(nil),
		(*RequestUnion_ConditionalPut)(nil),
		(*RequestUnion_Increment)(nil),
		(*RequestUnion_Delete)(nil),
		(*RequestUnion_DeleteRange)(nil),
		(*RequestUnion_ClearRange)(nil),
		(*RequestUnion_RevertRange)(nil),
		(*RequestUnion_Scan)(nil),
		(*RequestUnion_EndTxn)(nil),
		(*RequestUnion_AdminSplit)(nil),
		(*RequestUnion_AdminUnsplit)(nil),
		(*RequestUnion_AdminMerge)(nil),
		(*RequestUnion_AdminTransferLease)(nil),
		(*RequestUnion_AdminChangeReplicas)(nil),
		(*RequestUnion_AdminRelocateRange)(nil),
		(*RequestUnion_HeartbeatTxn)(nil),
		(*RequestUnion_Gc)(nil),
		(*RequestUnion_PushTxn)(nil),
		(*RequestUnion_RecoverTxn)(nil),
		(*RequestUnion_ResolveIntent)(nil),
		(*RequestUnion_ResolveIntentRange)(nil),
		(*RequestUnion_Merge)(nil),
		(*RequestUnion_TruncateLog)(nil),
		(*RequestUnion_RequestLease)(nil),
		(*RequestUnion_ReverseScan)(nil),
		(*RequestUnion_ComputeChecksum)(nil),
		(*RequestUnion_CheckConsistency)(nil),
		(*RequestUnion_TransferLease)(nil),
		(*RequestUnion_LeaseInfo)(nil),
		(*RequestUnion_Export)(nil),
		(*RequestUnion_QueryTxn)(nil),
		(*RequestUnion_QueryIntent)(nil),
		(*RequestUnion_QueryLocks)(nil),
		(*RequestUnion_AdminScatter)(nil),
		(*RequestUnion_AddSstable)(nil),
		(*RequestUnion_RecomputeStats)(nil),
		(*RequestUnion_Refresh)(nil),
		(*RequestUnion_RefreshRange)(nil),
		(*RequestUnion_Subsume)(nil),
		(*RequestUnion_RangeStats)(nil),
		(*RequestUnion_Migrate)(nil),
		(*RequestUnion_QueryResolvedTimestamp)(nil),
		(*RequestUnion_Barrier)(nil),
		(*RequestUnion_Probe)(nil),
		(*RequestUnion_IsSpanEmpty)(nil),
		(*RequestUnion_LinkExternalSstable)(nil),
		(*RequestUnion_Excise)(nil),
		(*RequestUnion_FlushLockTable)(nil),
	}
}

// A ResponseUnion contains exactly one of the responses.
// The values added here must match those in RequestUnion.
type ResponseUnion struct {
	// Types that are valid to be assigned to Value:
	//	*ResponseUnion_Get
	//	*ResponseUnion_Put
	//	*ResponseUnion_ConditionalPut
	//	*ResponseUnion_Increment
	//	*ResponseUnion_Delete
	//	*ResponseUnion_DeleteRange
	//	*ResponseUnion_ClearRange
	//	*ResponseUnion_RevertRange
	//	*ResponseUnion_Scan
	//	*ResponseUnion_EndTxn
	//	*ResponseUnion_AdminSplit
	//	*ResponseUnion_AdminUnsplit
	//	*ResponseUnion_AdminMerge
	//	*ResponseUnion_AdminTransferLease
	//	*ResponseUnion_AdminChangeReplicas
	//	*ResponseUnion_AdminRelocateRange
	//	*ResponseUnion_HeartbeatTxn
	//	*ResponseUnion_Gc
	//	*ResponseUnion_PushTxn
	//	*ResponseUnion_RecoverTxn
	//	*ResponseUnion_ResolveIntent
	//	*ResponseUnion_ResolveIntentRange
	//	*ResponseUnion_Merge
	//	*ResponseUnion_TruncateLog
	//	*ResponseUnion_RequestLease
	//	*ResponseUnion_ReverseScan
	//	*ResponseUnion_ComputeChecksum
	//	*ResponseUnion_CheckConsistency
	//	*ResponseUnion_LeaseInfo
	//	*ResponseUnion_Export
	//	*ResponseUnion_QueryTxn
	//	*ResponseUnion_QueryIntent
	//	*ResponseUnion_QueryLocks
	//	*ResponseUnion_AdminScatter
	//	*ResponseUnion_AddSstable
	//	*ResponseUnion_RecomputeStats
	//	*ResponseUnion_Refresh
	//	*ResponseUnion_RefreshRange
	//	*ResponseUnion_Subsume
	//	*ResponseUnion_RangeStats
	//	*ResponseUnion_Migrate
	//	*ResponseUnion_QueryResolvedTimestamp
	//	*ResponseUnion_Barrier
	//	*ResponseUnion_Probe
	//	*ResponseUnion_IsSpanEmpty
	//	*ResponseUnion_LinkExternalSstable
	//	*ResponseUnion_Excise
	//	*ResponseUnion_FlushLockTable
	Value isResponseUnion_Value `protobuf_oneof:"value"`
}

func (m *ResponseUnion) Reset()         { *m = ResponseUnion{} }
func (m *ResponseUnion) String() string { return proto.CompactTextString(m) }
func (*ResponseUnion) ProtoMessage()    {}
func (*ResponseUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{107}
}
func (m *ResponseUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseUnion.Merge(m, src)
}
func (m *ResponseUnion) XXX_Size() int {
	return m.Size()
}
func (m *ResponseUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseUnion.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseUnion proto.InternalMessageInfo

type isResponseUnion_Value interface {
	isResponseUnion_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResponseUnion_Get struct {
	Get *GetResponse `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type ResponseUnion_Put struct {
	Put *PutResponse `protobuf:"bytes,2,opt,name=put,proto3,oneof" json:"put,omitempty"`
}
type ResponseUnion_ConditionalPut struct {
	ConditionalPut *ConditionalPutResponse `protobuf:"bytes,3,opt,name=conditional_put,json=conditionalPut,proto3,oneof" json:"conditional_put,omitempty"`
}
type ResponseUnion_Increment struct {
	Increment *IncrementResponse `protobuf:"bytes,4,opt,name=increment,proto3,oneof" json:"increment,omitempty"`
}
type ResponseUnion_Delete struct {
	Delete *DeleteResponse `protobuf:"bytes,5,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type ResponseUnion_DeleteRange struct {
	DeleteRange *DeleteRangeResponse `protobuf:"bytes,6,opt,name=delete_range,json=deleteRange,proto3,oneof" json:"delete_range,omitempty"`
}
type ResponseUnion_ClearRange struct {
	ClearRange *ClearRangeResponse `protobuf:"bytes,38,opt,name=clear_range,json=clearRange,proto3,oneof" json:"clear_range,omitempty"`
}
type ResponseUnion_RevertRange struct {
	RevertRange *RevertRangeResponse `protobuf:"bytes,48,opt,name=revert_range,json=revertRange,proto3,oneof" json:"revert_range,omitempty"`
}
type ResponseUnion_Scan struct {
	Scan *ScanResponse `protobuf:"bytes,7,opt,name=scan,proto3,oneof" json:"scan,omitempty"`
}
type ResponseUnion_EndTxn struct {
	EndTxn *EndTxnResponse `protobuf:"bytes,9,opt,name=end_txn,json=endTxn,proto3,oneof" json:"end_txn,omitempty"`
}
type ResponseUnion_AdminSplit struct {
	AdminSplit *AdminSplitResponse `protobuf:"bytes,10,opt,name=admin_split,json=adminSplit,proto3,oneof" json:"admin_split,omitempty"`
}
type ResponseUnion_AdminUnsplit struct {
	AdminUnsplit *AdminUnsplitResponse `protobuf:"bytes,47,opt,name=admin_unsplit,json=adminUnsplit,proto3,oneof" json:"admin_unsplit,omitempty"`
}
type ResponseUnion_AdminMerge struct {
	AdminMerge *AdminMergeResponse `protobuf:"bytes,11,opt,name=admin_merge,json=adminMerge,proto3,oneof" json:"admin_merge,omitempty"`
}
type ResponseUnion_AdminTransferLease struct {
	AdminTransferLease *AdminTransferLeaseResponse `protobuf:"bytes,29,opt,name=admin_transfer_lease,json=adminTransferLease,proto3,oneof" json:"admin_transfer_lease,omitempty"`
}
type ResponseUnion_AdminChangeReplicas struct {
	AdminChangeReplicas *AdminChangeReplicasResponse `protobuf:"bytes,35,opt,name=admin_change_replicas,json=adminChangeReplicas,proto3,oneof" json:"admin_change_replicas,omitempty"`
}
type ResponseUnion_AdminRelocateRange struct {
	AdminRelocateRange *AdminRelocateRangeResponse `protobuf:"bytes,45,opt,name=admin_relocate_range,json=adminRelocateRange,proto3,oneof" json:"admin_relocate_range,omitempty"`
}
type ResponseUnion_HeartbeatTxn struct {
	HeartbeatTxn *HeartbeatTxnResponse `protobuf:"bytes,12,opt,name=heartbeat_txn,json=heartbeatTxn,proto3,oneof" json:"heartbeat_txn,omitempty"`
}
type ResponseUnion_Gc struct {
	Gc *GCResponse `protobuf:"bytes,13,opt,name=gc,proto3,oneof" json:"gc,omitempty"`
}
type ResponseUnion_PushTxn struct {
	PushTxn *PushTxnResponse `protobuf:"bytes,14,opt,name=push_txn,json=pushTxn,proto3,oneof" json:"push_txn,omitempty"`
}
type ResponseUnion_RecoverTxn struct {
	RecoverTxn *RecoverTxnResponse `protobuf:"bytes,46,opt,name=recover_txn,json=recoverTxn,proto3,oneof" json:"recover_txn,omitempty"`
}
type ResponseUnion_ResolveIntent struct {
	ResolveIntent *ResolveIntentResponse `protobuf:"bytes,16,opt,name=resolve_intent,json=resolveIntent,proto3,oneof" json:"resolve_intent,omitempty"`
}
type ResponseUnion_ResolveIntentRange struct {
	ResolveIntentRange *ResolveIntentRangeResponse `protobuf:"bytes,17,opt,name=resolve_intent_range,json=resolveIntentRange,proto3,oneof" json:"resolve_intent_range,omitempty"`
}
type ResponseUnion_Merge struct {
	Merge *MergeResponse `protobuf:"bytes,18,opt,name=merge,proto3,oneof" json:"merge,omitempty"`
}
type ResponseUnion_TruncateLog struct {
	TruncateLog *TruncateLogResponse `protobuf:"bytes,19,opt,name=truncate_log,json=truncateLog,proto3,oneof" json:"truncate_log,omitempty"`
}
type ResponseUnion_RequestLease struct {
	RequestLease *RequestLeaseResponse `protobuf:"bytes,20,opt,name=request_lease,json=requestLease,proto3,oneof" json:"request_lease,omitempty"`
}
type ResponseUnion_ReverseScan struct {
	ReverseScan *ReverseScanResponse `protobuf:"bytes,21,opt,name=reverse_scan,json=reverseScan,proto3,oneof" json:"reverse_scan,omitempty"`
}
type ResponseUnion_ComputeChecksum struct {
	ComputeChecksum *ComputeChecksumResponse `protobuf:"bytes,22,opt,name=compute_checksum,json=computeChecksum,proto3,oneof" json:"compute_checksum,omitempty"`
}
type ResponseUnion_CheckConsistency struct {
	CheckConsistency *CheckConsistencyResponse `protobuf:"bytes,24,opt,name=check_consistency,json=checkConsistency,proto3,oneof" json:"check_consistency,omitempty"`
}
type ResponseUnion_LeaseInfo struct {
	LeaseInfo *LeaseInfoResponse `protobuf:"bytes,30,opt,name=lease_info,json=leaseInfo,proto3,oneof" json:"lease_info,omitempty"`
}
type ResponseUnion_Export struct {
	Export *ExportResponse `protobuf:"bytes,32,opt,name=export,proto3,oneof" json:"export,omitempty"`
}
type ResponseUnion_QueryTxn struct {
	QueryTxn *QueryTxnResponse `protobuf:"bytes,33,opt,name=query_txn,json=queryTxn,proto3,oneof" json:"query_txn,omitempty"`
}
type ResponseUnion_QueryIntent struct {
	QueryIntent *QueryIntentResponse `protobuf:"bytes,42,opt,name=query_intent,json=queryIntent,proto3,oneof" json:"query_intent,omitempty"`
}
type ResponseUnion_QueryLocks struct {
	QueryLocks *QueryLocksResponse `protobuf:"bytes,55,opt,name=query_locks,json=queryLocks,proto3,oneof" json:"query_locks,omitempty"`
}
type ResponseUnion_AdminScatter struct {
	AdminScatter *AdminScatterResponse `protobuf:"bytes,36,opt,name=admin_scatter,json=adminScatter,proto3,oneof" json:"admin_scatter,omitempty"`
}
type ResponseUnion_AddSstable struct {
	AddSstable *AddSSTableResponse `protobuf:"bytes,37,opt,name=add_sstable,json=addSstable,proto3,oneof" json:"add_sstable,omitempty"`
}
type ResponseUnion_RecomputeStats struct {
	RecomputeStats *RecomputeStatsResponse `protobuf:"bytes,39,opt,name=recompute_stats,json=recomputeStats,proto3,oneof" json:"recompute_stats,omitempty"`
}
type ResponseUnion_Refresh struct {
	Refresh *RefreshResponse `protobuf:"bytes,40,opt,name=refresh,proto3,oneof" json:"refresh,omitempty"`
}
type ResponseUnion_RefreshRange struct {
	RefreshRange *RefreshRangeResponse `protobuf:"bytes,41,opt,name=refresh_range,json=refreshRange,proto3,oneof" json:"refresh_range,omitempty"`
}
type ResponseUnion_Subsume struct {
	Subsume *SubsumeResponse `protobuf:"bytes,43,opt,name=subsume,proto3,oneof" json:"subsume,omitempty"`
}
type ResponseUnion_RangeStats struct {
	RangeStats *RangeStatsResponse `protobuf:"bytes,44,opt,name=range_stats,json=rangeStats,proto3,oneof" json:"range_stats,omitempty"`
}
type ResponseUnion_Migrate struct {
	Migrate *MigrateResponse `protobuf:"bytes,50,opt,name=migrate,proto3,oneof" json:"migrate,omitempty"`
}
type ResponseUnion_QueryResolvedTimestamp struct {
	QueryResolvedTimestamp *QueryResolvedTimestampResponse `protobuf:"bytes,51,opt,name=query_resolved_timestamp,json=queryResolvedTimestamp,proto3,oneof" json:"query_resolved_timestamp,omitempty"`
}
type ResponseUnion_Barrier struct {
	Barrier *BarrierResponse `protobuf:"bytes,53,opt,name=barrier,proto3,oneof" json:"barrier,omitempty"`
}
type ResponseUnion_Probe struct {
	Probe *ProbeResponse `protobuf:"bytes,54,opt,name=probe,proto3,oneof" json:"probe,omitempty"`
}
type ResponseUnion_IsSpanEmpty struct {
	IsSpanEmpty *IsSpanEmptyResponse `protobuf:"bytes,56,opt,name=is_span_empty,json=isSpanEmpty,proto3,oneof" json:"is_span_empty,omitempty"`
}
type ResponseUnion_LinkExternalSstable struct {
	LinkExternalSstable *LinkExternalSSTableResponse `protobuf:"bytes,57,opt,name=link_external_sstable,json=linkExternalSstable,proto3,oneof" json:"link_external_sstable,omitempty"`
}
type ResponseUnion_Excise struct {
	Excise *ExciseResponse `protobuf:"bytes,58,opt,name=excise,proto3,oneof" json:"excise,omitempty"`
}
type ResponseUnion_FlushLockTable struct {
	FlushLockTable *FlushLockTableResponse `protobuf:"bytes,59,opt,name=flush_lock_table,json=flushLockTable,proto3,oneof" json:"flush_lock_table,omitempty"`
}

func (*ResponseUnion_Get) isResponseUnion_Value()                    {}
func (*ResponseUnion_Put) isResponseUnion_Value()                    {}
func (*ResponseUnion_ConditionalPut) isResponseUnion_Value()         {}
func (*ResponseUnion_Increment) isResponseUnion_Value()              {}
func (*ResponseUnion_Delete) isResponseUnion_Value()                 {}
func (*ResponseUnion_DeleteRange) isResponseUnion_Value()            {}
func (*ResponseUnion_ClearRange) isResponseUnion_Value()             {}
func (*ResponseUnion_RevertRange) isResponseUnion_Value()            {}
func (*ResponseUnion_Scan) isResponseUnion_Value()                   {}
func (*ResponseUnion_EndTxn) isResponseUnion_Value()                 {}
func (*ResponseUnion_AdminSplit) isResponseUnion_Value()             {}
func (*ResponseUnion_AdminUnsplit) isResponseUnion_Value()           {}
func (*ResponseUnion_AdminMerge) isResponseUnion_Value()             {}
func (*ResponseUnion_AdminTransferLease) isResponseUnion_Value()     {}
func (*ResponseUnion_AdminChangeReplicas) isResponseUnion_Value()    {}
func (*ResponseUnion_AdminRelocateRange) isResponseUnion_Value()     {}
func (*ResponseUnion_HeartbeatTxn) isResponseUnion_Value()           {}
func (*ResponseUnion_Gc) isResponseUnion_Value()                     {}
func (*ResponseUnion_PushTxn) isResponseUnion_Value()                {}
func (*ResponseUnion_RecoverTxn) isResponseUnion_Value()             {}
func (*ResponseUnion_ResolveIntent) isResponseUnion_Value()          {}
func (*ResponseUnion_ResolveIntentRange) isResponseUnion_Value()     {}
func (*ResponseUnion_Merge) isResponseUnion_Value()                  {}
func (*ResponseUnion_TruncateLog) isResponseUnion_Value()            {}
func (*ResponseUnion_RequestLease) isResponseUnion_Value()           {}
func (*ResponseUnion_ReverseScan) isResponseUnion_Value()            {}
func (*ResponseUnion_ComputeChecksum) isResponseUnion_Value()        {}
func (*ResponseUnion_CheckConsistency) isResponseUnion_Value()       {}
func (*ResponseUnion_LeaseInfo) isResponseUnion_Value()              {}
func (*ResponseUnion_Export) isResponseUnion_Value()                 {}
func (*ResponseUnion_QueryTxn) isResponseUnion_Value()               {}
func (*ResponseUnion_QueryIntent) isResponseUnion_Value()            {}
func (*ResponseUnion_QueryLocks) isResponseUnion_Value()             {}
func (*ResponseUnion_AdminScatter) isResponseUnion_Value()           {}
func (*ResponseUnion_AddSstable) isResponseUnion_Value()             {}
func (*ResponseUnion_RecomputeStats) isResponseUnion_Value()         {}
func (*ResponseUnion_Refresh) isResponseUnion_Value()                {}
func (*ResponseUnion_RefreshRange) isResponseUnion_Value()           {}
func (*ResponseUnion_Subsume) isResponseUnion_Value()                {}
func (*ResponseUnion_RangeStats) isResponseUnion_Value()             {}
func (*ResponseUnion_Migrate) isResponseUnion_Value()                {}
func (*ResponseUnion_QueryResolvedTimestamp) isResponseUnion_Value() {}
func (*ResponseUnion_Barrier) isResponseUnion_Value()                {}
func (*ResponseUnion_Probe) isResponseUnion_Value()                  {}
func (*ResponseUnion_IsSpanEmpty) isResponseUnion_Value()            {}
func (*ResponseUnion_LinkExternalSstable) isResponseUnion_Value()    {}
func (*ResponseUnion_Excise) isResponseUnion_Value()                 {}
func (*ResponseUnion_FlushLockTable) isResponseUnion_Value()         {}

func (m *ResponseUnion) GetValue() isResponseUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ResponseUnion) GetGet() *GetResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Get); ok {
		return x.Get
	}
	return nil
}

func (m *ResponseUnion) GetPut() *PutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Put); ok {
		return x.Put
	}
	return nil
}

func (m *ResponseUnion) GetConditionalPut() *ConditionalPutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ConditionalPut); ok {
		return x.ConditionalPut
	}
	return nil
}

func (m *ResponseUnion) GetIncrement() *IncrementResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *ResponseUnion) GetDelete() *DeleteResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *ResponseUnion) GetDeleteRange() *DeleteRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_DeleteRange); ok {
		return x.DeleteRange
	}
	return nil
}

func (m *ResponseUnion) GetClearRange() *ClearRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ClearRange); ok {
		return x.ClearRange
	}
	return nil
}

func (m *ResponseUnion) GetRevertRange() *RevertRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RevertRange); ok {
		return x.RevertRange
	}
	return nil
}

func (m *ResponseUnion) GetScan() *ScanResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Scan); ok {
		return x.Scan
	}
	return nil
}

func (m *ResponseUnion) GetEndTxn() *EndTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_EndTxn); ok {
		return x.EndTxn
	}
	return nil
}

func (m *ResponseUnion) GetAdminSplit() *AdminSplitResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminSplit); ok {
		return x.AdminSplit
	}
	return nil
}

func (m *ResponseUnion) GetAdminUnsplit() *AdminUnsplitResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminUnsplit); ok {
		return x.AdminUnsplit
	}
	return nil
}

func (m *ResponseUnion) GetAdminMerge() *AdminMergeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminMerge); ok {
		return x.AdminMerge
	}
	return nil
}

func (m *ResponseUnion) GetAdminTransferLease() *AdminTransferLeaseResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminTransferLease); ok {
		return x.AdminTransferLease
	}
	return nil
}

func (m *ResponseUnion) GetAdminChangeReplicas() *AdminChangeReplicasResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminChangeReplicas); ok {
		return x.AdminChangeReplicas
	}
	return nil
}

func (m *ResponseUnion) GetAdminRelocateRange() *AdminRelocateRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminRelocateRange); ok {
		return x.AdminRelocateRange
	}
	return nil
}

func (m *ResponseUnion) GetHeartbeatTxn() *HeartbeatTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_HeartbeatTxn); ok {
		return x.HeartbeatTxn
	}
	return nil
}

func (m *ResponseUnion) GetGc() *GCResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Gc); ok {
		return x.Gc
	}
	return nil
}

func (m *ResponseUnion) GetPushTxn() *PushTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_PushTxn); ok {
		return x.PushTxn
	}
	return nil
}

func (m *ResponseUnion) GetRecoverTxn() *RecoverTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RecoverTxn); ok {
		return x.RecoverTxn
	}
	return nil
}

func (m *ResponseUnion) GetResolveIntent() *ResolveIntentResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ResolveIntent); ok {
		return x.ResolveIntent
	}
	return nil
}

func (m *ResponseUnion) GetResolveIntentRange() *ResolveIntentRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ResolveIntentRange); ok {
		return x.ResolveIntentRange
	}
	return nil
}

func (m *ResponseUnion) GetMerge() *MergeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Merge); ok {
		return x.Merge
	}
	return nil
}

func (m *ResponseUnion) GetTruncateLog() *TruncateLogResponse {
	if x, ok := m.GetValue().(*ResponseUnion_TruncateLog); ok {
		return x.TruncateLog
	}
	return nil
}

func (m *ResponseUnion) GetRequestLease() *RequestLeaseResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RequestLease); ok {
		return x.RequestLease
	}
	return nil
}

func (m *ResponseUnion) GetReverseScan() *ReverseScanResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ReverseScan); ok {
		return x.ReverseScan
	}
	return nil
}

func (m *ResponseUnion) GetComputeChecksum() *ComputeChecksumResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ComputeChecksum); ok {
		return x.ComputeChecksum
	}
	return nil
}

func (m *ResponseUnion) GetCheckConsistency() *CheckConsistencyResponse {
	if x, ok := m.GetValue().(*ResponseUnion_CheckConsistency); ok {
		return x.CheckConsistency
	}
	return nil
}

func (m *ResponseUnion) GetLeaseInfo() *LeaseInfoResponse {
	if x, ok := m.GetValue().(*ResponseUnion_LeaseInfo); ok {
		return x.LeaseInfo
	}
	return nil
}

func (m *ResponseUnion) GetExport() *ExportResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Export); ok {
		return x.Export
	}
	return nil
}

func (m *ResponseUnion) GetQueryTxn() *QueryTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_QueryTxn); ok {
		return x.QueryTxn
	}
	return nil
}

func (m *ResponseUnion) GetQueryIntent() *QueryIntentResponse {
	if x, ok := m.GetValue().(*ResponseUnion_QueryIntent); ok {
		return x.QueryIntent
	}
	return nil
}

func (m *ResponseUnion) GetQueryLocks() *QueryLocksResponse {
	if x, ok := m.GetValue().(*ResponseUnion_QueryLocks); ok {
		return x.QueryLocks
	}
	return nil
}

func (m *ResponseUnion) GetAdminScatter() *AdminScatterResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminScatter); ok {
		return x.AdminScatter
	}
	return nil
}

func (m *ResponseUnion) GetAddSstable() *AddSSTableResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AddSstable); ok {
		return x.AddSstable
	}
	return nil
}

func (m *ResponseUnion) GetRecomputeStats() *RecomputeStatsResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RecomputeStats); ok {
		return x.RecomputeStats
	}
	return nil
}

func (m *ResponseUnion) GetRefresh() *RefreshResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Refresh); ok {
		return x.Refresh
	}
	return nil
}

func (m *ResponseUnion) GetRefreshRange() *RefreshRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RefreshRange); ok {
		return x.RefreshRange
	}
	return nil
}

func (m *ResponseUnion) GetSubsume() *SubsumeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Subsume); ok {
		return x.Subsume
	}
	return nil
}

func (m *ResponseUnion) GetRangeStats() *RangeStatsResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RangeStats); ok {
		return x.RangeStats
	}
	return nil
}

func (m *ResponseUnion) GetMigrate() *MigrateResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Migrate); ok {
		return x.Migrate
	}
	return nil
}

func (m *ResponseUnion) GetQueryResolvedTimestamp() *QueryResolvedTimestampResponse {
	if x, ok := m.GetValue().(*ResponseUnion_QueryResolvedTimestamp); ok {
		return x.QueryResolvedTimestamp
	}
	return nil
}

func (m *ResponseUnion) GetBarrier() *BarrierResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Barrier); ok {
		return x.Barrier
	}
	return nil
}

func (m *ResponseUnion) GetProbe() *ProbeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Probe); ok {
		return x.Probe
	}
	return nil
}

func (m *ResponseUnion) GetIsSpanEmpty() *IsSpanEmptyResponse {
	if x, ok := m.GetValue().(*ResponseUnion_IsSpanEmpty); ok {
		return x.IsSpanEmpty
	}
	return nil
}

func (m *ResponseUnion) GetLinkExternalSstable() *LinkExternalSSTableResponse {
	if x, ok := m.GetValue().(*ResponseUnion_LinkExternalSstable); ok {
		return x.LinkExternalSstable
	}
	return nil
}

func (m *ResponseUnion) GetExcise() *ExciseResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Excise); ok {
		return x.Excise
	}
	return nil
}

func (m *ResponseUnion) GetFlushLockTable() *FlushLockTableResponse {
	if x, ok := m.GetValue().(*ResponseUnion_FlushLockTable); ok {
		return x.FlushLockTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ResponseUnion) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ResponseUnion_Get)(nil),
		(*ResponseUnion_Put)(nil),
		(*ResponseUnion_ConditionalPut)(nil),
		(*ResponseUnion_Increment)(nil),
		(*ResponseUnion_Delete)(nil),
		(*ResponseUnion_DeleteRange)(nil),
		(*ResponseUnion_ClearRange)(nil),
		(*ResponseUnion_RevertRange)(nil),
		(*ResponseUnion_Scan)(nil),
		(*ResponseUnion_EndTxn)(nil),
		(*ResponseUnion_AdminSplit)(nil),
		(*ResponseUnion_AdminUnsplit)(nil),
		(*ResponseUnion_AdminMerge)(nil),
		(*ResponseUnion_AdminTransferLease)(nil),
		(*ResponseUnion_AdminChangeReplicas)(nil),
		(*ResponseUnion_AdminRelocateRange)(nil),
		(*ResponseUnion_HeartbeatTxn)(nil),
		(*ResponseUnion_Gc)(nil),
		(*ResponseUnion_PushTxn)(nil),
		(*ResponseUnion_RecoverTxn)(nil),
		(*ResponseUnion_ResolveIntent)(nil),
		(*ResponseUnion_ResolveIntentRange)(nil),
		(*ResponseUnion_Merge)(nil),
		(*ResponseUnion_TruncateLog)(nil),
		(*ResponseUnion_RequestLease)(nil),
		(*ResponseUnion_ReverseScan)(nil),
		(*ResponseUnion_ComputeChecksum)(nil),
		(*ResponseUnion_CheckConsistency)(nil),
		(*ResponseUnion_LeaseInfo)(nil),
		(*ResponseUnion_Export)(nil),
		(*ResponseUnion_QueryTxn)(nil),
		(*ResponseUnion_QueryIntent)(nil),
		(*ResponseUnion_QueryLocks)(nil),
		(*ResponseUnion_AdminScatter)(nil),
		(*ResponseUnion_AddSstable)(nil),
		(*ResponseUnion_RecomputeStats)(nil),
		(*ResponseUnion_Refresh)(nil),
		(*ResponseUnion_RefreshRange)(nil),
		(*ResponseUnion_Subsume)(nil),
		(*ResponseUnion_RangeStats)(nil),
		(*ResponseUnion_Migrate)(nil),
		(*ResponseUnion_QueryResolvedTimestamp)(nil),
		(*ResponseUnion_Barrier)(nil),
		(*ResponseUnion_Probe)(nil),
		(*ResponseUnion_IsSpanEmpty)(nil),
		(*ResponseUnion_LinkExternalSstable)(nil),
		(*ResponseUnion_Excise)(nil),
		(*ResponseUnion_FlushLockTable)(nil),
	}
}

// A Header is attached to a BatchRequest, encapsulating routing and auxiliary
// information required for executing it.
type Header struct {
	// timestamp specifies time at which reads or writes should be performed. If
	// the timestamp is set to zero value, its value is initialized to the wall
	// time of the server node.
	//
	// Transactional requests are not allowed to set this field; they must rely on
	// the server to set it from txn.ReadTimestamp. Also, for transactional
	// requests, writes are performed at the provisional commit timestamp
	// (txn.WriteTimestamp).
	Timestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp"`
	// timestamp_from_server_clock is set when a non-transactional BatchRequest
	// has its timestamp initialized to the wall time of the server node. When
	// non-nil, this denotes the clock timestamp that the timestamp field was
	// initially assigned upon arriving at the server node.
	//
	// It is needed to ensure that such requests are never served as follower
	// reads. Initializing the timestamp of a request on a node that holds a
	// follower instead of the leaseholder for a range and then using this
	// timestamp to deem a follower read safe could allow for consistency
	// violations where a non-transactional read following a write could fail to
	// observe the write.
	//
	// It is also needed to record the time at which the request was received by
	// the server node. The operation timestamp cannot serve this role because it
	// can change due to server-side uncertainty retries. By remembering a stable
	// reference to the initial timestamp, we ensure that a non-transactional
	// request's uncertainty interval remains fixed across retries.
	TimestampFromServerClock *github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,27,opt,name=timestamp_from_server_clock,json=timestampFromServerClock,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"timestamp_from_server_clock,omitempty"`
	// now is a clock reading from the sender of the request. It can be used by
	// the receiver to update its local HLC, which can help stabilize HLCs across
	// the cluster. The receiver is NOT required to use the timestamp to update
	// its local clock, and the sender is NOT required to attach a timestamp.
	Now github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,28,opt,name=now,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"now"`
	// replica specifies the destination of the request.
	Replica roachpb.ReplicaDescriptor `protobuf:"bytes,2,opt,name=replica,proto3" json:"replica"`
	// range_id specifies the ID of the Raft consensus group which the key
	// range belongs to. This is used by the receiving node to route the
	// request to the correct range.
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,3,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// user_priority allows any command's priority to be biased from the
	// default random priority. It specifies a multiple. If set to 0.5,
	// the chosen priority will be 1/2x as likely to beat any default
	// random priority. If set to 1, a default random priority is
	// chosen. If set to 2, the chosen priority will be 2x as likely to
	// beat any default random priority, and so on. As a special case, 0
	// priority is treated the same as 1. This value is ignored if txn
	// is specified. The min and max user priorities are set via
	// roachpb.MinUserPriority and roachpb.MaxUserPriority in roachpb/data.go.
	UserPriority github_com_cockroachdb_cockroach_pkg_roachpb.UserPriority `protobuf:"fixed64,4,opt,name=user_priority,json=userPriority,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.UserPriority" json:"user_priority,omitempty"`
	// txn is set non-nil if a transaction is underway. To start a txn,
	// the first request should set this field to non-nil with name and
	// isolation level set as desired. The response will contain the
	// fully-initialized transaction with txn ID, priority, initial
	// timestamp, and maximum timestamp.
	Txn *roachpb.Transaction `protobuf:"bytes,5,opt,name=txn,proto3" json:"txn,omitempty"`
	// read_consistency specifies the consistency for read
	// operations. The default is CONSISTENT. This value is ignored for
	// write operations.
	ReadConsistency ReadConsistencyType `protobuf:"varint,6,opt,name=read_consistency,json=readConsistency,proto3,enum=cockroach.roachpb.ReadConsistencyType" json:"read_consistency,omitempty"`
	// routing_policy specifies how a request should be routed to the
	// replicas of its target range(s) by the DistSender. The default is
	// LEASEHOLDER, which means that the request should be routed to the
	// leaseholder(s) of its target range(s).
	//
	// The policy does not dictate which replicas in a range are eligible to
	// serve the request, only which replicas are considered as targets by
	// the DistSender, and in which order. A request that is routed to an
	// ineligible replica (a function of request type, timestamp, and read
	// consistency) will be rejected by that replica and the DistSender will
	// target another replica in the range.
	RoutingPolicy RoutingPolicy `protobuf:"varint,19,opt,name=routing_policy,json=routingPolicy,proto3,enum=cockroach.roachpb.RoutingPolicy" json:"routing_policy,omitempty"`
	// wait_policy specifies the desired behavior for the batch request if it
	// encounters a conflicting lock held by another active transaction.
	//
	// If an Error wait policy is set and a conflicting lock held by an active
	// transaction is encountered, a LockConflictError will be returned.
	//
	// If a SkipLocked wait policy is set and a conflicting lock held by an active
	// transaction is encountered, the corresponding key is not included in the
	// response and the lock is ignored (i.e. the lock does not cause the request
	// to block or throw an error).
	//
	// If the desired behavior is to block on the conflicting lock up to some
	// maximum duration, use the Block wait policy and set a context timeout.
	WaitPolicy lock.WaitPolicy `protobuf:"varint,18,opt,name=wait_policy,json=waitPolicy,proto3,enum=cockroach.kv.kvserver.concurrency.lock.WaitPolicy" json:"wait_policy,omitempty"`
	// lock_timeout specifies the maximum amount of time that the batch request
	// will wait while attempting to acquire a lock on a key or while blocking on
	// an existing lock in order to perform a non-locking read on a key. The time
	// limit applies separately to each lock acquisition attempt. If the timeout
	// elapses when waiting for a lock, a LockConflictError will be returned.
	//
	// Unlike in some other systems like PostgreSQL, where non-locking reads do
	// not wait on conflicting locks, in CockroachDB, non-locking reads do wait
	// for conflicting locks to be released. Because of this, the lock_timeout
	// configuration applies to non-locking reads in read-write and read-only
	// transactions as well.
	//
	// Only the (default) Block wait policy will allow a request to wait on
	// conflicting locks, so the timeout only makes sense in conjunction with the
	// Block wait policy. The Error wait policy will throw an error immediately if
	// a conflicting lock held by an active transaction is encountered, so this
	// timeout can never be hit with an Error wait policy.
	//
	// A value of zero disables the timeout.
	LockTimeout time.Duration `protobuf:"bytes,21,opt,name=lock_timeout,json=lockTimeout,proto3,stdduration" json:"lock_timeout"`
	// If set to a non-zero value, the total number of keys touched by requests in
	// the batch is limited. A resume span will be provided on the response of the
	// requests that were not able to run to completion before the limit was
	// reached.
	//
	// Overlapping requests
	//
	// The spans accessed by the requests are allowed to overlap. However, if any
	// requests overlap, the caller must be prepared to handle *multiple* partial
	// responses in the corresponding BatchResponse. If no requests overlap, then
	// only up to one request will return a partial result. Additionally, if two
	// requests touch the same key, it is double counted towards the key limit.
	//
	// Unordered requests
	//
	// The spans accessed by requests do not need to be in sorted order. However,
	// if the requests are not in sorted order (e.g. increasing key order for
	// Scans and other forward requests, decreasing key order for ReverseScans),
	// the caller must be prepared to handle empty responses interleaved with full
	// responses and one (or more, see "Overlapping requests") partial response
	// in the corresponding BatchResponse. If the requests are in sorted order,
	// the caller can expect to receive a group of full responses, one (or more)
	// partial responses, and a group of empty responses.
	//
	// Pagination of requests
	//
	// As discussed above, overlapping requests or unordered requests in batches
	// with a limit can lead to response batches with multiple partial responses.
	// In practice, this is because DistSender paginates request evaluation over
	// ranges in increasing key order (decreasing for reverse batches). As ranges
	// are iterated over in order, all requests that target a given range are sent
	// to it, regardless of their position in the batch. Once split and delivered
	// to a range, the applicable requests are executed in-full according to their
	// order in the batch.
	//
	// This behavior makes it difficult to make assumptions about the resume spans
	// of individual responses in batches that contain either overlapping requests
	// or unordered requests. As such, clients should not make assumptions about
	// resume spans and should instead inspect the result for every request in the
	// batch if if cannot guarantee that the batch is ordered with no overlapping
	// requests.
	//
	// Supported requests
	//
	// If a limit is provided, the batch can contain only the following range
	// request types:
	// - ScanRequest
	// - ReverseScanRequest
	// - DeleteRangeRequest(*)
	// - GetRequest
	// - RevertRangeRequest
	// - ResolveIntentRangeRequest
	// - QueryLocksRequest
	// - IsSpanEmptyRequest
	//
	// The following request types are also allowed in the batch. These requests
	// do not consume any keys from the limit; however, they may fail to be
	// processed if the batch previously consumed the entire limit.
	//
	// - ExportRequest
	// - QueryIntentRequest
	// - EndTxnRequest
	// - ResolveIntentRequest
	// - DeleteRequest
	// - PutRequest
	//
	// [*] DeleteRangeRequests are generally not allowed to be batched together
	// with a commit (i.e. 1PC), except if Require1PC is also set. See #37457.
	//
	// Forward requests and reverse requests cannot be mixed in the same batch if
	// a limit is set. There doesn't seem to be a fundamental reason for this
	// restriction, but a batch that mixed forward and reverse requests would be
	// impossible to order, so it would unavoidably have to deal with the added
	// complications discussed in "Unordered requests". For now, that's a good
	// enough reason to disallow such batches.
	MaxSpanRequestKeys int64 `protobuf:"varint,8,opt,name=max_span_request_keys,json=maxSpanRequestKeys,proto3" json:"max_span_request_keys,omitempty"`
	// TargetBytes will have different behaviour depending on the request type.
	//
	// Forward and Reverse Scans:
	// If set to a non-zero value, sets a target (in bytes) for how large the
	// response may grow. For forward and reverse scans, TargetBytes limits the
	// number of rows scanned (and returned). The target will only be overshot
	// when the first result is larger than the target, unless
	// target_bytes_allow_empty is set. A suitable resume span will be returned.
	//
	// Resolve Intent and Resolve Intent Range:
	// If set to a non-zero value, sets a target (in bytes) for how large the
	// write batch from intent resolution may grow. For resolve intent and resolve
	// intent range: TargetBytes limits the number of intents resolved. We will
	// resolve intents until the number of bytes added to the write batch by
	// intent resolution exceeds the TargetBytes limit. A suitable resume span
	// will be returned.
	//
	// The semantics around overlapping requests, unordered requests, and
	// supported requests from max_span_request_keys apply to the target_bytes
	// option as well.
	TargetBytes int64 `protobuf:"varint,15,opt,name=target_bytes,json=targetBytes,proto3" json:"target_bytes,omitempty"`
	// If positive, Scan and ReverseScan requests with limits (MaxSpanRequestKeys
	// or TargetBytes) will not return results with partial SQL rows at the end
	// (recall that SQL rows can span multiple keys). Such partial rows will be
	// removed from the result, unless AllowEmpty is false and the partial row is
	// the first result row, in which case additional keys will be fetched to
	// complete the row.
	//
	// The given value specifies the maximum number of keys in a row (i.e. the
	// number of column families). If any larger rows are found at the end of the
	// result, an error is returned.
	WholeRowsOfSize int32 `protobuf:"varint,26,opt,name=whole_rows_of_size,json=wholeRowsOfSize,proto3" json:"whole_rows_of_size,omitempty"`
	// If true, allow returning an empty result when the first result exceeds a
	// limit (e.g. TargetBytes). Only supported by Get, Scan, and ReverseScan.
	AllowEmpty bool `protobuf:"varint,23,opt,name=allow_empty,json=allowEmpty,proto3" json:"allow_empty,omitempty"`
	// If set, all of the spans in the batch are distinct. Note that the
	// calculation of distinct spans does not include intents in an
	// EndTxnRequest. Currently set conservatively: a request might be
	// composed of distinct spans yet have this field set to false.
	DistinctSpans bool `protobuf:"varint,9,opt,name=distinct_spans,json=distinctSpans,proto3" json:"distinct_spans,omitempty"`
	// If set, the request will return to the client before proposing the
	// request into Raft. All consensus processing will be performed
	// asynchronously. Because consensus may fail, this means that the
	// request cannot be expected to succeed. Instead, its success must
	// be verified.
	// TODO(nvanbenschoten): Handling cases where consensus fails would
	// be much more straightforward if all transactional requests were
	// idempotent. We could just re-issue requests. See #26915.
	AsyncConsensus bool `protobuf:"varint,13,opt,name=async_consensus,json=asyncConsensus,proto3" json:"async_consensus,omitempty"`
	// can_forward_read_timestamp indicates that the batch can be evaluated at a
	// higher timestamp than the transaction's read timestamp. The flag is only
	// applicable to transactional batches and is assumed to be true for all
	// non-transactional batches. It is set by the client if the transaction
	// has not performed any reads that must be refreshed prior to sending this
	// current batch. When set, it allows the server to handle pushes and write
	// too old conditions locally.
	CanForwardReadTimestamp bool `protobuf:"varint,16,opt,name=can_forward_read_timestamp,json=canForwardReadTimestamp,proto3" json:"can_forward_read_timestamp,omitempty"`
	// gateway_node_id is the ID of the gateway node where the request
	// originated. For requests from a shared-process cluster, this is set to the
	// NodeID of the KV node which created the BatchRequest. For requests from a
	// separate-process SQL Pod or a CLI, this is set to 0.
	GatewayNodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,11,opt,name=gateway_node_id,json=gatewayNodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"gateway_node_id,omitempty"`
	// client_range_info represents the kvclient's knowledge about the state of
	// the range (i.e. of the range descriptor and lease). The kvserver checks
	// whether the client's info is up to date and, if it isn't, it will return a
	// RangeInfo with up-to-date information. Typically this entire field is set
	// by the client's DistSender, however it will preserve the value of the field
	// `ExplicitlyRequested` so that requests passed to DistSender can request
	// `RangeInfos` if desired.
	//
	// If empty, range info is never returned (from 23.2 onwards). Use
	// ExplicitlyRequested to force an update for an otherwise-empty field.
	ClientRangeInfo roachpb.ClientRangeInfo `protobuf:"bytes,17,opt,name=client_range_info,json=clientRangeInfo,proto3" json:"client_range_info"`
	// bounded_staleness is set when a read-only batch is performing a bounded
	// staleness read and wants its timestamp to be chosen dynamically, based
	// on a resolved timestamp from its target replica(s).
	//
	// Transactional requests are not allowed to set this field. As a result,
	// the request can not span ranges and will be rejected by the DistSender
	// with an OpRequiresTxnError if it attempts to.
	//
	// Requests with a non-zero timestamp are not allowed to set this field.
	BoundedStaleness *BoundedStalenessHeader `protobuf:"bytes,22,opt,name=bounded_staleness,json=boundedStaleness,proto3" json:"bounded_staleness,omitempty"`
	// trace_info gives the server information about the trace that the RPC is
	// part of. This is not set for local RPCs that don't go through gRPC.
	//
	// If a recording mode is set, the response will have collect_spans filled in.
	TraceInfo *tracingpb.TraceInfo `protobuf:"bytes,25,opt,name=trace_info,json=traceInfo,proto3" json:"trace_info,omitempty"`
	// index_fetch_spec, if set, is used for ScanRequests and ReverseScanRequests
	// with COL_BATCH_RESPONSE ScanFormat.
	//
	// The rationale for having this as a single "global" field on the
	// BatchRequest is that SQL never issues requests touching different indexes
	// in a single BatchRequest, so it would be redundant to copy this field into
	// each Scan and ReverseScan.
	IndexFetchSpec *fetchpb.IndexFetchSpec `protobuf:"bytes,29,opt,name=index_fetch_spec,json=indexFetchSpec,proto3" json:"index_fetch_spec,omitempty"`
	// ReturnElasticCPUResumeSpans, if set, indicates that the caller
	// expects early-termination of requests based on the Elastic CPU
	// limiter.
	//
	// Resume spans returned because of the underlying request being
	// rate-limited by the ElasticCPU limiter will have a reason of
	// RESUME_ELASTIC_CPU_LIMIT.
	ReturnElasticCPUResumeSpans bool `protobuf:"varint,30,opt,name=return_elastic_cpu_resume_spans,json=returnElasticCpuResumeSpans,proto3" json:"return_elastic_cpu_resume_spans,omitempty"`
	// ProfileLabels are the pprof labels set on the context that is sending the
	// BatchRequest.
	//
	// If the node processing the BatchRequest is collecting a CPU profile with
	// labels, then these profile labels will be applied to the root context
	// processing the BatchRequest on the server-side. Propagating these labels
	// across RPC boundaries will help correlate server CPU profile samples to the
	// sender.
	ProfileLabels []string `protobuf:"bytes,31,rep,name=profile_labels,json=profileLabels,proto3" json:"profile_labels,omitempty"`
	// AmbiguousReplayProtection, if set, prevents a retried write operation
	// from being considered an idempotent replay of a successful prior attempt
	// (of the same operation) if the request's write timestamp is different from
	// the prior attempt's. This protection is required when there has been an
	// ambiguous write (i.e. RPC error) on a batch that contained a commit,
	// as the transaction may have already been considered implicitly committed,
	// and/or been explicitly committed by a RecoverTxn request. See #103817.
	AmbiguousReplayProtection bool `protobuf:"varint,32,opt,name=ambiguous_replay_protection,json=ambiguousReplayProtection,proto3" json:"ambiguous_replay_protection,omitempty"`
	// ConnectionClass specifies the preferred RPC connection class to use for
	// sending or retransmitting this BatchRequest.
	//
	// This is only a hint. Senders of this request may override this preference.
	// For example, requests to some critical system ranges can be "upgraded" to
	// the SYSTEM class.
	//
	// If the enum value is unknown (for instance, may happen when the cluster is
	// in a mixed-version state after a new value got added), DEFAULT is assumed.
	ConnectionClass rpcpb.ConnectionClass `protobuf:"varint,33,opt,name=connection_class,json=connectionClass,proto3,enum=cockroach.rpc.ConnectionClass" json:"connection_class,omitempty"`
	// ProxyRangeInfo, if set, indicates the RangeInfo information a client had
	// when it sent this request. This information is passed to an intermediate
	// proxy node which can then forward the request to the final destination.
	// If this field is set, then the node which receives the BatchRequest should
	// first try and evaluate the request locally. If local evaluation fails with
	// a NotLeaseHolderError, it should act on behalf of the original client and
	// forward the original request, with this field cleared, to the leaseholder
	// as determined by the ProxyRangeInfo header.
	//
	// If the kv.dist_sender.proxy.enabled parameter is set to false, the client
	// will never set this header and proxying will be disabled.
	//
	// NB: This field is only used in 24.1+ systems. A mixed mode system with at
	// least one node not on 24.1 will exhibit the following behavior.
	// * A client older than 24.1 will never set this field.
	// * A proxy node older than 24.1 will ignore this field being set and return an
	// error after local evaluation like it does in older systems.
	// * A destination node older than 24.1 will not see this field.
	ProxyRangeInfo *roachpb.RangeInfo `protobuf:"bytes,34,opt,name=proxy_range_info,json=proxyRangeInfo,proto3" json:"proxy_range_info,omitempty"`
	WriteOptions   *WriteOptions      `protobuf:"bytes,35,opt,name=write_options,json=writeOptions,proto3" json:"write_options,omitempty"`
	// DeadlockTimeout specifies the amount of time that a request will wait on a
	// lock before pushing the lock holder transaction to detect deadlocks.
	//
	// DeadlockTimeout, if set, takes precedence over the
	// kv.lock_table.deadlock_detection_push_delay cluster setting. If unset,
	// the cluster setting is used instead.
	//
	// This differs from kv.lock_table.deadlock_detection_push_delay in that it
	// gets applied at a finer granularity, where
	// kv.lock_table.deadlock_detection_push_delay is a a cluster wide setting.
	DeadlockTimeout time.Duration `protobuf:"bytes,36,opt,name=deadlock_timeout,json=deadlockTimeout,proto3,stdduration" json:"deadlock_timeout"`
	// HasBufferedAllPrecedingWrites, if set, indicates that the batch belongs to
	// a transaction that has buffered all of its writes (from preceding batches)
	// on the client.
	//
	// The server may use this field to omit checking the AbortSpan. Transactions
	// use the AbortSpan to check whether they've been aborted or not. If they
	// have, any intents they may have previously written could be removed by
	// concurrent transactions, which means a transaction may not have a guarantee
	// to read its own writes. So, transactions eagerly check the AbortSpan to
	// identify this case and eagerly return a TransactionAbortedError to the
	// client, instead of breaking read-your-own-writes. However, transactions
	// that have buffered all writes on the client uphold read-your-own-writes
	// semantics by joining results from the KVServer against the write buffer;
	// simply put, they do not rely on the AbortSpan to uphold
	// read-your-own-writes. As such, they can eschew checking the AbortSpan on
	// the server.
	HasBufferedAllPrecedingWrites bool `protobuf:"varint,37,opt,name=has_buffered_all_preceding_writes,json=hasBufferedAllPrecedingWrites,proto3" json:"has_buffered_all_preceding_writes,omitempty"`
	// IsReverse, if set, indicates that the requests in the batch should be
	// evaluated in descending range order.
	IsReverse bool `protobuf:"varint,38,opt,name=is_reverse,json=isReverse,proto3" json:"is_reverse,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{108}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

type WriteOptions struct {
	OriginID uint32 `protobuf:"varint,1,opt,name=origin_id,json=originId,proto3" json:"origin_id,omitempty"`
	// OriginTimestamp is bound to the MVCCValueHeader of written key in the
	// batch. Note that a kv client cannot set this if they use CPut's origin
	// timestamp arg.
	OriginTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=origin_timestamp,json=originTimestamp,proto3" json:"origin_timestamp"`
}

func (m *WriteOptions) Reset()         { *m = WriteOptions{} }
func (m *WriteOptions) String() string { return proto.CompactTextString(m) }
func (*WriteOptions) ProtoMessage()    {}
func (*WriteOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{109}
}
func (m *WriteOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WriteOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteOptions.Merge(m, src)
}
func (m *WriteOptions) XXX_Size() int {
	return m.Size()
}
func (m *WriteOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteOptions.DiscardUnknown(m)
}

var xxx_messageInfo_WriteOptions proto.InternalMessageInfo

// BoundedStalenessHeader contains configuration values pertaining to bounded
// staleness read requests.
type BoundedStalenessHeader struct {
	// min_timestamp_bound places an (inclusive) lower bound on the dynamically
	// chosen timestamp during a bounded staleness read. During such reads, a
	// resolved timestamp over the request's key span will initially be computed
	// on the target replica. If the resolved timestamp is equal to or greater
	// than the minimum timestamp bound, then the batch timestamp will be set to
	// the resolved timestamp, the batch will be evaluated, and the negotiated
	// timestamp will be recorded in the BatchResponse Header. If the resolved
	// timestamp is less than the minimum timestamp bound, then the request will
	// either be rejected with a MinTimestampBoundUnsatisfiableError or will be
	// redirected to the leaseholder and permitted to block on conflicting
	// transactions, depending on the value of min_timestamp_bound_strict.
	//
	// This field is required when a BoundedStalenessHeader is set in a Header.
	MinTimestampBound hlc.Timestamp `protobuf:"bytes,1,opt,name=min_timestamp_bound,json=minTimestampBound,proto3" json:"min_timestamp_bound"`
	// min_timestamp_bound_strict specifies whether a bounded staleness read
	// whose min_timestamp_bound cannot be satisfied by the first replica it
	// visits (subject to routing_policy) without blocking should be rejected
	// with a MinTimestampBoundUnsatisfiableError or will be redirected to the
	// leaseholder and permitted to block on conflicting transactions. If the
	// flag is true, blocking is never permitted and users should be prepared
	// to handle MinTimestampBoundUnsatisfiableErrors. If the flag is false,
	// blocking is permitted and MinTimestampBoundUnsatisfiableErrors will never
	// be returned.
	MinTimestampBoundStrict bool `protobuf:"varint,2,opt,name=min_timestamp_bound_strict,json=minTimestampBoundStrict,proto3" json:"min_timestamp_bound_strict,omitempty"`
	// max_timestamp_bound places an (exclusive) upper bound on the dynamically
	// chosen timestamp during a bounded staleness read. If the field is set and a
	// resolved timestamp over the request's key span is computed to be greater
	// than or equal to the maximum timestamp bound, the batch timestamp will be
	// set to the timestamp preceding the maximum timestamp bound instead, then
	// the batch will be evaluated at this timestamp, and it will be recorded in
	// the BatchResponse Header.
	//
	// This field is optional when a BoundedStalenessHeader is set in a Header.
	// However, if the field is set, max_timestamp_bound must be greater than
	// min_timestamp_bound.
	MaxTimestampBound hlc.Timestamp `protobuf:"bytes,3,opt,name=max_timestamp_bound,json=maxTimestampBound,proto3" json:"max_timestamp_bound"`
}

func (m *BoundedStalenessHeader) Reset()         { *m = BoundedStalenessHeader{} }
func (m *BoundedStalenessHeader) String() string { return proto.CompactTextString(m) }
func (*BoundedStalenessHeader) ProtoMessage()    {}
func (*BoundedStalenessHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{110}
}
func (m *BoundedStalenessHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoundedStalenessHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BoundedStalenessHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundedStalenessHeader.Merge(m, src)
}
func (m *BoundedStalenessHeader) XXX_Size() int {
	return m.Size()
}
func (m *BoundedStalenessHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundedStalenessHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BoundedStalenessHeader proto.InternalMessageInfo

// AdmissionHeader contains information utilized by admission control for the
// request.
type AdmissionHeader struct {
	// Priority is utilized within a tenant. See admission.WorkPriority.
	//
	// TODO(sumeer): Use gogoproto.customtype to make this
	// admissionpb.WorkPriority.
	Priority int32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// CreateTime is equivalent to Time.UnixNano() at the creation time of this
	// request or a parent request. See admission.WorkInfo.Priority for details.
	// It is used to give preference to older requests.
	CreateTime     int64                          `protobuf:"varint,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	Source         AdmissionHeader_Source         `protobuf:"varint,3,opt,name=source,proto3,enum=cockroach.roachpb.AdmissionHeader_Source" json:"source,omitempty"`
	SourceLocation AdmissionHeader_SourceLocation `protobuf:"varint,4,opt,name=source_location,json=sourceLocation,proto3,enum=cockroach.roachpb.AdmissionHeader_SourceLocation" json:"source_location,omitempty"`
	// NoMemoryReservedAtSource is set by the source/client when it has
	// effectively reserved close to 0 bytes. It is read by the server only when
	// SourceLocation=LOCAL, to differentiate this 0 reservation case from the
	// case where the client has already reserved enough memory based on
	// previous responses. In the latter case the server avoids reserving more
	// since it would result in double counting. Not setting this defaults to
	// turning off server reserving more memory -- this optimistic choice was
	// made to err on the side of avoiding double counting in case we forget to
	// instrument some calling path.
	//
	// NOTE: This field is a temporary field until we move to comprehensive
	// accounting at the client, by reserving all the bytes for responses, and
	// explicitly propagating these through DistSender to the servers, so the
	// servers can (best-effort) respect these values when producing responses.
	// In that future world, the local server will explicitly know what has
	// already been accounted for, and can start reserving more only when it
	// exceeds.
	NoMemoryReservedAtSource bool `protobuf:"varint,5,opt,name=no_memory_reserved_at_source,json=noMemoryReservedAtSource,proto3" json:"no_memory_reserved_at_source,omitempty"`
}

func (m *AdmissionHeader) Reset()         { *m = AdmissionHeader{} }
func (m *AdmissionHeader) String() string { return proto.CompactTextString(m) }
func (*AdmissionHeader) ProtoMessage()    {}
func (*AdmissionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{111}
}
func (m *AdmissionHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdmissionHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdmissionHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdmissionHeader.Merge(m, src)
}
func (m *AdmissionHeader) XXX_Size() int {
	return m.Size()
}
func (m *AdmissionHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_AdmissionHeader.DiscardUnknown(m)
}

var xxx_messageInfo_AdmissionHeader proto.InternalMessageInfo

// A BatchRequest contains one or more requests to be executed in
// parallel, or if applicable (based on write-only commands and
// range-locality), as a single update.
type BatchRequest struct {
	Header          `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Requests        []RequestUnion  `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests"`
	AdmissionHeader AdmissionHeader `protobuf:"bytes,3,opt,name=admission_header,json=admissionHeader,proto3" json:"admission_header"`
}

func (m *BatchRequest) Reset()      { *m = BatchRequest{} }
func (*BatchRequest) ProtoMessage() {}
func (*BatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{112}
}
func (m *BatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchRequest.Merge(m, src)
}
func (m *BatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchRequest proto.InternalMessageInfo

// A BatchResponse contains one or more responses, one per request
// corresponding to the requests in the matching BatchRequest. The
// error in the response header is set to the first error from the
// slice of responses, if applicable.
type BatchResponse struct {
	BatchResponse_Header `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Responses            []ResponseUnion `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses"`
}

func (m *BatchResponse) Reset()      { *m = BatchResponse{} }
func (*BatchResponse) ProtoMessage() {}
func (*BatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{113}
}
func (m *BatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResponse.Merge(m, src)
}
func (m *BatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResponse proto.InternalMessageInfo

type BatchResponse_Header struct {
	// error communicates a structured error (i.e. one originating from a Node)
	// while the BatchResponse is sent over the network. If the code were
	// written today, the RPC endpoint would return a message containing both a
	// BatchResponse and an Error, and this embedding would go away. However, it
	// returns only a BatchResponse, and so the Error needs to be tucked away
	// somewhere (the structured error cannot be communicated via an RPC-level
	// error).
	//
	// Outside of the RPC boundaries, this field is nil and must neither be
	// checked nor populated (it is reset by the DistSender, which extracts this
	// error and returns it separately). In effect, nearly no usage of
	// BatchResponse needs to care about this field.
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// timestamp denotes the timestamp at which the batch's reads executed. The
	// timestamp cache is updated at this timestamp.
	//
	// TODO(tbg): for transactional requests, this duplicates `Txn.ReadTimestamp`,
	// which is awkward. We could consider making this field optional and only
	// populate it for non-transactional requests. The timestamp cache would then
	// use an accessor on BatchResponse to pick the one that matters.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=Timestamp,proto3" json:"Timestamp"`
	// txn is non-nil if the request specified a non-nil
	// transaction. The transaction timestamp and/or priority may have
	// been updated, depending on the outcome of the request.
	Txn *roachpb.Transaction `protobuf:"bytes,3,opt,name=txn,proto3" json:"txn,omitempty"`
	// now is the highest current time from any node contacted during the request.
	// It can be used by the receiver to update its local HLC.
	Now github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=now,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"now"`
	// collected_spans stores trace spans recorded during the execution of this
	// request, if recording is requested through trace_info on the request.
	//
	// The server fills in reply.CollectedSpans only when the client asked for
	// it by setting trace_info on the request, and specifying a recording mode.
	// Notably, the client does not set trace_info on local RPCs which don't go
	// through gRPC; for local RPCs, the Tracer is shared between the client and
	// the server, and the server span is a child of the server span.
	CollectedSpans []tracingpb.RecordedSpan `protobuf:"bytes,6,rep,name=collected_spans,json=collectedSpans,proto3" json:"collected_spans"`
	// Range used to execute the request. The server only populates this if the
	// server detects the client's client_range_info to be stale. Otherwise, it
	// is left empty. Not set when Error is set.
	//
	// The server may also include additional RangeInfo objects if it suspects
	// that the client may be interested in them. This is currently the case
	// immediately after a Range split, where a stale client_range_info from
	// before the split is taken to be an indication that the client may be
	// interested in information about both the LHS and RHS post-split ranges.
	//
	// The field is cleared by the DistSender because it refers routing
	// information not exposed by the KV API.
	RangeInfos []roachpb.RangeInfo `protobuf:"bytes,7,rep,name=range_infos,json=rangeInfos,proto3" json:"range_infos"`
}

func (m *BatchResponse_Header) Reset()         { *m = BatchResponse_Header{} }
func (m *BatchResponse_Header) String() string { return proto.CompactTextString(m) }
func (*BatchResponse_Header) ProtoMessage()    {}
func (*BatchResponse_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{113, 0}
}
func (m *BatchResponse_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResponse_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchResponse_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResponse_Header.Merge(m, src)
}
func (m *BatchResponse_Header) XXX_Size() int {
	return m.Size()
}
func (m *BatchResponse_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResponse_Header.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResponse_Header proto.InternalMessageInfo

// RangeLookupRequest is a request to proxy a RangeLookup through a Tenant
// service. Its fields correspond to a subset of the args of kv.RangeLookup.
type RangeLookupRequest struct {
	Key             github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,1,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"key,omitempty"`
	ReadConsistency ReadConsistencyType                               `protobuf:"varint,2,opt,name=read_consistency,json=readConsistency,proto3,enum=cockroach.roachpb.ReadConsistencyType" json:"read_consistency,omitempty"`
	PrefetchNum     int64                                             `protobuf:"varint,3,opt,name=prefetch_num,json=prefetchNum,proto3" json:"prefetch_num,omitempty"`
	PrefetchReverse bool                                              `protobuf:"varint,4,opt,name=prefetch_reverse,json=prefetchReverse,proto3" json:"prefetch_reverse,omitempty"`
}

func (m *RangeLookupRequest) Reset()         { *m = RangeLookupRequest{} }
func (m *RangeLookupRequest) String() string { return proto.CompactTextString(m) }
func (*RangeLookupRequest) ProtoMessage()    {}
func (*RangeLookupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{114}
}
func (m *RangeLookupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLookupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLookupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLookupRequest.Merge(m, src)
}
func (m *RangeLookupRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeLookupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLookupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLookupRequest proto.InternalMessageInfo

// RangeLookupResponse is returned from a RangeLookup request proxied through a
// Tenant service. Its fields correspond to the return values of kv.RangeLookup.
type RangeLookupResponse struct {
	Descriptors           []roachpb.RangeDescriptor `protobuf:"bytes,1,rep,name=descriptors,proto3" json:"descriptors"`
	PrefetchedDescriptors []roachpb.RangeDescriptor `protobuf:"bytes,2,rep,name=prefetched_descriptors,json=prefetchedDescriptors,proto3" json:"prefetched_descriptors"`
	// If non-nil, the other fields will be empty.
	Error *Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RangeLookupResponse) Reset()         { *m = RangeLookupResponse{} }
func (m *RangeLookupResponse) String() string { return proto.CompactTextString(m) }
func (*RangeLookupResponse) ProtoMessage()    {}
func (*RangeLookupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{115}
}
func (m *RangeLookupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLookupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLookupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLookupResponse.Merge(m, src)
}
func (m *RangeLookupResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeLookupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLookupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLookupResponse proto.InternalMessageInfo

// RangeFeedRequest is a request that expresses the intention to establish a
// RangeFeed stream over the provided span, starting at the specified timestamp
// (exclusive).
//
// Rangefeeds do not support inline (unversioned) values, and may omit them or
// error on them. Similarly, rangefeeds will error if MVCC history is mutated
// via e.g. ClearRange. Do not use rangefeeds across such key spans.
//
// NB: The start timestamp is exclusive, i.e. the first possible event emitted
// will be at Header.Timestamp.Next(). This includes catchup scans.
type RangeFeedRequest struct {
	Header `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Span   roachpb.Span `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
	// with_diff specifies whether RangeFeedValue updates should contain the
	// previous value that was overwritten.
	WithDiff bool `protobuf:"varint,3,opt,name=with_diff,json=withDiff,proto3" json:"with_diff,omitempty"`
	// AdmissionHeader is used only at the start of the range feed stream, since
	// the initial catch-up scan be expensive.
	AdmissionHeader AdmissionHeader `protobuf:"bytes,4,opt,name=admission_header,json=admissionHeader,proto3" json:"admission_header"`
	// StreamID is set by the client issuing MuxRangeFeed requests.
	StreamID int64 `protobuf:"varint,5,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// CloseStream is set by the mux RangeFeed client to indicate that
	// the server should close the stream with the specified stream_id.
	// When this bit is set, the server should attempt, as best effort, to
	// quickly terminate rangefeed for this stream.
	// When CloseStream is set, only the StreamID must be set, and
	// other fields (such as Span) are ignored.
	CloseStream bool `protobuf:"varint,6,opt,name=close_stream,json=closeStream,proto3" json:"close_stream,omitempty"`
	// WithFiltering specifies if the rangefeed server should respect the
	// OmitInRangefeeds flag of a transactional write. If WithFiltering = true and
	// OmitInRangefeeds = true, the write will not be emitted on the rangefeed.
	// WithFiltering should NOT be set for system-table rangefeeds.
	WithFiltering bool `protobuf:"varint,7,opt,name=with_filtering,json=withFiltering,proto3" json:"with_filtering,omitempty"`
	// WithMatchingOriginIDs specifies if the rangefeed server should emit events
	// originating from specific clusters during Logical Data Replication. If this
	// field is empty, all events are emitted.
	WithMatchingOriginIDs []uint32 `protobuf:"varint,8,rep,packed,name=with_matching_origin_ids,json=withMatchingOriginIds,proto3" json:"with_matching_origin_ids,omitempty"`
	// ConsumerID is set by the caller to identify itself.
	ConsumerID int64 `protobuf:"varint,9,opt,name=consumer_id,json=consumerId,proto3" json:"consumer_id,omitempty"`
	// WithBulkDelivery requests the stream include "bulk" events which wrap many
	// events in a single event to reduce overhead, e.g. during scans.
	WithBulkDelivery bool `protobuf:"varint,10,opt,name=with_bulk_delivery,json=withBulkDelivery,proto3" json:"with_bulk_delivery,omitempty"`
}

func (m *RangeFeedRequest) Reset()         { *m = RangeFeedRequest{} }
func (m *RangeFeedRequest) String() string { return proto.CompactTextString(m) }
func (*RangeFeedRequest) ProtoMessage()    {}
func (*RangeFeedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{116}
}
func (m *RangeFeedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedRequest.Merge(m, src)
}
func (m *RangeFeedRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedRequest proto.InternalMessageInfo

// RangeFeedValue is a variant of RangeFeedEvent that represents an update to
// the specified key with the provided value.
type RangeFeedValue struct {
	Key   github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	Value roachpb.Value                                    `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// prev_value is only populated if both:
	// 1. with_diff was passed in the corresponding RangeFeedRequest.
	// 2. the key-value was present and not a deletion tombstone before
	//    this event.
	// The timestamp on the previous value is empty.
	PrevValue roachpb.Value `protobuf:"bytes,3,opt,name=prev_value,json=prevValue,proto3" json:"prev_value"`
}

func (m *RangeFeedValue) Reset()         { *m = RangeFeedValue{} }
func (m *RangeFeedValue) String() string { return proto.CompactTextString(m) }
func (*RangeFeedValue) ProtoMessage()    {}
func (*RangeFeedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{117}
}
func (m *RangeFeedValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedValue.Merge(m, src)
}
func (m *RangeFeedValue) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedValue.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedValue proto.InternalMessageInfo

// RangeFeedBulkEvents is a variant of RangeFeedEvent that represetns a
// collection of many RangeFeedEvent delivered as a single event rather than
// individually for reduced delivery overhead when many events are available,
// such as during catch-up scans.
type RangeFeedBulkEvents struct {
	Events []*RangeFeedEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *RangeFeedBulkEvents) Reset()         { *m = RangeFeedBulkEvents{} }
func (m *RangeFeedBulkEvents) String() string { return proto.CompactTextString(m) }
func (*RangeFeedBulkEvents) ProtoMessage()    {}
func (*RangeFeedBulkEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{118}
}
func (m *RangeFeedBulkEvents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedBulkEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedBulkEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedBulkEvents.Merge(m, src)
}
func (m *RangeFeedBulkEvents) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedBulkEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedBulkEvents.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedBulkEvents proto.InternalMessageInfo

// RangeFeedCheckpoint is a variant of RangeFeedEvent that represents the
// promise that no more RangeFeedValue events with keys in the specified span
// with timestamps less than or equal to the specified resolved timestamp will
// be emitted on the RangeFeed response stream.
//
// Note that these resolved timestamps may be lower than the timestamp used in
// the RangeFeedRequest used to start the RangeFeed.
type RangeFeedCheckpoint struct {
	Span       roachpb.Span  `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	ResolvedTS hlc.Timestamp `protobuf:"bytes,2,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts"`
}

func (m *RangeFeedCheckpoint) Reset()         { *m = RangeFeedCheckpoint{} }
func (m *RangeFeedCheckpoint) String() string { return proto.CompactTextString(m) }
func (*RangeFeedCheckpoint) ProtoMessage()    {}
func (*RangeFeedCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{119}
}
func (m *RangeFeedCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedCheckpoint.Merge(m, src)
}
func (m *RangeFeedCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedCheckpoint proto.InternalMessageInfo

// RangeFeedError is a variant of RangeFeedEvent that indicates that an error
// occurred during the processing of the RangeFeed. If emitted, a RangeFeedError
// event will always be the final event on a RangeFeed response stream before
// it is torn down.
type RangeFeedError struct {
	Error Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
}

func (m *RangeFeedError) Reset()         { *m = RangeFeedError{} }
func (m *RangeFeedError) String() string { return proto.CompactTextString(m) }
func (*RangeFeedError) ProtoMessage()    {}
func (*RangeFeedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{120}
}
func (m *RangeFeedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedError.Merge(m, src)
}
func (m *RangeFeedError) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedError) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedError.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedError proto.InternalMessageInfo

// RangeFeedSSTable is a variant of RangeFeedEvent that represents an AddSSTable
// operation, containing the entire ingested SST. It is only emitted for
// SSTables written with SSTTimestampToRequestTimestamp enabled, so it is
// guaranteed to comply with the closed timestamp. The Span and WriteTS fields
// are advisory, and contain the client-provided SST key span (may be wider than
// the SST data) and the MVCC timestamp used for all contained entries.
//
// The entire SST is emitted even for registrations that have a narrower span,
// it is up to the caller to prune the SST as appropriate. Catchup scans emit
// the data as RangeFeedValue events instead (i.e. it reads the ingested KV
// pairs), but Raft log replay will emit RangeFeedSSTable events.
type RangeFeedSSTable struct {
	Data    []byte        `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Span    roachpb.Span  `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
	WriteTS hlc.Timestamp `protobuf:"bytes,3,opt,name=write_ts,json=writeTs,proto3" json:"write_ts"`
}

func (m *RangeFeedSSTable) Reset()         { *m = RangeFeedSSTable{} }
func (m *RangeFeedSSTable) String() string { return proto.CompactTextString(m) }
func (*RangeFeedSSTable) ProtoMessage()    {}
func (*RangeFeedSSTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{121}
}
func (m *RangeFeedSSTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedSSTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedSSTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedSSTable.Merge(m, src)
}
func (m *RangeFeedSSTable) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedSSTable) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedSSTable.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedSSTable proto.InternalMessageInfo

// RangeFeedDeleteRange is a variant of RangeFeedEvent that represents a
// deletion of the specified key range at the given timestamp using an MVCC
// range tombstone.
type RangeFeedDeleteRange struct {
	Span      roachpb.Span  `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *RangeFeedDeleteRange) Reset()         { *m = RangeFeedDeleteRange{} }
func (m *RangeFeedDeleteRange) String() string { return proto.CompactTextString(m) }
func (*RangeFeedDeleteRange) ProtoMessage()    {}
func (*RangeFeedDeleteRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{122}
}
func (m *RangeFeedDeleteRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedDeleteRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedDeleteRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedDeleteRange.Merge(m, src)
}
func (m *RangeFeedDeleteRange) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedDeleteRange) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedDeleteRange.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedDeleteRange proto.InternalMessageInfo

// RangefeedMetadata is a variant of RangefeedEvent that contains metadata about
// a newly spawned partial rangefeed.
type RangeFeedMetadata struct {
	// Span is the span of the newly spawned partial rangefeed.
	Span roachpb.Span `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	// FromManualSplit is true when this rangefeed spawned due to the parent
	// rangefeed retrying after a manual split.
	FromManualSplit bool `protobuf:"varint,2,opt,name=from_manual_split,json=fromManualSplit,proto3" json:"from_manual_split,omitempty"`
	// ParentStartKey is the start key of the retried parent rangefeed.
	ParentStartKey github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,3,opt,name=parent_start_key,json=parentStartKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"parent_start_key,omitempty"`
}

func (m *RangeFeedMetadata) Reset()         { *m = RangeFeedMetadata{} }
func (m *RangeFeedMetadata) String() string { return proto.CompactTextString(m) }
func (*RangeFeedMetadata) ProtoMessage()    {}
func (*RangeFeedMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{123}
}
func (m *RangeFeedMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedMetadata.Merge(m, src)
}
func (m *RangeFeedMetadata) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedMetadata proto.InternalMessageInfo

// RangeFeedEvent is a union of all event types that may be returned on a
// RangeFeed response stream.
type RangeFeedEvent struct {
	Val         *RangeFeedValue       `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty"`
	Checkpoint  *RangeFeedCheckpoint  `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	Error       *RangeFeedError       `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	SST         *RangeFeedSSTable     `protobuf:"bytes,4,opt,name=sst,proto3" json:"sst,omitempty"`
	DeleteRange *RangeFeedDeleteRange `protobuf:"bytes,5,opt,name=delete_range,json=deleteRange,proto3" json:"delete_range,omitempty"`
	Metadata    *RangeFeedMetadata    `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
	BulkEvents  *RangeFeedBulkEvents  `protobuf:"bytes,7,opt,name=bulk_events,json=bulkEvents,proto3" json:"bulk_events,omitempty"`
}

func (m *RangeFeedEvent) Reset()         { *m = RangeFeedEvent{} }
func (m *RangeFeedEvent) String() string { return proto.CompactTextString(m) }
func (*RangeFeedEvent) ProtoMessage()    {}
func (*RangeFeedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{124}
}
func (m *RangeFeedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedEvent.Merge(m, src)
}
func (m *RangeFeedEvent) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedEvent proto.InternalMessageInfo

// MuxRangeFeedEvent is a response generated by MuxRangeFeed RPC.  It tags
// the underlying RangeFeedEvent with the ID of the range that produced this event.
type MuxRangeFeedEvent struct {
	RangeFeedEvent `protobuf:"bytes,1,opt,name=event,proto3,embedded=event" json:"event"`
	RangeID        github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// Server echoes back stream_id set by the client.
	StreamID int64 `protobuf:"varint,3,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
}

func (m *MuxRangeFeedEvent) Reset()         { *m = MuxRangeFeedEvent{} }
func (m *MuxRangeFeedEvent) String() string { return proto.CompactTextString(m) }
func (*MuxRangeFeedEvent) ProtoMessage()    {}
func (*MuxRangeFeedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{125}
}
func (m *MuxRangeFeedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MuxRangeFeedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MuxRangeFeedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MuxRangeFeedEvent.Merge(m, src)
}
func (m *MuxRangeFeedEvent) XXX_Size() int {
	return m.Size()
}
func (m *MuxRangeFeedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MuxRangeFeedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MuxRangeFeedEvent proto.InternalMessageInfo

// ResetQuorumRequest makes a range that is unavailable due to lost quorum
// available again, at the cost of losing all of the data in the range. Any
// existing replica, even one residing on the target node, will irrevocably
// be removed. ResetQuorumRequest first uses meta2 to identify the range
// descriptor. Then, it removes all replicas from the range descriptor and
// adds a store from the target node as the one designated survivor replica.
// This change is then written to meta2 and sent as a snapshot to a store
// local to the target node.
//
// This RPC is called by the user directly and will not work for ranges
// that have not lost quorum or for a meta range.
type ResetQuorumRequest struct {
	RangeID int32 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *ResetQuorumRequest) Reset()         { *m = ResetQuorumRequest{} }
func (m *ResetQuorumRequest) String() string { return proto.CompactTextString(m) }
func (*ResetQuorumRequest) ProtoMessage()    {}
func (*ResetQuorumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{126}
}
func (m *ResetQuorumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetQuorumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetQuorumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetQuorumRequest.Merge(m, src)
}
func (m *ResetQuorumRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetQuorumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetQuorumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetQuorumRequest proto.InternalMessageInfo

type ResetQuorumResponse struct {
}

func (m *ResetQuorumResponse) Reset()         { *m = ResetQuorumResponse{} }
func (m *ResetQuorumResponse) String() string { return proto.CompactTextString(m) }
func (*ResetQuorumResponse) ProtoMessage()    {}
func (*ResetQuorumResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{127}
}
func (m *ResetQuorumResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetQuorumResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetQuorumResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetQuorumResponse.Merge(m, src)
}
func (m *ResetQuorumResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResetQuorumResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetQuorumResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetQuorumResponse proto.InternalMessageInfo

// GossipSubscriptionRequest initiates a game of telephone. It establishes an
// indefinite stream that proxies gossip information overheard by the recipient
// node back to the caller. Gossip information is filtered down to just those
// identified by a key matching any of the specified patterns.
//
// Upon establishment of the stream, all existing information that matches one
// or more of the patterns is returned. After this point, only new information
// matching the patterns is returned.
type GossipSubscriptionRequest struct {
	Patterns []string `protobuf:"bytes,1,rep,name=patterns,proto3" json:"patterns,omitempty"`
}

func (m *GossipSubscriptionRequest) Reset()         { *m = GossipSubscriptionRequest{} }
func (m *GossipSubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*GossipSubscriptionRequest) ProtoMessage()    {}
func (*GossipSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{128}
}
func (m *GossipSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GossipSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipSubscriptionRequest.Merge(m, src)
}
func (m *GossipSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GossipSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GossipSubscriptionRequest proto.InternalMessageInfo

// GossipSubscriptionEvent is a single piece of proxied gossip information.
type GossipSubscriptionEvent struct {
	Key     string        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Content roachpb.Value `protobuf:"bytes,2,opt,name=content,proto3" json:"content"`
	// Which pattern does this gossip information match?
	PatternMatched string `protobuf:"bytes,3,opt,name=pattern_matched,json=patternMatched,proto3" json:"pattern_matched,omitempty"`
	// If non-nil, the other fields will be empty and this will be the final event
	// send on the stream before it is terminated.
	Error *Error `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GossipSubscriptionEvent) Reset()         { *m = GossipSubscriptionEvent{} }
func (m *GossipSubscriptionEvent) String() string { return proto.CompactTextString(m) }
func (*GossipSubscriptionEvent) ProtoMessage()    {}
func (*GossipSubscriptionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{129}
}
func (m *GossipSubscriptionEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipSubscriptionEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GossipSubscriptionEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipSubscriptionEvent.Merge(m, src)
}
func (m *GossipSubscriptionEvent) XXX_Size() int {
	return m.Size()
}
func (m *GossipSubscriptionEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipSubscriptionEvent.DiscardUnknown(m)
}

var xxx_messageInfo_GossipSubscriptionEvent proto.InternalMessageInfo

// TenantSettingsRequest establishes an indefinite stream that provides
// up-to-date overrides for tenant settings.
//
// Upon establishment of the stream, the current overrides are returned as an
// event, and any time the overrides change a new event is generated.
type TenantSettingsRequest struct {
	TenantID roachpb.TenantID `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id"`
}

func (m *TenantSettingsRequest) Reset()         { *m = TenantSettingsRequest{} }
func (m *TenantSettingsRequest) String() string { return proto.CompactTextString(m) }
func (*TenantSettingsRequest) ProtoMessage()    {}
func (*TenantSettingsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{130}
}
func (m *TenantSettingsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantSettingsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantSettingsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantSettingsRequest.Merge(m, src)
}
func (m *TenantSettingsRequest) XXX_Size() int {
	return m.Size()
}
func (m *TenantSettingsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantSettingsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TenantSettingsRequest proto.InternalMessageInfo

// TenantSettingsEvent is used to report changes to setting overrides and
// other metadata for a particular tenant.
//
// When used to report changes to setting overrides, the protocol is as follows:
//   - When a tenant server first connects, a non-incremental TenantSettingsEvent
//     settings event is sent to the client for each precedence value.
//     This reports to the client the initial values of all the cluster setting
//     overrides.
//   - Afterwards, more TenantSettingsEvent are sent (with Incremental set or not)
//     whenever settings are updated.
//
// TODO(knz): The name of the message should be updated to reflect
// its more general purpose.
//
// Note: this API is designed to allow flexibility of implementation on the
// server side (e.g. to make it maintain very little state per tenant).
type TenantSettingsEvent struct {
	// The type of event. For backward-compatibility with early 23.1
	// servers that do not check the event_type field, server of any
	// 23.2 version must ensure all events of other types than
	// SETTING_EVENT must appear as a no-op event when interpreted as a
	// setting event. This means: 1) set precedence to any value; 2) set
	// incremental to true 3) provide a nil slice in overrides.
	// This constraint can be lifted once all servers are at least 23.2.
	EventType TenantSettingsEvent_EventType `protobuf:"varint,5,opt,name=event_type,json=eventType,proto3,enum=cockroach.roachpb.TenantSettingsEvent_EventType" json:"event_type,omitempty"`
	// If non-nil, the other fields will be empty and this will be the final event
	// sent on the stream before it is terminated.
	Error errorspb.EncodedError `protobuf:"bytes,4,opt,name=error,proto3" json:"error"`
	// Precedence is the type of overrides that are reported in this event.
	Precedence TenantSettingsEvent_Precedence `protobuf:"varint,1,opt,name=precedence,proto3,enum=cockroach.roachpb.TenantSettingsEvent_Precedence" json:"precedence,omitempty"`
	// Incremental is true if the list of overrides is a list of changes since the
	// last event. In that case, any overrides that have been removed are returned
	// as TenantSettings with empty RawValue and ValueType fields.
	//
	// When Incremental is false, the overrides contains the complete list of
	// current overrides for this precedence.
	//
	// The first event for a precedence is never incremental.
	Incremental bool `protobuf:"varint,2,opt,name=incremental,proto3" json:"incremental,omitempty"`
	// Overrides contains:
	//  - all current setting overrides for the given precedence if Incremental is
	//    false; or
	//  - the changed overrides since the last event for the precedence if
	//    Incremental is true (removed overrides have empty RawValue and ValueType
	//    fields).
	Overrides []TenantSetting `protobuf:"bytes,3,rep,name=overrides,proto3" json:"overrides"`
	// Name is the tenant's current name.
	Name github_com_cockroachdb_cockroach_pkg_roachpb.TenantName `protobuf:"bytes,6,opt,name=name,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.TenantName" json:"name,omitempty"`
	// Capabilities is the tenant's current capabilities.
	// Note that this field is advisory: the server may know of a more
	// recent (and different) set of capabilities, and server-side
	// capabilities checks always prevail.
	Capabilities *tenantcapabilitiespb.TenantCapabilities `protobuf:"bytes,7,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// DataState is the tenant's current data state.
	// TODO(knz): This should really be casted to go type mtinfopb.TenantDataState but we
	// can't do that yet due to a dependency cycle. We should break the cycle.
	DataState uint32 `protobuf:"varint,8,opt,name=data_state,json=dataState,proto3" json:"data_state,omitempty"`
	// ServiceMode is the tenant's current service mode.
	// TODO(knz): This should really be casted to go type mtinfopb.TenantServiceMode but we
	// can't do that yet due to a dependency cycle. We should break the cycle.
	ServiceMode uint32 `protobuf:"varint,9,opt,name=service_mode,json=serviceMode,proto3" json:"service_mode,omitempty"`
	// ClusterInitGracePeriodEndTS is the timestamp (in seconds since the Unix epoch)
	// marking the end of the grace period for clusters without a license. After this
	// timestamp, if no license is installed, the cluster will be subject to throttling.
	// Since secondary tenants cannot access the KV store where this is saved, the value
	// is propagated through the tenant settings. This is only set when the event type is
	// METADATA_EVENT.
	ClusterInitGracePeriodEndTS int64 `protobuf:"varint,10,opt,name=ClusterInitGracePeriodEndTS,proto3" json:"ClusterInitGracePeriodEndTS,omitempty"`
}

func (m *TenantSettingsEvent) Reset()         { *m = TenantSettingsEvent{} }
func (m *TenantSettingsEvent) String() string { return proto.CompactTextString(m) }
func (*TenantSettingsEvent) ProtoMessage()    {}
func (*TenantSettingsEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{131}
}
func (m *TenantSettingsEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantSettingsEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantSettingsEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantSettingsEvent.Merge(m, src)
}
func (m *TenantSettingsEvent) XXX_Size() int {
	return m.Size()
}
func (m *TenantSettingsEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantSettingsEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TenantSettingsEvent proto.InternalMessageInfo

// TenantSetting contains the setting key and value of a tenant setting.
type TenantSetting struct {
	InternalKey github_com_cockroachdb_cockroach_pkg_settings.InternalKey `protobuf:"bytes,1,opt,name=internal_key,json=internalKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/settings.InternalKey" json:"internal_key,omitempty"`
	Value       settings.EncodedValue                                     `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *TenantSetting) Reset()         { *m = TenantSetting{} }
func (m *TenantSetting) String() string { return proto.CompactTextString(m) }
func (*TenantSetting) ProtoMessage()    {}
func (*TenantSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{132}
}
func (m *TenantSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantSetting.Merge(m, src)
}
func (m *TenantSetting) XXX_Size() int {
	return m.Size()
}
func (m *TenantSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantSetting.DiscardUnknown(m)
}

var xxx_messageInfo_TenantSetting proto.InternalMessageInfo

// TenantConsumption contains information about resource utilization by a
// tenant, which directly factors into their bill.
type TenantConsumption struct {
	RU                     float64 `protobuf:"fixed64,1,opt,name=r_u,json=rU,proto3" json:"r_u,omitempty"`
	KVRU                   float64 `protobuf:"fixed64,8,opt,name=kv_r_u,json=kvRU,proto3" json:"kv_r_u,omitempty"`
	ReadBatches            uint64  `protobuf:"varint,11,opt,name=read_batches,json=readBatches,proto3" json:"read_batches,omitempty"`
	ReadRequests           uint64  `protobuf:"varint,2,opt,name=read_requests,json=readRequests,proto3" json:"read_requests,omitempty"`
	ReadBytes              uint64  `protobuf:"varint,3,opt,name=read_bytes,json=readBytes,proto3" json:"read_bytes,omitempty"`
	WriteBatches           uint64  `protobuf:"varint,12,opt,name=write_batches,json=writeBatches,proto3" json:"write_batches,omitempty"`
	WriteRequests          uint64  `protobuf:"varint,4,opt,name=write_requests,json=writeRequests,proto3" json:"write_requests,omitempty"`
	WriteBytes             uint64  `protobuf:"varint,5,opt,name=write_bytes,json=writeBytes,proto3" json:"write_bytes,omitempty"`
	SQLPodsCPUSeconds      float64 `protobuf:"fixed64,6,opt,name=sql_pods_cpu_seconds,json=sqlPodsCpuSeconds,proto3" json:"sql_pods_cpu_seconds,omitempty"`
	PGWireEgressBytes      uint64  `protobuf:"varint,7,opt,name=pgwire_egress_bytes,json=pgwireEgressBytes,proto3" json:"pgwire_egress_bytes,omitempty"`
	ExternalIOIngressBytes uint64  `protobuf:"varint,9,opt,name=external_io_ingress_bytes,json=externalIoIngressBytes,proto3" json:"external_io_ingress_bytes,omitempty"`
	ExternalIOEgressBytes  uint64  `protobuf:"varint,10,opt,name=external_io_egress_bytes,json=externalIoEgressBytes,proto3" json:"external_io_egress_bytes,omitempty"`
	CrossRegionNetworkRU   float64 `protobuf:"fixed64,13,opt,name=cross_region_network_r_u,json=crossRegionNetworkRU,proto3" json:"cross_region_network_r_u,omitempty"`
	EstimatedCPUSeconds    float64 `protobuf:"fixed64,14,opt,name=estimated_cpu_seconds,json=estimatedCpuSeconds,proto3" json:"estimated_cpu_seconds,omitempty"`
}

func (m *TenantConsumption) Reset()         { *m = TenantConsumption{} }
func (m *TenantConsumption) String() string { return proto.CompactTextString(m) }
func (*TenantConsumption) ProtoMessage()    {}
func (*TenantConsumption) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{133}
}
func (m *TenantConsumption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantConsumption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantConsumption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantConsumption.Merge(m, src)
}
func (m *TenantConsumption) XXX_Size() int {
	return m.Size()
}
func (m *TenantConsumption) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantConsumption.DiscardUnknown(m)
}

var xxx_messageInfo_TenantConsumption proto.InternalMessageInfo

// TenantConsumptionRates specifies rates of consumption for tenant metrics that
// are used in the cost model.
type TenantConsumptionRates struct {
	WriteBatchRate   float64 `protobuf:"fixed64,1,opt,name=write_batch_rate,json=writeBatchRate,proto3" json:"write_batch_rate,omitempty"`
	EstimatedCPURate float64 `protobuf:"fixed64,2,opt,name=estimated_cpu_rate,json=estimatedCpuRate,proto3" json:"estimated_cpu_rate,omitempty"`
}

func (m *TenantConsumptionRates) Reset()         { *m = TenantConsumptionRates{} }
func (m *TenantConsumptionRates) String() string { return proto.CompactTextString(m) }
func (*TenantConsumptionRates) ProtoMessage()    {}
func (*TenantConsumptionRates) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{134}
}
func (m *TenantConsumptionRates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantConsumptionRates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantConsumptionRates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantConsumptionRates.Merge(m, src)
}
func (m *TenantConsumptionRates) XXX_Size() int {
	return m.Size()
}
func (m *TenantConsumptionRates) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantConsumptionRates.DiscardUnknown(m)
}

var xxx_messageInfo_TenantConsumptionRates proto.InternalMessageInfo

// TokenBucketRequest is used by tenants to obtain Request Units and report
// consumption.
type TokenBucketRequest struct {
	// Consumption that occurred since this node's last request.
	ConsumptionSinceLastRequest TenantConsumption `protobuf:"bytes,1,opt,name=consumption_since_last_request,json=consumptionSinceLastRequest,proto3" json:"consumption_since_last_request"`
	// ConsumptionPeriod is the period over which the consumption was measured.
	ConsumptionPeriod time.Duration `protobuf:"bytes,9,opt,name=consumption_period,json=consumptionPeriod,proto3,stdduration" json:"consumption_period"`
	TenantID          uint64        `protobuf:"varint,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	// InstanceID is the ID of the SQL pod instance from where the request
	// originates.
	InstanceID uint32 `protobuf:"varint,3,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// NextLiveInstanceID is the ID of the next live SQL instance for this tenant,
	// in circular order by ID.
	//
	// In other words:
	//  - if this instance has the largest ID, NextLiveInstanceID is the smallest
	//    ID of a live instance.
	//  - otherwise, NextLiveInstanceID is the smallest ID of a live instance that
	//    is greater than InstanceID.
	//
	// In particular, if this is the only live instance, then NextLiveInstanceID
	// will equal InstanceID.
	//
	// The information in this field is used by the server to trigger checking for
	// dead instances; it is acceptable for the information to be stale.
	//
	// Can be zero if this information is not currently available.
	NextLiveInstanceID uint32 `protobuf:"varint,8,opt,name=next_live_instance_id,json=nextLiveInstanceId,proto3" json:"next_live_instance_id,omitempty"`
	// InstanceLease uniquely identifies the SQL pod instance from where the
	// request originates, in light of ID reuse.
	InstanceLease []byte `protobuf:"bytes,4,opt,name=instance_lease,json=instanceLease,proto3" json:"instance_lease,omitempty"`
	// SeqNum is a strictly positive, monotonically increasing sequence number,
	// used to detect duplicate requests on the server side (to avoid
	// double-charging). The consumption reported in a request with a lower
	// sequence number than the last request is ignored.
	SeqNum int64 `protobuf:"varint,7,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	// RequestedTokens is the number of requested tokens.
	RequestedTokens float64 `protobuf:"fixed64,5,opt,name=requested_tokens,json=requestedTokens,proto3" json:"requested_tokens,omitempty"`
	// TargetRequestPeriod is the approximate frequency of requests, used to limit
	// TrickleDuration in the response.
	TargetRequestPeriod time.Duration `protobuf:"bytes,6,opt,name=target_request_period,json=targetRequestPeriod,proto3,stdduration" json:"target_request_period"`
}

func (m *TokenBucketRequest) Reset()         { *m = TokenBucketRequest{} }
func (m *TokenBucketRequest) String() string { return proto.CompactTextString(m) }
func (*TokenBucketRequest) ProtoMessage()    {}
func (*TokenBucketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{135}
}
func (m *TokenBucketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenBucketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TokenBucketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenBucketRequest.Merge(m, src)
}
func (m *TokenBucketRequest) XXX_Size() int {
	return m.Size()
}
func (m *TokenBucketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenBucketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TokenBucketRequest proto.InternalMessageInfo

type TokenBucketResponse struct {
	// If non-empty, the other fields will be empty. This field stores any error
	// that occurs on the server, allowing us to differentiate between those and
	// RPC errors.
	Error errorspb.EncodedError `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
	// GrantedTokens is the number of tokens granted by the server. In most cases,
	// this is equal to the requested tokens; the only exception is when
	// TrickleDuration would otherwise exceed TargetRequestPeriod, in which case
	// the number of granted tokens is reduced.
	GrantedTokens float64 `protobuf:"fixed64,2,opt,name=granted_tokens,json=grantedTokens,proto3" json:"granted_tokens,omitempty"`
	// TrickleDuration describes how the granted tokens can be consumed.
	//
	// If zero, the granted tokens can be used immediately, without restriction.
	// If set, the granted tokens become available at a constant rate over the
	// trickle time period. E.g. if we are granted 1000 tokens and the trickle
	// duration is 10 seconds, the tokens become available at a rate of
	// 100 tokens/sec for the next 10 seconds.
	//
	// TrickleDuration is at most the given TargetRequestPeriod.
	TrickleDuration time.Duration `protobuf:"bytes,3,opt,name=trickle_duration,json=trickleDuration,proto3,stdduration" json:"trickle_duration"`
	// FallbackRate indicates a rate (in tokens/s) that the instance will use once
	// it runs out of tokens and a problem prevents TokenBucket requests from
	// completing.
	FallbackRate float64 `protobuf:"fixed64,4,opt,name=fallback_rate,json=fallbackRate,proto3" json:"fallback_rate,omitempty"`
	// ConsumptionRates contains the rate of consumption of tenant metrics that
	// are used by the cost model. These rates are calculated across all SQL pods
	// for the tenant.
	ConsumptionRates TenantConsumptionRates `protobuf:"bytes,5,opt,name=consumption_rates,json=consumptionRates,proto3" json:"consumption_rates"`
}

func (m *TokenBucketResponse) Reset()         { *m = TokenBucketResponse{} }
func (m *TokenBucketResponse) String() string { return proto.CompactTextString(m) }
func (*TokenBucketResponse) ProtoMessage()    {}
func (*TokenBucketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{136}
}
func (m *TokenBucketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenBucketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TokenBucketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenBucketResponse.Merge(m, src)
}
func (m *TokenBucketResponse) XXX_Size() int {
	return m.Size()
}
func (m *TokenBucketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenBucketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TokenBucketResponse proto.InternalMessageInfo

// JoinNodeRequest is used to specify to the server node what the client's
// binary version is. If it's not compatible with the rest of the cluster, the
// join attempt is refused.
type JoinNodeRequest struct {
	BinaryVersion *roachpb.Version `protobuf:"bytes,1,opt,name=binary_version,json=binaryVersion,proto3" json:"binary_version,omitempty"`
}

func (m *JoinNodeRequest) Reset()         { *m = JoinNodeRequest{} }
func (m *JoinNodeRequest) String() string { return proto.CompactTextString(m) }
func (*JoinNodeRequest) ProtoMessage()    {}
func (*JoinNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{137}
}
func (m *JoinNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JoinNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinNodeRequest.Merge(m, src)
}
func (m *JoinNodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *JoinNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JoinNodeRequest proto.InternalMessageInfo

// JoinNodeResponse informs the joining node what the cluster id is, what
// node id was allocated to it, and what store ID to use for its first store. It
// also informs the node what the current active version is.
type JoinNodeResponse struct {
	ClusterID     []byte           `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	NodeID        int32            `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StoreID       int32            `protobuf:"varint,3,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	ActiveVersion *roachpb.Version `protobuf:"bytes,4,opt,name=active_version,json=activeVersion,proto3" json:"active_version,omitempty"`
}

func (m *JoinNodeResponse) Reset()         { *m = JoinNodeResponse{} }
func (m *JoinNodeResponse) String() string { return proto.CompactTextString(m) }
func (*JoinNodeResponse) ProtoMessage()    {}
func (*JoinNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{138}
}
func (m *JoinNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JoinNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinNodeResponse.Merge(m, src)
}
func (m *JoinNodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *JoinNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JoinNodeResponse proto.InternalMessageInfo

// GetRangeDescriptorsRequest is used to fetch range descriptors.
type GetRangeDescriptorsRequest struct {
	// Span over which to request range descriptors.
	Span roachpb.Span `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	// BatchSize if set non-zero streams batches incrementally (which may not be
	// consistent).
	BatchSize int64 `protobuf:"varint,2,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
}

func (m *GetRangeDescriptorsRequest) Reset()         { *m = GetRangeDescriptorsRequest{} }
func (m *GetRangeDescriptorsRequest) String() string { return proto.CompactTextString(m) }
func (*GetRangeDescriptorsRequest) ProtoMessage()    {}
func (*GetRangeDescriptorsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{139}
}
func (m *GetRangeDescriptorsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRangeDescriptorsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetRangeDescriptorsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRangeDescriptorsRequest.Merge(m, src)
}
func (m *GetRangeDescriptorsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRangeDescriptorsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRangeDescriptorsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRangeDescriptorsRequest proto.InternalMessageInfo

// GetRangeDescriptorsResponse lists out the requested range descriptors.
type GetRangeDescriptorsResponse struct {
	// RangeDescriptors is the list of range descriptors over the requested span.
	RangeDescriptors []roachpb.RangeDescriptor `protobuf:"bytes,1,rep,name=range_descriptors,json=rangeDescriptors,proto3" json:"range_descriptors"`
}

func (m *GetRangeDescriptorsResponse) Reset()         { *m = GetRangeDescriptorsResponse{} }
func (m *GetRangeDescriptorsResponse) String() string { return proto.CompactTextString(m) }
func (*GetRangeDescriptorsResponse) ProtoMessage()    {}
func (*GetRangeDescriptorsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{140}
}
func (m *GetRangeDescriptorsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRangeDescriptorsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetRangeDescriptorsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRangeDescriptorsResponse.Merge(m, src)
}
func (m *GetRangeDescriptorsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRangeDescriptorsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRangeDescriptorsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRangeDescriptorsResponse proto.InternalMessageInfo

// ContentionEvent is a message that will be attached to BatchResponses
// indicating any conflicts with another transaction during replica evaluation.
type ContentionEvent struct {
	// Key is the key that this and the other transaction conflicted on.
	Key github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	// TxnMeta is the transaction conflicted with, i.e. the transaction holding a
	// lock or lock reservation.
	TxnMeta enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn_meta,json=txnMeta,proto3" json:"txn_meta"`
	// Duration spent contending against the other transaction.
	Duration time.Duration `protobuf:"bytes,3,opt,name=duration,proto3,stdduration" json:"duration"`
	// IsLatch, if true, indicates that the contention event was due to waiting to
	// acquire a latch.
	IsLatch bool `protobuf:"varint,4,opt,name=is_latch,json=isLatch,proto3" json:"is_latch,omitempty"`
}

func (m *ContentionEvent) Reset()      { *m = ContentionEvent{} }
func (*ContentionEvent) ProtoMessage() {}
func (*ContentionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{141}
}
func (m *ContentionEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentionEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContentionEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentionEvent.Merge(m, src)
}
func (m *ContentionEvent) XXX_Size() int {
	return m.Size()
}
func (m *ContentionEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentionEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ContentionEvent proto.InternalMessageInfo

// ScanStats is a message that tracks miscellaneous statistics of all Gets,
// Scans, and ReverseScans in a single BatchResponse.
type ScanStats struct {
	NumInterfaceSeeks uint64 `protobuf:"varint,1,opt,name=num_interface_seeks,json=numInterfaceSeeks,proto3" json:"num_interface_seeks,omitempty"`
	NumInternalSeeks  uint64 `protobuf:"varint,2,opt,name=num_internal_seeks,json=numInternalSeeks,proto3" json:"num_internal_seeks,omitempty"`
	NumInterfaceSteps uint64 `protobuf:"varint,3,opt,name=num_interface_steps,json=numInterfaceSteps,proto3" json:"num_interface_steps,omitempty"`
	NumInternalSteps  uint64 `protobuf:"varint,4,opt,name=num_internal_steps,json=numInternalSteps,proto3" json:"num_internal_steps,omitempty"`
	// Lower-level stats for the scan. See pebble.InternalIteratorStats for the
	// meaning of these.
	BlockBytes                           uint64        `protobuf:"varint,5,opt,name=block_bytes,json=blockBytes,proto3" json:"block_bytes,omitempty"`
	BlockBytesInCache                    uint64        `protobuf:"varint,6,opt,name=block_bytes_in_cache,json=blockBytesInCache,proto3" json:"block_bytes_in_cache,omitempty"`
	KeyBytes                             uint64        `protobuf:"varint,7,opt,name=key_bytes,json=keyBytes,proto3" json:"key_bytes,omitempty"`
	ValueBytes                           uint64        `protobuf:"varint,8,opt,name=value_bytes,json=valueBytes,proto3" json:"value_bytes,omitempty"`
	PointCount                           uint64        `protobuf:"varint,9,opt,name=point_count,json=pointCount,proto3" json:"point_count,omitempty"`
	PointsCoveredByRangeTombstones       uint64        `protobuf:"varint,10,opt,name=points_covered_by_range_tombstones,json=pointsCoveredByRangeTombstones,proto3" json:"points_covered_by_range_tombstones,omitempty"`
	RangeKeyCount                        uint64        `protobuf:"varint,11,opt,name=range_key_count,json=rangeKeyCount,proto3" json:"range_key_count,omitempty"`
	RangeKeyContainedPoints              uint64        `protobuf:"varint,12,opt,name=range_key_contained_points,json=rangeKeyContainedPoints,proto3" json:"range_key_contained_points,omitempty"`
	RangeKeySkippedPoints                uint64        `protobuf:"varint,13,opt,name=range_key_skipped_points,json=rangeKeySkippedPoints,proto3" json:"range_key_skipped_points,omitempty"`
	SeparatedPointCount                  uint64        `protobuf:"varint,14,opt,name=separated_point_count,json=separatedPointCount,proto3" json:"separated_point_count,omitempty"`
	SeparatedPointValueBytes             uint64        `protobuf:"varint,15,opt,name=separated_point_value_bytes,json=separatedPointValueBytes,proto3" json:"separated_point_value_bytes,omitempty"`
	SeparatedPointValueBytesFetched      uint64        `protobuf:"varint,16,opt,name=separated_point_value_bytes_fetched,json=separatedPointValueBytesFetched,proto3" json:"separated_point_value_bytes_fetched,omitempty"`
	SeparatedPointValueCountFetched      uint64        `protobuf:"varint,23,opt,name=separated_point_value_count_fetched,json=separatedPointValueCountFetched,proto3" json:"separated_point_value_count_fetched,omitempty"`
	SeparatedPointValueReaderCacheMisses uint64        `protobuf:"varint,24,opt,name=separated_point_value_reader_cache_misses,json=separatedPointValueReaderCacheMisses,proto3" json:"separated_point_value_reader_cache_misses,omitempty"`
	BlockReadDuration                    time.Duration `protobuf:"bytes,20,opt,name=block_read_duration,json=blockReadDuration,proto3,stdduration" json:"block_read_duration"`
	// NumGets, NumScans, and NumReverseScans tracks the number of Gets, Scans,
	// and ReverseScans, respectively, that were actually evaluated as part of the
	// BatchResponse. These don't include requests that were not evaluated due to
	// reaching the BatchResponse's limits or an error. NumScans also tracks the
	// number of ExportRequests evaluated (including ones that resulted in an
	// error).
	NumGets         uint64 `protobuf:"varint,17,opt,name=num_gets,json=numGets,proto3" json:"num_gets,omitempty"`
	NumScans        uint64 `protobuf:"varint,18,opt,name=num_scans,json=numScans,proto3" json:"num_scans,omitempty"`
	NumReverseScans uint64 `protobuf:"varint,19,opt,name=num_reverse_scans,json=numReverseScans,proto3" json:"num_reverse_scans,omitempty"`
	// NodeID is the NodeID of the KV server that evaluated the request.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,21,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Region, if set, is the region of the KV server that evaluated the request.
	Region string `protobuf:"bytes,22,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *ScanStats) Reset()      { *m = ScanStats{} }
func (*ScanStats) ProtoMessage() {}
func (*ScanStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{142}
}
func (m *ScanStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScanStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanStats.Merge(m, src)
}
func (m *ScanStats) XXX_Size() int {
	return m.Size()
}
func (m *ScanStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanStats.DiscardUnknown(m)
}

var xxx_messageInfo_ScanStats proto.InternalMessageInfo

// UsedFollowerRead indicates whether at least some reads were served by the
// follower replicas.
type UsedFollowerRead struct {
}

func (m *UsedFollowerRead) Reset()         { *m = UsedFollowerRead{} }
func (m *UsedFollowerRead) String() string { return proto.CompactTextString(m) }
func (*UsedFollowerRead) ProtoMessage()    {}
func (*UsedFollowerRead) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc8f41762a89273b, []int{143}
}
func (m *UsedFollowerRead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsedFollowerRead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UsedFollowerRead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsedFollowerRead.Merge(m, src)
}
func (m *UsedFollowerRead) XXX_Size() int {
	return m.Size()
}
func (m *UsedFollowerRead) XXX_DiscardUnknown() {
	xxx_messageInfo_UsedFollowerRead.DiscardUnknown(m)
}

var xxx_messageInfo_UsedFollowerRead proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.ReadConsistencyType", ReadConsistencyType_name, ReadConsistencyType_value)
	proto.RegisterEnum("cockroach.roachpb.RoutingPolicy", RoutingPolicy_name, RoutingPolicy_value)
	proto.RegisterEnum("cockroach.roachpb.ResumeReason", ResumeReason_name, ResumeReason_value)
	proto.RegisterEnum("cockroach.roachpb.ScanFormat", ScanFormat_name, ScanFormat_value)
	proto.RegisterEnum("cockroach.roachpb.ChecksumMode", ChecksumMode_name, ChecksumMode_value)
	proto.RegisterEnum("cockroach.roachpb.PushTxnType", PushTxnType_name, PushTxnType_value)
	proto.RegisterEnum("cockroach.roachpb.MVCCFilter", MVCCFilter_name, MVCCFilter_value)
	proto.RegisterEnum("cockroach.roachpb.CheckConsistencyResponse_Status", CheckConsistencyResponse_Status_name, CheckConsistencyResponse_Status_value)
	proto.RegisterEnum("cockroach.roachpb.AdmissionHeader_Source", AdmissionHeader_Source_name, AdmissionHeader_Source_value)
	proto.RegisterEnum("cockroach.roachpb.AdmissionHeader_SourceLocation", AdmissionHeader_SourceLocation_name, AdmissionHeader_SourceLocation_value)
	proto.RegisterEnum("cockroach.roachpb.TenantSettingsEvent_EventType", TenantSettingsEvent_EventType_name, TenantSettingsEvent_EventType_value)
	proto.RegisterEnum("cockroach.roachpb.TenantSettingsEvent_Precedence", TenantSettingsEvent_Precedence_name, TenantSettingsEvent_Precedence_value)
	proto.RegisterType((*RequestHeader)(nil), "cockroach.roachpb.RequestHeader")
	proto.RegisterType((*RequestHeader_Empty)(nil), "cockroach.roachpb.RequestHeader.Empty")
	proto.RegisterType((*ResponseHeader)(nil), "cockroach.roachpb.ResponseHeader")
	proto.RegisterType((*GetRequest)(nil), "cockroach.roachpb.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "cockroach.roachpb.GetResponse")
	proto.RegisterType((*ProbeRequest)(nil), "cockroach.roachpb.ProbeRequest")
	proto.RegisterType((*ProbeResponse)(nil), "cockroach.roachpb.ProbeResponse")
	proto.RegisterType((*IsSpanEmptyRequest)(nil), "cockroach.roachpb.IsSpanEmptyRequest")
	proto.RegisterType((*IsSpanEmptyResponse)(nil), "cockroach.roachpb.IsSpanEmptyResponse")
	proto.RegisterType((*PutRequest)(nil), "cockroach.roachpb.PutRequest")
	proto.RegisterType((*PutResponse)(nil), "cockroach.roachpb.PutResponse")
	proto.RegisterType((*ConditionalPutRequest)(nil), "cockroach.roachpb.ConditionalPutRequest")
	proto.RegisterType((*ConditionalPutResponse)(nil), "cockroach.roachpb.ConditionalPutResponse")
	proto.RegisterType((*IncrementRequest)(nil), "cockroach.roachpb.IncrementRequest")
	proto.RegisterType((*IncrementResponse)(nil), "cockroach.roachpb.IncrementResponse")
	proto.RegisterType((*DeleteRequest)(nil), "cockroach.roachpb.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "cockroach.roachpb.DeleteResponse")
	proto.RegisterType((*DeleteRangeRequest)(nil), "cockroach.roachpb.DeleteRangeRequest")
	proto.RegisterType((*DeleteRangePredicates)(nil), "cockroach.roachpb.DeleteRangePredicates")
	proto.RegisterType((*DeleteRangeResponse)(nil), "cockroach.roachpb.DeleteRangeResponse")
	proto.RegisterType((*ClearRangeRequest)(nil), "cockroach.roachpb.ClearRangeRequest")
	proto.RegisterType((*ClearRangeResponse)(nil), "cockroach.roachpb.ClearRangeResponse")
	proto.RegisterType((*RevertRangeRequest)(nil), "cockroach.roachpb.RevertRangeRequest")
	proto.RegisterType((*RevertRangeResponse)(nil), "cockroach.roachpb.RevertRangeResponse")
	proto.RegisterType((*ColBatches)(nil), "cockroach.roachpb.ColBatches")
	proto.RegisterType((*ScanRequest)(nil), "cockroach.roachpb.ScanRequest")
	proto.RegisterType((*ScanResponse)(nil), "cockroach.roachpb.ScanResponse")
	proto.RegisterType((*ExciseRequest)(nil), "cockroach.roachpb.ExciseRequest")
	proto.RegisterType((*ExciseResponse)(nil), "cockroach.roachpb.ExciseResponse")
	proto.RegisterType((*ReverseScanRequest)(nil), "cockroach.roachpb.ReverseScanRequest")
	proto.RegisterType((*ReverseScanResponse)(nil), "cockroach.roachpb.ReverseScanResponse")
	proto.RegisterType((*CheckConsistencyRequest)(nil), "cockroach.roachpb.CheckConsistencyRequest")
	proto.RegisterType((*CheckConsistencyResponse)(nil), "cockroach.roachpb.CheckConsistencyResponse")
	proto.RegisterType((*CheckConsistencyResponse_Result)(nil), "cockroach.roachpb.CheckConsistencyResponse.Result")
	proto.RegisterType((*RecomputeStatsRequest)(nil), "cockroach.roachpb.RecomputeStatsRequest")
	proto.RegisterType((*RecomputeStatsResponse)(nil), "cockroach.roachpb.RecomputeStatsResponse")
	proto.RegisterType((*EndTxnRequest)(nil), "cockroach.roachpb.EndTxnRequest")
	proto.RegisterType((*EndTxnResponse)(nil), "cockroach.roachpb.EndTxnResponse")
	proto.RegisterType((*AdminSplitRequest)(nil), "cockroach.roachpb.AdminSplitRequest")
	proto.RegisterType((*AdminSplitResponse)(nil), "cockroach.roachpb.AdminSplitResponse")
	proto.RegisterType((*AdminUnsplitRequest)(nil), "cockroach.roachpb.AdminUnsplitRequest")
	proto.RegisterType((*AdminUnsplitResponse)(nil), "cockroach.roachpb.AdminUnsplitResponse")
	proto.RegisterType((*AdminMergeRequest)(nil), "cockroach.roachpb.AdminMergeRequest")
	proto.RegisterType((*AdminMergeResponse)(nil), "cockroach.roachpb.AdminMergeResponse")
	proto.RegisterType((*AdminTransferLeaseRequest)(nil), "cockroach.roachpb.AdminTransferLeaseRequest")
	proto.RegisterType((*AdminTransferLeaseResponse)(nil), "cockroach.roachpb.AdminTransferLeaseResponse")
	proto.RegisterType((*ReplicationChange)(nil), "cockroach.roachpb.ReplicationChange")
	proto.RegisterType((*AdminChangeReplicasRequest)(nil), "cockroach.roachpb.AdminChangeReplicasRequest")
	proto.RegisterType((*AdminChangeReplicasResponse)(nil), "cockroach.roachpb.AdminChangeReplicasResponse")
	proto.RegisterType((*AdminRelocateRangeRequest)(nil), "cockroach.roachpb.AdminRelocateRangeRequest")
	proto.RegisterType((*AdminRelocateRangeResponse)(nil), "cockroach.roachpb.AdminRelocateRangeResponse")
	proto.RegisterType((*HeartbeatTxnRequest)(nil), "cockroach.roachpb.HeartbeatTxnRequest")
	proto.RegisterType((*HeartbeatTxnResponse)(nil), "cockroach.roachpb.HeartbeatTxnResponse")
	proto.RegisterType((*GCRequest)(nil), "cockroach.roachpb.GCRequest")
	proto.RegisterType((*GCRequest_GCKey)(nil), "cockroach.roachpb.GCRequest.GCKey")
	proto.RegisterType((*GCRequest_GCRangeKey)(nil), "cockroach.roachpb.GCRequest.GCRangeKey")
	proto.RegisterType((*GCRequest_GCClearRange)(nil), "cockroach.roachpb.GCRequest.GCClearRange")
	proto.RegisterType((*GCResponse)(nil), "cockroach.roachpb.GCResponse")
	proto.RegisterType((*PushTxnRequest)(nil), "cockroach.roachpb.PushTxnRequest")
	proto.RegisterType((*PushTxnResponse)(nil), "cockroach.roachpb.PushTxnResponse")
	proto.RegisterType((*RecoverTxnRequest)(nil), "cockroach.roachpb.RecoverTxnRequest")
	proto.RegisterType((*RecoverTxnResponse)(nil), "cockroach.roachpb.RecoverTxnResponse")
	proto.RegisterType((*QueryTxnRequest)(nil), "cockroach.roachpb.QueryTxnRequest")
	proto.RegisterType((*QueryTxnResponse)(nil), "cockroach.roachpb.QueryTxnResponse")
	proto.RegisterType((*QueryIntentRequest)(nil), "cockroach.roachpb.QueryIntentRequest")
	proto.RegisterType((*QueryIntentResponse)(nil), "cockroach.roachpb.QueryIntentResponse")
	proto.RegisterType((*QueryLocksRequest)(nil), "cockroach.roachpb.QueryLocksRequest")
	proto.RegisterType((*QueryLocksResponse)(nil), "cockroach.roachpb.QueryLocksResponse")
	proto.RegisterType((*ResolveIntentRequest)(nil), "cockroach.roachpb.ResolveIntentRequest")
	proto.RegisterType((*ResolveIntentResponse)(nil), "cockroach.roachpb.ResolveIntentResponse")
	proto.RegisterType((*ResolveIntentRangeRequest)(nil), "cockroach.roachpb.ResolveIntentRangeRequest")
	proto.RegisterType((*ResolveIntentRangeResponse)(nil), "cockroach.roachpb.ResolveIntentRangeResponse")
	proto.RegisterType((*MergeRequest)(nil), "cockroach.roachpb.MergeRequest")
	proto.RegisterType((*MergeResponse)(nil), "cockroach.roachpb.MergeResponse")
	proto.RegisterType((*TruncateLogRequest)(nil), "cockroach.roachpb.TruncateLogRequest")
	proto.RegisterType((*TruncateLogResponse)(nil), "cockroach.roachpb.TruncateLogResponse")
	proto.RegisterType((*RequestLeaseRequest)(nil), "cockroach.roachpb.RequestLeaseRequest")
	proto.RegisterType((*TransferLeaseRequest)(nil), "cockroach.roachpb.TransferLeaseRequest")
	proto.RegisterType((*LeaseInfoRequest)(nil), "cockroach.roachpb.LeaseInfoRequest")
	proto.RegisterType((*LeaseInfoResponse)(nil), "cockroach.roachpb.LeaseInfoResponse")
	proto.RegisterType((*RequestLeaseResponse)(nil), "cockroach.roachpb.RequestLeaseResponse")
	proto.RegisterType((*ComputeChecksumRequest)(nil), "cockroach.roachpb.ComputeChecksumRequest")
	proto.RegisterType((*ComputeChecksumResponse)(nil), "cockroach.roachpb.ComputeChecksumResponse")
	proto.RegisterType((*RetryTracingEvent)(nil), "cockroach.roachpb.RetryTracingEvent")
	proto.RegisterType((*FileEncryptionOptions)(nil), "cockroach.roachpb.FileEncryptionOptions")
	proto.RegisterType((*ExportRequest)(nil), "cockroach.roachpb.ExportRequest")
	proto.RegisterType((*FingerprintOptions)(nil), "cockroach.roachpb.FingerprintOptions")
	proto.RegisterType((*BulkOpSummary)(nil), "cockroach.roachpb.BulkOpSummary")
	proto.RegisterMapType((map[uint64]int64)(nil), "cockroach.roachpb.BulkOpSummary.EntryCountsEntry")
	proto.RegisterType((*ExportResponse)(nil), "cockroach.roachpb.ExportResponse")
	proto.RegisterType((*ExportResponse_File)(nil), "cockroach.roachpb.ExportResponse.File")
	proto.RegisterType((*AdminScatterRequest)(nil), "cockroach.roachpb.AdminScatterRequest")
	proto.RegisterType((*AdminScatterResponse)(nil), "cockroach.roachpb.AdminScatterResponse")
	proto.RegisterType((*AdminScatterResponse_Range)(nil), "cockroach.roachpb.AdminScatterResponse.Range")
	proto.RegisterType((*AddSSTableRequest)(nil), "cockroach.roachpb.AddSSTableRequest")
	proto.RegisterType((*AddSSTableResponse)(nil), "cockroach.roachpb.AddSSTableResponse")
	proto.RegisterType((*LinkExternalSSTableRequest)(nil), "cockroach.roachpb.LinkExternalSSTableRequest")
	proto.RegisterType((*LinkExternalSSTableRequest_ExternalFile)(nil), "cockroach.roachpb.LinkExternalSSTableRequest.ExternalFile")
	proto.RegisterType((*LinkExternalSSTableResponse)(nil), "cockroach.roachpb.LinkExternalSSTableResponse")
	proto.RegisterType((*RefreshRequest)(nil), "cockroach.roachpb.RefreshRequest")
	proto.RegisterType((*RefreshResponse)(nil), "cockroach.roachpb.RefreshResponse")
	proto.RegisterType((*RefreshRangeRequest)(nil), "cockroach.roachpb.RefreshRangeRequest")
	proto.RegisterType((*RefreshRangeResponse)(nil), "cockroach.roachpb.RefreshRangeResponse")
	proto.RegisterType((*SubsumeRequest)(nil), "cockroach.roachpb.SubsumeRequest")
	proto.RegisterType((*SubsumeResponse)(nil), "cockroach.roachpb.SubsumeResponse")
	proto.RegisterType((*RangeStatsRequest)(nil), "cockroach.roachpb.RangeStatsRequest")
	proto.RegisterType((*RangeStatsResponse)(nil), "cockroach.roachpb.RangeStatsResponse")
	proto.RegisterType((*MigrateRequest)(nil), "cockroach.roachpb.MigrateRequest")
	proto.RegisterType((*MigrateResponse)(nil), "cockroach.roachpb.MigrateResponse")
	proto.RegisterType((*QueryResolvedTimestampRequest)(nil), "cockroach.roachpb.QueryResolvedTimestampRequest")
	proto.RegisterType((*QueryResolvedTimestampResponse)(nil), "cockroach.roachpb.QueryResolvedTimestampResponse")
	proto.RegisterType((*BarrierRequest)(nil), "cockroach.roachpb.BarrierRequest")
	proto.RegisterType((*BarrierResponse)(nil), "cockroach.roachpb.BarrierResponse")
	proto.RegisterType((*FlushLockTableRequest)(nil), "cockroach.roachpb.FlushLockTableRequest")
	proto.RegisterType((*FlushLockTableResponse)(nil), "cockroach.roachpb.FlushLockTableResponse")
	proto.RegisterType((*RequestUnion)(nil), "cockroach.roachpb.RequestUnion")
	proto.RegisterType((*ResponseUnion)(nil), "cockroach.roachpb.ResponseUnion")
	proto.RegisterType((*Header)(nil), "cockroach.roachpb.Header")
	proto.RegisterType((*WriteOptions)(nil), "cockroach.roachpb.WriteOptions")
	proto.RegisterType((*BoundedStalenessHeader)(nil), "cockroach.roachpb.BoundedStalenessHeader")
	proto.RegisterType((*AdmissionHeader)(nil), "cockroach.roachpb.AdmissionHeader")
	proto.RegisterType((*BatchRequest)(nil), "cockroach.roachpb.BatchRequest")
	proto.RegisterType((*BatchResponse)(nil), "cockroach.roachpb.BatchResponse")
	proto.RegisterType((*BatchResponse_Header)(nil), "cockroach.roachpb.BatchResponse.Header")
	proto.RegisterType((*RangeLookupRequest)(nil), "cockroach.roachpb.RangeLookupRequest")
	proto.RegisterType((*RangeLookupResponse)(nil), "cockroach.roachpb.RangeLookupResponse")
	proto.RegisterType((*RangeFeedRequest)(nil), "cockroach.roachpb.RangeFeedRequest")
	proto.RegisterType((*RangeFeedValue)(nil), "cockroach.roachpb.RangeFeedValue")
	proto.RegisterType((*RangeFeedBulkEvents)(nil), "cockroach.roachpb.RangeFeedBulkEvents")
	proto.RegisterType((*RangeFeedCheckpoint)(nil), "cockroach.roachpb.RangeFeedCheckpoint")
	proto.RegisterType((*RangeFeedError)(nil), "cockroach.roachpb.RangeFeedError")
	proto.RegisterType((*RangeFeedSSTable)(nil), "cockroach.roachpb.RangeFeedSSTable")
	proto.RegisterType((*RangeFeedDeleteRange)(nil), "cockroach.roachpb.RangeFeedDeleteRange")
	proto.RegisterType((*RangeFeedMetadata)(nil), "cockroach.roachpb.RangeFeedMetadata")
	proto.RegisterType((*RangeFeedEvent)(nil), "cockroach.roachpb.RangeFeedEvent")
	proto.RegisterType((*MuxRangeFeedEvent)(nil), "cockroach.roachpb.MuxRangeFeedEvent")
	proto.RegisterType((*ResetQuorumRequest)(nil), "cockroach.roachpb.ResetQuorumRequest")
	proto.RegisterType((*ResetQuorumResponse)(nil), "cockroach.roachpb.ResetQuorumResponse")
	proto.RegisterType((*GossipSubscriptionRequest)(nil), "cockroach.roachpb.GossipSubscriptionRequest")
	proto.RegisterType((*GossipSubscriptionEvent)(nil), "cockroach.roachpb.GossipSubscriptionEvent")
	proto.RegisterType((*TenantSettingsRequest)(nil), "cockroach.roachpb.TenantSettingsRequest")
	proto.RegisterType((*TenantSettingsEvent)(nil), "cockroach.roachpb.TenantSettingsEvent")
	proto.RegisterType((*TenantSetting)(nil), "cockroach.roachpb.TenantSetting")
	proto.RegisterType((*TenantConsumption)(nil), "cockroach.roachpb.TenantConsumption")
	proto.RegisterType((*TenantConsumptionRates)(nil), "cockroach.roachpb.TenantConsumptionRates")
	proto.RegisterType((*TokenBucketRequest)(nil), "cockroach.roachpb.TokenBucketRequest")
	proto.RegisterType((*TokenBucketResponse)(nil), "cockroach.roachpb.TokenBucketResponse")
	proto.RegisterType((*JoinNodeRequest)(nil), "cockroach.roachpb.JoinNodeRequest")
	proto.RegisterType((*JoinNodeResponse)(nil), "cockroach.roachpb.JoinNodeResponse")
	proto.RegisterType((*GetRangeDescriptorsRequest)(nil), "cockroach.roachpb.GetRangeDescriptorsRequest")
	proto.RegisterType((*GetRangeDescriptorsResponse)(nil), "cockroach.roachpb.GetRangeDescriptorsResponse")
	proto.RegisterType((*ContentionEvent)(nil), "cockroach.roachpb.ContentionEvent")
	proto.RegisterType((*ScanStats)(nil), "cockroach.roachpb.ScanStats")
	proto.RegisterType((*UsedFollowerRead)(nil), "cockroach.roachpb.UsedFollowerRead")
}

func init() { proto.RegisterFile("kv/kvpb/api.proto", fileDescriptor_dc8f41762a89273b) }

var fileDescriptor_dc8f41762a89273b = []byte{
	// 12519 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x6b, 0x6c, 0x24, 0x49,
	0x72, 0x18, 0xcc, 0x7e, 0x90, 0xec, 0x8e, 0x7e, 0xb0, 0x99, 0x7c, 0x4c, 0x0f, 0x67, 0x67, 0x7a,
	0xa6, 0x76, 0xe7, 0xa9, 0x5d, 0x72, 0x67, 0xf6, 0x4e, 0xbb, 0xda, 0xdd, 0xdb, 0x3b, 0xb2, 0xd9,
	0x1c, 0x36, 0x87, 0xaf, 0xa9, 0x6e, 0xce, 0x7c, 0xbb, 0x77, 0x52, 0xa9, 0x58, 0x95, 0x24, 0xeb,
	0x63, 0x77, 0x55, 0x4f, 0x55, 0x35, 0x87, 0x3c, 0x18, 0x32, 0x64, 0x43, 0x87, 0x13, 0x6c, 0x03,
	0x67, 0xc1, 0xb0, 0x0f, 0xb0, 0x24, 0xef, 0xd9, 0x67, 0x5b, 0x36, 0x0c, 0xcb, 0x96, 0x7f, 0x09,
	0x86, 0x1f, 0x3f, 0x24, 0xe8, 0x60, 0x40, 0xc2, 0x41, 0x7e, 0xc9, 0x32, 0x44, 0x59, 0x73, 0x7f,
	0xac, 0x1f, 0x36, 0x60, 0xfb, 0x87, 0xe1, 0x35, 0x2c, 0x1b, 0x19, 0x99, 0xf5, 0xe8, 0x66, 0x35,
	0xd9, 0xe4, 0xf4, 0xdc, 0x9d, 0x6c, 0xfd, 0x18, 0x4e, 0x57, 0x64, 0x44, 0x64, 0x56, 0x3e, 0x22,
	0x23, 0x32, 0x23, 0xa2, 0x60, 0x7c, 0xff, 0x60, 0x6e, 0xff, 0xa0, 0xb5, 0x3d, 0xa7, 0xb6, 0x8c,
	0xd9, 0x96, 0x6d, 0xb9, 0x16, 0x19, 0xd7, 0x2c, 0x6d, 0xdf, 0xb6, 0x54, 0x6d, 0x6f, 0x16, 0xff,
	0xb6, 0xb6, 0x67, 0xa6, 0xa8, 0x6d, 0x5b, 0xb6, 0xd3, 0xda, 0x9e, 0xe3, 0x3f, 0x38, 0xe6, 0xcc,
	0x3d, 0x24, 0x76, 0xa8, 0x7d, 0x40, 0xed, 0x39, 0xcd, 0x32, 0xb5, 0xb6, 0x6d, 0x53, 0x53, 0x3b,
	0x9a, 0x6b, 0x58, 0xda, 0x3e, 0xfe, 0x31, 0xcc, 0xdd, 0x28, 0x5c, 0x9b, 0xaa, 0xba, 0xd3, 0x6e,
	0x36, 0x55, 0xfb, 0x68, 0x0e, 0xd9, 0x8a, 0x07, 0x81, 0x4b, 0x44, 0xbd, 0x73, 0xba, 0xea, 0xaa,
	0x02, 0x36, 0xe9, 0x35, 0xb4, 0xa3, 0x05, 0xd3, 0x1e, 0x66, 0x93, 0xba, 0x6a, 0x08, 0xfb, 0xb2,
	0x07, 0x77, 0x5a, 0xaa, 0xa9, 0x68, 0x96, 0xb9, 0x63, 0x78, 0x0d, 0x99, 0xb0, 0x5b, 0xda, 0x9c,
	0xdd, 0xd2, 0x5a, 0xdb, 0xec, 0xaf, 0x00, 0x5e, 0x72, 0xa8, 0xeb, 0x1a, 0xe6, 0xae, 0x33, 0x47,
	0x4d, 0xcd, 0xd2, 0x83, 0x66, 0xdf, 0x74, 0x9e, 0x35, 0xe6, 0x34, 0xd5, 0x55, 0x1b, 0xd6, 0xee,
	0xdc, 0x0e, 0x75, 0x91, 0xa9, 0x61, 0xea, 0xf4, 0x50, 0xc1, 0x27, 0x81, 0x76, 0xc5, 0x71, 0x2d,
	0x5b, 0xdd, 0xa5, 0x73, 0xd4, 0xdc, 0x35, 0x4c, 0xca, 0x1a, 0x74, 0xa0, 0x79, 0xcc, 0x5f, 0x8b,
	0x2c, 0x7c, 0x47, 0x94, 0x16, 0xdb, 0xae, 0xd1, 0x98, 0xdb, 0x6b, 0x68, 0x73, 0xae, 0xd1, 0xa4,
	0x8e, 0xab, 0x36, 0x5b, 0x5e, 0x97, 0x61, 0x89, 0x6b, 0xab, 0x9a, 0x61, 0xee, 0x7a, 0xff, 0xb3,
	0x66, 0x53, 0xcd, 0xb2, 0x75, 0xaa, 0x2b, 0xec, 0xe5, 0x04, 0xee, 0x1b, 0x3d, 0x70, 0xc5, 0x2f,
	0xaf, 0x13, 0x77, 0xad, 0x5d, 0x0b, 0x7f, 0xce, 0xb1, 0x5f, 0x02, 0x7a, 0x6d, 0xd7, 0xb2, 0x76,
	0x1b, 0x74, 0x0e, 0x9f, 0xb6, 0xdb, 0x3b, 0x73, 0x7a, 0xdb, 0x56, 0x5d, 0xc3, 0xf2, 0x78, 0xbf,
	0xd3, 0x6c, 0x37, 0x5c, 0xc3, 0xa5, 0xa6, 0x6a, 0xba, 0x73, 0xfc, 0x3f, 0x4d, 0x6d, 0xa9, 0xdb,
	0x46, 0xc3, 0x70, 0x0d, 0xca, 0x86, 0x2f, 0xfc, 0xc8, 0x89, 0xa4, 0xdf, 0x4a, 0x40, 0x4e, 0xa6,
	0xcf, 0xda, 0xd4, 0x71, 0x97, 0xa9, 0xaa, 0x53, 0x9b, 0xfc, 0x4a, 0x0c, 0x72, 0xfb, 0x07, 0x26,
	0x6d, 0x52, 0xc7, 0x70, 0x14, 0x87, 0x3e, 0x2b, 0x8e, 0x5c, 0x8f, 0xdd, 0xc9, 0x3c, 0xb8, 0x35,
	0x7b, 0x62, 0xc2, 0xcd, 0x76, 0x50, 0xce, 0x56, 0x9a, 0x2d, 0xf7, 0x68, 0x81, 0x7e, 0xe7, 0xb8,
	0x34, 0xf4, 0xe2, 0xb8, 0x94, 0x7d, 0xf4, 0x64, 0x9d, 0x33, 0xa9, 0xd1, 0x67, 0x9f, 0x1d, 0x97,
	0xaa, 0xbb, 0x86, 0xbb, 0xd7, 0xde, 0x9e, 0xd5, 0xac, 0xe6, 0x9c, 0xcf, 0x49, 0xdf, 0x0e, 0x7e,
	0xcf, 0xb5, 0xf6, 0x77, 0xe7, 0x70, 0xfa, 0x88, 0xca, 0x83, 0x5f, 0xac, 0xd7, 0x66, 0xcb, 0x96,
	0xe9, 0xaa, 0x86, 0x49, 0xed, 0x5f, 0xfa, 0xfd, 0x52, 0x4c, 0xce, 0xfa, 0x85, 0x35, 0xfa, 0x8c,
	0x2c, 0x41, 0x62, 0x9f, 0x1e, 0x15, 0x13, 0xd7, 0x63, 0x77, 0xb2, 0x0b, 0x9f, 0xfb, 0xec, 0xb8,
	0xf4, 0x76, 0x5f, 0xb5, 0x79, 0xef, 0xf1, 0x88, 0x1e, 0xc9, 0x8c, 0x01, 0x59, 0x83, 0x51, 0x6a,
	0xea, 0x0a, 0xe3, 0x95, 0x7c, 0x09, 0x5e, 0x23, 0xd4, 0xd4, 0x1f, 0xd1, 0x23, 0xf2, 0x15, 0x48,
	0x39, 0xac, 0x8b, 0x4c, 0x8d, 0x16, 0x87, 0xaf, 0xc7, 0xee, 0x0c, 0x2f, 0x7c, 0xe9, 0xb3, 0xe3,
	0xd2, 0x87, 0x7d, 0xf1, 0xeb, 0x9e, 0x8d, 0xb3, 0xf5, 0x43, 0xb3, 0x46, 0x9f, 0xc9, 0x3e, 0xc7,
	0x99, 0x51, 0x18, 0xc6, 0x2e, 0x5f, 0x49, 0xa6, 0x62, 0x85, 0xf8, 0x4a, 0x32, 0x15, 0x2f, 0x24,
	0xa4, 0xbf, 0x17, 0x87, 0xbc, 0x4c, 0x9d, 0x96, 0x65, 0x3a, 0x54, 0x8c, 0xe8, 0xdb, 0x90, 0x70,
	0x0f, 0x4d, 0xec, 0x9c, 0xcc, 0x83, 0x6b, 0x11, 0xc3, 0x58, 0xb7, 0x55, 0xd3, 0x51, 0x35, 0x36,
	0x97, 0x64, 0x86, 0x4a, 0xde, 0x83, 0x8c, 0x4d, 0x9d, 0x76, 0x93, 0xe2, 0xdc, 0xc5, 0xae, 0xc8,
	0x3c, 0xb8, 0x14, 0x41, 0x59, 0x6b, 0xa9, 0xa6, 0x0c, 0x1c, 0x97, 0xfd, 0x26, 0x8b, 0x90, 0x13,
	0x94, 0x36, 0x55, 0x1d, 0xcb, 0x2c, 0x8e, 0x5e, 0x8f, 0xdd, 0xc9, 0x3f, 0x28, 0x45, 0x4e, 0x1e,
	0x86, 0x27, 0x23, 0x9a, 0x9c, 0xb5, 0x43, 0x4f, 0xe4, 0x1e, 0x8c, 0x0b, 0x2e, 0x26, 0x3d, 0x74,
	0x95, 0xed, 0x23, 0x97, 0x3a, 0xc5, 0xf4, 0xf5, 0xd8, 0x9d, 0x84, 0x3c, 0xc6, 0x0b, 0xd6, 0xe9,
	0xa1, 0xbb, 0xc0, 0xc0, 0xe4, 0x32, 0xa4, 0xcc, 0x76, 0x93, 0x0d, 0x99, 0x83, 0x7d, 0x9c, 0x90,
	0x47, 0xcd, 0x76, 0xf3, 0x11, 0x3d, 0x72, 0xc8, 0x15, 0x48, 0xb3, 0x22, 0x4e, 0x9e, 0xc2, 0x32,
	0x86, 0x8b, 0x74, 0x2b, 0xc9, 0xd4, 0x48, 0x61, 0x54, 0xfa, 0x6f, 0x09, 0x80, 0x87, 0xd4, 0x15,
	0x13, 0x99, 0x2c, 0xc0, 0xc8, 0x1e, 0x76, 0x5a, 0x31, 0x86, 0xef, 0x7c, 0xfd, 0xac, 0x49, 0xbf,
	0x90, 0x62, 0xd3, 0xfd, 0xbb, 0xc7, 0xa5, 0x98, 0x2c, 0x28, 0xc9, 0x36, 0x4c, 0xee, 0xd3, 0x23,
	0x45, 0xc8, 0x55, 0xc5, 0x71, 0x6d, 0x6a, 0xee, 0xba, 0x7b, 0xc5, 0x38, 0xf6, 0xc4, 0xdb, 0x21,
	0x8e, 0xfb, 0x07, 0xb3, 0x9e, 0xac, 0x9d, 0x0d, 0xc9, 0xe5, 0x59, 0x46, 0x3a, 0x5b, 0x13, 0x74,
	0x32, 0xd9, 0xa7, 0x47, 0xab, 0x9c, 0x99, 0x07, 0x23, 0x7b, 0x30, 0x1d, 0xae, 0x83, 0x49, 0x02,
	0x5c, 0xd8, 0x7c, 0x09, 0xe4, 0x1f, 0x3c, 0xe8, 0xb7, 0x96, 0x45, 0x9f, 0x52, 0x9e, 0x0c, 0xea,
	0x09, 0xa0, 0x64, 0x15, 0xa6, 0x6d, 0xea, 0xb6, 0x6d, 0x53, 0xb1, 0xd5, 0xe7, 0x0a, 0x93, 0x88,
	0xca, 0x81, 0xda, 0x68, 0x53, 0x07, 0x67, 0x45, 0x6a, 0xe1, 0xd2, 0x8b, 0xe3, 0xd2, 0x84, 0x8c,
	0x18, 0xb2, 0xfa, 0x7c, 0xed, 0x49, 0xb9, 0xfc, 0x04, 0x8b, 0xe5, 0x09, 0xdb, 0x07, 0x1e, 0x68,
	0x1a, 0x07, 0xb2, 0x81, 0x65, 0xd5, 0x2a, 0xa6, 0x65, 0x2a, 0xf4, 0xd0, 0x70, 0x98, 0x30, 0xc7,
	0x51, 0x4b, 0xc9, 0x63, 0xac, 0x60, 0xdd, 0x32, 0x2b, 0x02, 0x4c, 0x3e, 0x86, 0x69, 0x7a, 0xd8,
	0xa2, 0x9a, 0xab, 0xd0, 0x43, 0xad, 0xd1, 0x76, 0x0c, 0xcb, 0x54, 0x1c, 0x83, 0x2d, 0x25, 0x2e,
	0x90, 0xae, 0x86, 0xde, 0x11, 0x05, 0xc4, 0x5e, 0x43, 0x9b, 0xad, 0x7b, 0xc2, 0x79, 0x21, 0xc9,
	0x06, 0x46, 0x9e, 0xe4, 0x2c, 0x2a, 0x1e, 0x87, 0x1a, 0x63, 0x20, 0xfd, 0xb3, 0x18, 0x64, 0x70,
	0xd4, 0xf9, 0x3a, 0x21, 0xe5, 0xae, 0x61, 0xbf, 0x11, 0x3d, 0x5d, 0x43, 0x8b, 0x2a, 0x62, 0xdc,
	0x67, 0x61, 0x18, 0x7b, 0x06, 0x07, 0x3a, 0xf3, 0xa0, 0x18, 0xc1, 0x03, 0x7b, 0x41, 0xe6, 0x68,
	0xe4, 0x03, 0xc8, 0x1a, 0xa6, 0x4b, 0x4d, 0x97, 0x77, 0xa8, 0x58, 0x9f, 0xbd, 0xc9, 0x32, 0x1c,
	0x1b, 0x1f, 0x24, 0x19, 0xb2, 0x9b, 0xb6, 0xb5, 0x4d, 0x07, 0x38, 0x71, 0xa5, 0x3a, 0xe4, 0x04,
	0xcf, 0x01, 0x76, 0x8b, 0xf4, 0xff, 0x01, 0xa9, 0x3a, 0x4c, 0x36, 0xa0, 0xac, 0x1a, 0x64, 0x7b,
	0x3f, 0x81, 0x89, 0x0e, 0xce, 0x83, 0x6c, 0xf5, 0x6f, 0xc5, 0x01, 0x36, 0xdb, 0x03, 0x95, 0x0b,
	0x9f, 0xeb, 0x73, 0x7e, 0x88, 0x99, 0x2b, 0x66, 0xc9, 0x34, 0x8c, 0x18, 0x66, 0xc3, 0x30, 0xf9,
	0xfc, 0x48, 0xc9, 0xe2, 0x89, 0x4c, 0xc2, 0xf0, 0x76, 0xc3, 0x30, 0x75, 0xbe, 0x0c, 0x65, 0xfe,
	0x40, 0xbe, 0x00, 0x57, 0x9a, 0x6d, 0xc7, 0x55, 0x54, 0xed, 0x59, 0xdb, 0xb0, 0xa9, 0xb7, 0x72,
	0x0e, 0x28, 0x8a, 0x0a, 0xb1, 0xd2, 0x8a, 0x0c, 0x65, 0x9e, 0x63, 0x54, 0x3c, 0x04, 0xb6, 0xf2,
	0x5f, 0xe5, 0x92, 0x93, 0x21, 0x83, 0xfd, 0x39, 0xc8, 0x41, 0xfa, 0xcf, 0x71, 0x98, 0x2a, 0x5b,
	0xa6, 0x6e, 0xb0, 0x9d, 0x4b, 0x6d, 0xfc, 0x50, 0x8c, 0xd7, 0x15, 0x48, 0xd3, 0xc3, 0x96, 0xd8,
	0x73, 0x58, 0xaf, 0x65, 0xe5, 0x14, 0x3d, 0x6c, 0xf1, 0xbd, 0x2a, 0x7a, 0xd0, 0x3e, 0x07, 0x97,
	0xd4, 0x46, 0xc3, 0x7a, 0xae, 0x18, 0x3b, 0x8a, 0x6e, 0x51, 0x47, 0x31, 0x2d, 0x97, 0x4b, 0x47,
	0x31, 0x60, 0x13, 0x58, 0x5c, 0xdd, 0x59, 0xb4, 0xa8, 0xb3, 0x6e, 0xb9, 0x28, 0x21, 0x43, 0x13,
	0x63, 0xb4, 0x63, 0x62, 0xac, 0x43, 0xc1, 0xb2, 0x8d, 0x5d, 0xc3, 0x54, 0x7c, 0x45, 0x15, 0xf7,
	0xbe, 0x3e, 0x47, 0x6f, 0x8c, 0x13, 0xfb, 0xe0, 0x95, 0x64, 0x2a, 0x51, 0x48, 0xae, 0x24, 0x53,
	0xe9, 0x02, 0x48, 0x3f, 0x0e, 0xd3, 0xdd, 0xfd, 0x3d, 0xc8, 0xf1, 0x74, 0xa1, 0x50, 0x35, 0x35,
	0x9b, 0x36, 0xa9, 0x39, 0xd0, 0x91, 0x7c, 0x0d, 0xd2, 0x86, 0xc7, 0x17, 0x47, 0x33, 0x21, 0x07,
	0x00, 0xa9, 0x0d, 0xe3, 0xa1, 0x5a, 0x07, 0xb9, 0x23, 0x30, 0xfd, 0x83, 0x3e, 0x57, 0x82, 0x59,
	0xc4, 0xf4, 0x0f, 0xfa, 0x9c, 0x4b, 0xf0, 0xff, 0x14, 0x83, 0xdc, 0x22, 0x6d, 0x50, 0x77, 0x90,
	0x32, 0xfc, 0x2c, 0x01, 0x10, 0xbf, 0xb0, 0x00, 0x48, 0xbc, 0xac, 0x00, 0xb0, 0x21, 0xef, 0xbd,
	0xee, 0x80, 0xfb, 0x78, 0xc7, 0x6a, 0x0b, 0x9d, 0x9d, 0xbf, 0x5e, 0x0a, 0x01, 0x8f, 0xe8, 0x91,
	0xf4, 0x37, 0x13, 0x40, 0x44, 0xa5, 0xaa, 0xb9, 0x3b, 0xd0, 0x8e, 0x2e, 0x31, 0x15, 0x19, 0xf5,
	0x22, 0xd4, 0x3c, 0xb9, 0x70, 0x06, 0x0e, 0x42, 0xe5, 0x33, 0x58, 0x9f, 0xc9, 0x8e, 0xf5, 0x39,
	0x0b, 0x13, 0x6d, 0x87, 0x2a, 0x36, 0x6b, 0x90, 0xe2, 0x5a, 0xcd, 0x6d, 0xc7, 0xb5, 0x4c, 0x2a,
	0x56, 0xfa, 0x78, 0xdb, 0xe1, 0x4d, 0xad, 0x7b, 0x05, 0xe4, 0x3e, 0x4c, 0x1a, 0x3a, 0x6d, 0xb6,
	0x2c, 0x54, 0x15, 0x02, 0x02, 0xbe, 0xea, 0x27, 0x82, 0xb2, 0x80, 0xe4, 0x63, 0xb8, 0xd2, 0x6e,
	0xe9, 0xaa, 0xeb, 0xd5, 0xa2, 0x63, 0x17, 0x28, 0xbb, 0x9a, 0xb2, 0x67, 0x98, 0x2e, 0x4a, 0x83,
	0xd4, 0xc2, 0x95, 0x17, 0xc7, 0xa5, 0x4b, 0x5b, 0x88, 0x86, 0x35, 0xf2, 0x7e, 0x7a, 0x58, 0x5e,
	0x36, 0x4c, 0x57, 0xbe, 0xd4, 0x3e, 0x51, 0xa0, 0xb1, 0x02, 0xb2, 0x0e, 0xd0, 0xb2, 0xa9, 0x6e,
	0x68, 0xaa, 0x27, 0xdf, 0x32, 0x0f, 0xee, 0x44, 0x74, 0x5f, 0xa8, 0xd7, 0x37, 0x7d, 0x7c, 0x31,
	0x3f, 0x42, 0x1c, 0x84, 0xd1, 0xf2, 0x53, 0x30, 0x15, 0x49, 0x40, 0x6e, 0x40, 0xd6, 0x68, 0xb6,
	0x2c, 0xdb, 0x55, 0x68, 0xcb, 0xd2, 0xf6, 0x70, 0xbc, 0x72, 0x72, 0x86, 0xc3, 0x2a, 0x0c, 0x44,
	0x16, 0x00, 0x1c, 0x57, 0xb5, 0x5d, 0x14, 0x77, 0xe7, 0xd9, 0xa7, 0xd2, 0x48, 0xc6, 0xa0, 0xd2,
	0xb7, 0x63, 0x30, 0xd1, 0x31, 0x4f, 0x06, 0x39, 0x43, 0x97, 0x21, 0x89, 0x53, 0x24, 0x7e, 0x3d,
	0x71, 0x61, 0x83, 0x12, 0x39, 0x48, 0xdf, 0x8c, 0xc1, 0x78, 0xb9, 0x41, 0x55, 0x7b, 0xe0, 0xb3,
	0xf9, 0x8b, 0x90, 0xd2, 0xa9, 0xaa, 0xe3, 0x74, 0x8d, 0xf7, 0xdf, 0x85, 0x3e, 0x91, 0xf4, 0x31,
	0x90, 0x70, 0xcb, 0x06, 0xb9, 0x2b, 0xfc, 0xab, 0x18, 0x10, 0x99, 0x1e, 0x50, 0xdb, 0x1d, 0xf8,
	0x6b, 0x2f, 0x42, 0xc6, 0x55, 0xed, 0x5d, 0x2a, 0x26, 0xcf, 0x39, 0xde, 0x1c, 0x38, 0x1d, 0x03,
	0xb3, 0x15, 0x6d, 0xec, 0x9a, 0x96, 0x8d, 0x2b, 0xcc, 0xdd, 0xb3, 0xa9, 0xb3, 0x67, 0x35, 0xbc,
	0x3d, 0x7e, 0x9c, 0x17, 0x3d, 0xd4, 0xea, 0x5e, 0x01, 0xdf, 0x51, 0x99, 0xf6, 0xda, 0xf1, 0x56,
	0x83, 0xec, 0xb2, 0x3f, 0x1b, 0x03, 0x28, 0x5b, 0x8d, 0x05, 0xd5, 0xd5, 0xf6, 0xa8, 0x43, 0x14,
	0xc8, 0x68, 0x56, 0x43, 0xd9, 0xe6, 0x8f, 0xc5, 0x18, 0x4e, 0xc4, 0x8f, 0x18, 0xd5, 0xef, 0x1e,
	0x97, 0x7e, 0xb4, 0xaf, 0xc9, 0xa8, 0x59, 0x0d, 0xf6, 0x0f, 0xcf, 0xee, 0x90, 0xad, 0x0c, 0x9a,
	0x5f, 0xc1, 0xfb, 0x93, 0xdf, 0xfc, 0xb4, 0x34, 0xf4, 0x1f, 0x3f, 0x2d, 0x0d, 0x7d, 0xfd, 0x5b,
	0xa5, 0xa1, 0x6f, 0x7c, 0xab, 0x34, 0xf4, 0xe9, 0xb7, 0x4a, 0x43, 0xd2, 0xaf, 0x26, 0x20, 0x53,
	0xd3, 0x54, 0x73, 0x90, 0x23, 0xf6, 0x11, 0x64, 0x1c, 0x4d, 0x35, 0x95, 0x1d, 0xcb, 0x6e, 0xaa,
	0x2e, 0xf6, 0x71, 0xbe, 0x63, 0xc4, 0xfc, 0x93, 0x09, 0x4d, 0x35, 0x97, 0x10, 0x49, 0x06, 0xc7,
	0xff, 0xdd, 0xd3, 0x38, 0x1f, 0xfe, 0xbe, 0x18, 0xe7, 0x23, 0xdf, 0x37, 0xe3, 0x7c, 0xf4, 0xfc,
	0xc6, 0x39, 0x97, 0xc5, 0x62, 0x76, 0xfe, 0x93, 0x38, 0x64, 0xf9, 0xd8, 0x0d, 0x52, 0x14, 0x7e,
	0x1e, 0x92, 0xb6, 0xf5, 0x9c, 0x8b, 0xc2, 0xcc, 0x83, 0x2b, 0x11, 0x2c, 0x1e, 0xd1, 0xa3, 0xb0,
	0x52, 0x8d, 0xe8, 0x64, 0x01, 0x84, 0xed, 0xab, 0x20, 0x75, 0xa2, 0x5f, 0x6a, 0xe0, 0x54, 0x32,
	0xe3, 0x71, 0x1b, 0xc6, 0x70, 0xfe, 0x2b, 0xb6, 0x68, 0xa4, 0x53, 0x4c, 0xb2, 0x75, 0x20, 0xe7,
	0x11, 0xec, 0x35, 0xdd, 0x61, 0x32, 0x21, 0xbc, 0x58, 0x86, 0x4f, 0xc8, 0x04, 0xaf, 0xb2, 0x60,
	0x81, 0x79, 0xd5, 0x05, 0x2b, 0x42, 0x52, 0x20, 0x57, 0x39, 0xd4, 0x0c, 0x67, 0x90, 0xe2, 0xaa,
	0x63, 0x80, 0xb6, 0x20, 0xef, 0x55, 0x30, 0x48, 0xc9, 0xf1, 0xcf, 0x13, 0x42, 0xd8, 0x3a, 0xf4,
	0x4f, 0x96, 0xee, 0x1f, 0xcf, 0xa5, 0xfb, 0x6b, 0x71, 0xb1, 0xb3, 0x78, 0x43, 0xf8, 0x27, 0x2b,
	0xf8, 0x22, 0x2b, 0xf8, 0xdb, 0x31, 0xb8, 0x54, 0xde, 0xa3, 0xda, 0x7e, 0xd9, 0x32, 0x1d, 0xc3,
	0x71, 0xd9, 0xd8, 0x0e, 0x72, 0x39, 0xbc, 0x03, 0xc9, 0xa6, 0xa5, 0x53, 0x71, 0x60, 0x1b, 0x75,
	0x40, 0x8e, 0xb5, 0x3b, 0xed, 0xe6, 0x9a, 0xa5, 0x53, 0x19, 0x91, 0xfd, 0x71, 0x4e, 0x16, 0x86,
	0x57, 0x92, 0xa9, 0xe1, 0xc2, 0x88, 0xf4, 0x8f, 0x93, 0x50, 0x3c, 0xd9, 0xcc, 0x41, 0x0e, 0xf9,
	0x26, 0x8c, 0xd8, 0xd4, 0x69, 0x37, 0x5c, 0x31, 0xe8, 0x0f, 0x7a, 0x35, 0x35, 0xa2, 0x05, 0x78,
	0xc8, 0xdf, 0x70, 0x45, 0xf7, 0x0a, 0x3e, 0x33, 0x7f, 0x18, 0x83, 0x11, 0x5e, 0x40, 0x7e, 0x02,
	0x52, 0xdc, 0x46, 0x31, 0x74, 0x6c, 0x63, 0x62, 0xa1, 0xfc, 0xe2, 0xb8, 0x34, 0x8a, 0x3a, 0x51,
	0x75, 0xf1, 0xb3, 0xe3, 0xd2, 0xe7, 0xce, 0xa5, 0x2b, 0x0b, 0x3a, 0x79, 0x14, 0x99, 0x56, 0x75,
	0x66, 0x1e, 0x72, 0xeb, 0xc0, 0x33, 0x0f, 0xb3, 0x72, 0x0a, 0x01, 0x8f, 0xe8, 0x11, 0x59, 0x81,
	0x11, 0xc7, 0x55, 0xdd, 0xb6, 0x13, 0x71, 0x6a, 0x7e, 0xe6, 0x9b, 0xd5, 0x90, 0x52, 0x16, 0x1c,
	0x98, 0xb9, 0xa7, 0x53, 0x57, 0x35, 0x1a, 0x28, 0xd8, 0xd2, 0xb2, 0x78, 0x92, 0xfe, 0x6a, 0x0c,
	0x46, 0x38, 0x2a, 0xb9, 0x04, 0x13, 0xf2, 0xfc, 0xfa, 0xc3, 0x8a, 0x52, 0x5d, 0x5f, 0xac, 0xd4,
	0x2b, 0xf2, 0x5a, 0x75, 0x7d, 0xbe, 0x5e, 0x29, 0x0c, 0x91, 0x69, 0x20, 0x5e, 0x41, 0x79, 0x63,
	0xbd, 0x56, 0xad, 0xd5, 0x2b, 0xeb, 0xf5, 0x42, 0x8c, 0x4c, 0x42, 0x81, 0xc3, 0x43, 0xd0, 0x38,
	0x79, 0x03, 0xae, 0x77, 0x43, 0x95, 0x5a, 0x7d, 0xbe, 0x5e, 0x53, 0x2a, 0xb5, 0x7a, 0x75, 0x6d,
	0xbe, 0x5e, 0x59, 0x2c, 0x24, 0x4e, 0xc1, 0x62, 0x95, 0xc8, 0x72, 0xa5, 0x5c, 0x2f, 0x24, 0x25,
	0x17, 0xa6, 0x64, 0xaa, 0x59, 0xcd, 0x56, 0xdb, 0xa5, 0xac, 0x95, 0xce, 0x20, 0x67, 0xf8, 0x25,
	0x18, 0xd5, 0xed, 0x23, 0xc5, 0x6e, 0x9b, 0xc2, 0x30, 0x1f, 0xd1, 0xed, 0x23, 0xb9, 0x6d, 0x4a,
	0xff, 0x20, 0x06, 0xd3, 0xdd, 0xd5, 0x0e, 0x72, 0xc6, 0x3e, 0x86, 0x8c, 0xaa, 0xeb, 0x54, 0x67,
	0x86, 0xaf, 0xab, 0x0a, 0xb5, 0xfe, 0x5e, 0x88, 0x93, 0xb8, 0x5b, 0x9b, 0xf5, 0xef, 0xd6, 0x98,
	0x7c, 0xc5, 0x86, 0x2c, 0x32, 0x0a, 0x4f, 0x1a, 0x20, 0x13, 0x84, 0x48, 0xbf, 0x9e, 0x84, 0x5c,
	0xc5, 0xd4, 0xeb, 0x87, 0x03, 0xdd, 0x12, 0xa7, 0x61, 0x44, 0xb3, 0x9a, 0x4d, 0xc3, 0xf5, 0x3a,
	0x88, 0x3f, 0x75, 0x98, 0x63, 0x89, 0x0b, 0x98, 0x63, 0xe4, 0x27, 0xe1, 0x12, 0x93, 0x9c, 0xb6,
	0xa9, 0x36, 0x14, 0xce, 0x53, 0x71, 0x6d, 0x63, 0x77, 0x97, 0xda, 0xe2, 0x32, 0x2f, 0xca, 0x66,
	0xaf, 0x0a, 0x8a, 0x32, 0x12, 0xd4, 0x39, 0xbe, 0x3c, 0x65, 0x44, 0x81, 0xc9, 0x87, 0x00, 0x78,
	0x93, 0xe3, 0xb4, 0x54, 0x93, 0xc9, 0xd8, 0xc4, 0x29, 0x37, 0x84, 0x9e, 0xc1, 0xcd, 0x08, 0xd8,
	0xb3, 0x43, 0x1e, 0x43, 0xc1, 0x30, 0x95, 0x9d, 0x86, 0xb1, 0xbb, 0xe7, 0x2a, 0xcf, 0x6d, 0xc3,
	0xa5, 0x4e, 0x71, 0x1c, 0x79, 0x44, 0x0d, 0x78, 0x4d, 0xdc, 0x78, 0xea, 0x4f, 0x19, 0xa6, 0xe0,
	0x96, 0x37, 0xcc, 0x25, 0xa4, 0x47, 0xa0, 0x43, 0xe6, 0x20, 0x63, 0x53, 0x7e, 0xe8, 0x75, 0xbf,
	0xa5, 0xe1, 0x7e, 0x9d, 0x5a, 0xc8, 0xbf, 0x38, 0x2e, 0x81, 0xcc, 0xc1, 0xf7, 0x37, 0xcb, 0x32,
	0x08, 0x94, 0xfb, 0x2d, 0x8d, 0x11, 0xe8, 0x86, 0xa3, 0x6e, 0x37, 0x38, 0x41, 0x26, 0x20, 0x58,
	0xe4, 0x60, 0x24, 0x10, 0x28, 0x8c, 0x60, 0x1a, 0x46, 0x5a, 0x96, 0xe1, 0x58, 0x26, 0x5e, 0x45,
	0xa6, 0x64, 0xf1, 0x44, 0x8a, 0x30, 0xda, 0xb2, 0x69, 0x4b, 0xb5, 0x69, 0x31, 0x8b, 0x05, 0xde,
	0xe3, 0x4a, 0x32, 0x35, 0x5a, 0x48, 0xad, 0x24, 0x53, 0xa9, 0x42, 0x7a, 0x25, 0x99, 0x82, 0x42,
	0x46, 0xfa, 0xd7, 0x71, 0xc8, 0x7b, 0xf3, 0x68, 0x90, 0x53, 0xfe, 0x0e, 0x14, 0x2c, 0x93, 0x2a,
	0xad, 0x3d, 0xd5, 0xa1, 0x62, 0xc4, 0x85, 0x01, 0x9a, 0xb7, 0x4c, 0xba, 0xc9, 0xc0, 0x7c, 0xfc,
	0xc8, 0x26, 0x8c, 0x3b, 0xae, 0xba, 0xcb, 0xd4, 0x9b, 0xe0, 0x80, 0x78, 0xb8, 0xff, 0x49, 0x56,
	0x10, 0xd4, 0x3e, 0x9c, 0x1c, 0xc0, 0x5d, 0x9b, 0xb6, 0x1a, 0x78, 0x64, 0xa3, 0x33, 0xdd, 0x49,
	0x6d, 0xa0, 0x06, 0xe5, 0x28, 0x36, 0x6d, 0x50, 0xd5, 0xa1, 0xba, 0x62, 0x99, 0x5e, 0xa3, 0x46,
	0xfa, 0x99, 0x29, 0x6f, 0x04, 0xfc, 0x56, 0x19, 0x3b, 0xa6, 0x3e, 0x39, 0xb2, 0x60, 0xb6, 0x61,
	0xf2, 0x37, 0xe9, 0x50, 0x7a, 0xfe, 0x7d, 0x1c, 0xc6, 0xe7, 0xf5, 0xa6, 0x61, 0xd6, 0x5a, 0x0d,
	0x63, 0xa0, 0x87, 0xc7, 0x8f, 0x21, 0xed, 0x30, 0x9e, 0xc1, 0x0e, 0x72, 0xc1, 0x33, 0x9c, 0x14,
	0xb2, 0x61, 0xfb, 0xce, 0x2a, 0x8c, 0xd1, 0xc3, 0x96, 0xc1, 0xbd, 0x37, 0xf8, 0xd1, 0x43, 0xb2,
	0xff, 0x01, 0xc8, 0x07, 0xb4, 0x78, 0xfc, 0xf0, 0x65, 0xc8, 0xfb, 0x07, 0x6a, 0xde, 0x35, 0xf8,
	0xc5, 0x4f, 0x9a, 0x72, 0x3e, 0xaf, 0x47, 0xf4, 0xc8, 0x11, 0xbd, 0xfb, 0x31, 0x90, 0x70, 0xe7,
	0x0e, 0xd2, 0xe0, 0xf8, 0x18, 0x26, 0x90, 0xf5, 0x96, 0xe9, 0x0c, 0x78, 0xe4, 0xa4, 0x2f, 0xc3,
	0x64, 0x27, 0xeb, 0x41, 0xb6, 0xfb, 0xa9, 0x98, 0x6f, 0x6b, 0xd4, 0x1e, 0xe8, 0x99, 0x94, 0xdf,
	0xd7, 0x82, 0xf1, 0x20, 0xdb, 0xfc, 0xbd, 0x18, 0x5c, 0x46, 0xde, 0xe8, 0xf0, 0xb1, 0x43, 0xed,
	0x55, 0xb6, 0xa0, 0x06, 0xb9, 0x58, 0x36, 0x61, 0x84, 0x1f, 0x8c, 0xe1, 0x4a, 0x19, 0x5e, 0x78,
	0xef, 0xdc, 0x1a, 0x5c, 0xcd, 0xb5, 0x6c, 0xa6, 0xc1, 0x09, 0x3e, 0xe4, 0x6d, 0x98, 0xdc, 0x3e,
	0x6a, 0xa9, 0x8e, 0xa3, 0x38, 0xea, 0x0e, 0x75, 0x8f, 0x14, 0x0d, 0xb5, 0x62, 0x71, 0xe0, 0x4e,
	0x78, 0x59, 0x0d, 0x8b, 0xb8, 0xbe, 0x2c, 0xa9, 0x30, 0x13, 0xf5, 0x92, 0x83, 0xec, 0xc8, 0x5f,
	0x8c, 0xc1, 0xb8, 0x2c, 0x44, 0x94, 0x61, 0x99, 0xe5, 0x3d, 0xa6, 0x6d, 0x92, 0x0a, 0x64, 0xb4,
	0x3d, 0x7e, 0xac, 0x7f, 0xd4, 0xa2, 0xc8, 0x3f, 0xff, 0xe0, 0x8d, 0x48, 0xfe, 0x48, 0xca, 0xc9,
	0xea, 0x47, 0x2d, 0x2a, 0x83, 0xe6, 0xff, 0x66, 0xe3, 0x10, 0xea, 0xc3, 0xcc, 0x69, 0x1c, 0x50,
	0x06, 0x20, 0xae, 0xa7, 0x61, 0x73, 0x4a, 0xe9, 0x1f, 0x25, 0x44, 0x27, 0xf0, 0x3a, 0x04, 0xfa,
	0x40, 0xb5, 0xbb, 0x4f, 0x60, 0x5a, 0xa7, 0x2d, 0x9b, 0x72, 0xa9, 0x1f, 0x7e, 0xf1, 0xf8, 0x39,
	0x5e, 0x7c, 0x32, 0xe0, 0x11, 0x40, 0xc9, 0xc7, 0x40, 0x42, 0xbc, 0xf9, 0x3b, 0x79, 0x56, 0xe3,
	0x79, 0xba, 0x63, 0x3c, 0xe0, 0xc2, 0xe1, 0x0e, 0x29, 0x43, 0x8a, 0x1e, 0xb6, 0x14, 0x9d, 0x3a,
	0x9a, 0x10, 0xba, 0x52, 0x14, 0x43, 0x7e, 0xf1, 0xe1, 0x68, 0xb6, 0xd1, 0x72, 0x2d, 0x5b, 0xb0,
	0x1b, 0xa5, 0x87, 0x2d, 0x06, 0x24, 0x5b, 0x4c, 0x7d, 0xf1, 0xd4, 0x2b, 0x6c, 0xb6, 0xa7, 0x02,
	0x9d, 0xd1, 0x3a, 0xfe, 0x8e, 0xde, 0x55, 0xab, 0xaf, 0x59, 0x71, 0x16, 0xd2, 0xa7, 0x31, 0xb8,
	0x12, 0x39, 0x6a, 0x83, 0xd4, 0x14, 0x3e, 0x84, 0x24, 0xbe, 0x7c, 0xfc, 0x9c, 0x2f, 0x8f, 0x54,
	0xd2, 0x2f, 0x24, 0x84, 0x08, 0x91, 0x29, 0xdb, 0xe8, 0x5f, 0xc1, 0xc5, 0xda, 0x06, 0xe4, 0x0e,
	0x2c, 0x97, 0xda, 0xfe, 0xb0, 0xc7, 0xcf, 0x3d, 0xec, 0x59, 0x64, 0xe0, 0x8d, 0xf8, 0x13, 0x18,
	0x37, 0x2d, 0x53, 0xe9, 0x64, 0x7a, 0xfe, 0xb9, 0x34, 0x66, 0x5a, 0xe6, 0x93, 0x30, 0xdf, 0x2f,
	0xc1, 0x55, 0x57, 0x88, 0x18, 0x05, 0x35, 0x13, 0xc5, 0xb5, 0x94, 0x1d, 0xc3, 0x76, 0x5c, 0x5e,
	0x97, 0xd0, 0xbf, 0x2e, 0xbb, 0x61, 0x39, 0x54, 0xb7, 0x96, 0x18, 0x06, 0x32, 0x22, 0x8f, 0xe1,
	0xd6, 0xa9, 0x1c, 0x14, 0x55, 0xd3, 0xda, 0xb6, 0xea, 0x7a, 0xb7, 0x83, 0x37, 0x7a, 0xb2, 0x9a,
	0x17, 0x88, 0xbe, 0xf0, 0xeb, 0x1a, 0x9e, 0x41, 0x0a, 0xbf, 0x6f, 0xc4, 0x60, 0x62, 0x99, 0xaa,
	0xb6, 0xbb, 0x4d, 0x55, 0x77, 0xc0, 0x06, 0xd1, 0xe7, 0x21, 0x61, 0x5a, 0xcf, 0xcf, 0x73, 0x11,
	0xc3, 0xf0, 0xd9, 0x4e, 0xdf, 0xd9, 0xa2, 0x41, 0xbe, 0xef, 0x4f, 0xa7, 0x20, 0xfd, 0xb0, 0x3c,
	0xc8, 0xb7, 0xfc, 0x50, 0xdc, 0x08, 0xf2, 0x49, 0x18, 0xb5, 0x04, 0xfd, 0xfa, 0x66, 0x1f, 0x96,
	0x1f, 0xd1, 0x23, 0x6f, 0x09, 0x32, 0x2a, 0xb2, 0x0a, 0xc0, 0x8f, 0x4c, 0x90, 0x07, 0xd7, 0xa7,
	0x6f, 0x9f, 0xc1, 0x03, 0xa7, 0x41, 0xc0, 0x28, 0x6d, 0x8b, 0x67, 0x87, 0xcc, 0x43, 0xba, 0xf3,
	0xca, 0xaa, 0xdf, 0xdb, 0x53, 0x9f, 0x8a, 0xac, 0x40, 0x46, 0x6b, 0x50, 0xd5, 0xe6, 0xb7, 0xcd,
	0x78, 0x7e, 0x99, 0x79, 0x70, 0xf7, 0x8c, 0x16, 0x85, 0x6e, 0x0b, 0x41, 0xf3, 0x7f, 0xcf, 0xfc,
	0x5c, 0x0c, 0x86, 0xf1, 0x95, 0x3d, 0x97, 0xde, 0xd8, 0xcb, 0xba, 0xf4, 0xb2, 0x17, 0xf4, 0xed,
	0x9c, 0xf8, 0x79, 0x5e, 0xd0, 0x03, 0xcc, 0xfc, 0x97, 0x18, 0x40, 0xd0, 0x87, 0x68, 0x11, 0xf8,
	0x67, 0x4a, 0xb1, 0x97, 0xb2, 0x08, 0xbc, 0x93, 0xa8, 0x90, 0xdf, 0x71, 0x7c, 0x00, 0x7e, 0xc7,
	0x1d, 0xef, 0x9c, 0xb8, 0xd0, 0x3b, 0xff, 0x4c, 0x1c, 0xb2, 0xe1, 0x51, 0xfa, 0x63, 0xf0, 0xd6,
	0x35, 0x98, 0xf0, 0x5b, 0xa8, 0x5c, 0xe8, 0xfd, 0xc7, 0xbd, 0xa6, 0x85, 0xdd, 0x9f, 0x86, 0x0b,
	0x23, 0xd2, 0x63, 0x9c, 0x00, 0x03, 0x15, 0x2b, 0x5f, 0x4b, 0x40, 0x7e, 0xb3, 0xed, 0xec, 0x0d,
	0x58, 0x82, 0x96, 0x01, 0x5a, 0x6d, 0x67, 0x8f, 0x6d, 0x75, 0x87, 0xa6, 0x98, 0xef, 0x67, 0xf8,
	0x7c, 0x7b, 0x83, 0xcf, 0xe9, 0xea, 0x87, 0x26, 0x59, 0x16, 0x4c, 0xa8, 0x12, 0x38, 0x8e, 0xbf,
	0x7e, 0xda, 0xf9, 0x59, 0xfd, 0xd0, 0x5c, 0xa3, 0xfe, 0xc1, 0x19, 0xe7, 0x44, 0x19, 0xa7, 0x0f,
	0x61, 0x94, 0x3d, 0x28, 0xae, 0x75, 0x1e, 0xe1, 0x32, 0xc2, 0x68, 0xea, 0x16, 0xf9, 0x00, 0xd2,
	0x9c, 0x9a, 0xa9, 0x95, 0xfc, 0x06, 0x26, 0xea, 0x5d, 0x44, 0x37, 0xa2, 0x42, 0x99, 0x42, 0x52,
	0xa6, 0x44, 0x4e, 0xc2, 0xf0, 0x8e, 0x65, 0x6b, 0x9e, 0xa7, 0x0c, 0x7f, 0xe0, 0xe3, 0xe9, 0x1f,
	0xc9, 0xa4, 0x0b, 0x20, 0xfd, 0x5a, 0x0c, 0xc6, 0xfc, 0x81, 0x18, 0xa4, 0xa6, 0x55, 0xee, 0xe8,
	0xc5, 0xf3, 0x0f, 0x05, 0x76, 0xe0, 0x6d, 0x18, 0x53, 0x9b, 0xdb, 0xc6, 0x6e, 0xdb, 0x6a, 0x3b,
	0x8a, 0xba, 0x6d, 0xd9, 0xae, 0x30, 0x7d, 0xf2, 0x3e, 0x78, 0x9e, 0x41, 0xa5, 0xdf, 0x40, 0x9b,
	0x44, 0xb3, 0x0e, 0x70, 0x08, 0x07, 0x39, 0xa5, 0x3e, 0xe0, 0xf1, 0x03, 0xf1, 0xf3, 0x4e, 0x03,
	0x0c, 0x25, 0xb8, 0x0f, 0x93, 0x46, 0x93, 0x69, 0x54, 0x86, 0xdb, 0x38, 0x12, 0x87, 0x40, 0x2e,
	0xd5, 0xc5, 0x4b, 0x4c, 0x04, 0x65, 0x65, 0xaf, 0x48, 0xfa, 0x36, 0x3a, 0x7c, 0x04, 0x6f, 0x32,
	0xc8, 0x31, 0xa9, 0x42, 0xce, 0xe6, 0xac, 0x99, 0x61, 0x71, 0xce, 0x61, 0xc9, 0xfa, 0xa4, 0xf5,
	0x43, 0x53, 0xfa, 0x56, 0x1c, 0xc6, 0x1e, 0xb7, 0xa9, 0x7d, 0xf4, 0xc3, 0xd4, 0xdd, 0xb7, 0x60,
	0xec, 0xb9, 0x6a, 0xb8, 0xca, 0x8e, 0x65, 0x2b, 0xdc, 0x87, 0x4b, 0xf4, 0x74, 0x8e, 0x81, 0x97,
	0x2c, 0x9b, 0x7b, 0x7c, 0x11, 0x0a, 0x64, 0xdf, 0xb4, 0x9e, 0x9b, 0x0a, 0x03, 0xe3, 0x59, 0xe0,
	0xa1, 0x29, 0xee, 0xd3, 0x16, 0xde, 0xfd, 0xdd, 0xe3, 0xd2, 0x3b, 0x7d, 0x49, 0x61, 0x8c, 0x66,
	0x6a, 0xb7, 0x0d, 0x7d, 0x76, 0x6b, 0xab, 0xba, 0x28, 0x17, 0x90, 0xe5, 0x53, 0xce, 0xb1, 0x7e,
	0x68, 0x3a, 0xd2, 0xdf, 0x8a, 0x43, 0x21, 0xe8, 0xa3, 0x41, 0x0e, 0x64, 0x05, 0x32, 0xcf, 0xda,
	0xd4, 0x36, 0x2e, 0x30, 0x8c, 0x20, 0x08, 0xd9, 0xf2, 0xba, 0x07, 0xe3, 0xee, 0xa1, 0xa9, 0xf0,
	0x58, 0x2d, 0xee, 0x74, 0x2b, 0x22, 0x1b, 0xe4, 0x31, 0x97, 0xb5, 0x99, 0xc1, 0xd1, 0xe1, 0xd6,
	0x21, 0x9f, 0x40, 0xb6, 0xa3, 0xb7, 0x12, 0x2f, 0xd7, 0x5b, 0x99, 0xe7, 0xa1, 0x8e, 0xfa, 0xa3,
	0x38, 0x10, 0xec, 0xa8, 0x2a, 0xbf, 0xf0, 0xfc, 0x61, 0x99, 0x4f, 0x77, 0xa0, 0x80, 0x91, 0x7c,
	0x8a, 0xb1, 0xa3, 0x34, 0x0d, 0xc7, 0x31, 0xcc, 0x5d, 0x4f, 0xfe, 0x20, 0xbc, 0xba, 0xb3, 0xc6,
	0xa1, 0x64, 0x15, 0x52, 0xfe, 0x95, 0x7c, 0xf2, 0x82, 0x57, 0xf2, 0x3e, 0x07, 0x62, 0xc1, 0x18,
	0x77, 0x9c, 0xd2, 0x15, 0x87, 0x3e, 0x33, 0xdb, 0x4d, 0xcf, 0xc0, 0x9e, 0x3d, 0xed, 0x05, 0xaa,
	0x9c, 0xa4, 0x46, 0x9f, 0xad, 0xb7, 0x9b, 0xa8, 0xb6, 0x2c, 0x4c, 0x8b, 0x70, 0xb4, 0x7c, 0x47,
	0x99, 0x23, 0xe7, 0x0d, 0xff, 0x99, 0x71, 0x97, 0xfe, 0x61, 0x0c, 0x26, 0x3a, 0x06, 0x60, 0x90,
	0x93, 0xf5, 0x01, 0x4c, 0x71, 0x27, 0xd5, 0xb6, 0x89, 0x92, 0x5d, 0x57, 0xf8, 0xbd, 0xb6, 0xb8,
	0xf6, 0x99, 0xc0, 0xc2, 0x2d, 0x51, 0xc6, 0x1b, 0x40, 0x6e, 0x40, 0x96, 0xd3, 0x08, 0x54, 0xde,
	0xeb, 0x19, 0x84, 0x71, 0x14, 0xe9, 0xeb, 0x31, 0x18, 0xc7, 0x36, 0x8b, 0xf3, 0xf1, 0xc1, 0xcd,
	0x99, 0x39, 0x98, 0x30, 0x4c, 0xad, 0xd1, 0xd6, 0xa9, 0xd2, 0x36, 0x35, 0x8b, 0x55, 0xa7, 0x53,
	0x5d, 0x34, 0x97, 0x88, 0xa2, 0xad, 0xa0, 0x44, 0xfa, 0x2b, 0x31, 0x31, 0x7f, 0x45, 0x53, 0x06,
	0x7b, 0x62, 0x31, 0x8c, 0xd7, 0x09, 0xe2, 0x24, 0x20, 0xea, 0x7d, 0x58, 0xad, 0x35, 0x57, 0x75,
	0x69, 0xd5, 0xdc, 0xb1, 0x3c, 0x87, 0x7c, 0x24, 0x92, 0x7e, 0x23, 0x01, 0x93, 0x32, 0x75, 0xac,
	0xc6, 0x01, 0x1d, 0xfc, 0xda, 0x5a, 0x06, 0xe1, 0xa1, 0xa0, 0x5c, 0x68, 0x89, 0xa5, 0x39, 0x31,
	0x57, 0x94, 0x3a, 0xef, 0xa2, 0xdf, 0x38, 0x5d, 0x94, 0x9d, 0xbc, 0x7d, 0x16, 0x57, 0x53, 0xc9,
	0x8e, 0xab, 0xa9, 0xef, 0xf7, 0x32, 0x22, 0x9f, 0xc0, 0x84, 0x86, 0xf7, 0x82, 0xcf, 0xf7, 0x8c,
	0x06, 0x55, 0x5a, 0xd4, 0xd4, 0x99, 0xc8, 0x18, 0xe9, 0x79, 0x92, 0xb9, 0xb1, 0x8d, 0x52, 0x41,
	0x3f, 0xa1, 0x8a, 0x23, 0x9b, 0xa7, 0x8c, 0xcb, 0x26, 0x67, 0x22, 0xfd, 0x5e, 0x0c, 0xa6, 0xba,
	0x46, 0x72, 0x90, 0xd3, 0xec, 0x4f, 0xc3, 0xbd, 0xce, 0x6b, 0xac, 0xf0, 0x05, 0x96, 0x77, 0x89,
	0x7a, 0x11, 0x4b, 0xf2, 0x56, 0xc7, 0x6d, 0x56, 0x70, 0x91, 0x25, 0x2e, 0x54, 0x3d, 0x6c, 0xe9,
	0x2f, 0x27, 0xe1, 0x72, 0xe7, 0xfb, 0x0d, 0xfa, 0x6c, 0xed, 0x87, 0x7d, 0xba, 0x2e, 0x43, 0xae,
	0xd9, 0x11, 0xb8, 0x72, 0x8e, 0x7b, 0xc9, 0x6c, 0x33, 0x14, 0xb5, 0x12, 0x35, 0xf1, 0x47, 0x7e,
	0x10, 0x13, 0x7f, 0x74, 0x10, 0x13, 0xff, 0x45, 0x0c, 0x66, 0xa2, 0x26, 0xc6, 0xff, 0x55, 0xb3,
	0xff, 0xeb, 0x31, 0xc8, 0x0e, 0xfa, 0x32, 0xed, 0x62, 0x31, 0x5c, 0x52, 0x1d, 0x72, 0xaf, 0xe0,
	0xf6, 0xed, 0x17, 0xe3, 0x40, 0xea, 0x76, 0xdb, 0x64, 0x5d, 0xb1, 0x6a, 0xed, 0x0e, 0xf2, 0x35,
	0x5f, 0x87, 0x61, 0x4c, 0x76, 0x80, 0xaf, 0x99, 0x5c, 0xc8, 0x7d, 0x76, 0x5c, 0x4a, 0xcb, 0xea,
	0x8e, 0x5b, 0x65, 0x40, 0x99, 0x97, 0x75, 0xb8, 0x5a, 0x25, 0x5e, 0x81, 0xab, 0xd5, 0x17, 0x41,
	0x04, 0xfe, 0x50, 0x5d, 0x1c, 0x62, 0xf3, 0x36, 0x25, 0xa3, 0xda, 0x44, 0x3c, 0x54, 0x3c, 0xc3,
	0x46, 0x98, 0xf4, 0x09, 0x4c, 0x74, 0xf4, 0xcf, 0x20, 0x3b, 0xff, 0x53, 0x74, 0x8a, 0xc4, 0x5e,
	0x1c, 0xf8, 0xa5, 0xe7, 0xe7, 0x60, 0x18, 0xa7, 0xf4, 0x29, 0x93, 0x0c, 0xeb, 0xf4, 0xf5, 0x12,
	0xf6, 0x40, 0xbe, 0x80, 0x91, 0x34, 0x07, 0xfc, 0xe0, 0xff, 0x94, 0xe0, 0xdf, 0x30, 0x69, 0x9a,
	0x51, 0x20, 0x80, 0xac, 0x80, 0x64, 0xd3, 0x03, 0x6b, 0x9f, 0x2a, 0xc8, 0x45, 0x35, 0x75, 0x66,
	0xf3, 0x3d, 0x57, 0xd1, 0x8a, 0xf1, 0xfc, 0x03, 0xc4, 0xbd, 0xc1, 0x35, 0x8e, 0xb9, 0x69, 0xd3,
	0x83, 0x79, 0x53, 0x5f, 0xe2, 0x68, 0x15, 0x1f, 0x8b, 0xfb, 0x13, 0x4a, 0x3f, 0x1d, 0x87, 0xc9,
	0x57, 0x76, 0x31, 0xfc, 0x03, 0xe9, 0xa3, 0x5e, 0x77, 0xc7, 0xc9, 0x9e, 0x77, 0xc7, 0x4f, 0xa0,
	0x80, 0xa4, 0x4c, 0x8d, 0x1c, 0xe4, 0xa5, 0xfe, 0xdf, 0x8d, 0xc3, 0x78, 0x88, 0xf1, 0x20, 0x05,
	0xf7, 0x45, 0x7b, 0x36, 0xc7, 0x6d, 0x30, 0xb7, 0xbf, 0xce, 0x95, 0xb3, 0x02, 0x9d, 0xf7, 0xec,
	0x97, 0x21, 0x4b, 0x99, 0xac, 0xc4, 0xcd, 0x62, 0x9b, 0x27, 0xcb, 0x78, 0x99, 0xdb, 0xfe, 0x8c,
	0xcf, 0x6d, 0xe1, 0x48, 0xfa, 0x32, 0x53, 0xd8, 0xc3, 0x4b, 0x75, 0x90, 0x82, 0xe0, 0x5b, 0x71,
	0x98, 0x2e, 0x73, 0xcf, 0x43, 0xcf, 0xbf, 0x76, 0x90, 0xf3, 0xbc, 0x08, 0xa3, 0x07, 0xd4, 0x76,
	0xd8, 0xda, 0x8b, 0x63, 0xac, 0x9a, 0xf7, 0xe8, 0xfb, 0xfb, 0x0e, 0x9f, 0xc3, 0xdf, 0x97, 0x5c,
	0x03, 0xc0, 0x39, 0xdb, 0xb2, 0x0c, 0xd3, 0xe5, 0x3e, 0x6d, 0x72, 0x08, 0x42, 0x96, 0x21, 0xed,
	0x52, 0xbb, 0x69, 0x98, 0xaa, 0x4b, 0x8b, 0xa3, 0x67, 0xdd, 0x69, 0x9e, 0xb8, 0xd3, 0x0d, 0x88,
	0xfd, 0x30, 0x5f, 0x26, 0x09, 0xfe, 0x45, 0x0c, 0x2e, 0x9d, 0xe8, 0xa3, 0x41, 0xce, 0xd9, 0xff,
	0x1f, 0x32, 0x9a, 0x60, 0xcc, 0x76, 0x23, 0x7e, 0xf8, 0x5f, 0x15, 0x01, 0x49, 0x17, 0x39, 0x4c,
	0x79, 0x71, 0x5c, 0x02, 0xaf, 0xa9, 0xd5, 0x45, 0xd1, 0x45, 0xec, 0xb7, 0x2e, 0x1d, 0xc1, 0xb8,
	0x4c, 0x5d, 0xfb, 0xa8, 0xce, 0x53, 0xec, 0x54, 0x0e, 0x98, 0x71, 0xfd, 0x1a, 0xa4, 0xad, 0x16,
	0x15, 0x42, 0x32, 0x86, 0x0e, 0xbb, 0x01, 0x80, 0xdc, 0x84, 0xbc, 0xea, 0xba, 0xb4, 0xd9, 0x72,
	0x15, 0xb3, 0xdd, 0xdc, 0xa6, 0x36, 0xf7, 0x66, 0x91, 0x73, 0x02, 0xba, 0x8e, 0x40, 0x11, 0x02,
	0x6a, 0x1f, 0x29, 0x78, 0x12, 0x82, 0x2b, 0x28, 0x8d, 0x21, 0xa0, 0xf6, 0x51, 0x85, 0x41, 0xa4,
	0xbb, 0x30, 0xb5, 0x64, 0x34, 0x68, 0xc5, 0xd4, 0xec, 0xa3, 0x16, 0xe3, 0xbc, 0x81, 0x7f, 0x1d,
	0x52, 0x08, 0xdd, 0x6d, 0xe1, 0x2d, 0x95, 0xf4, 0xef, 0x86, 0x21, 0x57, 0x39, 0x6c, 0x59, 0xf6,
	0x40, 0xcd, 0xd3, 0x27, 0x7e, 0x36, 0x16, 0xbc, 0x12, 0x71, 0xd0, 0x3f, 0xf1, 0x4c, 0xbd, 0x6d,
	0x42, 0xa8, 0xbc, 0x19, 0x9e, 0xa1, 0xe5, 0x11, 0x3d, 0xaa, 0xd7, 0x64, 0x91, 0x10, 0x86, 0x3d,
	0x38, 0x64, 0x1d, 0x32, 0x18, 0xb1, 0xb0, 0x63, 0x34, 0xbc, 0x8b, 0xee, 0xe8, 0x50, 0x8e, 0xb5,
	0x27, 0xe5, 0xf2, 0x12, 0x22, 0x71, 0xcf, 0xca, 0xe0, 0x59, 0x06, 0xc6, 0x81, 0xff, 0xee, 0x8a,
	0xe1, 0x4c, 0x5c, 0x24, 0x86, 0x93, 0x48, 0x90, 0xe3, 0x7e, 0x7a, 0x4d, 0x83, 0x5f, 0x29, 0xe5,
	0xf8, 0x81, 0x09, 0x02, 0xd7, 0x0c, 0xbc, 0x21, 0x5a, 0x06, 0xa0, 0xfe, 0x60, 0xa0, 0x17, 0x67,
	0xb4, 0x27, 0x6c, 0xe4, 0xa8, 0xc9, 0x21, 0x5a, 0x72, 0x07, 0x0a, 0x22, 0x72, 0x70, 0x87, 0xa9,
	0xfb, 0x8e, 0xf1, 0x55, 0x5a, 0x04, 0x8c, 0xf0, 0xce, 0x73, 0x38, 0x63, 0x51, 0x33, 0xbe, 0x4a,
	0xc9, 0x5b, 0xc0, 0x74, 0x1d, 0xcb, 0x66, 0x98, 0xe6, 0x2e, 0xb5, 0x5b, 0x36, 0x5b, 0xca, 0x79,
	0x1e, 0x1c, 0xc8, 0x4b, 0x96, 0x82, 0x02, 0xf2, 0x15, 0x98, 0x08, 0xe1, 0x29, 0x16, 0xaf, 0xbb,
	0x38, 0x86, 0x6d, 0xbd, 0x19, 0xd9, 0x56, 0x1f, 0x5b, 0x34, 0x54, 0xf4, 0x0d, 0xd9, 0x39, 0x51,
	0x42, 0xb6, 0xe0, 0xb2, 0x77, 0xae, 0x13, 0x84, 0x9c, 0x28, 0x62, 0x9e, 0x15, 0xd0, 0x03, 0x76,
	0xe6, 0xc5, 0x71, 0x69, 0xba, 0xca, 0x91, 0xfc, 0xb0, 0x13, 0x3e, 0xc3, 0xe4, 0x69, 0x41, 0xec,
	0x47, 0x9e, 0x2c, 0x77, 0x06, 0x26, 0xf1, 0xab, 0x95, 0xb0, 0xcf, 0x6b, 0xa6, 0x90, 0x95, 0xbe,
	0x02, 0xe4, 0x64, 0x23, 0xc9, 0x12, 0x5c, 0x77, 0x5c, 0xdb, 0x68, 0x71, 0x2d, 0x91, 0x69, 0x31,
	0x3b, 0xc6, 0x21, 0xea, 0x31, 0x81, 0x99, 0x11, 0xc3, 0x5e, 0x7a, 0x0d, 0xf1, 0x50, 0x47, 0xdc,
	0x44, 0xac, 0x79, 0x33, 0xb0, 0x9a, 0xa4, 0x9f, 0x8d, 0x43, 0x6e, 0xa1, 0xdd, 0xd8, 0xdf, 0x68,
	0xd5, 0x78, 0x76, 0x32, 0x72, 0x05, 0xd2, 0xba, 0xea, 0xaa, 0x7c, 0x50, 0x62, 0x3c, 0xec, 0x9e,
	0x01, 0x70, 0x38, 0xde, 0x81, 0x9c, 0xe3, 0xb8, 0x4a, 0x80, 0x30, 0x82, 0xaa, 0xf0, 0x18, 0x9b,
	0xef, 0xb5, 0x5a, 0x7d, 0x51, 0xe0, 0xc9, 0x19, 0xc7, 0x71, 0xbd, 0x07, 0x52, 0x87, 0x2c, 0x35,
	0xd9, 0x4a, 0xd7, 0xac, 0xb6, 0xe9, 0x7a, 0x67, 0x28, 0xf7, 0x23, 0x46, 0xa3, 0xa3, 0x25, 0xb3,
	0x15, 0x46, 0x54, 0x46, 0x1a, 0xfc, 0x29, 0x67, 0x68, 0x00, 0x99, 0xf9, 0x08, 0x0a, 0xdd, 0x08,
	0x61, 0xc9, 0x90, 0xe4, 0xf7, 0xd7, 0x93, 0x61, 0x13, 0x26, 0x21, 0x4c, 0x94, 0xf7, 0xe3, 0xef,
	0xc5, 0xc2, 0xfe, 0xaf, 0x42, 0x70, 0xff, 0x4a, 0x12, 0xf2, 0x9e, 0x14, 0x19, 0xa4, 0xbc, 0x5e,
	0x80, 0x61, 0x36, 0xcd, 0xbd, 0x13, 0xb8, 0xa8, 0x54, 0x60, 0x9d, 0xd5, 0xe2, 0x0a, 0xf2, 0x34,
	0x0e, 0x24, 0x1d, 0xc4, 0x1a, 0x9f, 0xf9, 0xed, 0x38, 0x24, 0x19, 0x67, 0x72, 0x1f, 0x92, 0x98,
	0x99, 0x2a, 0x76, 0x6a, 0x66, 0x2a, 0xcf, 0x6d, 0x82, 0xa1, 0x92, 0x35, 0xb6, 0xf6, 0x75, 0x4f,
	0x10, 0xa6, 0xfb, 0xa9, 0xbf, 0x20, 0x04, 0x61, 0xaa, 0x82, 0x17, 0xcc, 0xf5, 0x9a, 0x9c, 0xe2,
	0x57, 0xcd, 0x75, 0xf6, 0x3a, 0x29, 0xbe, 0x78, 0xa9, 0x2e, 0x4e, 0xb7, 0xae, 0x9f, 0x35, 0x1d,
	0x3c, 0x2f, 0x7d, 0x8f, 0x8e, 0x5c, 0x86, 0x84, 0xe3, 0xb8, 0x78, 0x46, 0x90, 0x5d, 0x18, 0x7d,
	0x71, 0x5c, 0x4a, 0xd4, 0x6a, 0x75, 0x99, 0xc1, 0xc8, 0x1c, 0x64, 0xd0, 0x91, 0xda, 0x70, 0x8f,
	0x94, 0xfd, 0x03, 0x0c, 0xd9, 0x4f, 0x73, 0x11, 0xba, 0x2a, 0xc0, 0x8f, 0x9e, 0xc8, 0xe0, 0xa1,
	0x3c, 0x3a, 0x20, 0xd7, 0x21, 0x13, 0x96, 0x2f, 0x80, 0x13, 0x28, 0x0c, 0x3a, 0x39, 0x5d, 0xc4,
	0xdd, 0xf6, 0x5f, 0x8b, 0x09, 0x17, 0xdc, 0x9a, 0xc6, 0xf6, 0x37, 0x7b, 0x90, 0x1b, 0xd0, 0x5d,
	0x28, 0xd8, 0xaa, 0xa9, 0x5b, 0x4d, 0xe3, 0xab, 0x94, 0x2b, 0x9a, 0x8e, 0x38, 0x44, 0x1e, 0xf3,
	0xe1, 0xa8, 0xe4, 0x61, 0x1e, 0xaf, 0xa6, 0x7a, 0xc8, 0xd7, 0x64, 0x82, 0xe7, 0xf1, 0x6a, 0xaa,
	0x87, 0x6c, 0xf9, 0x49, 0xff, 0x33, 0x2e, 0x3c, 0x79, 0xfd, 0x16, 0x0e, 0xf6, 0x9a, 0x36, 0x23,
	0xec, 0x62, 0x73, 0xc7, 0xf2, 0x9c, 0x72, 0x5e, 0xeb, 0xe5, 0x17, 0x17, 0x3a, 0x60, 0xe6, 0x6e,
	0x38, 0x0c, 0xe0, 0x90, 0xa7, 0x80, 0xfb, 0x99, 0xe2, 0xb8, 0xaa, 0xb8, 0x40, 0xea, 0x94, 0xd6,
	0xbd, 0x23, 0x4e, 0x16, 0xc6, 0xc5, 0x2c, 0x4b, 0xfb, 0x20, 0x39, 0xcd, 0x78, 0xe1, 0x4f, 0xf2,
	0x1e, 0x14, 0xc5, 0x01, 0x8a, 0xa3, 0x38, 0xfc, 0xf5, 0x51, 0xe5, 0x76, 0xa9, 0x97, 0xee, 0x6c,
	0xda, 0x2b, 0xaf, 0x79, 0xc5, 0x98, 0x6c, 0x66, 0xe6, 0x4b, 0x30, 0xcc, 0x3d, 0x37, 0xce, 0xbf,
	0x58, 0xfc, 0xb9, 0x12, 0x2f, 0x24, 0xa4, 0x6f, 0x8f, 0xc0, 0xf8, 0xbc, 0xae, 0xd7, 0x6a, 0x75,
	0x75, 0xbb, 0x31, 0x50, 0xa3, 0x90, 0x40, 0x92, 0xc9, 0x61, 0x11, 0x97, 0x85, 0xbf, 0xc9, 0x5f,
	0x8c, 0x81, 0xc4, 0x04, 0xb4, 0xbf, 0x09, 0x28, 0xae, 0xa5, 0xd8, 0x9c, 0x51, 0x68, 0x67, 0xe8,
	0x2b, 0xcf, 0xc3, 0x2d, 0xd1, 0xb3, 0xd7, 0x6a, 0xb5, 0xba, 0x0f, 0xad, 0x7b, 0x86, 0x9d, 0x0f,
	0x91, 0xaf, 0x39, 0xa1, 0xa7, 0x93, 0xe5, 0x6c, 0x0b, 0xd7, 0x0d, 0x87, 0xe7, 0xe8, 0xd1, 0x2c,
	0x73, 0xa7, 0x61, 0x68, 0xae, 0x88, 0xd3, 0x94, 0xc7, 0xbd, 0x92, 0xb2, 0x57, 0x40, 0x7e, 0x1c,
	0x8a, 0x3e, 0xba, 0xb3, 0xa7, 0xea, 0xd6, 0x73, 0xc3, 0xdc, 0x55, 0xb6, 0x69, 0xc3, 0x7a, 0x7e,
	0x9e, 0x4c, 0x3c, 0xd3, 0x1e, 0x93, 0x9a, 0xc7, 0x63, 0x81, 0xb1, 0x20, 0xb5, 0x8b, 0x4f, 0xb5,
	0x5c, 0xcf, 0x69, 0x76, 0x07, 0x0a, 0x4c, 0x54, 0x38, 0xae, 0xa2, 0x3a, 0x5e, 0x40, 0x0e, 0x3f,
	0x3c, 0xc8, 0x73, 0xf8, 0xbc, 0x23, 0xe2, 0x6c, 0xbe, 0x02, 0x6f, 0x8a, 0xc0, 0xd5, 0x1d, 0x8b,
	0xb5, 0x8e, 0xbd, 0x5b, 0xc3, 0xd8, 0xa7, 0x8d, 0x23, 0x9e, 0xd5, 0xad, 0xd9, 0x72, 0x8f, 0x30,
	0x2a, 0x48, 0x41, 0xb9, 0x2d, 0x62, 0x65, 0x6e, 0x71, 0x9a, 0x25, 0x8f, 0x64, 0x15, 0x29, 0xd6,
	0x2d, 0x9e, 0xbb, 0x8b, 0xcd, 0xbf, 0x1a, 0xc3, 0x26, 0xdb, 0x70, 0x45, 0xe4, 0x52, 0xd8, 0xa7,
	0x47, 0xe8, 0xf0, 0x70, 0x40, 0x43, 0xc3, 0x9e, 0xed, 0xbf, 0xfb, 0x8a, 0x9c, 0xcf, 0x23, 0x7a,
	0xe4, 0xcc, 0x33, 0x2e, 0xc1, 0x70, 0x2e, 0x00, 0x11, 0xb1, 0x67, 0xbc, 0x0f, 0x15, 0xdd, 0xd8,
	0xd9, 0xe1, 0xea, 0xe2, 0xc2, 0xe4, 0x8b, 0xe3, 0x52, 0xa1, 0x1c, 0x8a, 0x4c, 0x5b, 0x34, 0x76,
	0x76, 0xe4, 0x82, 0xd6, 0x05, 0xf1, 0xc5, 0x28, 0x14, 0x32, 0x42, 0xcb, 0xf9, 0x4e, 0x1c, 0x48,
	0x78, 0x99, 0x0c, 0xf6, 0x06, 0x4c, 0xb8, 0xfc, 0xe1, 0x3a, 0x8e, 0xf7, 0xb3, 0x8e, 0xb9, 0x8b,
	0x1f, 0xe6, 0x64, 0xbc, 0x0d, 0x63, 0xea, 0x81, 0x6a, 0x34, 0x30, 0xd4, 0x89, 0x4b, 0x0e, 0x2e,
	0x60, 0xf3, 0x3e, 0x98, 0xa7, 0xa7, 0xfa, 0x99, 0x18, 0xdc, 0xec, 0x6f, 0x50, 0x5f, 0x26, 0x39,
	0xe6, 0xf5, 0x9d, 0x33, 0x26, 0x81, 0xf4, 0x69, 0x12, 0x66, 0x56, 0x0d, 0x73, 0xbf, 0x72, 0xc8,
	0xfd, 0xa3, 0x5f, 0x81, 0xe8, 0xa1, 0x90, 0xa3, 0x82, 0x3b, 0x6a, 0xf0, 0x62, 0x1d, 0xbd, 0x1f,
	0x75, 0xfe, 0xd1, 0xb3, 0x25, 0xb3, 0x1e, 0x38, 0xa4, 0xed, 0x64, 0x69, 0x08, 0x36, 0xf3, 0x6f,
	0xe2, 0x90, 0x0d, 0x23, 0x91, 0x22, 0x8c, 0xa2, 0x63, 0xae, 0x65, 0x0b, 0xb3, 0xd3, 0x7b, 0x64,
	0xc2, 0xb0, 0xa5, 0x8a, 0x34, 0x91, 0x69, 0x19, 0x7f, 0x93, 0x7b, 0x30, 0xbe, 0xad, 0xf2, 0x50,
	0xf4, 0xc0, 0xcc, 0x48, 0xe0, 0xd6, 0x3e, 0x26, 0x0a, 0x7c, 0x3b, 0xe3, 0x7d, 0xb8, 0xac, 0xb6,
	0x5a, 0xb6, 0x75, 0x68, 0x34, 0x55, 0x97, 0x2a, 0xad, 0xbd, 0x23, 0xc7, 0xd0, 0xd4, 0x06, 0xa7,
	0xc1, 0x33, 0x58, 0xf9, 0x52, 0x08, 0x61, 0x53, 0x94, 0x23, 0xed, 0x5d, 0x28, 0x38, 0x47, 0xa6,
	0xbb, 0x47, 0x5d, 0x43, 0x13, 0x9a, 0x38, 0xae, 0xfe, 0xac, 0x3c, 0xe6, 0xc3, 0xb9, 0xea, 0x4d,
	0xde, 0x86, 0xc9, 0xb6, 0x43, 0x95, 0x00, 0xdd, 0x69, 0xef, 0x30, 0x74, 0x7e, 0x36, 0x41, 0xda,
	0x0e, 0xad, 0x79, 0x45, 0x35, 0x2c, 0xe9, 0x92, 0x57, 0xa3, 0x03, 0x91, 0x57, 0xd2, 0x36, 0x5c,
	0x89, 0x1c, 0x97, 0x41, 0x1e, 0x15, 0xfd, 0xf5, 0x18, 0xe4, 0x65, 0xba, 0x63, 0x53, 0x67, 0x6f,
	0x90, 0x53, 0x6f, 0x09, 0xb2, 0x36, 0xe7, 0xaa, 0xec, 0xd8, 0x56, 0xf3, 0x3c, 0xaa, 0x70, 0x46,
	0x10, 0x2e, 0xd9, 0x56, 0x53, 0xec, 0xce, 0x4f, 0x60, 0xcc, 0x6f, 0xe3, 0x20, 0x5f, 0xfe, 0x6f,
	0xc7, 0x60, 0xc2, 0x63, 0x3c, 0xe8, 0x6b, 0xc8, 0xc1, 0xf6, 0x00, 0x1e, 0x17, 0x86, 0x1b, 0x3a,
	0xc8, 0x6e, 0xf8, 0x76, 0x1c, 0xf2, 0xb5, 0xf6, 0x36, 0xcf, 0x4d, 0x3b, 0xb8, 0x1e, 0xa8, 0x40,
	0xba, 0x41, 0x77, 0x5c, 0xe5, 0x42, 0x91, 0x18, 0x29, 0x46, 0x8a, 0x71, 0x28, 0x0f, 0x01, 0x6c,
	0x0c, 0xa1, 0x45, 0x3e, 0x89, 0x73, 0xf2, 0x49, 0x23, 0x2d, 0x32, 0xfa, 0x08, 0xae, 0xb4, 0x6c,
	0x8a, 0x17, 0x92, 0x4a, 0xdb, 0xec, 0xbe, 0x08, 0xf4, 0x22, 0x19, 0x3c, 0x94, 0x2d, 0xb3, 0xeb,
	0x4e, 0x4f, 0xfa, 0xa5, 0x61, 0x18, 0xf3, 0xbb, 0x69, 0x90, 0x3b, 0x5f, 0xa7, 0x5e, 0x9d, 0x18,
	0x9c, 0x5e, 0xfd, 0x53, 0x70, 0xd9, 0xbb, 0x0d, 0x13, 0x21, 0xab, 0xa1, 0x7a, 0x52, 0xe7, 0xa9,
	0xe7, 0xaa, 0xa8, 0x67, 0x4a, 0xdc, 0x88, 0xa1, 0x81, 0x16, 0xd4, 0x39, 0x25, 0xee, 0xc7, 0x38,
	0xd8, 0xaf, 0xbf, 0x02, 0x13, 0x3c, 0xe4, 0x43, 0x6d, 0xb5, 0x1a, 0x06, 0x7a, 0x04, 0x05, 0x97,
	0x65, 0x53, 0x9f, 0x1d, 0x97, 0xf8, 0x7d, 0xc1, 0x3c, 0x2f, 0xe5, 0x97, 0x66, 0xe3, 0x8d, 0x6e,
	0x10, 0xf9, 0x5a, 0x0c, 0xb2, 0x3b, 0x36, 0xa5, 0x5f, 0xa5, 0x62, 0x67, 0xee, 0xeb, 0xc6, 0x7c,
	0x91, 0x35, 0xb9, 0xef, 0x4c, 0xd4, 0x5e, 0xe6, 0xf3, 0xd9, 0x32, 0x9b, 0x0d, 0x81, 0xda, 0x9c,
	0xe1, 0x15, 0x73, 0xc5, 0x6d, 0x1d, 0x0a, 0x5a, 0xc3, 0x72, 0xa8, 0x7e, 0x5e, 0x25, 0x5d, 0x44,
	0xd7, 0x70, 0xe2, 0x40, 0x49, 0x7b, 0xcc, 0x64, 0x84, 0xaa, 0x2b, 0x22, 0xe5, 0xbc, 0xd8, 0x37,
	0x66, 0x7b, 0xb8, 0x94, 0x85, 0x32, 0xd5, 0xcf, 0xca, 0x54, 0xd5, 0x85, 0xc5, 0xcd, 0xc4, 0x85,
	0xff, 0x20, 0xc4, 0xc5, 0x53, 0x18, 0xc7, 0x81, 0x1a, 0x74, 0xba, 0x03, 0xe9, 0xef, 0x27, 0x80,
	0x84, 0x39, 0xbf, 0xba, 0x65, 0x10, 0x1f, 0xdc, 0x32, 0x78, 0x07, 0xa6, 0x99, 0xd5, 0xcd, 0x3d,
	0x22, 0x1d, 0xa5, 0x45, 0x6d, 0xc5, 0xa1, 0x9a, 0x65, 0xea, 0x38, 0x91, 0x62, 0xf2, 0x44, 0x53,
	0x3d, 0x7c, 0xcc, 0x0b, 0x37, 0xa9, 0x5d, 0xc3, 0x22, 0xf2, 0x3e, 0xcc, 0x44, 0x13, 0x29, 0x0e,
	0xf5, 0x6e, 0x29, 0xa6, 0x23, 0x08, 0x6b, 0xd4, 0x25, 0x5f, 0x02, 0xc2, 0x68, 0xb5, 0x56, 0x3b,
	0x5c, 0x19, 0x1b, 0xdd, 0xd8, 0xc2, 0xc4, 0x8b, 0xe3, 0xd2, 0xd8, 0x9a, 0x7a, 0x58, 0xde, 0xdc,
	0xf2, 0x69, 0xe4, 0xb1, 0xa6, 0x7a, 0x58, 0x6e, 0xb5, 0x83, 0xda, 0xe7, 0x3d, 0x65, 0x98, 0xd9,
	0xeb, 0x42, 0x6f, 0xeb, 0xc7, 0x5c, 0x4f, 0xfb, 0xe6, 0xba, 0x88, 0x6a, 0xfe, 0x46, 0x0c, 0xf2,
	0x6b, 0xc6, 0xae, 0xad, 0x0e, 0x36, 0x05, 0xe7, 0xfb, 0x9d, 0x57, 0x40, 0x99, 0x07, 0x33, 0x51,
	0x5e, 0x07, 0x1c, 0xc3, 0x0b, 0x2c, 0x14, 0x04, 0x6c, 0x37, 0xf7, 0x5b, 0x34, 0xc8, 0x6d, 0x4c,
	0x83, 0xab, 0xe8, 0x9d, 0x27, 0xbc, 0x48, 0x82, 0x75, 0x36, 0xc8, 0x05, 0xf0, 0xab, 0x31, 0xb8,
	0xd6, 0xab, 0x96, 0x41, 0x2e, 0x06, 0x19, 0xb3, 0xd3, 0x63, 0x0d, 0x8a, 0xbf, 0x1a, 0xce, 0x90,
	0x32, 0x44, 0xac, 0x02, 0xf0, 0xdb, 0x56, 0xc3, 0xbc, 0xf5, 0xfc, 0xb7, 0x23, 0xfd, 0x85, 0x18,
	0xe4, 0x17, 0x54, 0xdb, 0x36, 0x06, 0x7b, 0xfe, 0xf5, 0x2e, 0x14, 0x9f, 0x1b, 0xee, 0x9e, 0x12,
	0x25, 0xea, 0xf9, 0x39, 0xd8, 0x14, 0x2b, 0x3f, 0x21, 0xea, 0xa5, 0xbf, 0x13, 0x87, 0x31, 0xbf,
	0x3d, 0x83, 0xec, 0xbc, 0x97, 0x0f, 0x87, 0xea, 0xb5, 0x75, 0x25, 0xce, 0xb9, 0x75, 0x3d, 0xf4,
	0xd6, 0xf1, 0x85, 0x62, 0x71, 0xf9, 0x6a, 0x66, 0x60, 0xe9, 0xcb, 0x30, 0xb5, 0xd4, 0x68, 0x3b,
	0x7b, 0x4c, 0x15, 0x19, 0xb4, 0xa1, 0x28, 0xfd, 0x99, 0x18, 0x4c, 0x77, 0x73, 0x1f, 0xe4, 0x78,
	0xbc, 0x0e, 0x39, 0xee, 0x6c, 0xf5, 0xdc, 0x36, 0x5c, 0x97, 0x72, 0x99, 0x91, 0x94, 0xb3, 0x08,
	0x7c, 0xca, 0x61, 0xd2, 0x5f, 0xba, 0x0a, 0x59, 0xd1, 0xd0, 0x2d, 0xd3, 0xb0, 0x4c, 0x72, 0x1f,
	0x12, 0xbb, 0xd4, 0x15, 0xf5, 0x46, 0x5d, 0xbc, 0x05, 0xdf, 0x34, 0x58, 0x1e, 0x92, 0x19, 0x2e,
	0x23, 0x69, 0xb5, 0xdd, 0x88, 0x21, 0x0f, 0xa2, 0x68, 0xc2, 0x24, 0xad, 0xb6, 0x4b, 0x6a, 0x30,
	0xa6, 0x05, 0xe9, 0x9e, 0x15, 0x46, 0x9e, 0xe8, 0x79, 0x67, 0x16, 0x99, 0x88, 0x7b, 0x79, 0x48,
	0xce, 0x6b, 0x1d, 0x05, 0xa4, 0x1c, 0x4e, 0xc6, 0x9c, 0x3c, 0xe1, 0x82, 0x18, 0x24, 0xa3, 0xe9,
	0x4c, 0x04, 0xbd, 0x3c, 0x14, 0xca, 0xd9, 0x4c, 0xde, 0x87, 0x11, 0x9e, 0xd4, 0x56, 0xe8, 0x3b,
	0xd7, 0x7b, 0xa7, 0xa0, 0xf5, 0xc9, 0x05, 0x05, 0x59, 0x81, 0xac, 0x48, 0x88, 0xcb, 0xe3, 0x15,
	0x47, 0x7a, 0x5e, 0xad, 0x9d, 0x4c, 0x1d, 0xbc, 0x3c, 0x24, 0x67, 0xf4, 0x00, 0x4a, 0x1e, 0x76,
	0x86, 0x3e, 0xde, 0xea, 0xe9, 0xed, 0x77, 0x22, 0x6d, 0xeb, 0xf2, 0x50, 0x38, 0xee, 0x91, 0x35,
	0xca, 0xc6, 0x6c, 0xa0, 0x82, 0xd3, 0xdb, 0x3d, 0x1b, 0x75, 0x32, 0x15, 0xea, 0x32, 0x9a, 0x45,
	0x3e, 0x94, 0x7c, 0x0e, 0x92, 0x8e, 0xa6, 0x9a, 0x42, 0x65, 0xba, 0xd6, 0x23, 0xc3, 0x5e, 0x40,
	0x8c, 0xd8, 0xe4, 0x03, 0x1e, 0x8c, 0xe7, 0x1e, 0x7a, 0x17, 0xa3, 0x51, 0x7d, 0xda, 0x91, 0x02,
	0x89, 0xf5, 0x29, 0x45, 0x00, 0xeb, 0x07, 0x55, 0x6f, 0x1a, 0xa6, 0x82, 0xb7, 0xad, 0x78, 0xfb,
	0x10, 0xdd, 0x0f, 0x27, 0x72, 0xb4, 0x2c, 0x63, 0x9e, 0x25, 0x0f, 0x48, 0xd6, 0x20, 0xc7, 0x19,
	0xb5, 0x79, 0xd2, 0x8e, 0xe2, 0x5c, 0xcf, 0x8f, 0xcf, 0x44, 0xa4, 0x0d, 0x59, 0x1e, 0x92, 0xb3,
	0x6a, 0x08, 0x1c, 0xb4, 0xab, 0x49, 0xed, 0x5d, 0x8a, 0x39, 0x7e, 0x4e, 0x69, 0x57, 0xd8, 0xfd,
	0xd0, 0x6f, 0x17, 0x02, 0xc9, 0x4f, 0xc2, 0x24, 0x67, 0xd4, 0x19, 0xb0, 0x5d, 0xbc, 0x8a, 0x1c,
	0xdf, 0xec, 0xc5, 0x31, 0xca, 0x9f, 0x6a, 0x79, 0x48, 0x26, 0xea, 0x89, 0x42, 0xa2, 0xc1, 0x14,
	0xaf, 0x41, 0xa4, 0x52, 0xf0, 0x4e, 0xf5, 0x8b, 0xaf, 0x63, 0x15, 0x6f, 0xf5, 0xaa, 0x22, 0x32,
	0xc3, 0xc3, 0xf2, 0x90, 0x3c, 0xa1, 0x9e, 0x2c, 0x0d, 0x5e, 0xc3, 0x16, 0xf1, 0xe1, 0x62, 0xba,
	0xbd, 0x75, 0xfa, 0x6b, 0x44, 0x05, 0xfb, 0xfb, 0xaf, 0xd1, 0x51, 0xc8, 0x06, 0x70, 0xcf, 0x0b,
	0xc5, 0xc6, 0xc9, 0x94, 0xed, 0x39, 0x80, 0x11, 0x41, 0xe4, 0x6c, 0x00, 0xf7, 0x42, 0x60, 0x32,
	0x0b, 0xf1, 0x5d, 0x0d, 0xcf, 0x66, 0xa3, 0x95, 0x3c, 0x3f, 0xa4, 0x78, 0x79, 0x48, 0x8e, 0xef,
	0x32, 0x43, 0x36, 0xc5, 0x23, 0x06, 0x0f, 0x4d, 0xbc, 0x63, 0x8f, 0x96, 0xca, 0x9d, 0x71, 0x97,
	0xcb, 0x43, 0x32, 0x06, 0x29, 0x8a, 0x89, 0x2c, 0x82, 0xbc, 0x90, 0xc5, 0xec, 0x29, 0x19, 0x38,
	0xba, 0x42, 0xed, 0xd8, 0x84, 0xb1, 0x7d, 0x20, 0xd9, 0x84, 0xbc, 0x50, 0x2f, 0xbc, 0x00, 0x8e,
	0x02, 0xf2, 0xba, 0x1d, 0xbd, 0x49, 0x9c, 0x08, 0x4f, 0x58, 0x1e, 0x92, 0x73, 0x76, 0x18, 0xce,
	0xc6, 0xae, 0x93, 0xa3, 0x18, 0xbb, 0xf1, 0x9e, 0x63, 0xd7, 0xd3, 0x99, 0x9c, 0x8d, 0x9d, 0x7d,
	0xa2, 0x90, 0xbc, 0x0b, 0xc3, 0x7c, 0x9d, 0x10, 0x64, 0x19, 0xe5, 0xa3, 0xd4, 0xb5, 0x44, 0x38,
	0x3e, 0x93, 0x5e, 0xae, 0xf0, 0xdc, 0x54, 0x1a, 0xd6, 0x6e, 0x71, 0xa2, 0xa7, 0xf4, 0x3a, 0xe9,
	0x00, 0xcb, 0xa4, 0x97, 0x1b, 0x40, 0xd9, 0x04, 0xf2, 0xae, 0x7b, 0xf8, 0x12, 0x9b, 0x3c, 0xeb,
	0xf3, 0x53, 0x5d, 0x8b, 0x2b, 0x6b, 0x87, 0xc0, 0xbe, 0x60, 0x75, 0xa8, 0x82, 0x42, 0x71, 0xea,
	0x74, 0xc1, 0xda, 0x91, 0xf6, 0xd4, 0x17, 0xac, 0x1c, 0x4a, 0x9e, 0x80, 0x77, 0x11, 0xa0, 0x78,
	0x0e, 0x46, 0xc5, 0xe9, 0x9e, 0xd1, 0xee, 0xd1, 0x5e, 0x66, 0xcb, 0xcc, 0xd6, 0xed, 0x2c, 0x21,
	0x1f, 0xc3, 0x38, 0xf2, 0x53, 0xb4, 0x20, 0xcf, 0x60, 0xb1, 0x78, 0x22, 0x6b, 0x5d, 0xef, 0x94,
	0x84, 0x1e, 0xe7, 0x82, 0xd6, 0x55, 0xc4, 0xa6, 0x61, 0x97, 0xc4, 0x7a, 0xad, 0xe7, 0x34, 0xec,
	0x21, 0xac, 0x72, 0x1d, 0x59, 0x27, 0xc8, 0x22, 0x00, 0xd7, 0xfe, 0xd0, 0xfc, 0xba, 0xd6, 0x73,
	0x03, 0xef, 0xf6, 0xa3, 0x64, 0x1b, 0x78, 0xc3, 0x83, 0xb1, 0x0d, 0x9c, 0x5f, 0x83, 0x17, 0xaf,
	0xf7, 0xde, 0x6c, 0xc2, 0xfe, 0x50, 0xb8, 0xd9, 0x20, 0x80, 0xa9, 0xb0, 0xcc, 0xf4, 0x3c, 0xc2,
	0x15, 0x7a, 0xa3, 0xa7, 0xde, 0xd8, 0x15, 0x9b, 0xb9, 0x3c, 0x24, 0xa7, 0x9e, 0x09, 0x10, 0x9b,
	0x15, 0x9c, 0x85, 0x58, 0x9b, 0xf7, 0x7a, 0xce, 0x8a, 0x93, 0x41, 0x79, 0x6c, 0x56, 0x3c, 0x0b,
	0xa0, 0x4c, 0x64, 0x70, 0x5e, 0xfc, 0xac, 0xec, 0xdd, 0x9e, 0x22, 0xe3, 0x44, 0xa8, 0xd6, 0xb2,
	0x88, 0x45, 0xe4, 0xc0, 0x60, 0xef, 0x13, 0xf7, 0xbc, 0xc5, 0x37, 0x4e, 0xdf, 0xfb, 0x3a, 0xef,
	0xeb, 0xfd, 0xbd, 0x4f, 0x80, 0xf9, 0xde, 0xa7, 0x2b, 0x8e, 0xe3, 0x32, 0xad, 0xb5, 0x78, 0xf3,
	0x94, 0xbd, 0xaf, 0xeb, 0x72, 0x97, 0xef, 0x7d, 0x7a, 0x8d, 0x53, 0x32, 0x35, 0xd0, 0xa6, 0x1d,
	0x37, 0x66, 0xc5, 0xdb, 0x3d, 0xd5, 0xc0, 0xc8, 0x74, 0x92, 0x4c, 0x0d, 0xb4, 0x3b, 0x0a, 0xc8,
	0x17, 0x60, 0x54, 0x1c, 0xe5, 0x16, 0xef, 0x9c, 0xa2, 0x3d, 0x87, 0x4f, 0xdf, 0x99, 0x9c, 0x16,
	0x34, 0x5c, 0x4a, 0xf0, 0x23, 0x64, 0x2e, 0x05, 0xef, 0x9e, 0x22, 0x25, 0x4e, 0x9c, 0x62, 0x73,
	0x29, 0x11, 0x80, 0x59, 0x6b, 0x1c, 0x7e, 0x7c, 0x59, 0xfc, 0x91, 0x9e, 0xad, 0xe9, 0x3c, 0x07,
	0x66, 0xad, 0x11, 0x34, 0xb8, 0x6b, 0xf0, 0xfb, 0x39, 0xec, 0x9d, 0x37, 0x7b, 0xef, 0x1a, 0xdd,
	0x27, 0x4f, 0xcb, 0x9e, 0x1b, 0x81, 0xdf, 0x2b, 0x4d, 0x6e, 0xff, 0x17, 0x1f, 0xf4, 0x6c, 0x47,
	0xe7, 0x99, 0x05, 0x6b, 0x87, 0xa0, 0x21, 0x0d, 0x28, 0xf2, 0xa9, 0x18, 0xd8, 0xc7, 0xbe, 0xad,
	0xf7, 0x0e, 0xf2, 0x7b, 0xbb, 0xd7, 0xbc, 0xec, 0x75, 0x32, 0xb0, 0x3c, 0x24, 0x4f, 0x3f, 0x8b,
	0x44, 0x60, 0x8d, 0xdd, 0xe6, 0x26, 0x6a, 0xf1, 0xf3, 0x3d, 0x1b, 0xdb, 0x69, 0x54, 0xb3, 0xc6,
	0x0a, 0x1a, 0xb6, 0xdb, 0xb4, 0x6c, 0x6b, 0x9b, 0x16, 0x7f, 0xb4, 0xe7, 0x6e, 0x13, 0xfe, 0xc4,
	0x15, 0xdb, 0x6d, 0x10, 0x9f, 0x3c, 0x82, 0x9c, 0xe1, 0xf0, 0xdb, 0x48, 0xbc, 0x98, 0x2c, 0xbe,
	0xd7, 0x73, 0xf5, 0x9e, 0xfc, 0xf2, 0x14, 0x5b, 0xbd, 0x46, 0x00, 0x65, 0x6a, 0x57, 0xc3, 0x30,
	0xf7, 0x15, 0xff, 0x36, 0xd0, 0x5b, 0x2f, 0x3f, 0xd6, 0x53, 0xed, 0xea, 0x7d, 0x21, 0xc8, 0xd4,
	0xae, 0x46, 0xb8, 0x54, 0xac, 0x20, 0x94, 0x76, 0x9a, 0xe1, 0xd0, 0xe2, 0xfb, 0xa7, 0x48, 0xbb,
	0x50, 0xba, 0x70, 0x2e, 0xed, 0x18, 0x80, 0xd4, 0xa1, 0xb0, 0xc3, 0xec, 0x4f, 0x14, 0x2f, 0x0a,
	0x6f, 0xdb, 0x07, 0xbd, 0x3d, 0x17, 0xa3, 0x0c, 0x61, 0xb6, 0xfc, 0x76, 0x3a, 0x0a, 0x16, 0x46,
	0x85, 0x57, 0x99, 0xef, 0xa8, 0x37, 0x56, 0x28, 0xac, 0x24, 0x53, 0x97, 0x0a, 0xc5, 0x95, 0x64,
	0xea, 0x72, 0x61, 0x66, 0x25, 0x99, 0x9a, 0x29, 0x5c, 0x59, 0x49, 0xa6, 0xae, 0x14, 0x5e, 0x5b,
	0x49, 0xa6, 0x4a, 0x85, 0xeb, 0x2b, 0xc9, 0x94, 0x54, 0x78, 0x7d, 0x25, 0x99, 0xba, 0x5f, 0x78,
	0xb0, 0x92, 0x4c, 0x7d, 0xae, 0xf0, 0x79, 0xe9, 0x7f, 0xbc, 0x06, 0x39, 0xcf, 0xc0, 0xe5, 0x76,
	0xe9, 0x83, 0xb0, 0x5d, 0x7a, 0xad, 0x97, 0x5d, 0x2a, 0x4c, 0x62, 0x61, 0x98, 0x3e, 0x08, 0x1b,
	0xa6, 0xd7, 0x7a, 0x19, 0xa6, 0x01, 0x0d, 0xb3, 0x4c, 0xeb, 0xbd, 0x2c, 0xd3, 0xbb, 0x7d, 0x58,
	0xa6, 0x3e, 0xab, 0x6e, 0xd3, 0x74, 0xf1, 0xa4, 0x69, 0xfa, 0xc6, 0xe9, 0xa6, 0xa9, 0xcf, 0x2a,
	0x64, 0x9b, 0x7e, 0xd0, 0x65, 0x9b, 0xde, 0x38, 0xc5, 0x36, 0xf5, 0xe9, 0x3d, 0xe3, 0xf4, 0x51,
	0xa4, 0x71, 0x7a, 0xeb, 0x2c, 0xe3, 0xd4, 0xe7, 0xd3, 0x61, 0x9d, 0x2e, 0x47, 0x59, 0xa7, 0x37,
	0xcf, 0xb0, 0x4e, 0x7d, 0x56, 0x61, 0xf3, 0xf4, 0x51, 0xa4, 0x79, 0x7a, 0xeb, 0x2c, 0xf3, 0x34,
	0x68, 0x56, 0xd8, 0x3e, 0xfd, 0x7c, 0x87, 0x7d, 0x5a, 0xea, 0x69, 0x9f, 0xfa, 0xd4, 0xdc, 0x40,
	0xfd, 0xb0, 0xdb, 0x40, 0xbd, 0x71, 0x8a, 0x81, 0x1a, 0x74, 0xac, 0xb0, 0x50, 0x97, 0xa3, 0x2c,
	0xd4, 0x9b, 0x67, 0x58, 0xa8, 0x41, 0x5f, 0x84, 0x4c, 0xd4, 0xf5, 0x68, 0x13, 0xf5, 0xf6, 0x99,
	0x26, 0xaa, 0xcf, 0xad, 0xd3, 0x46, 0x5d, 0x8e, 0xb2, 0x51, 0x6f, 0x9e, 0x61, 0xa3, 0x76, 0xb5,
	0x8c, 0x1b, 0xa9, 0xea, 0xa9, 0x46, 0xea, 0x5b, 0x7d, 0x1a, 0xa9, 0x3e, 0xeb, 0x28, 0x2b, 0x55,
	0x3f, 0xdd, 0x4a, 0x9d, 0xed, 0xd7, 0x4a, 0xf5, 0x2b, 0x89, 0x34, 0x53, 0xd5, 0x53, 0xcd, 0xd4,
	0xb7, 0xfa, 0x34, 0x53, 0xbb, 0x5e, 0xa4, 0xd3, 0x4e, 0x5d, 0x8f, 0xb6, 0x53, 0x6f, 0x9f, 0x69,
	0xa7, 0x06, 0xa3, 0xd8, 0x61, 0xa8, 0xce, 0x85, 0x0c, 0xd5, 0xab, 0x3d, 0x0c, 0x55, 0x9f, 0x94,
	0x59, 0xaa, 0x5f, 0x3c, 0x61, 0xa9, 0x4a, 0xa7, 0x59, 0xaa, 0x3e, 0xad, 0x6f, 0xaa, 0x2e, 0x47,
	0x99, 0xaa, 0x37, 0xcf, 0x30, 0x55, 0x83, 0x79, 0x13, 0xb2, 0x55, 0x1f, 0xf7, 0xb0, 0x55, 0xef,
	0x9c, 0x6d, 0xab, 0xfa, 0xfc, 0xba, 0x8c, 0x55, 0xf5, 0x54, 0x63, 0xf5, 0xad, 0x3e, 0x8d, 0xd5,
	0x60, 0x04, 0x23, 0xac, 0xd5, 0xf7, 0x3a, 0xad, 0xd5, 0xeb, 0xbd, 0xad, 0x55, 0x9f, 0x8d, 0x30,
	0x57, 0x1f, 0x45, 0x9a, 0xab, 0xb7, 0xce, 0x32, 0x57, 0x03, 0x69, 0x16, 0xb6, 0x57, 0xd7, 0xa3,
	0xed, 0xd5, 0xdb, 0x67, 0xda, 0xab, 0xc1, 0x44, 0xea, 0x30, 0x58, 0x1f, 0x45, 0x1a, 0xac, 0xb7,
	0xce, 0x32, 0x58, 0xbb, 0x44, 0xad, 0xb0, 0x58, 0x9f, 0xf6, 0xb4, 0x58, 0xef, 0xf5, 0x63, 0xb1,
	0xfa, 0x4c, 0x4f, 0x98, 0xac, 0x9f, 0xf4, 0x36, 0x59, 0x7f, 0xe4, 0x1c, 0x59, 0xf4, 0x23, 0x6d,
	0xd6, 0x4a, 0x84, 0x85, 0xf9, 0xc6, 0xe9, 0x16, 0x66, 0xb0, 0x0f, 0x07, 0x26, 0xe6, 0x07, 0x5d,
	0x26, 0xe6, 0x8d, 0x33, 0xbd, 0xd6, 0x43, 0x36, 0xe6, 0xc2, 0x49, 0x1b, 0xf3, 0xf5, 0x53, 0x6d,
	0x4c, 0x9f, 0x43, 0x60, 0x64, 0x3e, 0x8a, 0x34, 0x32, 0x6f, 0x9d, 0x65, 0x64, 0x06, 0x23, 0x19,
	0xb6, 0x32, 0x97, 0xa3, 0xac, 0xcc, 0x9b, 0x67, 0x58, 0x99, 0xc1, 0x6a, 0x0f, 0x99, 0x99, 0xeb,
	0xd1, 0x66, 0xe6, 0xed, 0x33, 0xcd, 0xcc, 0xae, 0xfd, 0xcb, 0xb3, 0x33, 0x97, 0xa3, 0xec, 0xcc,
	0x9b, 0x67, 0xd8, 0x99, 0xe1, 0xfd, 0xcb, 0x37, 0x34, 0xeb, 0xbd, 0x0c, 0xcd, 0xbb, 0x7d, 0x18,
	0x9a, 0x81, 0x56, 0xd7, 0x65, 0x69, 0x7e, 0xd4, 0x6d, 0x69, 0x4a, 0xa7, 0x59, 0x9a, 0x81, 0x9c,
	0xf5, 0x4c, 0xcd, 0xf5, 0x68, 0x53, 0xf3, 0xf6, 0x99, 0xa6, 0x66, 0x78, 0x81, 0x87, 0x6c, 0xcd,
	0x8f, 0xba, 0x6d, 0x4d, 0xe9, 0x34, 0x5b, 0x33, 0x68, 0x8f, 0x67, 0x6c, 0x2e, 0x47, 0x19, 0x9b,
	0x37, 0xcf, 0x30, 0x36, 0x43, 0x72, 0x3f, 0xb0, 0x36, 0x3f, 0xea, 0xb6, 0x36, 0xa5, 0xd3, 0xac,
	0xcd, 0xa0, 0x25, 0x9e, 0xb9, 0xd9, 0x3c, 0xd3, 0xdc, 0xbc, 0x7f, 0x0e, 0x73, 0xd3, 0xe7, 0xdf,
	0xcb, 0xde, 0xfc, 0xa8, 0xdb, 0xde, 0x94, 0x4e, 0xb3, 0x37, 0x83, 0xe6, 0x7a, 0x06, 0xe7, 0x7b,
	0x9d, 0x06, 0xe7, 0xf5, 0xde, 0x06, 0x67, 0xb0, 0x61, 0x70, 0x8b, 0x73, 0x35, 0xda, 0xe2, 0xbc,
	0x75, 0x96, 0xc5, 0x19, 0x2c, 0xe5, 0xb0, 0xc9, 0xa9, 0x9f, 0x6e, 0x72, 0xce, 0xf6, 0x6b, 0x72,
	0x06, 0x3a, 0x54, 0x94, 0xcd, 0xf9, 0x41, 0x97, 0xcd, 0x79, 0xe3, 0x14, 0x9b, 0x33, 0x2c, 0xfe,
	0xd0, 0xe8, 0xdc, 0xea, 0x69, 0x74, 0xde, 0xed, 0xc3, 0xe8, 0x0c, 0x96, 0xe2, 0xcb, 0x59, 0x9d,
	0xaf, 0x15, 0xae, 0xf6, 0xb4, 0x3d, 0x7f, 0x8f, 0xc0, 0xc8, 0x72, 0xc4, 0x95, 0x76, 0xec, 0x42,
	0x57, 0xda, 0xbf, 0x18, 0x83, 0x2b, 0x41, 0xc4, 0xc1, 0x8e, 0x6d, 0x35, 0x15, 0xee, 0x59, 0xa4,
	0x60, 0x36, 0x8e, 0xe2, 0x95, 0x7e, 0xb8, 0x7e, 0xe9, 0xa5, 0x3d, 0xaa, 0x8a, 0x7e, 0x1b, 0x96,
	0x6c, 0xab, 0x59, 0xc3, 0x16, 0x20, 0x0a, 0x69, 0xf3, 0xc4, 0xb8, 0xaf, 0x7d, 0xff, 0xbc, 0xbb,
	0x58, 0x7d, 0x64, 0x91, 0xc9, 0x4e, 0x54, 0xca, 0xcf, 0x4e, 0x46, 0x7e, 0x32, 0x5d, 0xb6, 0x20,
	0x7d, 0xe5, 0x99, 0x27, 0xb6, 0x21, 0xd7, 0x76, 0xa8, 0xad, 0xb4, 0x6c, 0xc3, 0xb2, 0x0d, 0x97,
	0x87, 0xa3, 0xc7, 0x16, 0xbe, 0xf0, 0xd9, 0x71, 0xe9, 0xc7, 0xce, 0xc5, 0x79, 0xcb, 0xa1, 0xf6,
	0xa6, 0x60, 0x22, 0x67, 0xdb, 0xa1, 0x27, 0xf2, 0x36, 0xcf, 0xa2, 0x36, 0xdc, 0x4f, 0x9e, 0x39,
	0x9e, 0x3a, 0xed, 0x31, 0x14, 0xd0, 0x83, 0x2d, 0xac, 0x21, 0xf1, 0x1c, 0x96, 0xd1, 0xca, 0x9c,
	0xaa, 0x87, 0x94, 0x20, 0xcc, 0x65, 0x39, 0x66, 0x77, 0x02, 0xc9, 0x43, 0xc8, 0xdb, 0x56, 0x1b,
	0x33, 0xd0, 0xb5, 0xac, 0x86, 0xa1, 0x1d, 0xa1, 0xea, 0x9a, 0x8f, 0x76, 0x6c, 0xe0, 0x88, 0x9b,
	0x88, 0x27, 0xe7, 0xec, 0xf0, 0x23, 0xa9, 0x01, 0x66, 0x9f, 0xf3, 0xb8, 0x90, 0xf3, 0x7d, 0xdc,
	0xec, 0xa9, 0x6a, 0xb8, 0x82, 0x2f, 0x3c, 0xf7, 0x7f, 0x93, 0x25, 0xc8, 0x72, 0x71, 0x61, 0x34,
	0xa9, 0xd5, 0x76, 0x85, 0xe6, 0x7a, 0x79, 0x76, 0xd7, 0xb2, 0x76, 0x1b, 0x74, 0xb6, 0x65, 0x5b,
	0xae, 0xb5, 0xdd, 0xde, 0xc1, 0x6f, 0xa3, 0x61, 0x3a, 0x3e, 0xf4, 0x86, 0xf8, 0xe6, 0xef, 0x97,
	0x62, 0x72, 0xc6, 0x9b, 0x7b, 0x56, 0xdb, 0x25, 0xf7, 0x61, 0x0a, 0x23, 0xc1, 0x98, 0xb8, 0xf5,
	0x54, 0x6b, 0xcc, 0x75, 0x9c, 0xc2, 0xa8, 0x05, 0xd2, 0x54, 0x0f, 0x99, 0x30, 0x15, 0xda, 0x34,
	0x66, 0x31, 0xbe, 0x01, 0x59, 0x11, 0x8e, 0xcb, 0xe3, 0x1b, 0xc6, 0x10, 0x53, 0x7c, 0xdc, 0x93,
	0x07, 0x37, 0xfc, 0x08, 0x90, 0xe7, 0x7b, 0x56, 0x83, 0xe2, 0x17, 0xc8, 0x14, 0x6b, 0x87, 0x3b,
	0xc6, 0xcf, 0x60, 0x60, 0xf7, 0x18, 0x96, 0xc8, 0xd6, 0x73, 0x67, 0x63, 0x07, 0x1d, 0xe2, 0x4b,
	0x90, 0xe1, 0xf1, 0x3b, 0x5c, 0xdc, 0x5f, 0xe2, 0x81, 0xf7, 0x08, 0xe2, 0x32, 0xfc, 0x26, 0xe4,
	0x75, 0xc3, 0x71, 0x0d, 0x53, 0x73, 0xc5, 0x27, 0x70, 0x78, 0x9c, 0x4b, 0xce, 0x83, 0xf2, 0xef,
	0xdc, 0xdc, 0x86, 0x31, 0xd5, 0x39, 0x32, 0x35, 0x9c, 0x04, 0xd4, 0x74, 0xda, 0x8e, 0x08, 0x4b,
	0xce, 0x23, 0xb8, 0xec, 0x41, 0xc9, 0x07, 0x30, 0x23, 0xbe, 0x8d, 0x87, 0x29, 0x3c, 0x70, 0xe2,
	0x04, 0x42, 0x0d, 0x23, 0x73, 0xe5, 0x4b, 0xfc, 0x5b, 0x78, 0x0c, 0x81, 0xcd, 0x96, 0x60, 0x63,
	0x6c, 0xc1, 0xd8, 0xae, 0xea, 0xd2, 0xe7, 0xea, 0x91, 0x62, 0x5a, 0x3a, 0x2e, 0xb3, 0x0c, 0x26,
	0x64, 0x58, 0x7e, 0x71, 0x5c, 0xca, 0x3d, 0xe4, 0x45, 0xeb, 0x96, 0xce, 0x17, 0xdb, 0x3b, 0xe7,
	0x5a, 0x12, 0x9c, 0x4c, 0xce, 0xed, 0x86, 0xb8, 0xe8, 0xa4, 0x0e, 0xe3, 0x5a, 0xc3, 0xf0, 0xcd,
	0x3a, 0xae, 0xa9, 0x8f, 0xf7, 0xdc, 0x94, 0xcb, 0x88, 0xdb, 0xed, 0x90, 0x37, 0xa6, 0x75, 0x82,
	0xc9, 0x13, 0x18, 0xdf, 0xb6, 0xda, 0xa6, 0x4e, 0x75, 0xa6, 0xdb, 0x34, 0xa8, 0x49, 0x1d, 0xe7,
	0x94, 0x0b, 0xb6, 0x05, 0x8e, 0x5b, 0xf3, 0x50, 0x45, 0x90, 0x72, 0x61, 0xbb, 0x0b, 0x4e, 0x56,
	0x00, 0x5c, 0x5b, 0xd5, 0x44, 0x33, 0x2f, 0x9f, 0xb0, 0x52, 0x50, 0x86, 0xba, 0x3c, 0x3f, 0x80,
	0xf7, 0x3f, 0x5f, 0xd1, 0x1a, 0xb7, 0x2f, 0xd2, 0xae, 0xf7, 0x93, 0x6c, 0x40, 0x81, 0x07, 0x2c,
	0xef, 0x50, 0x57, 0xdb, 0x53, 0x9c, 0x16, 0xd5, 0xc4, 0xf9, 0x4a, 0x87, 0x3f, 0xe6, 0xb3, 0x06,
	0xfb, 0xb7, 0xad, 0x3a, 0x74, 0x16, 0xbd, 0x9d, 0x96, 0x18, 0x76, 0xad, 0x45, 0x35, 0x39, 0x6f,
	0x74, 0x3c, 0x13, 0x0a, 0x25, 0x11, 0x4f, 0x45, 0x1b, 0xaa, 0xe3, 0x1a, 0x1a, 0xfa, 0x46, 0x8a,
	0xb0, 0x7d, 0x3e, 0xb5, 0xae, 0x61, 0x68, 0x52, 0xe9, 0xc5, 0x71, 0xe9, 0x0a, 0xff, 0x22, 0x60,
	0x85, 0x63, 0x96, 0x37, 0xb7, 0x78, 0x88, 0x3e, 0x4e, 0x36, 0xf9, 0x8a, 0xdd, 0x51, 0xd8, 0x6a,
	0x87, 0x0a, 0xc9, 0x7b, 0x90, 0x6f, 0xd9, 0x16, 0x46, 0x91, 0x34, 0xd4, 0x6d, 0xda, 0x70, 0x8a,
	0xa5, 0xeb, 0x89, 0x3b, 0xe9, 0x85, 0x71, 0x36, 0x45, 0x36, 0x79, 0xc9, 0x2a, 0x16, 0xc8, 0xb9,
	0x56, 0xf8, 0x91, 0x7c, 0x04, 0x57, 0x82, 0x0c, 0xb4, 0x4c, 0xa4, 0xab, 0x47, 0x0a, 0x5b, 0xcb,
	0x14, 0x65, 0x1d, 0x1a, 0x57, 0x29, 0xf9, 0xb2, 0x8f, 0x22, 0x23, 0xc6, 0xa6, 0x8f, 0x40, 0xaa,
	0xcc, 0x06, 0x35, 0x4d, 0xfe, 0xa4, 0x68, 0x0d, 0xd5, 0x71, 0xd0, 0xa2, 0xea, 0xca, 0xe5, 0xdb,
	0xd2, 0x66, 0xcb, 0x3e, 0x5a, 0x99, 0x61, 0x31, 0xab, 0xb3, 0x03, 0x40, 0x96, 0xa0, 0xd0, 0xb2,
	0xad, 0xc3, 0xa3, 0xf0, 0xac, 0x93, 0xce, 0x76, 0x00, 0x95, 0xf3, 0x48, 0x15, 0x4c, 0xb4, 0x45,
	0xc8, 0x61, 0x8c, 0x9b, 0x1f, 0x5e, 0xff, 0x7a, 0xcf, 0xa3, 0x48, 0x8c, 0x7a, 0xf3, 0x32, 0x00,
	0x64, 0x9f, 0x87, 0x9e, 0xc8, 0x3a, 0x14, 0xf0, 0x83, 0x5b, 0x61, 0x99, 0xf7, 0x46, 0xff, 0x32,
	0x6f, 0xcc, 0x23, 0xf6, 0xe4, 0xde, 0x32, 0xdc, 0xd8, 0x53, 0x1d, 0x65, 0xbb, 0xbd, 0xb3, 0x83,
	0x41, 0x9e, 0x6a, 0xa3, 0xa1, 0xb4, 0x6c, 0xaa, 0x51, 0x9d, 0x09, 0x7c, 0x11, 0x94, 0x77, 0x13,
	0xbb, 0xfb, 0xea, 0x9e, 0xea, 0x2c, 0x08, 0xbc, 0xf9, 0x46, 0x63, 0xd3, 0xc3, 0x12, 0x31, 0x7a,
	0x57, 0x01, 0x0c, 0x36, 0x56, 0x78, 0x10, 0x80, 0xe7, 0xbe, 0x29, 0x39, 0x6d, 0x38, 0xe2, 0xc0,
	0xc0, 0x0f, 0xd1, 0xe7, 0xc1, 0x6b, 0xd9, 0x42, 0x6e, 0x25, 0x99, 0xca, 0x17, 0xc6, 0x56, 0x92,
	0xa9, 0xc9, 0xc2, 0xd4, 0x4a, 0x32, 0x55, 0x2c, 0x5c, 0x96, 0x7e, 0x36, 0x06, 0xd9, 0xf0, 0xbb,
	0x93, 0xbb, 0x90, 0xb6, 0x6c, 0x63, 0xd7, 0x30, 0xbd, 0x4f, 0xf5, 0xe5, 0x16, 0xb2, 0x2f, 0x8e,
	0x4b, 0xa9, 0x0d, 0x04, 0x56, 0x17, 0xe5, 0x14, 0x2f, 0xae, 0xea, 0xac, 0x63, 0x04, 0xea, 0x85,
	0x5c, 0x0d, 0xc7, 0x38, 0x71, 0x10, 0xe2, 0xff, 0xbf, 0x63, 0x30, 0x1d, 0xbd, 0xd8, 0x49, 0x0d,
	0x26, 0x3a, 0x32, 0xc6, 0x29, 0xb8, 0xf8, 0xcf, 0xa3, 0x05, 0x8e, 0x87, 0xf3, 0xc6, 0x61, 0x2d,
	0x4c, 0x18, 0x47, 0x30, 0x55, 0x1c, 0xd7, 0x36, 0x34, 0x2f, 0x67, 0xe7, 0xa5, 0x13, 0x64, 0x35,
	0x2c, 0xc6, 0x16, 0xa9, 0x87, 0x27, 0x5a, 0x74, 0x9e, 0x2c, 0xe4, 0x4d, 0xf5, 0xb0, 0x93, 0xb5,
	0xf4, 0xb5, 0x04, 0x8c, 0x31, 0x63, 0xdc, 0x71, 0x0c, 0xcb, 0x14, 0xaf, 0x3e, 0x03, 0x29, 0x5f,
	0xe1, 0x89, 0xe1, 0x36, 0xe6, 0x3f, 0xb3, 0xfd, 0x4b, 0xb3, 0xa9, 0xea, 0xd2, 0xe0, 0xc3, 0xd6,
	0x09, 0x19, 0x38, 0x08, 0xb3, 0x65, 0xcc, 0xc3, 0x88, 0x63, 0xb5, 0x6d, 0xcd, 0xfb, 0xfe, 0xe4,
	0xdd, 0x1e, 0xd6, 0x7f, 0xa8, 0xc2, 0xd9, 0x1a, 0x12, 0xc8, 0x82, 0x90, 0x7c, 0x02, 0x63, 0xfc,
	0x17, 0xc6, 0x4f, 0xa0, 0x2c, 0xe0, 0x89, 0x40, 0xee, 0xf7, 0xcd, 0x6b, 0x55, 0x10, 0xca, 0x79,
	0xa7, 0xe3, 0x99, 0x7c, 0x04, 0xaf, 0x99, 0x96, 0xd2, 0xa4, 0x4d, 0x8b, 0x5b, 0x97, 0x98, 0x29,
	0x4f, 0x51, 0x5d, 0x45, 0x34, 0x9a, 0x87, 0xa6, 0x16, 0x4d, 0x6b, 0x0d, 0x51, 0x64, 0x81, 0x31,
	0xef, 0x72, 0xbe, 0xd2, 0x2c, 0x8c, 0xf0, 0x5f, 0x24, 0x0d, 0xc3, 0x1b, 0xf5, 0xe5, 0x8a, 0x5c,
	0x18, 0x22, 0x59, 0x48, 0x2d, 0xc9, 0x1b, 0x6b, 0x4a, 0xed, 0xf1, 0x6a, 0x21, 0x46, 0x32, 0x30,
	0x2a, 0x6f, 0x6c, 0xd4, 0x95, 0x47, 0x4f, 0x0a, 0x71, 0xe9, 0x36, 0xe4, 0x3b, 0x5b, 0x44, 0x00,
	0x46, 0xe4, 0xca, 0xda, 0x06, 0x7e, 0x9f, 0x31, 0x0d, 0xc3, 0xab, 0x1b, 0xe5, 0xf9, 0xd5, 0x42,
	0x4c, 0xfa, 0xc3, 0x18, 0x64, 0xf9, 0xf7, 0xaf, 0x85, 0x8f, 0xe9, 0x07, 0x5d, 0x4e, 0xa0, 0x97,
	0xa3, 0x0f, 0x90, 0x7b, 0x39, 0xe3, 0xa6, 0x84, 0x82, 0xe3, 0xa5, 0x56, 0x28, 0xf5, 0x3e, 0x36,
	0xc4, 0x1b, 0x36, 0x2f, 0x04, 0xc8, 0x23, 0x23, 0x35, 0x28, 0xa8, 0x5e, 0xdf, 0x7a, 0x89, 0x3c,
	0x7a, 0x07, 0x02, 0x75, 0x0d, 0x83, 0xb7, 0xe0, 0xd4, 0x4e, 0xf0, 0xfb, 0xc9, 0x6f, 0x7e, 0x5a,
	0x1a, 0x92, 0xfe, 0x7b, 0x12, 0x72, 0x0b, 0xe1, 0x4f, 0xab, 0x92, 0x6a, 0xd7, 0xcb, 0xde, 0x8e,
	0x34, 0xc0, 0x43, 0x14, 0xb3, 0xa7, 0x7c, 0x7a, 0x3d, 0x1d, 0x7c, 0xc7, 0xb5, 0x77, 0x62, 0xd7,
	0x8e, 0xeb, 0x45, 0xdf, 0xf5, 0xd7, 0x23, 0x9c, 0xf9, 0xad, 0x84, 0x6f, 0x05, 0xce, 0xc2, 0x30,
	0xcf, 0xc3, 0x13, 0x3b, 0x91, 0xc9, 0x0a, 0x95, 0x59, 0x66, 0xee, 0xb2, 0x72, 0x99, 0xa3, 0x31,
	0xab, 0xb1, 0x7e, 0x21, 0x47, 0xe8, 0x40, 0xef, 0x12, 0x36, 0x41, 0xa2, 0x7f, 0x9b, 0x40, 0x98,
	0x71, 0xc3, 0xdf, 0x67, 0x33, 0xee, 0xc7, 0x61, 0x4c, 0xb3, 0x1a, 0x0d, 0x9e, 0x9b, 0x8f, 0xeb,
	0x14, 0x27, 0xb3, 0x61, 0xf6, 0xd0, 0x82, 0x78, 0x0a, 0x6c, 0xaa, 0x87, 0x62, 0x8b, 0xf3, 0x3e,
	0x33, 0xae, 0x5b, 0x74, 0x65, 0x50, 0x18, 0xbd, 0x48, 0x06, 0x05, 0x9e, 0x92, 0x42, 0xcc, 0xbc,
	0x3f, 0x8a, 0x89, 0x50, 0x9a, 0x55, 0xcb, 0xda, 0x6f, 0xfb, 0x41, 0x0a, 0x0f, 0xc3, 0x9f, 0x04,
	0xf9, 0xfc, 0x67, 0xc7, 0xa5, 0xfb, 0xe7, 0xb3, 0x1b, 0xfd, 0x6f, 0x82, 0x44, 0x99, 0x66, 0xf1,
	0x97, 0x33, 0xcd, 0x6e, 0x40, 0xb6, 0x65, 0x53, 0xae, 0x14, 0x9a, 0xed, 0xa6, 0x88, 0xb0, 0xce,
	0x78, 0xb0, 0xf5, 0x76, 0x93, 0xdc, 0x65, 0xda, 0x8b, 0x40, 0xf1, 0xf6, 0x66, 0x91, 0x6a, 0xdc,
	0x83, 0x8b, 0x1d, 0x5a, 0xfa, 0xaf, 0x31, 0x98, 0xe8, 0xe8, 0x00, 0xb1, 0x00, 0x57, 0x20, 0xa3,
	0xfb, 0x66, 0x36, 0xff, 0x92, 0xff, 0x79, 0x9c, 0xe6, 0xc3, 0xc4, 0x44, 0x81, 0x69, 0xaf, 0x5a,
	0xfc, 0x54, 0x6a, 0xc0, 0x36, 0x7e, 0x4e, 0xb6, 0x53, 0x01, 0x9f, 0xc5, 0x50, 0x05, 0xfe, 0x8a,
	0x4c, 0xf4, 0xb5, 0x22, 0xa5, 0x9f, 0x4f, 0x42, 0x01, 0x2b, 0x58, 0xa2, 0x54, 0x1f, 0x88, 0x7c,
	0xf5, 0x32, 0x5f, 0xc4, 0xfb, 0x4f, 0x13, 0x73, 0x05, 0xd2, 0x18, 0xb1, 0x81, 0x39, 0x01, 0x78,
	0xce, 0xed, 0x14, 0x03, 0x2c, 0x1a, 0x3b, 0x3b, 0x91, 0xc2, 0x36, 0xf9, 0x92, 0xc2, 0x96, 0x29,
	0x56, 0x8e, 0x6b, 0x53, 0x15, 0x53, 0xa1, 0x61, 0x4a, 0x0f, 0xae, 0x58, 0xd5, 0x10, 0xc8, 0x14,
	0x2b, 0x5e, 0x5c, 0xd5, 0xd9, 0x24, 0xc3, 0x38, 0x39, 0x85, 0x43, 0x44, 0xa8, 0x55, 0x06, 0x61,
	0x1c, 0x9d, 0x19, 0xa6, 0xd8, 0x7e, 0x9e, 0x9a, 0xcb, 0x4b, 0x41, 0x9b, 0x92, 0x73, 0x0c, 0xba,
	0xe4, 0x01, 0x89, 0x2c, 0x02, 0x53, 0x9a, 0x4c, 0x5a, 0x33, 0xf5, 0xd2, 0xd7, 0xed, 0x98, 0x99,
	0x9d, 0xb8, 0x93, 0x5b, 0xb8, 0xfc, 0xe2, 0xb8, 0x34, 0xf5, 0xd4, 0x70, 0xf7, 0xd6, 0x04, 0x8a,
	0xa7, 0xe8, 0x39, 0x3c, 0x66, 0xa5, 0x0b, 0xac, 0xe3, 0x17, 0x58, 0xd9, 0x82, 0x6a, 0x37, 0xa9,
	0xcd, 0x5e, 0x25, 0x8d, 0xaf, 0x82, 0x39, 0x6b, 0xca, 0x02, 0x8c, 0xa9, 0xd9, 0xbc, 0xdf, 0x3a,
	0x79, 0x13, 0x08, 0x36, 0x62, 0xbb, 0xdd, 0xd8, 0x57, 0x74, 0xda, 0x30, 0x0e, 0xa8, 0x7d, 0x84,
	0x57, 0xf3, 0x29, 0xb9, 0xc0, 0x4a, 0x16, 0xda, 0x8d, 0xfd, 0x45, 0x01, 0x97, 0x7e, 0x33, 0x06,
	0x79, 0x7f, 0x7a, 0x60, 0xf6, 0xa9, 0x81, 0x7d, 0x23, 0xe8, 0x42, 0x69, 0x62, 0xfd, 0xec, 0x94,
	0x9c, 0x34, 0xd1, 0x17, 0x29, 0x66, 0xa7, 0x44, 0x80, 0xb4, 0x29, 0x96, 0x38, 0x7b, 0x1d, 0xf6,
	0xa2, 0x98, 0x99, 0xce, 0x21, 0x3f, 0x06, 0x23, 0x14, 0x7f, 0x89, 0xd5, 0x7d, 0xa3, 0xd7, 0x32,
	0x64, 0x74, 0x48, 0x23, 0x0b, 0x02, 0xe9, 0xe7, 0x63, 0x21, 0x96, 0xe5, 0x20, 0x4b, 0xe0, 0x05,
	0xb2, 0x25, 0xbd, 0x8a, 0x18, 0xab, 0xa5, 0xd0, 0xf8, 0xe1, 0xc2, 0x67, 0xfd, 0xde, 0xd7, 0x9e,
	0xed, 0xf5, 0x3b, 0x97, 0x13, 0xdf, 0x8e, 0x85, 0xe4, 0x84, 0x38, 0x0d, 0xf7, 0x73, 0xc9, 0xc4,
	0x42, 0xb9, 0x64, 0x2e, 0xb0, 0xfc, 0xab, 0x90, 0xe2, 0x96, 0xa1, 0x1f, 0x6d, 0x7c, 0xc6, 0x4b,
	0x8f, 0x89, 0x97, 0x1e, 0x45, 0x63, 0xa9, 0x5e, 0x93, 0x47, 0x91, 0xbe, 0xee, 0x48, 0x7f, 0x3e,
	0x06, 0x93, 0x7e, 0x33, 0x43, 0xde, 0x3a, 0x17, 0x19, 0x8e, 0x97, 0x8f, 0xda, 0x92, 0x7e, 0x3b,
	0x26, 0x02, 0x5f, 0x59, 0x73, 0xd6, 0xa8, 0xab, 0x76, 0x74, 0xd1, 0x39, 0xda, 0x72, 0x0f, 0xc6,
	0xf1, 0x80, 0xbc, 0xa9, 0x9a, 0x6d, 0xb5, 0x21, 0xfc, 0x69, 0x44, 0x52, 0x27, 0x56, 0xb0, 0x86,
	0x70, 0xee, 0x2b, 0xf3, 0x13, 0x50, 0x68, 0xa9, 0x98, 0x65, 0x34, 0xf8, 0x76, 0x54, 0xe2, 0x25,
	0x56, 0x6b, 0x9e, 0x73, 0xab, 0x89, 0xcf, 0x34, 0x49, 0xdf, 0x4b, 0x84, 0xe7, 0x14, 0xa6, 0x76,
	0x7c, 0x07, 0x12, 0x07, 0x6a, 0xe3, 0xb4, 0x90, 0xac, 0x0e, 0x19, 0x22, 0x33, 0x6c, 0xb2, 0xd4,
	0x91, 0x67, 0x33, 0xde, 0xfb, 0xca, 0xfd, 0xe4, 0xea, 0xea, 0xc8, 0xc7, 0xf9, 0x6e, 0xe7, 0x96,
	0x77, 0xfa, 0xda, 0x0d, 0x6b, 0xa3, 0x1f, 0xf1, 0x54, 0x60, 0xbd, 0xe3, 0xa1, 0xba, 0x27, 0x7c,
	0x57, 0xbe, 0xb0, 0xee, 0xa0, 0xa6, 0xe1, 0xde, 0x77, 0x94, 0x11, 0x53, 0xb2, 0xd3, 0x6d, 0xec,
	0x4b, 0x90, 0x6a, 0x8a, 0xf9, 0x71, 0x4a, 0xe2, 0xfe, 0x13, 0x73, 0x49, 0xf6, 0xa9, 0xc8, 0x43,
	0xc8, 0xa0, 0x4c, 0x17, 0x82, 0x6c, 0xf4, 0xec, 0xfe, 0x0c, 0x04, 0xa0, 0x0c, 0xdb, 0xfe, 0xef,
	0xf7, 0x93, 0xdf, 0xf9, 0xb4, 0x14, 0x93, 0xfe, 0x20, 0x06, 0xe3, 0x6b, 0xed, 0xc3, 0xae, 0x81,
	0x9e, 0x87, 0x61, 0xe4, 0xdf, 0xcf, 0x50, 0x23, 0x45, 0x48, 0x41, 0xe0, 0x94, 0x1d, 0x17, 0x13,
	0xfc, 0x83, 0xb5, 0x83, 0xbd, 0x98, 0xe8, 0xd8, 0xda, 0x13, 0xa7, 0x6d, 0xed, 0xd2, 0x87, 0x40,
	0x98, 0x15, 0xeb, 0x3e, 0x6e, 0x5b, 0x76, 0x90, 0x92, 0xf6, 0x56, 0xa8, 0x81, 0x68, 0xe3, 0x2f,
	0x64, 0x42, 0x0d, 0xf4, 0x2b, 0x92, 0xa6, 0x60, 0xa2, 0x83, 0x9a, 0xab, 0x8b, 0xd2, 0xbb, 0x70,
	0xf9, 0xa1, 0xe5, 0x38, 0x46, 0xab, 0xd6, 0xde, 0xe6, 0x7a, 0x19, 0xb3, 0x44, 0x04, 0xef, 0x19,
	0x48, 0xb5, 0xf0, 0x06, 0xdf, 0xe4, 0x5b, 0x4d, 0x5a, 0xf6, 0x9f, 0xa5, 0x7f, 0x1a, 0x83, 0x4b,
	0x27, 0x29, 0x79, 0xbf, 0x87, 0x52, 0x14, 0xa6, 0xf9, 0xf6, 0xf9, 0x1e, 0x8c, 0xf2, 0x2f, 0x81,
	0xb8, 0x7d, 0x6e, 0xa0, 0x1e, 0x3a, 0xb9, 0x0d, 0x63, 0xa2, 0x4e, 0xae, 0x89, 0x88, 0x0f, 0x43,
	0xa5, 0xd9, 0x42, 0x47, 0xf0, 0x1a, 0x87, 0x06, 0xba, 0x64, 0xb2, 0x3f, 0x5d, 0x52, 0x83, 0xa9,
	0x3a, 0x35, 0x55, 0xd3, 0xad, 0x51, 0xd7, 0x35, 0xcc, 0x5d, 0x3f, 0xd2, 0x7f, 0x05, 0xd2, 0x2e,
	0x16, 0x78, 0x5d, 0x9a, 0x79, 0x70, 0x25, 0xca, 0x72, 0x43, 0x9c, 0xea, 0x62, 0x90, 0x03, 0xd0,
	0x83, 0xc8, 0x29, 0x4e, 0x5f, 0xd5, 0xa5, 0x6f, 0x8d, 0xc0, 0x44, 0x67, 0x2d, 0xbc, 0x87, 0x36,
	0x00, 0x70, 0x7e, 0xf1, 0xef, 0x96, 0x0d, 0x9f, 0xf8, 0x18, 0x4e, 0x67, 0x25, 0x1d, 0xb4, 0xb3,
	0xf8, 0x17, 0x4d, 0x8c, 0x34, 0xf5, 0x7e, 0x92, 0x0f, 0x3b, 0xdf, 0x3e, 0x6c, 0x28, 0x23, 0xdc,
	0x41, 0xcf, 0x47, 0xcd, 0xd2, 0x85, 0x54, 0xe9, 0xd8, 0x2f, 0xc9, 0x63, 0xd4, 0x53, 0x34, 0xaa,
	0x53, 0x53, 0xf3, 0x3e, 0x4b, 0x7c, 0xbf, 0xcf, 0xe6, 0x6c, 0xfa, 0x84, 0x72, 0x88, 0x09, 0xb9,
	0x0e, 0x19, 0xdf, 0xe1, 0x55, 0x6d, 0x08, 0xe9, 0x1f, 0x06, 0x31, 0xfb, 0xde, 0x3a, 0xa0, 0xb6,
	0x6d, 0xe8, 0xd4, 0xcb, 0xa9, 0x77, 0xfd, 0xac, 0x3a, 0xbd, 0x4d, 0xcb, 0x27, 0x24, 0x1b, 0x90,
	0x34, 0xd5, 0x26, 0x77, 0x83, 0x4d, 0x2f, 0x7c, 0xf0, 0xd9, 0x71, 0xe9, 0xdd, 0x73, 0xad, 0x48,
	0xce, 0x7e, 0x5d, 0x6d, 0x52, 0x19, 0x19, 0x91, 0x6d, 0xc8, 0x6a, 0x6a, 0x4b, 0xdd, 0x36, 0x1a,
	0x86, 0x6b, 0x50, 0x4f, 0x34, 0x7d, 0x14, 0x6a, 0x59, 0xb3, 0xdd, 0x70, 0x0d, 0x3e, 0xc4, 0xb3,
	0xfc, 0xbf, 0x30, 0x81, 0xcf, 0xb3, 0x1c, 0x02, 0xca, 0x1d, 0x3c, 0xc9, 0x55, 0x00, 0x9e, 0x5e,
	0xd4, 0x55, 0x5d, 0x8a, 0x97, 0x56, 0x39, 0x19, 0x33, 0x92, 0xe2, 0x17, 0x6a, 0x98, 0x12, 0xef,
	0x50, 0xfb, 0xc0, 0xd0, 0xa8, 0x82, 0x09, 0xa1, 0xd3, 0x88, 0x90, 0x11, 0xb0, 0x35, 0x4b, 0x67,
	0x12, 0xf8, 0x4a, 0xb9, 0xd1, 0x76, 0x5c, 0x6a, 0x57, 0x4d, 0xc3, 0x7d, 0x68, 0xab, 0x1a, 0xdd,
	0xa4, 0xb6, 0x61, 0xe9, 0x15, 0x53, 0xaf, 0xd7, 0x44, 0xa2, 0xd9, 0xd3, 0x50, 0xa4, 0x07, 0x90,
	0xf6, 0x67, 0x12, 0x19, 0x87, 0x5c, 0xad, 0x52, 0xaf, 0x57, 0xd7, 0x1f, 0x2a, 0x95, 0x27, 0x95,
	0xf5, 0x7a, 0x61, 0x88, 0x10, 0xc8, 0xaf, 0x55, 0xea, 0xf3, 0x8b, 0xf3, 0xf5, 0x79, 0x01, 0x8b,
	0x49, 0x35, 0x80, 0x60, 0xb8, 0x49, 0x06, 0x46, 0xab, 0xeb, 0x4f, 0xe6, 0x57, 0xab, 0x8b, 0x85,
	0x21, 0x72, 0x15, 0x2e, 0xd7, 0x2b, 0xeb, 0xf3, 0xeb, 0x75, 0xa5, 0xb6, 0x59, 0x29, 0x57, 0x97,
	0xaa, 0x65, 0x65, 0xe3, 0x49, 0x45, 0x96, 0xab, 0x8b, 0x95, 0x5a, 0x21, 0x46, 0x2e, 0xc3, 0xd4,
	0xfc, 0xea, 0xaa, 0xc2, 0x51, 0x6a, 0xa1, 0xa2, 0xb8, 0xf4, 0xcb, 0x31, 0xc8, 0x75, 0x0c, 0x32,
	0xf9, 0x49, 0xc8, 0xfa, 0x1f, 0x4f, 0xf6, 0x05, 0xc9, 0x39, 0x2e, 0x6b, 0x1d, 0x31, 0x41, 0x67,
	0xab, 0x82, 0x0b, 0x53, 0x0c, 0x32, 0x46, 0xf0, 0xc0, 0x96, 0x4b, 0x58, 0x9d, 0x0f, 0xcf, 0x3b,
	0x9f, 0x58, 0x2c, 0x97, 0x88, 0xaf, 0x3f, 0xfc, 0xdb, 0x61, 0x18, 0x17, 0x63, 0x8c, 0xa6, 0x0a,
	0x4f, 0xf8, 0x3b, 0x06, 0x09, 0x5b, 0x69, 0x63, 0x63, 0x63, 0x72, 0xdc, 0xde, 0x22, 0xd7, 0x60,
	0x64, 0xff, 0x40, 0x61, 0xb0, 0x14, 0xde, 0x36, 0xa7, 0x5e, 0x1c, 0x97, 0x92, 0x8f, 0x9e, 0xc8,
	0x5b, 0x72, 0x72, 0xff, 0x40, 0xde, 0x62, 0xc3, 0x8c, 0x67, 0x0c, 0xdb, 0x28, 0xc1, 0x1c, 0xbc,
	0x91, 0x4b, 0xf2, 0x84, 0x24, 0x0b, 0x1c, 0x44, 0x5e, 0x87, 0x1c, 0xa2, 0x84, 0xce, 0x00, 0x31,
	0xf6, 0x9b, 0x01, 0x65, 0xef, 0x80, 0xef, 0x2a, 0x00, 0xe7, 0xe3, 0x27, 0x6e, 0x4b, 0xca, 0x69,
	0xe4, 0x82, 0xd7, 0x9a, 0xaf, 0x7b, 0x57, 0x19, 0x5e, 0x3d, 0x59, 0xce, 0x03, 0x81, 0x5e, 0x45,
	0xcc, 0x28, 0x44, 0x24, 0xbf, 0x26, 0x9e, 0x10, 0x8c, 0x93, 0xfa, 0x55, 0x95, 0x20, 0x23, 0x78,
	0xf9, 0xe9, 0x25, 0x93, 0x32, 0x70, 0x4e, 0x58, 0xd9, 0x12, 0x4c, 0x3a, 0xcf, 0x1a, 0x4a, 0xcb,
	0xd2, 0x1d, 0xbc, 0xa5, 0xe2, 0xd9, 0x3b, 0x1c, 0x5c, 0x9e, 0xb1, 0x85, 0xa9, 0x17, 0xc7, 0xa5,
	0xf1, 0xda, 0xe3, 0xd5, 0x4d, 0x4b, 0x77, 0xca, 0x9b, 0x5b, 0x3c, 0x5d, 0x87, 0x23, 0x8f, 0x3b,
	0xcf, 0x1a, 0x08, 0x6a, 0xb5, 0x05, 0x88, 0x54, 0x60, 0xa2, 0xb5, 0xfb, 0xdc, 0xb0, 0xa9, 0x42,
	0x77, 0x6d, 0xea, 0x38, 0xa2, 0xc2, 0x51, 0x9e, 0x41, 0x80, 0xb1, 0xd9, 0x7c, 0xf8, 0xd4, 0xb0,
	0x69, 0x05, 0x4b, 0xb1, 0x6e, 0x79, 0x9c, 0x53, 0x84, 0x40, 0x64, 0x0b, 0x2e, 0xfb, 0x3e, 0x34,
	0x86, 0xa5, 0x18, 0x66, 0x98, 0x59, 0x1a, 0x99, 0x61, 0x36, 0x63, 0xcf, 0x35, 0xa6, 0xba, 0x51,
	0x35, 0x43, 0x1c, 0xa7, 0x3d, 0xe2, 0xaa, 0x15, 0x86, 0x33, 0xdb, 0x38, 0xcc, 0xb6, 0xa3, 0x89,
	0x98, 0x57, 0x95, 0xdb, 0xc6, 0x01, 0xd7, 0x70, 0x33, 0xa7, 0x02, 0xa6, 0xe1, 0xa6, 0xfe, 0x28,
	0x14, 0x35, 0xdb, 0x72, 0x1c, 0xc5, 0xa6, 0xbb, 0x86, 0x65, 0x2a, 0x26, 0x75, 0x9f, 0x5b, 0xf6,
	0x3e, 0xce, 0x9f, 0x1c, 0xce, 0xa9, 0x49, 0x2c, 0x97, 0xb1, 0x78, 0x9d, 0x97, 0xca, 0x5b, 0xe4,
	0x11, 0x4c, 0x51, 0xc7, 0xc5, 0x8c, 0x6d, 0x7a, 0x47, 0x97, 0xe7, 0xb1, 0xcb, 0x2f, 0xbd, 0x38,
	0x2e, 0x4d, 0x54, 0x3c, 0x84, 0x50, 0xa7, 0x4f, 0xf8, 0x54, 0x41, 0xb7, 0x4b, 0x5f, 0x8b, 0xc1,
	0xf4, 0x89, 0x99, 0x2d, 0xab, 0xac, 0x7d, 0x77, 0xa0, 0x10, 0x9a, 0x46, 0x0a, 0xfa, 0x84, 0xf1,
	0xb9, 0x9e, 0x0f, 0x66, 0x12, 0x43, 0x25, 0x0b, 0x40, 0x3a, 0x5b, 0x84, 0xb8, 0x71, 0x6c, 0x0e,
	0x66, 0x4f, 0x0c, 0x37, 0x87, 0x51, 0xc8, 0x85, 0x70, 0x5b, 0x18, 0x44, 0xfa, 0xb5, 0x24, 0x90,
	0xba, 0xb5, 0x4f, 0xcd, 0x85, 0xb6, 0xb6, 0xef, 0x67, 0x2a, 0x20, 0x16, 0x5c, 0xd3, 0x82, 0x86,
	0x29, 0x8e, 0x61, 0x6a, 0x54, 0x69, 0xa8, 0x8e, 0xeb, 0xcd, 0x5b, 0xb1, 0x61, 0xbf, 0xd1, 0x73,
	0x23, 0x09, 0xbd, 0x97, 0x58, 0xd4, 0x57, 0x42, 0x1c, 0x6b, 0x8c, 0xe1, 0xaa, 0xea, 0xf8, 0x15,
	0xca, 0x40, 0xc2, 0x15, 0xb6, 0x50, 0x80, 0x8a, 0xe8, 0x82, 0xbe, 0xee, 0xf0, 0xc6, 0x43, 0xe4,
	0x5c, 0xfc, 0x32, 0x9d, 0x2f, 0x50, 0x30, 0xf8, 0xf7, 0x58, 0xb2, 0xd1, 0xfa, 0x03, 0x99, 0x63,
	0xbb, 0xa8, 0xe3, 0xaa, 0xec, 0x35, 0x85, 0x82, 0x98, 0xe3, 0x07, 0x26, 0x55, 0x01, 0xae, 0x2e,
	0xca, 0xe0, 0xa1, 0x54, 0x75, 0x52, 0x85, 0x29, 0x93, 0x1e, 0xba, 0x4a, 0xc3, 0x40, 0xbf, 0xea,
	0x80, 0x14, 0x37, 0x99, 0x85, 0xe9, 0x17, 0xc7, 0x25, 0xb2, 0x4e, 0x0f, 0xdd, 0x55, 0xe3, 0x80,
	0x86, 0x58, 0x10, 0xb3, 0x1b, 0xa6, 0x33, 0x91, 0xe0, 0x33, 0xe0, 0x7e, 0xcb, 0x98, 0xd3, 0x51,
	0xce, 0x79, 0x50, 0xee, 0x8d, 0x7c, 0x09, 0x46, 0x1d, 0xfa, 0x0c, 0x4f, 0x34, 0x47, 0x71, 0xd7,
	0x19, 0x71, 0xf0, 0x03, 0x48, 0x98, 0xd9, 0x97, 0xf7, 0x22, 0xd5, 0x15, 0x97, 0x8d, 0xa5, 0x23,
	0x52, 0x06, 0x8d, 0xf9, 0x70, 0x1c, 0x62, 0x87, 0x3c, 0x85, 0x29, 0xe1, 0x9c, 0xe1, 0x79, 0x73,
	0x88, 0x8e, 0x1e, 0xe9, 0xbf, 0xa3, 0x27, 0x38, 0x07, 0x31, 0x70, 0xbc, 0xab, 0xa5, 0xdf, 0x8c,
	0xc3, 0x44, 0xc7, 0x34, 0x12, 0xa7, 0xa4, 0x1f, 0x76, 0x1e, 0x2b, 0x9c, 0x53, 0x5d, 0xba, 0x09,
	0xf9, 0x5d, 0x5b, 0x35, 0x43, 0xef, 0x85, 0x93, 0x5b, 0xce, 0x09, 0xa8, 0x78, 0xab, 0x75, 0x28,
	0xb8, 0xb6, 0xa1, 0xed, 0x37, 0xa8, 0xa2, 0x8b, 0xf6, 0x0a, 0xab, 0xaf, 0xbf, 0xdb, 0x5f, 0x41,
	0xec, 0x15, 0x31, 0x41, 0xbe, 0xa3, 0x36, 0x1a, 0xdb, 0xaa, 0xb6, 0xcf, 0x97, 0x14, 0x3a, 0x31,
	0xc9, 0x59, 0x0f, 0x88, 0x8b, 0xef, 0x2b, 0x10, 0x9e, 0x71, 0x88, 0xe7, 0x08, 0x5b, 0xef, 0x6e,
	0x3f, 0x8b, 0x02, 0x17, 0xbb, 0x78, 0xdd, 0x82, 0xd6, 0x05, 0x97, 0xea, 0x30, 0xb6, 0x62, 0x19,
	0xe6, 0xba, 0xa5, 0xfb, 0x29, 0x54, 0xe6, 0x21, 0xbf, 0x6d, 0x98, 0xaa, 0x7d, 0xa4, 0x78, 0x39,
	0x8d, 0x62, 0x67, 0xe5, 0x34, 0x92, 0x73, 0x9c, 0x42, 0x3c, 0x4a, 0xdf, 0x8d, 0x41, 0x21, 0x60,
	0x2b, 0x86, 0xe8, 0x4d, 0x00, 0x8d, 0xab, 0x2f, 0x9e, 0x1e, 0x9e, 0xe5, 0xd9, 0x1e, 0x3d, 0xa5,
	0x66, 0x51, 0x4e, 0x0b, 0x84, 0xaa, 0x4e, 0x5e, 0x87, 0x51, 0xcf, 0xb1, 0x85, 0x9b, 0x69, 0xf0,
	0xe2, 0xb8, 0x34, 0x22, 0x5c, 0x53, 0x46, 0x4c, 0xee, 0x93, 0x72, 0x0b, 0x52, 0x8e, 0x6b, 0xd9,
	0xfe, 0x52, 0x12, 0xb6, 0x92, 0xf7, 0x89, 0x91, 0x51, 0x2c, 0xac, 0xea, 0xec, 0x95, 0x54, 0xcd,
	0x65, 0x2b, 0xc8, 0x7b, 0xa5, 0xe4, 0xd9, 0xaf, 0xc4, 0x29, 0xbc, 0x57, 0x32, 0x61, 0xe6, 0x21,
	0x75, 0xbb, 0x0e, 0xc3, 0x7d, 0x13, 0xe3, 0x02, 0x67, 0x2a, 0x57, 0x01, 0xb8, 0xe0, 0x45, 0xa7,
	0x24, 0x7e, 0x5d, 0x9b, 0x46, 0x08, 0x26, 0xc0, 0x76, 0xe1, 0x4a, 0x64, 0x7d, 0xa2, 0x33, 0xb7,
	0x60, 0x3c, 0xc8, 0xa4, 0x73, 0xd1, 0xbb, 0x81, 0x82, 0xdd, 0xc5, 0x5e, 0xfa, 0xe9, 0x38, 0x8c,
	0x95, 0xb9, 0xa1, 0xe6, 0x1b, 0x7f, 0x83, 0x3a, 0x71, 0x5d, 0x84, 0x94, 0x7b, 0x68, 0x2a, 0x4d,
	0xea, 0xaa, 0xe7, 0xff, 0x0e, 0xdd, 0xa8, 0xcb, 0x1f, 0xc9, 0x17, 0x21, 0x75, 0x91, 0xb5, 0xe7,
	0x13, 0x91, 0xcb, 0x90, 0x32, 0x1c, 0xa5, 0xc1, 0x3a, 0x5a, 0x5c, 0xc5, 0x8c, 0x1a, 0xce, 0x2a,
	0x7b, 0x14, 0x37, 0x51, 0xff, 0x2b, 0x0d, 0xe9, 0x9a, 0x86, 0x89, 0x69, 0x5d, 0x87, 0xcc, 0xc2,
	0x84, 0xd9, 0x6e, 0xa2, 0x3f, 0xbf, 0xbd, 0xa3, 0x6a, 0x54, 0x71, 0x28, 0xdd, 0x77, 0x44, 0xb6,
	0xfe, 0x71, 0xb3, 0xdd, 0xac, 0x7a, 0x25, 0x35, 0x56, 0x40, 0xde, 0x04, 0xe2, 0xe3, 0xa3, 0xa3,
	0x2f, 0xa2, 0x73, 0x2d, 0xaf, 0xe0, 0xa1, 0x9b, 0x6a, 0x83, 0x63, 0x9f, 0xe4, 0xee, 0xd2, 0x96,
	0xa7, 0xf2, 0x75, 0x72, 0x67, 0x05, 0x27, 0xb9, 0x23, 0x7a, 0xf2, 0x24, 0x77, 0xc4, 0x2e, 0x41,
	0x66, 0x1b, 0x5d, 0x55, 0x3a, 0x94, 0x3b, 0x04, 0x71, 0x15, 0x65, 0x0e, 0x26, 0x43, 0x08, 0x8a,
	0x61, 0x2a, 0x9a, 0xaa, 0xed, 0x71, 0xdb, 0x2b, 0x29, 0x8f, 0x07, 0x98, 0x55, 0xb3, 0xcc, 0x0a,
	0xc8, 0x15, 0x48, 0xef, 0xd3, 0xa3, 0xb0, 0xee, 0x26, 0xa7, 0xf6, 0xe9, 0x11, 0xe7, 0x56, 0x82,
	0x0c, 0xff, 0xb8, 0x04, 0x2f, 0x4e, 0xf1, 0xea, 0x10, 0xe4, 0x23, 0xe0, 0x99, 0x19, 0xff, 0xa6,
	0x02, 0x57, 0xd7, 0x64, 0x40, 0x10, 0x7e, 0x10, 0x81, 0xac, 0x80, 0x84, 0x4f, 0x8e, 0xe2, 0x7d,
	0xaf, 0x79, 0xdb, 0x73, 0xfc, 0x71, 0xad, 0xe6, 0xb6, 0xe3, 0x5a, 0xa6, 0xa7, 0x90, 0xc9, 0xd7,
	0x38, 0x66, 0x99, 0x23, 0x2e, 0x70, 0x57, 0x9f, 0xba, 0x8f, 0x45, 0x6e, 0xc1, 0x18, 0xa7, 0x64,
	0x0d, 0xe6, 0x15, 0x72, 0x7d, 0x3c, 0x67, 0x8b, 0xaf, 0xfa, 0xf3, 0x3a, 0x3f, 0x80, 0x99, 0x30,
	0x9e, 0xe9, 0xaa, 0x86, 0x49, 0x75, 0x85, 0x73, 0x17, 0xaa, 0xf5, 0xa5, 0x80, 0x44, 0x94, 0x6f,
	0x62, 0x31, 0x79, 0x17, 0x8a, 0x01, 0xb1, 0xb3, 0x6f, 0xb4, 0x5a, 0x01, 0x69, 0x0e, 0x49, 0xa7,
	0x3c, 0xd2, 0x1a, 0x2f, 0x15, 0x84, 0x0f, 0x60, 0xca, 0xa1, 0x2d, 0xd5, 0x46, 0x95, 0x2a, 0xdc,
	0x29, 0x79, 0xa4, 0x9a, 0xf0, 0x0b, 0x37, 0x83, 0xde, 0xf9, 0x02, 0x5c, 0xe9, 0xa6, 0x09, 0xf7,
	0xf7, 0x18, 0x52, 0x16, 0x3b, 0x29, 0x9f, 0x04, 0xbd, 0xbf, 0x0a, 0xaf, 0x9f, 0x42, 0xae, 0x88,
	0xdb, 0x3c, 0x74, 0x3c, 0x4c, 0xca, 0xa5, 0x5e, 0x6c, 0x96, 0x38, 0x5a, 0x6f, 0x6e, 0xf8, 0x1a,
	0x3e, 0xb7, 0x4b, 0x3d, 0xb9, 0xe1, 0x3b, 0x79, 0xdc, 0x9e, 0xc2, 0xdd, 0x68, 0x6e, 0x36, 0x5e,
	0x98, 0xf1, 0x69, 0x89, 0x5f, 0x23, 0xa6, 0x0e, 0xc6, 0x1c, 0x25, 0xe5, 0x37, 0x22, 0x78, 0xca,
	0x88, 0x8d, 0x53, 0x75, 0x0d, 0x71, 0x49, 0x0d, 0x26, 0xf8, 0x0c, 0x47, 0x83, 0xca, 0x97, 0x1c,
	0x93, 0xe7, 0xd0, 0xf7, 0x90, 0x9e, 0x71, 0x5e, 0x0c, 0x89, 0x10, 0xb6, 0x0a, 0x77, 0xa9, 0xeb,
	0xa0, 0x07, 0x64, 0x52, 0x1e, 0x35, 0xdb, 0xcd, 0x87, 0xd4, 0x75, 0xd8, 0x02, 0x61, 0x45, 0x8e,
	0xa6, 0x9a, 0x0e, 0xfa, 0xd8, 0x26, 0x65, 0x86, 0xcb, 0xe4, 0x89, 0x43, 0xee, 0x01, 0x5b, 0xd2,
	0x4a, 0x38, 0xd6, 0xcb, 0x41, 0x77, 0xde, 0xa4, 0x3c, 0x66, 0xb6, 0x9b, 0xa1, 0xe0, 0x2e, 0x87,
	0x7c, 0x12, 0xec, 0x7f, 0x53, 0xb8, 0xb3, 0xcd, 0x07, 0xfb, 0xdf, 0x45, 0x3d, 0x3a, 0xbd, 0x6d,
	0x73, 0x1a, 0x46, 0xb8, 0x4d, 0x82, 0x9e, 0x96, 0x69, 0x59, 0x3c, 0x09, 0xf9, 0x47, 0xa0, 0xb0,
	0xe5, 0x50, 0x9d, 0xe7, 0x6d, 0xa7, 0x36, 0x7b, 0xf3, 0x7b, 0x35, 0x98, 0x88, 0xb8, 0x12, 0x27,
	0x79, 0x80, 0xf2, 0xc6, 0x7a, 0xad, 0x5a, 0xab, 0xf3, 0x23, 0x86, 0x49, 0x28, 0xc8, 0x95, 0xf9,
	0x45, 0x65, 0x6b, 0xbd, 0xbc, 0xb1, 0xb6, 0x56, 0xad, 0xd7, 0x2b, 0x8b, 0x85, 0x18, 0x29, 0x40,
	0xb6, 0xba, 0x1e, 0xc2, 0x8b, 0xcf, 0x24, 0xbf, 0xfe, 0x37, 0xae, 0x0d, 0xdd, 0x7b, 0x0b, 0x72,
	0x1d, 0x1e, 0xcb, 0x64, 0x0c, 0x32, 0xab, 0x95, 0xf9, 0x5a, 0x65, 0x79, 0x63, 0x75, 0x11, 0xdd,
	0x77, 0x32, 0x30, 0xba, 0x5e, 0x99, 0x97, 0x2b, 0xb5, 0x7a, 0x21, 0x76, 0xef, 0xe7, 0x62, 0x90,
	0xe5, 0xee, 0x8d, 0x32, 0x55, 0x1d, 0xcb, 0x24, 0x04, 0xf2, 0x72, 0xa5, 0xb6, 0xb5, 0x56, 0x51,
	0xb6, 0xd6, 0x1f, 0xad, 0x6f, 0x3c, 0x5d, 0xf7, 0x5a, 0x80, 0xb0, 0x47, 0x95, 0x8f, 0x95, 0xd5,
	0xea, 0x5a, 0xb5, 0x5e, 0x88, 0x91, 0x29, 0x18, 0x17, 0xd0, 0x85, 0x8f, 0xeb, 0x15, 0x01, 0x8e,
	0x93, 0x4b, 0x30, 0x21, 0xc0, 0xd5, 0x75, 0xd6, 0x32, 0x51, 0x90, 0x20, 0xaf, 0x41, 0x51, 0x14,
	0x54, 0x56, 0xe7, 0x6b, 0xf5, 0x6a, 0x59, 0x29, 0x6f, 0x6e, 0x89, 0xd2, 0x61, 0xde, 0x7a, 0x29,
	0x99, 0x4a, 0x16, 0x92, 0xf7, 0xd6, 0x01, 0x6a, 0xdc, 0x47, 0xb7, 0xa9, 0xba, 0xac, 0x3f, 0x58,
	0xb5, 0x4f, 0xe6, 0x57, 0xb7, 0x2a, 0x35, 0x7e, 0xe4, 0xb2, 0x30, 0x5f, 0x2f, 0x2f, 0x2b, 0x72,
	0xa5, 0xb6, 0xb9, 0xb1, 0x5e, 0xab, 0x14, 0x62, 0x64, 0x1a, 0x48, 0x79, 0x63, 0x55, 0xe9, 0x82,
	0x7b, 0x7d, 0xb2, 0x08, 0xd9, 0xf0, 0x37, 0xc1, 0xc8, 0x04, 0x8c, 0x95, 0x97, 0x2b, 0xe5, 0x47,
	0xca, 0x93, 0xea, 0xbc, 0xf2, 0x78, 0xab, 0xb2, 0x55, 0x29, 0x0c, 0x61, 0xb7, 0x23, 0x70, 0x69,
	0x6b, 0x75, 0xb5, 0x10, 0x63, 0xfd, 0xc6, 0x9f, 0x6b, 0xf5, 0xf9, 0x7a, 0xad, 0x10, 0xbf, 0xb7,
	0x06, 0x19, 0x11, 0x45, 0x8a, 0xc3, 0x44, 0x20, 0xbf, 0xb9, 0x55, 0x5b, 0x56, 0xea, 0xd5, 0xb5,
	0x4a, 0xad, 0x3e, 0xbf, 0xb6, 0xc9, 0x79, 0x20, 0x6c, 0x7e, 0x61, 0x43, 0x66, 0x5d, 0xe4, 0x3d,
	0xd7, 0x37, 0xb6, 0xca, 0xcb, 0x5e, 0x73, 0xa4, 0x64, 0x2a, 0x51, 0x48, 0xdc, 0xbb, 0x01, 0xa1,
	0xaf, 0x38, 0x11, 0x80, 0x91, 0x55, 0xa6, 0x3b, 0xba, 0x85, 0x21, 0x32, 0x0a, 0x89, 0xf9, 0x46,
	0xa3, 0x10, 0x7b, 0xf0, 0xcb, 0x31, 0x18, 0x7d, 0xf4, 0x04, 0x4d, 0x46, 0xb2, 0x0a, 0xc3, 0xfc,
	0x47, 0xa9, 0xb7, 0xaf, 0x10, 0xaa, 0x4d, 0x33, 0xd7, 0xcf, 0x72, 0x26, 0x92, 0x86, 0xc8, 0x13,
	0xc8, 0x20, 0x48, 0x5c, 0x76, 0x0f, 0x82, 0xe7, 0x9d, 0xd8, 0xdb, 0xb1, 0x07, 0xbf, 0x9e, 0x08,
	0x4e, 0xa9, 0xf0, 0x18, 0x8e, 0xec, 0x40, 0xbe, 0xf3, 0x3c, 0x94, 0xdc, 0x39, 0xf3, 0xc8, 0xd4,
	0xab, 0xf5, 0x56, 0x7f, 0x87, 0xab, 0xd2, 0xd0, 0xdb, 0x31, 0x62, 0x03, 0x39, 0x79, 0xd0, 0x4e,
	0xa2, 0xb2, 0x39, 0xf5, 0x3c, 0xc9, 0x9f, 0xb9, 0xd7, 0x17, 0x76, 0x50, 0xe7, 0x4f, 0x40, 0x26,
	0xe4, 0x5c, 0x42, 0x7a, 0xc6, 0x8e, 0x75, 0x78, 0xdf, 0xcc, 0xdc, 0x3a, 0x0b, 0xcd, 0x1f, 0xa5,
	0x43, 0x98, 0x88, 0x50, 0x57, 0xc9, 0x5b, 0x3d, 0xf2, 0x41, 0x44, 0xab, 0xd1, 0x33, 0xb3, 0xfd,
	0xa2, 0x7b, 0xf5, 0xbe, 0x1d, 0x7b, 0xd0, 0x84, 0x0c, 0xef, 0xe8, 0x2d, 0x47, 0xdd, 0xa5, 0xec,
	0x45, 0x43, 0xf6, 0x61, 0xe4, 0x8b, 0x9e, 0x3c, 0x86, 0x88, 0x1e, 0xbe, 0x93, 0x66, 0xa6, 0x34,
	0xf4, 0xe0, 0xcf, 0x25, 0xa1, 0x20, 0x06, 0xb6, 0xa5, 0x9a, 0x65, 0xcb, 0xdc, 0x31, 0x76, 0xc9,
	0x2e, 0xe4, 0x1f, 0xd2, 0x10, 0x20, 0x7a, 0xe6, 0x74, 0xa2, 0x78, 0x55, 0xdf, 0xed, 0x03, 0xd3,
	0xef, 0xe6, 0x5f, 0x88, 0xc1, 0xf5, 0x87, 0xd4, 0x9d, 0x6f, 0x34, 0x6a, 0x47, 0x8e, 0x4b, 0x9b,
	0x21, 0xac, 0xfa, 0x9e, 0xea, 0xce, 0xb7, 0x5a, 0x8d, 0x23, 0xf2, 0x7e, 0x34, 0xc7, 0x53, 0x89,
	0xbc, 0xd6, 0x7c, 0x70, 0x21, 0x5a, 0xbf, 0x7d, 0x2d, 0x18, 0xdf, 0x6a, 0xe9, 0xaa, 0x4b, 0xc3,
	0x7d, 0x11, 0x15, 0x1d, 0x7c, 0x02, 0xcb, 0x6b, 0xc0, 0x9b, 0xfd, 0x21, 0xfb, 0x35, 0xfe, 0x29,
	0x98, 0x0a, 0x0a, 0xd8, 0x5f, 0x26, 0x89, 0x4d, 0x8d, 0x92, 0xb9, 0x1e, 0x46, 0xd8, 0x09, 0x4c,
	0xaf, 0xe6, 0xb7, 0xfb, 0x27, 0xf0, 0x67, 0xc3, 0xc7, 0x90, 0x64, 0x7b, 0x2b, 0x79, 0x0c, 0x49,
	0x66, 0xef, 0x92, 0x28, 0xdb, 0xab, 0xcb, 0xbe, 0x9e, 0x79, 0xfd, 0x54, 0x1c, 0x9f, 0x75, 0x03,
	0xd2, 0xfe, 0x5d, 0x26, 0x51, 0x20, 0x1b, 0xbe, 0x0d, 0x25, 0xa7, 0x5e, 0x17, 0x7b, 0x15, 0x45,
	0x9d, 0x99, 0x9d, 0xb8, 0x53, 0x15, 0xd2, 0xb0, 0x05, 0x79, 0xef, 0x22, 0x11, 0x55, 0xef, 0x23,
	0x94, 0x18, 0xc1, 0xfd, 0x62, 0xb4, 0xc4, 0x38, 0x71, 0x7b, 0x19, 0x2d, 0x31, 0x22, 0xae, 0x29,
	0x87, 0x1e, 0xfc, 0xcb, 0x0c, 0xa4, 0x3c, 0x73, 0xe5, 0x8f, 0xc7, 0x96, 0xf1, 0xca, 0x85, 0xe8,
	0xab, 0x1e, 0xe5, 0x1f, 0xd8, 0xce, 0xf3, 0x0a, 0xe7, 0xd1, 0xab, 0x16, 0xf8, 0xaf, 0x60, 0x69,
	0xff, 0xc9, 0x76, 0xf1, 0xff, 0xe8, 0x76, 0xf1, 0x7d, 0xd3, 0x30, 0x7f, 0x60, 0xda, 0xd8, 0xc2,
	0xfa, 0x77, 0xfe, 0xe0, 0xda, 0xd0, 0x77, 0x5e, 0x5c, 0x8b, 0x7d, 0xf7, 0xc5, 0xb5, 0xd8, 0xef,
	0xbc, 0xb8, 0x16, 0xfb, 0x0f, 0x2f, 0xae, 0xc5, 0xbe, 0xf1, 0xbd, 0x6b, 0x43, 0xdf, 0xfd, 0xde,
	0xb5, 0xa1, 0xdf, 0xf9, 0xde, 0xb5, 0xa1, 0x4f, 0xde, 0xec, 0xcb, 0x72, 0xdd, 0x3f, 0x98, 0xdb,
	0x3f, 0x68, 0x6d, 0x6f, 0x8f, 0xa0, 0x69, 0xfe, 0xce, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x3c,
	0x6b, 0x2a, 0x80, 0x0e, 0xc1, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KVBatchClient is the client API for KVBatch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KVBatchClient interface {
	Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error)
	BatchStream(ctx context.Context, opts ...grpc.CallOption) (KVBatch_BatchStreamClient, error)
}

type kVBatchClient struct {
	cc *grpc.ClientConn
}

func NewKVBatchClient(cc *grpc.ClientConn) KVBatchClient {
	return &kVBatchClient{cc}
}

func (c *kVBatchClient) Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.KVBatch/Batch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVBatchClient) BatchStream(ctx context.Context, opts ...grpc.CallOption) (KVBatch_BatchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_KVBatch_serviceDesc.Streams[0], "/cockroach.roachpb.KVBatch/BatchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kVBatchBatchStreamClient{stream}
	return x, nil
}

type KVBatch_BatchStreamClient interface {
	Send(*BatchRequest) error
	Recv() (*BatchResponse, error)
	grpc.ClientStream
}

type kVBatchBatchStreamClient struct {
	grpc.ClientStream
}

func (x *kVBatchBatchStreamClient) Send(m *BatchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVBatchBatchStreamClient) Recv() (*BatchResponse, error) {
	m := new(BatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KVBatchServer is the server API for KVBatch service.
type KVBatchServer interface {
	Batch(context.Context, *BatchRequest) (*BatchResponse, error)
	BatchStream(KVBatch_BatchStreamServer) error
}

// UnimplementedKVBatchServer can be embedded to have forward compatible implementations.
type UnimplementedKVBatchServer struct {
}

func (*UnimplementedKVBatchServer) Batch(ctx context.Context, req *BatchRequest) (*BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Batch not implemented")
}
func (*UnimplementedKVBatchServer) BatchStream(srv KVBatch_BatchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchStream not implemented")
}

func RegisterKVBatchServer(s *grpc.Server, srv KVBatchServer) {
	s.RegisterService(&_KVBatch_serviceDesc, srv)
}

func _KVBatch_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVBatchServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.KVBatch/Batch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVBatchServer).Batch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVBatch_BatchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVBatchServer).BatchStream(&kVBatchBatchStreamServer{stream})
}

type KVBatch_BatchStreamServer interface {
	Send(*BatchResponse) error
	Recv() (*BatchRequest, error)
	grpc.ServerStream
}

type kVBatchBatchStreamServer struct {
	grpc.ServerStream
}

func (x *kVBatchBatchStreamServer) Send(m *BatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVBatchBatchStreamServer) Recv() (*BatchRequest, error) {
	m := new(BatchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _KVBatch_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.KVBatch",
	HandlerType: (*KVBatchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Batch",
			Handler:    _KVBatch_Batch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchStream",
			Handler:       _KVBatch_BatchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "kv/kvpb/api.proto",
}

// TenantServiceClient is the client API for TenantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TenantServiceClient interface {
	// TenantSettings is used by tenants to obtain and stay up to date with tenant
	// setting overrides.
	TenantSettings(ctx context.Context, in *TenantSettingsRequest, opts ...grpc.CallOption) (TenantService_TenantSettingsClient, error)
	GossipSubscription(ctx context.Context, in *GossipSubscriptionRequest, opts ...grpc.CallOption) (TenantService_GossipSubscriptionClient, error)
	RangeLookup(ctx context.Context, in *RangeLookupRequest, opts ...grpc.CallOption) (*RangeLookupResponse, error)
	// GetRangeDescriptors is used by tenants to get range descriptors for their
	// own ranges.
	GetRangeDescriptors(ctx context.Context, in *GetRangeDescriptorsRequest, opts ...grpc.CallOption) (TenantService_GetRangeDescriptorsClient, error)
}

type tenantServiceClient struct {
	cc *grpc.ClientConn
}

func NewTenantServiceClient(cc *grpc.ClientConn) TenantServiceClient {
	return &tenantServiceClient{cc}
}

func (c *tenantServiceClient) TenantSettings(ctx context.Context, in *TenantSettingsRequest, opts ...grpc.CallOption) (TenantService_TenantSettingsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TenantService_serviceDesc.Streams[0], "/cockroach.roachpb.TenantService/TenantSettings", opts...)
	if err != nil {
		return nil, err
	}
	x := &tenantServiceTenantSettingsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TenantService_TenantSettingsClient interface {
	Recv() (*TenantSettingsEvent, error)
	grpc.ClientStream
}

type tenantServiceTenantSettingsClient struct {
	grpc.ClientStream
}

func (x *tenantServiceTenantSettingsClient) Recv() (*TenantSettingsEvent, error) {
	m := new(TenantSettingsEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tenantServiceClient) GossipSubscription(ctx context.Context, in *GossipSubscriptionRequest, opts ...grpc.CallOption) (TenantService_GossipSubscriptionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TenantService_serviceDesc.Streams[1], "/cockroach.roachpb.TenantService/GossipSubscription", opts...)
	if err != nil {
		return nil, err
	}
	x := &tenantServiceGossipSubscriptionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TenantService_GossipSubscriptionClient interface {
	Recv() (*GossipSubscriptionEvent, error)
	grpc.ClientStream
}

type tenantServiceGossipSubscriptionClient struct {
	grpc.ClientStream
}

func (x *tenantServiceGossipSubscriptionClient) Recv() (*GossipSubscriptionEvent, error) {
	m := new(GossipSubscriptionEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tenantServiceClient) RangeLookup(ctx context.Context, in *RangeLookupRequest, opts ...grpc.CallOption) (*RangeLookupResponse, error) {
	out := new(RangeLookupResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.TenantService/RangeLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) GetRangeDescriptors(ctx context.Context, in *GetRangeDescriptorsRequest, opts ...grpc.CallOption) (TenantService_GetRangeDescriptorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TenantService_serviceDesc.Streams[2], "/cockroach.roachpb.TenantService/GetRangeDescriptors", opts...)
	if err != nil {
		return nil, err
	}
	x := &tenantServiceGetRangeDescriptorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TenantService_GetRangeDescriptorsClient interface {
	Recv() (*GetRangeDescriptorsResponse, error)
	grpc.ClientStream
}

type tenantServiceGetRangeDescriptorsClient struct {
	grpc.ClientStream
}

func (x *tenantServiceGetRangeDescriptorsClient) Recv() (*GetRangeDescriptorsResponse, error) {
	m := new(GetRangeDescriptorsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TenantServiceServer is the server API for TenantService service.
type TenantServiceServer interface {
	// TenantSettings is used by tenants to obtain and stay up to date with tenant
	// setting overrides.
	TenantSettings(*TenantSettingsRequest, TenantService_TenantSettingsServer) error
	GossipSubscription(*GossipSubscriptionRequest, TenantService_GossipSubscriptionServer) error
	RangeLookup(context.Context, *RangeLookupRequest) (*RangeLookupResponse, error)
	// GetRangeDescriptors is used by tenants to get range descriptors for their
	// own ranges.
	GetRangeDescriptors(*GetRangeDescriptorsRequest, TenantService_GetRangeDescriptorsServer) error
}

// UnimplementedTenantServiceServer can be embedded to have forward compatible implementations.
type UnimplementedTenantServiceServer struct {
}

func (*UnimplementedTenantServiceServer) TenantSettings(req *TenantSettingsRequest, srv TenantService_TenantSettingsServer) error {
	return status.Errorf(codes.Unimplemented, "method TenantSettings not implemented")
}
func (*UnimplementedTenantServiceServer) GossipSubscription(req *GossipSubscriptionRequest, srv TenantService_GossipSubscriptionServer) error {
	return status.Errorf(codes.Unimplemented, "method GossipSubscription not implemented")
}
func (*UnimplementedTenantServiceServer) RangeLookup(ctx context.Context, req *RangeLookupRequest) (*RangeLookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeLookup not implemented")
}
func (*UnimplementedTenantServiceServer) GetRangeDescriptors(req *GetRangeDescriptorsRequest, srv TenantService_GetRangeDescriptorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRangeDescriptors not implemented")
}

func RegisterTenantServiceServer(s *grpc.Server, srv TenantServiceServer) {
	s.RegisterService(&_TenantService_serviceDesc, srv)
}

func _TenantService_TenantSettings_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TenantSettingsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TenantServiceServer).TenantSettings(m, &tenantServiceTenantSettingsServer{stream})
}

type TenantService_TenantSettingsServer interface {
	Send(*TenantSettingsEvent) error
	grpc.ServerStream
}

type tenantServiceTenantSettingsServer struct {
	grpc.ServerStream
}

func (x *tenantServiceTenantSettingsServer) Send(m *TenantSettingsEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _TenantService_GossipSubscription_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GossipSubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TenantServiceServer).GossipSubscription(m, &tenantServiceGossipSubscriptionServer{stream})
}

type TenantService_GossipSubscriptionServer interface {
	Send(*GossipSubscriptionEvent) error
	grpc.ServerStream
}

type tenantServiceGossipSubscriptionServer struct {
	grpc.ServerStream
}

func (x *tenantServiceGossipSubscriptionServer) Send(m *GossipSubscriptionEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _TenantService_RangeLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).RangeLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.TenantService/RangeLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).RangeLookup(ctx, req.(*RangeLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_GetRangeDescriptors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRangeDescriptorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TenantServiceServer).GetRangeDescriptors(m, &tenantServiceGetRangeDescriptorsServer{stream})
}

type TenantService_GetRangeDescriptorsServer interface {
	Send(*GetRangeDescriptorsResponse) error
	grpc.ServerStream
}

type tenantServiceGetRangeDescriptorsServer struct {
	grpc.ServerStream
}

func (x *tenantServiceGetRangeDescriptorsServer) Send(m *GetRangeDescriptorsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _TenantService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.TenantService",
	HandlerType: (*TenantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RangeLookup",
			Handler:    _TenantService_RangeLookup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TenantSettings",
			Handler:       _TenantService_TenantSettings_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GossipSubscription",
			Handler:       _TenantService_GossipSubscription_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetRangeDescriptors",
			Handler:       _TenantService_GetRangeDescriptors_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kv/kvpb/api.proto",
}

// TenantUsageClient is the client API for TenantUsage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TenantUsageClient interface {
	// TokenBucket is used by tenants to obtain Request Units and report
	// consumption.
	TokenBucket(ctx context.Context, in *TokenBucketRequest, opts ...grpc.CallOption) (*TokenBucketResponse, error)
}

type tenantUsageClient struct {
	cc *grpc.ClientConn
}

func NewTenantUsageClient(cc *grpc.ClientConn) TenantUsageClient {
	return &tenantUsageClient{cc}
}

func (c *tenantUsageClient) TokenBucket(ctx context.Context, in *TokenBucketRequest, opts ...grpc.CallOption) (*TokenBucketResponse, error) {
	out := new(TokenBucketResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.TenantUsage/TokenBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantUsageServer is the server API for TenantUsage service.
type TenantUsageServer interface {
	// TokenBucket is used by tenants to obtain Request Units and report
	// consumption.
	TokenBucket(context.Context, *TokenBucketRequest) (*TokenBucketResponse, error)
}

// UnimplementedTenantUsageServer can be embedded to have forward compatible implementations.
type UnimplementedTenantUsageServer struct {
}

func (*UnimplementedTenantUsageServer) TokenBucket(ctx context.Context, req *TokenBucketRequest) (*TokenBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenBucket not implemented")
}

func RegisterTenantUsageServer(s *grpc.Server, srv TenantUsageServer) {
	s.RegisterService(&_TenantUsage_serviceDesc, srv)
}

func _TenantUsage_TokenBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUsageServer).TokenBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.TenantUsage/TokenBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUsageServer).TokenBucket(ctx, req.(*TokenBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TenantUsage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.TenantUsage",
	HandlerType: (*TenantUsageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TokenBucket",
			Handler:    _TenantUsage_TokenBucket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv/kvpb/api.proto",
}

// TenantSpanConfigClient is the client API for TenantSpanConfig service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TenantSpanConfigClient interface {
	// GetSpanConfigs is used to fetch the span configurations over a given
	// keyspan.
	GetSpanConfigs(ctx context.Context, in *roachpb.GetSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.GetSpanConfigsResponse, error)
	// GetAllSystemSpanConfigsThatApply is used to fetch all system span
	// configurations that apply over a tenant's ranges.
	GetAllSystemSpanConfigsThatApply(ctx context.Context, in *roachpb.GetAllSystemSpanConfigsThatApplyRequest, opts ...grpc.CallOption) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error)
	// UpdateSpanConfigs is used to update the span configurations over given
	// keyspans.
	UpdateSpanConfigs(ctx context.Context, in *roachpb.UpdateSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.UpdateSpanConfigsResponse, error)
	// SpanConfigConformance is used to determine whether ranges backing the given
	// keyspans conform to span configs that apply over them.
	SpanConfigConformance(ctx context.Context, in *roachpb.SpanConfigConformanceRequest, opts ...grpc.CallOption) (*roachpb.SpanConfigConformanceResponse, error)
}

type tenantSpanConfigClient struct {
	cc *grpc.ClientConn
}

func NewTenantSpanConfigClient(cc *grpc.ClientConn) TenantSpanConfigClient {
	return &tenantSpanConfigClient{cc}
}

func (c *tenantSpanConfigClient) GetSpanConfigs(ctx context.Context, in *roachpb.GetSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.GetSpanConfigsResponse, error) {
	out := new(roachpb.GetSpanConfigsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.TenantSpanConfig/GetSpanConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantSpanConfigClient) GetAllSystemSpanConfigsThatApply(ctx context.Context, in *roachpb.GetAllSystemSpanConfigsThatApplyRequest, opts ...grpc.CallOption) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error) {
	out := new(roachpb.GetAllSystemSpanConfigsThatApplyResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.TenantSpanConfig/GetAllSystemSpanConfigsThatApply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantSpanConfigClient) UpdateSpanConfigs(ctx context.Context, in *roachpb.UpdateSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.UpdateSpanConfigsResponse, error) {
	out := new(roachpb.UpdateSpanConfigsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.TenantSpanConfig/UpdateSpanConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantSpanConfigClient) SpanConfigConformance(ctx context.Context, in *roachpb.SpanConfigConformanceRequest, opts ...grpc.CallOption) (*roachpb.SpanConfigConformanceResponse, error) {
	out := new(roachpb.SpanConfigConformanceResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.TenantSpanConfig/SpanConfigConformance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantSpanConfigServer is the server API for TenantSpanConfig service.
type TenantSpanConfigServer interface {
	// GetSpanConfigs is used to fetch the span configurations over a given
	// keyspan.
	GetSpanConfigs(context.Context, *roachpb.GetSpanConfigsRequest) (*roachpb.GetSpanConfigsResponse, error)
	// GetAllSystemSpanConfigsThatApply is used to fetch all system span
	// configurations that apply over a tenant's ranges.
	GetAllSystemSpanConfigsThatApply(context.Context, *roachpb.GetAllSystemSpanConfigsThatApplyRequest) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error)
	// UpdateSpanConfigs is used to update the span configurations over given
	// keyspans.
	UpdateSpanConfigs(context.Context, *roachpb.UpdateSpanConfigsRequest) (*roachpb.UpdateSpanConfigsResponse, error)
	// SpanConfigConformance is used to determine whether ranges backing the given
	// keyspans conform to span configs that apply over them.
	SpanConfigConformance(context.Context, *roachpb.SpanConfigConformanceRequest) (*roachpb.SpanConfigConformanceResponse, error)
}

// UnimplementedTenantSpanConfigServer can be embedded to have forward compatible implementations.
type UnimplementedTenantSpanConfigServer struct {
}

func (*UnimplementedTenantSpanConfigServer) GetSpanConfigs(ctx context.Context, req *roachpb.GetSpanConfigsRequest) (*roachpb.GetSpanConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpanConfigs not implemented")
}
func (*UnimplementedTenantSpanConfigServer) GetAllSystemSpanConfigsThatApply(ctx context.Context, req *roachpb.GetAllSystemSpanConfigsThatApplyRequest) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSystemSpanConfigsThatApply not implemented")
}
func (*UnimplementedTenantSpanConfigServer) UpdateSpanConfigs(ctx context.Context, req *roachpb.UpdateSpanConfigsRequest) (*roachpb.UpdateSpanConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSpanConfigs not implemented")
}
func (*UnimplementedTenantSpanConfigServer) SpanConfigConformance(ctx context.Context, req *roachpb.SpanConfigConformanceRequest) (*roachpb.SpanConfigConformanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanConfigConformance not implemented")
}

func RegisterTenantSpanConfigServer(s *grpc.Server, srv TenantSpanConfigServer) {
	s.RegisterService(&_TenantSpanConfig_serviceDesc, srv)
}

func _TenantSpanConfig_GetSpanConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.GetSpanConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantSpanConfigServer).GetSpanConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.TenantSpanConfig/GetSpanConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantSpanConfigServer).GetSpanConfigs(ctx, req.(*roachpb.GetSpanConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantSpanConfig_GetAllSystemSpanConfigsThatApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.GetAllSystemSpanConfigsThatApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantSpanConfigServer).GetAllSystemSpanConfigsThatApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.TenantSpanConfig/GetAllSystemSpanConfigsThatApply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantSpanConfigServer).GetAllSystemSpanConfigsThatApply(ctx, req.(*roachpb.GetAllSystemSpanConfigsThatApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantSpanConfig_UpdateSpanConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.UpdateSpanConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantSpanConfigServer).UpdateSpanConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.TenantSpanConfig/UpdateSpanConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantSpanConfigServer).UpdateSpanConfigs(ctx, req.(*roachpb.UpdateSpanConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantSpanConfig_SpanConfigConformance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.SpanConfigConformanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantSpanConfigServer).SpanConfigConformance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.TenantSpanConfig/SpanConfigConformance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantSpanConfigServer).SpanConfigConformance(ctx, req.(*roachpb.SpanConfigConformanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TenantSpanConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.TenantSpanConfig",
	HandlerType: (*TenantSpanConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSpanConfigs",
			Handler:    _TenantSpanConfig_GetSpanConfigs_Handler,
		},
		{
			MethodName: "GetAllSystemSpanConfigsThatApply",
			Handler:    _TenantSpanConfig_GetAllSystemSpanConfigsThatApply_Handler,
		},
		{
			MethodName: "UpdateSpanConfigs",
			Handler:    _TenantSpanConfig_UpdateSpanConfigs_Handler,
		},
		{
			MethodName: "SpanConfigConformance",
			Handler:    _TenantSpanConfig_SpanConfigConformance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv/kvpb/api.proto",
}

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeClient interface {
	// Join a bootstrapped cluster. If the target node is itself not part of a
	// bootstrapped cluster, an appropriate error is returned.
	Join(ctx context.Context, in *JoinNodeRequest, opts ...grpc.CallOption) (*JoinNodeResponse, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) Join(ctx context.Context, in *JoinNodeRequest, opts ...grpc.CallOption) (*JoinNodeResponse, error) {
	out := new(JoinNodeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Node/Join", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
type NodeServer interface {
	// Join a bootstrapped cluster. If the target node is itself not part of a
	// bootstrapped cluster, an appropriate error is returned.
	Join(context.Context, *JoinNodeRequest) (*JoinNodeResponse, error)
}

// UnimplementedNodeServer can be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (*UnimplementedNodeServer) Join(ctx context.Context, req *JoinNodeRequest) (*JoinNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Node/Join",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Join(ctx, req.(*JoinNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Join",
			Handler:    _Node_Join_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv/kvpb/api.proto",
}

// RangeFeedClient is the client API for RangeFeed service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RangeFeedClient interface {
	MuxRangeFeed(ctx context.Context, opts ...grpc.CallOption) (RangeFeed_MuxRangeFeedClient, error)
}

type rangeFeedClient struct {
	cc *grpc.ClientConn
}

func NewRangeFeedClient(cc *grpc.ClientConn) RangeFeedClient {
	return &rangeFeedClient{cc}
}

func (c *rangeFeedClient) MuxRangeFeed(ctx context.Context, opts ...grpc.CallOption) (RangeFeed_MuxRangeFeedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RangeFeed_serviceDesc.Streams[0], "/cockroach.roachpb.RangeFeed/MuxRangeFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &rangeFeedMuxRangeFeedClient{stream}
	return x, nil
}

type RangeFeed_MuxRangeFeedClient interface {
	Send(*RangeFeedRequest) error
	Recv() (*MuxRangeFeedEvent, error)
	grpc.ClientStream
}

type rangeFeedMuxRangeFeedClient struct {
	grpc.ClientStream
}

func (x *rangeFeedMuxRangeFeedClient) Send(m *RangeFeedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rangeFeedMuxRangeFeedClient) Recv() (*MuxRangeFeedEvent, error) {
	m := new(MuxRangeFeedEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RangeFeedServer is the server API for RangeFeed service.
type RangeFeedServer interface {
	MuxRangeFeed(RangeFeed_MuxRangeFeedServer) error
}

// UnimplementedRangeFeedServer can be embedded to have forward compatible implementations.
type UnimplementedRangeFeedServer struct {
}

func (*UnimplementedRangeFeedServer) MuxRangeFeed(srv RangeFeed_MuxRangeFeedServer) error {
	return status.Errorf(codes.Unimplemented, "method MuxRangeFeed not implemented")
}

func RegisterRangeFeedServer(s *grpc.Server, srv RangeFeedServer) {
	s.RegisterService(&_RangeFeed_serviceDesc, srv)
}

func _RangeFeed_MuxRangeFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RangeFeedServer).MuxRangeFeed(&rangeFeedMuxRangeFeedServer{stream})
}

type RangeFeed_MuxRangeFeedServer interface {
	Send(*MuxRangeFeedEvent) error
	Recv() (*RangeFeedRequest, error)
	grpc.ServerStream
}

type rangeFeedMuxRangeFeedServer struct {
	grpc.ServerStream
}

func (x *rangeFeedMuxRangeFeedServer) Send(m *MuxRangeFeedEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rangeFeedMuxRangeFeedServer) Recv() (*RangeFeedRequest, error) {
	m := new(RangeFeedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RangeFeed_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.RangeFeed",
	HandlerType: (*RangeFeedServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MuxRangeFeed",
			Handler:       _RangeFeed_MuxRangeFeed_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "kv/kvpb/api.proto",
}

// QuorumRecoveryClient is the client API for QuorumRecovery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuorumRecoveryClient interface {
	ResetQuorum(ctx context.Context, in *ResetQuorumRequest, opts ...grpc.CallOption) (*ResetQuorumResponse, error)
}

type quorumRecoveryClient struct {
	cc *grpc.ClientConn
}

func NewQuorumRecoveryClient(cc *grpc.ClientConn) QuorumRecoveryClient {
	return &quorumRecoveryClient{cc}
}

func (c *quorumRecoveryClient) ResetQuorum(ctx context.Context, in *ResetQuorumRequest, opts ...grpc.CallOption) (*ResetQuorumResponse, error) {
	out := new(ResetQuorumResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.QuorumRecovery/ResetQuorum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuorumRecoveryServer is the server API for QuorumRecovery service.
type QuorumRecoveryServer interface {
	ResetQuorum(context.Context, *ResetQuorumRequest) (*ResetQuorumResponse, error)
}

// UnimplementedQuorumRecoveryServer can be embedded to have forward compatible implementations.
type UnimplementedQuorumRecoveryServer struct {
}

func (*UnimplementedQuorumRecoveryServer) ResetQuorum(ctx context.Context, req *ResetQuorumRequest) (*ResetQuorumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetQuorum not implemented")
}

func RegisterQuorumRecoveryServer(s *grpc.Server, srv QuorumRecoveryServer) {
	s.RegisterService(&_QuorumRecovery_serviceDesc, srv)
}

func _QuorumRecovery_ResetQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetQuorumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuorumRecoveryServer).ResetQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.QuorumRecovery/ResetQuorum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuorumRecoveryServer).ResetQuorum(ctx, req.(*ResetQuorumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QuorumRecovery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.QuorumRecovery",
	HandlerType: (*QuorumRecoveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResetQuorum",
			Handler:    _QuorumRecovery_ResetQuorum_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv/kvpb/api.proto",
}

// InternalClient is the client API for Internal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InternalClient interface {
	Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error)
	// BatchStream is a streaming variant of Batch. There is a 1:1 correspondence
	// between requests and responses. The method is used to facilitate pooling of
	// gRPC streams to avoid the overhead of creating and discarding a new stream
	// for each unary Batch RPC invocation. See rpc.BatchStreamPool.
	BatchStream(ctx context.Context, opts ...grpc.CallOption) (Internal_BatchStreamClient, error)
	RangeLookup(ctx context.Context, in *RangeLookupRequest, opts ...grpc.CallOption) (*RangeLookupResponse, error)
	MuxRangeFeed(ctx context.Context, opts ...grpc.CallOption) (Internal_MuxRangeFeedClient, error)
	GossipSubscription(ctx context.Context, in *GossipSubscriptionRequest, opts ...grpc.CallOption) (Internal_GossipSubscriptionClient, error)
	ResetQuorum(ctx context.Context, in *ResetQuorumRequest, opts ...grpc.CallOption) (*ResetQuorumResponse, error)
	// TokenBucket is used by tenants to obtain Request Units and report
	// consumption.
	TokenBucket(ctx context.Context, in *TokenBucketRequest, opts ...grpc.CallOption) (*TokenBucketResponse, error)
	// Join a bootstrapped cluster. If the target node is itself not part of a
	// bootstrapped cluster, an appropriate error is returned.
	Join(ctx context.Context, in *JoinNodeRequest, opts ...grpc.CallOption) (*JoinNodeResponse, error)
	// GetSpanConfigs is used to fetch the span configurations over a given
	// keyspan.
	GetSpanConfigs(ctx context.Context, in *roachpb.GetSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.GetSpanConfigsResponse, error)
	// GetAllSystemSpanConfigsThatApply is used to fetch all system span
	// configurations that apply over a tenant's ranges.
	GetAllSystemSpanConfigsThatApply(ctx context.Context, in *roachpb.GetAllSystemSpanConfigsThatApplyRequest, opts ...grpc.CallOption) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error)
	// UpdateSpanConfigs is used to update the span configurations over given
	// keyspans.
	UpdateSpanConfigs(ctx context.Context, in *roachpb.UpdateSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.UpdateSpanConfigsResponse, error)
	// SpanConfigConformance is used to determine whether ranges backing the given
	// keyspans conform to span configs that apply over them.
	SpanConfigConformance(ctx context.Context, in *roachpb.SpanConfigConformanceRequest, opts ...grpc.CallOption) (*roachpb.SpanConfigConformanceResponse, error)
	// TenantSettings is used by tenants to obtain and stay up to date with tenant
	// setting overrides.
	TenantSettings(ctx context.Context, in *TenantSettingsRequest, opts ...grpc.CallOption) (Internal_TenantSettingsClient, error)
	// GetRangeDescriptors is used by tenants to get range descriptors for their
	// own ranges.
	GetRangeDescriptors(ctx context.Context, in *GetRangeDescriptorsRequest, opts ...grpc.CallOption) (Internal_GetRangeDescriptorsClient, error)
}

type internalClient struct {
	cc *grpc.ClientConn
}

func NewInternalClient(cc *grpc.ClientConn) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/Batch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) BatchStream(ctx context.Context, opts ...grpc.CallOption) (Internal_BatchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[0], "/cockroach.roachpb.Internal/BatchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalBatchStreamClient{stream}
	return x, nil
}

type Internal_BatchStreamClient interface {
	Send(*BatchRequest) error
	Recv() (*BatchResponse, error)
	grpc.ClientStream
}

type internalBatchStreamClient struct {
	grpc.ClientStream
}

func (x *internalBatchStreamClient) Send(m *BatchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalBatchStreamClient) Recv() (*BatchResponse, error) {
	m := new(BatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) RangeLookup(ctx context.Context, in *RangeLookupRequest, opts ...grpc.CallOption) (*RangeLookupResponse, error) {
	out := new(RangeLookupResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/RangeLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) MuxRangeFeed(ctx context.Context, opts ...grpc.CallOption) (Internal_MuxRangeFeedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[1], "/cockroach.roachpb.Internal/MuxRangeFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalMuxRangeFeedClient{stream}
	return x, nil
}

type Internal_MuxRangeFeedClient interface {
	Send(*RangeFeedRequest) error
	Recv() (*MuxRangeFeedEvent, error)
	grpc.ClientStream
}

type internalMuxRangeFeedClient struct {
	grpc.ClientStream
}

func (x *internalMuxRangeFeedClient) Send(m *RangeFeedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalMuxRangeFeedClient) Recv() (*MuxRangeFeedEvent, error) {
	m := new(MuxRangeFeedEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) GossipSubscription(ctx context.Context, in *GossipSubscriptionRequest, opts ...grpc.CallOption) (Internal_GossipSubscriptionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[2], "/cockroach.roachpb.Internal/GossipSubscription", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalGossipSubscriptionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_GossipSubscriptionClient interface {
	Recv() (*GossipSubscriptionEvent, error)
	grpc.ClientStream
}

type internalGossipSubscriptionClient struct {
	grpc.ClientStream
}

func (x *internalGossipSubscriptionClient) Recv() (*GossipSubscriptionEvent, error) {
	m := new(GossipSubscriptionEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) ResetQuorum(ctx context.Context, in *ResetQuorumRequest, opts ...grpc.CallOption) (*ResetQuorumResponse, error) {
	out := new(ResetQuorumResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/ResetQuorum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) TokenBucket(ctx context.Context, in *TokenBucketRequest, opts ...grpc.CallOption) (*TokenBucketResponse, error) {
	out := new(TokenBucketResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/TokenBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) Join(ctx context.Context, in *JoinNodeRequest, opts ...grpc.CallOption) (*JoinNodeResponse, error) {
	out := new(JoinNodeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/Join", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) GetSpanConfigs(ctx context.Context, in *roachpb.GetSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.GetSpanConfigsResponse, error) {
	out := new(roachpb.GetSpanConfigsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/GetSpanConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) GetAllSystemSpanConfigsThatApply(ctx context.Context, in *roachpb.GetAllSystemSpanConfigsThatApplyRequest, opts ...grpc.CallOption) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error) {
	out := new(roachpb.GetAllSystemSpanConfigsThatApplyResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/GetAllSystemSpanConfigsThatApply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) UpdateSpanConfigs(ctx context.Context, in *roachpb.UpdateSpanConfigsRequest, opts ...grpc.CallOption) (*roachpb.UpdateSpanConfigsResponse, error) {
	out := new(roachpb.UpdateSpanConfigsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/UpdateSpanConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) SpanConfigConformance(ctx context.Context, in *roachpb.SpanConfigConformanceRequest, opts ...grpc.CallOption) (*roachpb.SpanConfigConformanceResponse, error) {
	out := new(roachpb.SpanConfigConformanceResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/SpanConfigConformance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) TenantSettings(ctx context.Context, in *TenantSettingsRequest, opts ...grpc.CallOption) (Internal_TenantSettingsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[3], "/cockroach.roachpb.Internal/TenantSettings", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalTenantSettingsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_TenantSettingsClient interface {
	Recv() (*TenantSettingsEvent, error)
	grpc.ClientStream
}

type internalTenantSettingsClient struct {
	grpc.ClientStream
}

func (x *internalTenantSettingsClient) Recv() (*TenantSettingsEvent, error) {
	m := new(TenantSettingsEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) GetRangeDescriptors(ctx context.Context, in *GetRangeDescriptorsRequest, opts ...grpc.CallOption) (Internal_GetRangeDescriptorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[4], "/cockroach.roachpb.Internal/GetRangeDescriptors", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalGetRangeDescriptorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_GetRangeDescriptorsClient interface {
	Recv() (*GetRangeDescriptorsResponse, error)
	grpc.ClientStream
}

type internalGetRangeDescriptorsClient struct {
	grpc.ClientStream
}

func (x *internalGetRangeDescriptorsClient) Recv() (*GetRangeDescriptorsResponse, error) {
	m := new(GetRangeDescriptorsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InternalServer is the server API for Internal service.
type InternalServer interface {
	Batch(context.Context, *BatchRequest) (*BatchResponse, error)
	// BatchStream is a streaming variant of Batch. There is a 1:1 correspondence
	// between requests and responses. The method is used to facilitate pooling of
	// gRPC streams to avoid the overhead of creating and discarding a new stream
	// for each unary Batch RPC invocation. See rpc.BatchStreamPool.
	BatchStream(Internal_BatchStreamServer) error
	RangeLookup(context.Context, *RangeLookupRequest) (*RangeLookupResponse, error)
	MuxRangeFeed(Internal_MuxRangeFeedServer) error
	GossipSubscription(*GossipSubscriptionRequest, Internal_GossipSubscriptionServer) error
	ResetQuorum(context.Context, *ResetQuorumRequest) (*ResetQuorumResponse, error)
	// TokenBucket is used by tenants to obtain Request Units and report
	// consumption.
	TokenBucket(context.Context, *TokenBucketRequest) (*TokenBucketResponse, error)
	// Join a bootstrapped cluster. If the target node is itself not part of a
	// bootstrapped cluster, an appropriate error is returned.
	Join(context.Context, *JoinNodeRequest) (*JoinNodeResponse, error)
	// GetSpanConfigs is used to fetch the span configurations over a given
	// keyspan.
	GetSpanConfigs(context.Context, *roachpb.GetSpanConfigsRequest) (*roachpb.GetSpanConfigsResponse, error)
	// GetAllSystemSpanConfigsThatApply is used to fetch all system span
	// configurations that apply over a tenant's ranges.
	GetAllSystemSpanConfigsThatApply(context.Context, *roachpb.GetAllSystemSpanConfigsThatApplyRequest) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error)
	// UpdateSpanConfigs is used to update the span configurations over given
	// keyspans.
	UpdateSpanConfigs(context.Context, *roachpb.UpdateSpanConfigsRequest) (*roachpb.UpdateSpanConfigsResponse, error)
	// SpanConfigConformance is used to determine whether ranges backing the given
	// keyspans conform to span configs that apply over them.
	SpanConfigConformance(context.Context, *roachpb.SpanConfigConformanceRequest) (*roachpb.SpanConfigConformanceResponse, error)
	// TenantSettings is used by tenants to obtain and stay up to date with tenant
	// setting overrides.
	TenantSettings(*TenantSettingsRequest, Internal_TenantSettingsServer) error
	// GetRangeDescriptors is used by tenants to get range descriptors for their
	// own ranges.
	GetRangeDescriptors(*GetRangeDescriptorsRequest, Internal_GetRangeDescriptorsServer) error
}

// UnimplementedInternalServer can be embedded to have forward compatible implementations.
type UnimplementedInternalServer struct {
}

func (*UnimplementedInternalServer) Batch(ctx context.Context, req *BatchRequest) (*BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Batch not implemented")
}
func (*UnimplementedInternalServer) BatchStream(srv Internal_BatchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchStream not implemented")
}
func (*UnimplementedInternalServer) RangeLookup(ctx context.Context, req *RangeLookupRequest) (*RangeLookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeLookup not implemented")
}
func (*UnimplementedInternalServer) MuxRangeFeed(srv Internal_MuxRangeFeedServer) error {
	return status.Errorf(codes.Unimplemented, "method MuxRangeFeed not implemented")
}
func (*UnimplementedInternalServer) GossipSubscription(req *GossipSubscriptionRequest, srv Internal_GossipSubscriptionServer) error {
	return status.Errorf(codes.Unimplemented, "method GossipSubscription not implemented")
}
func (*UnimplementedInternalServer) ResetQuorum(ctx context.Context, req *ResetQuorumRequest) (*ResetQuorumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetQuorum not implemented")
}
func (*UnimplementedInternalServer) TokenBucket(ctx context.Context, req *TokenBucketRequest) (*TokenBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenBucket not implemented")
}
func (*UnimplementedInternalServer) Join(ctx context.Context, req *JoinNodeRequest) (*JoinNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}
func (*UnimplementedInternalServer) GetSpanConfigs(ctx context.Context, req *roachpb.GetSpanConfigsRequest) (*roachpb.GetSpanConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpanConfigs not implemented")
}
func (*UnimplementedInternalServer) GetAllSystemSpanConfigsThatApply(ctx context.Context, req *roachpb.GetAllSystemSpanConfigsThatApplyRequest) (*roachpb.GetAllSystemSpanConfigsThatApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSystemSpanConfigsThatApply not implemented")
}
func (*UnimplementedInternalServer) UpdateSpanConfigs(ctx context.Context, req *roachpb.UpdateSpanConfigsRequest) (*roachpb.UpdateSpanConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSpanConfigs not implemented")
}
func (*UnimplementedInternalServer) SpanConfigConformance(ctx context.Context, req *roachpb.SpanConfigConformanceRequest) (*roachpb.SpanConfigConformanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanConfigConformance not implemented")
}
func (*UnimplementedInternalServer) TenantSettings(req *TenantSettingsRequest, srv Internal_TenantSettingsServer) error {
	return status.Errorf(codes.Unimplemented, "method TenantSettings not implemented")
}
func (*UnimplementedInternalServer) GetRangeDescriptors(req *GetRangeDescriptorsRequest, srv Internal_GetRangeDescriptorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRangeDescriptors not implemented")
}

func RegisterInternalServer(s *grpc.Server, srv InternalServer) {
	s.RegisterService(&_Internal_serviceDesc, srv)
}

func _Internal_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/Batch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Batch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_BatchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).BatchStream(&internalBatchStreamServer{stream})
}

type Internal_BatchStreamServer interface {
	Send(*BatchResponse) error
	Recv() (*BatchRequest, error)
	grpc.ServerStream
}

type internalBatchStreamServer struct {
	grpc.ServerStream
}

func (x *internalBatchStreamServer) Send(m *BatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalBatchStreamServer) Recv() (*BatchRequest, error) {
	m := new(BatchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_RangeLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).RangeLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/RangeLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).RangeLookup(ctx, req.(*RangeLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_MuxRangeFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).MuxRangeFeed(&internalMuxRangeFeedServer{stream})
}

type Internal_MuxRangeFeedServer interface {
	Send(*MuxRangeFeedEvent) error
	Recv() (*RangeFeedRequest, error)
	grpc.ServerStream
}

type internalMuxRangeFeedServer struct {
	grpc.ServerStream
}

func (x *internalMuxRangeFeedServer) Send(m *MuxRangeFeedEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalMuxRangeFeedServer) Recv() (*RangeFeedRequest, error) {
	m := new(RangeFeedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_GossipSubscription_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GossipSubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).GossipSubscription(m, &internalGossipSubscriptionServer{stream})
}

type Internal_GossipSubscriptionServer interface {
	Send(*GossipSubscriptionEvent) error
	grpc.ServerStream
}

type internalGossipSubscriptionServer struct {
	grpc.ServerStream
}

func (x *internalGossipSubscriptionServer) Send(m *GossipSubscriptionEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_ResetQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetQuorumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).ResetQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/ResetQuorum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).ResetQuorum(ctx, req.(*ResetQuorumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_TokenBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).TokenBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/TokenBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).TokenBucket(ctx, req.(*TokenBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/Join",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Join(ctx, req.(*JoinNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_GetSpanConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.GetSpanConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).GetSpanConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/GetSpanConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).GetSpanConfigs(ctx, req.(*roachpb.GetSpanConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_GetAllSystemSpanConfigsThatApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.GetAllSystemSpanConfigsThatApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).GetAllSystemSpanConfigsThatApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/GetAllSystemSpanConfigsThatApply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).GetAllSystemSpanConfigsThatApply(ctx, req.(*roachpb.GetAllSystemSpanConfigsThatApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_UpdateSpanConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.UpdateSpanConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).UpdateSpanConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/UpdateSpanConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).UpdateSpanConfigs(ctx, req.(*roachpb.UpdateSpanConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_SpanConfigConformance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(roachpb.SpanConfigConformanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).SpanConfigConformance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/SpanConfigConformance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).SpanConfigConformance(ctx, req.(*roachpb.SpanConfigConformanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_TenantSettings_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TenantSettingsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).TenantSettings(m, &internalTenantSettingsServer{stream})
}

type Internal_TenantSettingsServer interface {
	Send(*TenantSettingsEvent) error
	grpc.ServerStream
}

type internalTenantSettingsServer struct {
	grpc.ServerStream
}

func (x *internalTenantSettingsServer) Send(m *TenantSettingsEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_GetRangeDescriptors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRangeDescriptorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).GetRangeDescriptors(m, &internalGetRangeDescriptorsServer{stream})
}

type Internal_GetRangeDescriptorsServer interface {
	Send(*GetRangeDescriptorsResponse) error
	grpc.ServerStream
}

type internalGetRangeDescriptorsServer struct {
	grpc.ServerStream
}

func (x *internalGetRangeDescriptorsServer) Send(m *GetRangeDescriptorsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Internal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Batch",
			Handler:    _Internal_Batch_Handler,
		},
		{
			MethodName: "RangeLookup",
			Handler:    _Internal_RangeLookup_Handler,
		},
		{
			MethodName: "ResetQuorum",
			Handler:    _Internal_ResetQuorum_Handler,
		},
		{
			MethodName: "TokenBucket",
			Handler:    _Internal_TokenBucket_Handler,
		},
		{
			MethodName: "Join",
			Handler:    _Internal_Join_Handler,
		},
		{
			MethodName: "GetSpanConfigs",
			Handler:    _Internal_GetSpanConfigs_Handler,
		},
		{
			MethodName: "GetAllSystemSpanConfigsThatApply",
			Handler:    _Internal_GetAllSystemSpanConfigsThatApply_Handler,
		},
		{
			MethodName: "UpdateSpanConfigs",
			Handler:    _Internal_UpdateSpanConfigs_Handler,
		},
		{
			MethodName: "SpanConfigConformance",
			Handler:    _Internal_SpanConfigConformance_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchStream",
			Handler:       _Internal_BatchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "MuxRangeFeed",
			Handler:       _Internal_MuxRangeFeed_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GossipSubscription",
			Handler:       _Internal_GossipSubscription_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TenantSettings",
			Handler:       _Internal_TenantSettings_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetRangeDescriptors",
			Handler:       _Internal_GetRangeDescriptors_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kv/kvpb/api.proto",
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	// Field has gogoproto.omitempty set.
	if !m.KVNemesisSeq.IsEmpty() {
		{
			size, err := m.KVNemesisSeq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Sequence != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *RequestHeader_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestHeader_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResumeNextBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ResumeNextBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.NumBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.ResumeReason != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ResumeReason))
		i--
		dAtA[i] = 0x38
	}
	if m.NumKeys != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumKeys))
		i--
		dAtA[i] = 0x28
	}
	if m.ResumeSpan != nil {
		{
			size, err := m.ResumeSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ExpectExclusionSince.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.LockNonExisting {
		i--
		if m.LockNonExisting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ReturnRawMVCCValues {
		i--
		if m.ReturnRawMVCCValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.KeyLockingDurability != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLockingDurability))
		i--
		dAtA[i] = 0x18
	}
	if m.KeyLockingStrength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLockingStrength))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IntentValue != nil {
		{
			size, err := m.IntentValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProbeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProbeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProbeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProbeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IsSpanEmptyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsSpanEmptyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsSpanEmptyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IsSpanEmptyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsSpanEmptyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsSpanEmptyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ExpectExclusionSince.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.MustAcquireExclusiveLock {
		i--
		if m.MustAcquireExclusiveLock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Blind {
		i--
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Inline {
		i--
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConditionalPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalPutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionalPutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OriginTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Inline {
		i--
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ExpBytes) > 0 {
		i -= len(m.ExpBytes)
		copy(dAtA[i:], m.ExpBytes)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ExpBytes)))
		i--
		dAtA[i] = 0x32
	}
	if m.AllowIfDoesNotExist {
		i--
		if m.AllowIfDoesNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Blind {
		i--
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConditionalPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionalPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Increment != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Increment))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewValue != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NewValue))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ExpectExclusionSince.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.MustAcquireExclusiveLock {
		i--
		if m.MustAcquireExclusiveLock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FoundKey {
		i--
		if m.FoundKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateRangeDeleteGCHint {
		i--
		if m.UpdateRangeDeleteGCHint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IdempotentTombstone {
		i--
		if m.IdempotentTombstone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.Predicates.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.UseRangeTombstone {
		i--
		if m.UseRangeTombstone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Inline {
		i--
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReturnKeys {
		i--
		if m.ReturnKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteRangePredicates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangePredicates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRangePredicates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.ImportEpoch != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ImportEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Deadline.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RevertRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevertRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevertRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreGcThreshold {
		i--
		if m.IgnoreGcThreshold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.TargetTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RevertRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevertRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevertRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReturnRawMVCCValues {
		i--
		if m.ReturnRawMVCCValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.KeyLockingDurability != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLockingDurability))
		i--
		dAtA[i] = 0x30
	}
	if m.KeyLockingStrength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLockingStrength))
		i--
		dAtA[i] = 0x28
	}
	if m.ScanFormat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ScanFormat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ColBatches.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.BatchResponses) > 0 {
		for iNdEx := len(m.BatchResponses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BatchResponses[iNdEx])
			copy(dAtA[i:], m.BatchResponses[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.BatchResponses[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntentRows) > 0 {
		for iNdEx := len(m.IntentRows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntentRows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExciseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExciseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExciseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExciseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExciseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExciseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReverseScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReverseScanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReverseScanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReturnRawMVCCValues {
		i--
		if m.ReturnRawMVCCValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.KeyLockingDurability != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLockingDurability))
		i--
		dAtA[i] = 0x30
	}
	if m.KeyLockingStrength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLockingStrength))
		i--
		dAtA[i] = 0x28
	}
	if m.ScanFormat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ScanFormat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReverseScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReverseScanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReverseScanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ColBatches.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.BatchResponses) > 0 {
		for iNdEx := len(m.BatchResponses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BatchResponses[iNdEx])
			copy(dAtA[i:], m.BatchResponses[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.BatchResponses[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntentRows) > 0 {
		for iNdEx := len(m.IntentRows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntentRows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CheckConsistencyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConsistencyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConsistencyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CheckConsistencyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConsistencyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConsistencyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CheckConsistencyResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConsistencyResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConsistencyResponse_Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecomputeStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecomputeStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecomputeStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DryRun {
		i--
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecomputeStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecomputeStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecomputeStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AddedDelta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EndTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Prepare {
		i--
		if m.Prepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Disable1PC {
		i--
		if m.Disable1PC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Poison {
		i--
		if m.Poison {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Require1PC {
		i--
		if m.Require1PC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.LockSpans) > 0 {
		for iNdEx := len(m.LockSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.InternalCommitTrigger != nil {
		{
			size, err := m.InternalCommitTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Deadline.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Commit {
		i--
		if m.Commit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EndTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReplicatedLocalLocksReleasedOnCommit) > 0 {
		for iNdEx := len(m.ReplicatedLocalLocksReleasedOnCommit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReplicatedLocalLocksReleasedOnCommit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.StagingTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.OnePhaseCommit {
		i--
		if m.OnePhaseCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PredicateKeys) > 0 {
		for iNdEx := len(m.PredicateKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PredicateKeys[iNdEx])
			copy(dAtA[i:], m.PredicateKeys[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.PredicateKeys[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.ExpirationTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.SplitKey) > 0 {
		i -= len(m.SplitKey)
		copy(dAtA[i:], m.SplitKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SplitKey)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminUnsplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminUnsplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminUnsplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminUnsplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminUnsplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminUnsplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminMergeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminMergeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminMergeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminMergeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminMergeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminMergeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminTransferLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminTransferLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminTransferLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BypassSafetyChecks {
		i--
		if m.BypassSafetyChecks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Target != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminTransferLeaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminTransferLeaseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminTransferLeaseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReplicationChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicationChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ChangeType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdminChangeReplicasRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminChangeReplicasRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminChangeReplicasRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalChanges) > 0 {
		for iNdEx := len(m.InternalChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.ExpDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DeprecatedTargets) > 0 {
		for iNdEx := len(m.DeprecatedTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeprecatedTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DeprecatedChangeType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DeprecatedChangeType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminChangeReplicasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminChangeReplicasResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminChangeReplicasResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminRelocateRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminRelocateRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminRelocateRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferLeaseToFirstVoterAccurate {
		i--
		if m.TransferLeaseToFirstVoterAccurate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TransferLeaseToFirstVoter {
		i--
		if m.TransferLeaseToFirstVoter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.NonVoterTargets) > 0 {
		for iNdEx := len(m.NonVoterTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NonVoterTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VoterTargets) > 0 {
		for iNdEx := len(m.VoterTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VoterTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminRelocateRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminRelocateRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminRelocateRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HeartbeatTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HeartbeatTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClearRange != nil {
		{
			size, err := m.ClearRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RangeKeys) > 0 {
		for iNdEx := len(m.RangeKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.Threshold.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GCRequest_GCKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest_GCKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRequest_GCKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCRequest_GCRangeKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest_GCRangeKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRequest_GCRangeKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCRequest_GCClearRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest_GCClearRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRequest_GCClearRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StartKeyTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PushTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.PushType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PushType))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.PushTo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.PusheeTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.PusherTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PushTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AmbiguousAbort {
		i--
		if m.AmbiguousAbort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.PusheeTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoverTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoverTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ImplicitlyCommitted {
		i--
		if m.ImplicitlyCommitted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoverTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoverTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RecoveredTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KnownWaitingTxns) > 0 {
		for iNdEx := len(m.KnownWaitingTxns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.KnownWaitingTxns[iNdEx].Size()
				i -= size
				if _, err := m.KnownWaitingTxns[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.WaitForUpdate {
		i--
		if m.WaitForUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxnRecordExists {
		i--
		if m.TxnRecordExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.WaitingTxns) > 0 {
		for iNdEx := len(m.WaitingTxns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.WaitingTxns[iNdEx].Size()
				i -= size
				if _, err := m.WaitingTxns[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.QueriedTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryIntentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIntentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIntentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Strength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x20
	}
	if m.ErrorIfMissing {
		i--
		if m.ErrorIfMissing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryIntentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIntentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIntentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FoundIntent {
		i--
		if m.FoundIntent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FoundUnpushedIntent {
		i--
		if m.FoundUnpushedIntent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeUncontended {
		i--
		if m.IncludeUncontended {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryLocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLocksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLocksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClockWhilePending.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Poison {
		i--
		if m.Poison {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.IntentTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ReplicatedLocksReleasedCommitTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClockWhilePending.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.MinTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Poison {
		i--
		if m.Poison {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.IntentTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ReplicatedLocksReleasedCommitTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MergeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MergeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TruncateLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpectedFirstIndex != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ExpectedFirstIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TruncateLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevokePrevAndForwardExpiration {
		i--
		if m.RevokePrevAndForwardExpiration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.PrevLease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BypassSafetyChecks {
		i--
		if m.BypassSafetyChecks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PrevLease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvaluatedBy != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EvaluatedBy))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentLease != nil {
		{
			size, err := m.CurrentLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestLeaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLeaseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestLeaseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComputeChecksumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeChecksumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeChecksumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Terminate) > 0 {
		for iNdEx := len(m.Terminate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Terminate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Checkpoint {
		i--
		if m.Checkpoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Mode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComputeChecksumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeChecksumResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeChecksumResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ChecksumID.Size()
		i -= size
		if _, err := m.ChecksumID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RetryTracingEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryTracingEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryTracingEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetryError) > 0 {
		i -= len(m.RetryError)
		copy(dAtA[i:], m.RetryError)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RetryError)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AttemptNumber != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AttemptNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileEncryptionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileEncryptionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileEncryptionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeMVCCValueHeader {
		i--
		if m.IncludeMVCCValueHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.FingerprintOptions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if m.ExportFingerprint {
		i--
		if m.ExportFingerprint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.SplitMidKey {
		i--
		if m.SplitMidKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	{
		size, err := m.ResumeKeyTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.TargetFileSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TargetFileSize))
		i--
		dAtA[i] = 0x50
	}
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.MVCCFilter != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MVCCFilter))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FingerprintOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FingerprintOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FingerprintOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StripIndexPrefixAndTimestamp {
		i--
		if m.StripIndexPrefixAndTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BulkOpSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkOpSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkOpSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SSTDataSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SSTDataSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EntryCounts) > 0 {
		keysForEntryCounts := make([]uint64, 0, len(m.EntryCounts))
		for k := range m.EntryCounts {
			keysForEntryCounts = append(keysForEntryCounts, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForEntryCounts)
		for iNdEx := len(keysForEntryCounts) - 1; iNdEx >= 0; iNdEx-- {
			v := m.EntryCounts[uint64(keysForEntryCounts[iNdEx])]
			baseI := i
			i = encodeVarintApi(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintApi(dAtA, i, uint64(keysForEntryCounts[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DataSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DataSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExportResponse_File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportResponse_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportResponse_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fingerprint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Fingerprint))
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.EndKeyTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.LocalityKV) > 0 {
		i -= len(m.LocalityKV)
		copy(dAtA[i:], m.LocalityKV)
		i = encodeVarintApi(dAtA, i, uint64(len(m.LocalityKV)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SST) > 0 {
		i -= len(m.SST)
		copy(dAtA[i:], m.SST)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SST)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Exported.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminScatterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminScatterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminScatterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxSize))
		i--
		dAtA[i] = 0x18
	}
	if m.RandomizeLeases {
		i--
		if m.RandomizeLeases {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminScatterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminScatterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminScatterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplicasScatteredBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReplicasScatteredBytes))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RangeInfos) > 0 {
		for iNdEx := len(m.RangeInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminScatterResponse_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminScatterResponse_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminScatterResponse_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddSSTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddSSTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddSSTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputeStatsDiff {
		i--
		if m.ComputeStatsDiff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	{
		size, err := m.IgnoreKeysAboveTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.ReturnFollowingLikelyNonEmptySpanStart {
		i--
		if m.ReturnFollowingLikelyNonEmptySpanStart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	{
		size, err := m.DisallowShadowingBelow.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.DisallowConflicts {
		i--
		if m.DisallowConflicts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.SSTTimestampToRequestTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.IngestAsWrites {
		i--
		if m.IngestAsWrites {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MVCCStats != nil {
		{
			size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddSSTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddSSTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddSSTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FollowingLikelyNonEmptySpanStart) > 0 {
		i -= len(m.FollowingLikelyNonEmptySpanStart)
		copy(dAtA[i:], m.FollowingLikelyNonEmptySpanStart)
		i = encodeVarintApi(dAtA, i, uint64(len(m.FollowingLikelyNonEmptySpanStart)))
		i--
		dAtA[i] = 0x22
	}
	if m.AvailableBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AvailableBytes))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RangeSpan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LinkExternalSSTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkExternalSSTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkExternalSSTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ExternalFile.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LinkExternalSSTableRequest_ExternalFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkExternalSSTableRequest_ExternalFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkExternalSSTableRequest_ExternalFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MVCCStats != nil {
		{
			size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UseSyntheticSuffix {
		i--
		if m.UseSyntheticSuffix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.SyntheticPrefix) > 0 {
		i -= len(m.SyntheticPrefix)
		copy(dAtA[i:], m.SyntheticPrefix)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SyntheticPrefix)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ApproximatePhysicalSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApproximatePhysicalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.BackingFileSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BackingFileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Locator) > 0 {
		i -= len(m.Locator)
		copy(dAtA[i:], m.Locator)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Locator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LinkExternalSSTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkExternalSSTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkExternalSSTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RefreshFrom.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RefreshFrom.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubsumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubsumeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubsumeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreserveUnreplicatedLocks {
		i--
		if m.PreserveUnreplicatedLocks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.RightDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LeftDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubsumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubsumeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubsumeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RangeIDLocalMVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.ReadSummary != nil {
		{
			size, err := m.ReadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.ClosedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.FreezeStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.LeaseAppliedIndex != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LeaseAppliedIndex))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxCPUPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxCPUPerSecond))))
		i--
		dAtA[i] = 0x39
	}
	if m.MaxQueriesPerSecondSet {
		i--
		if m.MaxQueriesPerSecondSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MaxQueriesPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxQueriesPerSecond))))
		i--
		dAtA[i] = 0x29
	}
	{
		size, err := m.RangeInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MigrateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MigrateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryResolvedTimestampRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolvedTimestampRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolvedTimestampRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryResolvedTimestampResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolvedTimestampResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolvedTimestampResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResolvedTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BarrierRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BarrierRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BarrierRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithLeaseAppliedIndex {
		i--
		if m.WithLeaseAppliedIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BarrierResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BarrierResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BarrierResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RangeDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.LeaseAppliedIndex != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LeaseAppliedIndex))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FlushLockTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushLockTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlushLockTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FlushLockTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushLockTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlushLockTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocksWritten != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LocksWritten))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RequestUnion_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Put) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Put) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ConditionalPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ConditionalPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConditionalPut != nil {
		{
			size, err := m.ConditionalPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Increment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Increment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Increment != nil {
		{
			size, err := m.Increment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_DeleteRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_DeleteRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteRange != nil {
		{
			size, err := m.DeleteRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Scan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Scan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_EndTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_EndTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndTxn != nil {
		{
			size, err := m.EndTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminSplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminSplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminSplit != nil {
		{
			size, err := m.AdminSplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminMerge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminMerge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminMerge != nil {
		{
			size, err := m.AdminMerge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_HeartbeatTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_HeartbeatTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeartbeatTxn != nil {
		{
			size, err := m.HeartbeatTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Gc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Gc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gc != nil {
		{
			size, err := m.Gc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_PushTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_PushTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PushTxn != nil {
		{
			size, err := m.PushTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ResolveIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ResolveIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntent != nil {
		{
			size, err := m.ResolveIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ResolveIntentRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ResolveIntentRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntentRange != nil {
		{
			size, err := m.ResolveIntentRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_TruncateLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_TruncateLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateLog != nil {
		{
			size, err := m.TruncateLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RequestLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RequestLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestLease != nil {
		{
			size, err := m.RequestLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ReverseScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ReverseScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReverseScan != nil {
		{
			size, err := m.ReverseScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ComputeChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ComputeChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ComputeChecksum != nil {
		{
			size, err := m.ComputeChecksum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_CheckConsistency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_CheckConsistency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConsistency != nil {
		{
			size, err := m.CheckConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_TransferLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_TransferLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TransferLease != nil {
		{
			size, err := m.TransferLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminTransferLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminTransferLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminTransferLease != nil {
		{
			size, err := m.AdminTransferLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_LeaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_LeaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaseInfo != nil {
		{
			size, err := m.LeaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Export) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Export) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Export != nil {
		{
			size, err := m.Export.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_QueryTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_QueryTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryTxn != nil {
		{
			size, err := m.QueryTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminChangeReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminChangeReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminChangeReplicas != nil {
		{
			size, err := m.AdminChangeReplicas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminScatter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminScatter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminScatter != nil {
		{
			size, err := m.AdminScatter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AddSstable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AddSstable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddSstable != nil {
		{
			size, err := m.AddSstable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ClearRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ClearRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearRange != nil {
		{
			size, err := m.ClearRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RecomputeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RecomputeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecomputeStats != nil {
		{
			size, err := m.RecomputeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Refresh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Refresh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Refresh != nil {
		{
			size, err := m.Refresh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RefreshRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RefreshRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RefreshRange != nil {
		{
			size, err := m.RefreshRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_QueryIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_QueryIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryIntent != nil {
		{
			size, err := m.QueryIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Subsume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Subsume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subsume != nil {
		{
			size, err := m.Subsume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RangeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RangeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeStats != nil {
		{
			size, err := m.RangeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminRelocateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminRelocateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminRelocateRange != nil {
		{
			size, err := m.AdminRelocateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RecoverTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RecoverTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecoverTxn != nil {
		{
			size, err := m.RecoverTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminUnsplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminUnsplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminUnsplit != nil {
		{
			size, err := m.AdminUnsplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RevertRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RevertRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RevertRange != nil {
		{
			size, err := m.RevertRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Migrate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Migrate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Migrate != nil {
		{
			size, err := m.Migrate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_QueryResolvedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_QueryResolvedTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryResolvedTimestamp != nil {
		{
			size, err := m.QueryResolvedTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Barrier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Barrier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Barrier != nil {
		{
			size, err := m.Barrier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Probe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Probe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Probe != nil {
		{
			size, err := m.Probe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_QueryLocks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_QueryLocks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryLocks != nil {
		{
			size, err := m.QueryLocks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_IsSpanEmpty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_IsSpanEmpty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsSpanEmpty != nil {
		{
			size, err := m.IsSpanEmpty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_LinkExternalSstable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_LinkExternalSstable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LinkExternalSstable != nil {
		{
			size, err := m.LinkExternalSstable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Excise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Excise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Excise != nil {
		{
			size, err := m.Excise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_FlushLockTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_FlushLockTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlushLockTable != nil {
		{
			size, err := m.FlushLockTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResponseUnion_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Put) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Put) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ConditionalPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ConditionalPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConditionalPut != nil {
		{
			size, err := m.ConditionalPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Increment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Increment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Increment != nil {
		{
			size, err := m.Increment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_DeleteRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_DeleteRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteRange != nil {
		{
			size, err := m.DeleteRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Scan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Scan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_EndTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_EndTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndTxn != nil {
		{
			size, err := m.EndTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminSplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminSplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminSplit != nil {
		{
			size, err := m.AdminSplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminMerge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminMerge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminMerge != nil {
		{
			size, err := m.AdminMerge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_HeartbeatTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_HeartbeatTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeartbeatTxn != nil {
		{
			size, err := m.HeartbeatTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Gc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Gc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gc != nil {
		{
			size, err := m.Gc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_PushTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_PushTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PushTxn != nil {
		{
			size, err := m.PushTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ResolveIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ResolveIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntent != nil {
		{
			size, err := m.ResolveIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ResolveIntentRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ResolveIntentRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntentRange != nil {
		{
			size, err := m.ResolveIntentRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_TruncateLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_TruncateLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateLog != nil {
		{
			size, err := m.TruncateLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RequestLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RequestLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestLease != nil {
		{
			size, err := m.RequestLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ReverseScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ReverseScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReverseScan != nil {
		{
			size, err := m.ReverseScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ComputeChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ComputeChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ComputeChecksum != nil {
		{
			size, err := m.ComputeChecksum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_CheckConsistency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_CheckConsistency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConsistency != nil {
		{
			size, err := m.CheckConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminTransferLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminTransferLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminTransferLease != nil {
		{
			size, err := m.AdminTransferLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_LeaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_LeaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaseInfo != nil {
		{
			size, err := m.LeaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Export) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Export) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Export != nil {
		{
			size, err := m.Export.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_QueryTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_QueryTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryTxn != nil {
		{
			size, err := m.QueryTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminChangeReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminChangeReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminChangeReplicas != nil {
		{
			size, err := m.AdminChangeReplicas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminScatter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminScatter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminScatter != nil {
		{
			size, err := m.AdminScatter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AddSstable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AddSstable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddSstable != nil {
		{
			size, err := m.AddSstable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ClearRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ClearRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearRange != nil {
		{
			size, err := m.ClearRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RecomputeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RecomputeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecomputeStats != nil {
		{
			size, err := m.RecomputeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Refresh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Refresh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Refresh != nil {
		{
			size, err := m.Refresh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RefreshRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RefreshRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RefreshRange != nil {
		{
			size, err := m.RefreshRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_QueryIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_QueryIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryIntent != nil {
		{
			size, err := m.QueryIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Subsume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Subsume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subsume != nil {
		{
			size, err := m.Subsume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RangeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RangeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeStats != nil {
		{
			size, err := m.RangeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminRelocateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminRelocateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminRelocateRange != nil {
		{
			size, err := m.AdminRelocateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RecoverTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RecoverTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecoverTxn != nil {
		{
			size, err := m.RecoverTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminUnsplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminUnsplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminUnsplit != nil {
		{
			size, err := m.AdminUnsplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RevertRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RevertRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RevertRange != nil {
		{
			size, err := m.RevertRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Migrate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Migrate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Migrate != nil {
		{
			size, err := m.Migrate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_QueryResolvedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_QueryResolvedTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryResolvedTimestamp != nil {
		{
			size, err := m.QueryResolvedTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Barrier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Barrier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Barrier != nil {
		{
			size, err := m.Barrier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Probe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Probe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Probe != nil {
		{
			size, err := m.Probe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_QueryLocks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_QueryLocks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryLocks != nil {
		{
			size, err := m.QueryLocks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_IsSpanEmpty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_IsSpanEmpty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsSpanEmpty != nil {
		{
			size, err := m.IsSpanEmpty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_LinkExternalSstable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_LinkExternalSstable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LinkExternalSstable != nil {
		{
			size, err := m.LinkExternalSstable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Excise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Excise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Excise != nil {
		{
			size, err := m.Excise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_FlushLockTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_FlushLockTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlushLockTable != nil {
		{
			size, err := m.FlushLockTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsReverse {
		i--
		if m.IsReverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.HasBufferedAllPrecedingWrites {
		i--
		if m.HasBufferedAllPrecedingWrites {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.DeadlockTimeout != 0 {
		n281, err281 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeadlockTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeadlockTimeout):])
		if err281 != nil {
			return 0, err281
		}
		i -= n281
		i = encodeVarintApi(dAtA, i, uint64(n281))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.WriteOptions != nil {
		{
			size, err := m.WriteOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.ProxyRangeInfo != nil {
		{
			size, err := m.ProxyRangeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.ConnectionClass != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ConnectionClass))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.AmbiguousReplayProtection {
		i--
		if m.AmbiguousReplayProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if len(m.ProfileLabels) > 0 {
		for iNdEx := len(m.ProfileLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProfileLabels[iNdEx])
			copy(dAtA[i:], m.ProfileLabels[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.ProfileLabels[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.ReturnElasticCPUResumeSpans {
		i--
		if m.ReturnElasticCPUResumeSpans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.IndexFetchSpec != nil {
		{
			size, err := m.IndexFetchSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if m.TimestampFromServerClock != nil {
		{
			size, err := m.TimestampFromServerClock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.WholeRowsOfSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WholeRowsOfSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.TraceInfo != nil {
		{
			size, err := m.TraceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.AllowEmpty {
		i--
		if m.AllowEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.BoundedStaleness != nil {
		{
			size, err := m.BoundedStaleness.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.LockTimeout != 0 {
		n289, err289 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.LockTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.LockTimeout):])
		if err289 != nil {
			return 0, err289
		}
		i -= n289
		i = encodeVarintApi(dAtA, i, uint64(n289))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.RoutingPolicy != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoutingPolicy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.WaitPolicy != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WaitPolicy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	{
		size, err := m.ClientRangeInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.CanForwardReadTimestamp {
		i--
		if m.CanForwardReadTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TargetBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TargetBytes))
		i--
		dAtA[i] = 0x78
	}
	if m.AsyncConsensus {
		i--
		if m.AsyncConsensus {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.GatewayNodeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GatewayNodeID))
		i--
		dAtA[i] = 0x58
	}
	if m.DistinctSpans {
		i--
		if m.DistinctSpans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxSpanRequestKeys != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxSpanRequestKeys))
		i--
		dAtA[i] = 0x40
	}
	if m.ReadConsistency != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadConsistency))
		i--
		dAtA[i] = 0x30
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.UserPriority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UserPriority))))
		i--
		dAtA[i] = 0x21
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WriteOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OriginTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.OriginID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OriginID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BoundedStalenessHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundedStalenessHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoundedStalenessHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MaxTimestampBound.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.MinTimestampBoundStrict {
		i--
		if m.MinTimestampBoundStrict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.MinTimestampBound.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdmissionHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdmissionHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoMemoryReservedAtSource {
		i--
		if m.NoMemoryReservedAtSource {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SourceLocation != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SourceLocation))
		i--
		dAtA[i] = 0x20
	}
	if m.Source != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Priority != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AdmissionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Responses) > 0 {
		for iNdEx := len(m.Responses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Responses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BatchResponse_Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BatchResponse_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResponse_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchResponse_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeInfos) > 0 {
		for iNdEx := len(m.RangeInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CollectedSpans) > 0 {
		for iNdEx := len(m.CollectedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeLookupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLookupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLookupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrefetchReverse {
		i--
		if m.PrefetchReverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PrefetchNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PrefetchNum))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadConsistency != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadConsistency))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeLookupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLookupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLookupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PrefetchedDescriptors) > 0 {
		for iNdEx := len(m.PrefetchedDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrefetchedDescriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Descriptors) > 0 {
		for iNdEx := len(m.Descriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Descriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RangeFeedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithBulkDelivery {
		i--
		if m.WithBulkDelivery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.ConsumerID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ConsumerID))
		i--
		dAtA[i] = 0x48
	}
	if len(m.WithMatchingOriginIDs) > 0 {
		l := 0
		for _, e := range m.WithMatchingOriginIDs {
			l += sovApi(uint64(e))
		}
		i -= l
		if l == len(m.WithMatchingOriginIDs) {
			dest := dAtA[i : i+len(m.WithMatchingOriginIDs)]
			for k, num := range m.WithMatchingOriginIDs {
				dest[k] = uint8(num)
			}
		} else {
			j305 := i
			for _, num := range m.WithMatchingOriginIDs {
				for num >= 1<<7 {
					dAtA[j305] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j305++
				}
				dAtA[j305] = uint8(num)
				j305++
			}
		}
		i = encodeVarintApi(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x42
	}
	if m.WithFiltering {
		i--
		if m.WithFiltering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.CloseStream {
		i--
		if m.CloseStream {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.StreamID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StreamID))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.AdmissionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.WithDiff {
		i--
		if m.WithDiff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeFeedBulkEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedBulkEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedBulkEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RangeFeedCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResolvedTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedSSTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedSSTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedSSTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.WriteTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeFeedDeleteRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedDeleteRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedDeleteRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParentStartKey) > 0 {
		i -= len(m.ParentStartKey)
		copy(dAtA[i:], m.ParentStartKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ParentStartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FromManualSplit {
		i--
		if m.FromManualSplit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BulkEvents != nil {
		{
			size, err := m.BulkEvents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DeleteRange != nil {
		{
			size, err := m.DeleteRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SST != nil {
		{
			size, err := m.SST.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MuxRangeFeedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MuxRangeFeedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MuxRangeFeedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StreamID))
		i--
		dAtA[i] = 0x18
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RangeFeedEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResetQuorumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetQuorumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetQuorumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResetQuorumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetQuorumResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetQuorumResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GossipSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Patterns) > 0 {
		for iNdEx := len(m.Patterns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Patterns[iNdEx])
			copy(dAtA[i:], m.Patterns[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Patterns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GossipSubscriptionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipSubscriptionEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipSubscriptionEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PatternMatched) > 0 {
		i -= len(m.PatternMatched)
		copy(dAtA[i:], m.PatternMatched)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PatternMatched)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TenantSettingsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantSettingsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantSettingsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TenantSettingsEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantSettingsEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantSettingsEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterInitGracePeriodEndTS != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ClusterInitGracePeriodEndTS))
		i--
		dAtA[i] = 0x50
	}
	if m.ServiceMode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ServiceMode))
		i--
		dAtA[i] = 0x48
	}
	if m.DataState != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DataState))
		i--
		dAtA[i] = 0x40
	}
	if m.Capabilities != nil {
		{
			size, err := m.Capabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if m.EventType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Overrides) > 0 {
		for iNdEx := len(m.Overrides) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Overrides[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Incremental {
		i--
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Precedence != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Precedence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TenantSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.InternalKey) > 0 {
		i -= len(m.InternalKey)
		copy(dAtA[i:], m.InternalKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.InternalKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TenantConsumption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantConsumption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantConsumption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EstimatedCPUSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EstimatedCPUSeconds))))
		i--
		dAtA[i] = 0x71
	}
	if m.CrossRegionNetworkRU != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CrossRegionNetworkRU))))
		i--
		dAtA[i] = 0x69
	}
	if m.WriteBatches != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WriteBatches))
		i--
		dAtA[i] = 0x60
	}
	if m.ReadBatches != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadBatches))
		i--
		dAtA[i] = 0x58
	}
	if m.ExternalIOEgressBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ExternalIOEgressBytes))
		i--
		dAtA[i] = 0x50
	}
	if m.ExternalIOIngressBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ExternalIOIngressBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.KVRU != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.KVRU))))
		i--
		dAtA[i] = 0x41
	}
	if m.PGWireEgressBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PGWireEgressBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.SQLPodsCPUSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SQLPodsCPUSeconds))))
		i--
		dAtA[i] = 0x31
	}
	if m.WriteBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WriteBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.WriteRequests != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WriteRequests))
		i--
		dAtA[i] = 0x20
	}
	if m.ReadBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadRequests != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadRequests))
		i--
		dAtA[i] = 0x10
	}
	if m.RU != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RU))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TenantConsumptionRates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantConsumptionRates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantConsumptionRates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EstimatedCPURate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EstimatedCPURate))))
		i--
		dAtA[i] = 0x11
	}
	if m.WriteBatchRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WriteBatchRate))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TokenBucketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenBucketRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenBucketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsumptionPeriod != 0 {
		n333, err333 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.ConsumptionPeriod, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.ConsumptionPeriod):])
		if err333 != nil {
			return 0, err333
		}
		i -= n333
		i = encodeVarintApi(dAtA, i, uint64(n333))
		i--
		dAtA[i] = 0x4a
	}
	if m.NextLiveInstanceID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NextLiveInstanceID))
		i--
		dAtA[i] = 0x40
	}
	if m.SeqNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x38
	}
	if m.TargetRequestPeriod != 0 {
		n334, err334 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TargetRequestPeriod, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TargetRequestPeriod):])
		if err334 != nil {
			return 0, err334
		}
		i -= n334
		i = encodeVarintApi(dAtA, i, uint64(n334))
		i--
		dAtA[i] = 0x32
	}
	if m.RequestedTokens != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RequestedTokens))))
		i--
		dAtA[i] = 0x29
	}
	if len(m.InstanceLease) > 0 {
		i -= len(m.InstanceLease)
		copy(dAtA[i:], m.InstanceLease)
		i = encodeVarintApi(dAtA, i, uint64(len(m.InstanceLease)))
		i--
		dAtA[i] = 0x22
	}
	if m.InstanceID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.InstanceID))
		i--
		dAtA[i] = 0x18
	}
	if m.TenantID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ConsumptionSinceLastRequest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TokenBucketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenBucketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenBucketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ConsumptionRates.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.FallbackRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FallbackRate))))
		i--
		dAtA[i] = 0x21
	}
	if m.TrickleDuration != 0 {
		n337, err337 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TrickleDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TrickleDuration):])
		if err337 != nil {
			return 0, err337
		}
		i -= n337
		i = encodeVarintApi(dAtA, i, uint64(n337))
		i--
		dAtA[i] = 0x1a
	}
	if m.GrantedTokens != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GrantedTokens))))
		i--
		dAtA[i] = 0x11
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *JoinNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BinaryVersion != nil {
		{
			size, err := m.BinaryVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JoinNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveVersion != nil {
		{
			size, err := m.ActiveVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StoreID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRangeDescriptorsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRangeDescriptorsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRangeDescriptorsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BatchSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetRangeDescriptorsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRangeDescriptorsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRangeDescriptorsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeDescriptors) > 0 {
		for iNdEx := len(m.RangeDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeDescriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContentionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentionEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentionEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLatch {
		i--
		if m.IsLatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Duration != 0 {
		n342, err342 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Duration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Duration):])
		if err342 != nil {
			return 0, err342
		}
		i -= n342
		i = encodeVarintApi(dAtA, i, uint64(n342))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.TxnMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeparatedPointValueReaderCacheMisses != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeparatedPointValueReaderCacheMisses))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.SeparatedPointValueCountFetched != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeparatedPointValueCountFetched))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.NodeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.BlockReadDuration != 0 {
		n344, err344 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.BlockReadDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.BlockReadDuration):])
		if err344 != nil {
			return 0, err344
		}
		i -= n344
		i = encodeVarintApi(dAtA, i, uint64(n344))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.NumReverseScans != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumReverseScans))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NumScans != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumScans))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.NumGets != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumGets))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SeparatedPointValueBytesFetched != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeparatedPointValueBytesFetched))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SeparatedPointValueBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeparatedPointValueBytes))
		i--
		dAtA[i] = 0x78
	}
	if m.SeparatedPointCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SeparatedPointCount))
		i--
		dAtA[i] = 0x70
	}
	if m.RangeKeySkippedPoints != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeKeySkippedPoints))
		i--
		dAtA[i] = 0x68
	}
	if m.RangeKeyContainedPoints != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeKeyContainedPoints))
		i--
		dAtA[i] = 0x60
	}
	if m.RangeKeyCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeKeyCount))
		i--
		dAtA[i] = 0x58
	}
	if m.PointsCoveredByRangeTombstones != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PointsCoveredByRangeTombstones))
		i--
		dAtA[i] = 0x50
	}
	if m.PointCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PointCount))
		i--
		dAtA[i] = 0x48
	}
	if m.ValueBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ValueBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.KeyBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.BlockBytesInCache != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BlockBytesInCache))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BlockBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.NumInternalSteps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumInternalSteps))
		i--
		dAtA[i] = 0x20
	}
	if m.NumInterfaceSteps != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumInterfaceSteps))
		i--
		dAtA[i] = 0x18
	}
	if m.NumInternalSeeks != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumInternalSeeks))
		i--
		dAtA[i] = 0x10
	}
	if m.NumInterfaceSeeks != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumInterfaceSeeks))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UsedFollowerRead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsedFollowerRead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsedFollowerRead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovApi(uint64(m.Sequence))
	}
	// Field has gogoproto.omitempty set.
	if !m.KVNemesisSeq.IsEmpty() {
		l = m.KVNemesisSeq.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RequestHeader_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ResumeSpan != nil {
		l = m.ResumeSpan.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NumKeys != 0 {
		n += 1 + sovApi(uint64(m.NumKeys))
	}
	if m.ResumeReason != 0 {
		n += 1 + sovApi(uint64(m.ResumeReason))
	}
	if m.NumBytes != 0 {
		n += 1 + sovApi(uint64(m.NumBytes))
	}
	if m.ResumeNextBytes != 0 {
		n += 1 + sovApi(uint64(m.ResumeNextBytes))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.KeyLockingStrength != 0 {
		n += 1 + sovApi(uint64(m.KeyLockingStrength))
	}
	if m.KeyLockingDurability != 0 {
		n += 1 + sovApi(uint64(m.KeyLockingDurability))
	}
	if m.ReturnRawMVCCValues {
		n += 2
	}
	if m.LockNonExisting {
		n += 2
	}
	l = m.ExpectExclusionSince.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IntentValue != nil {
		l = m.IntentValue.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ProbeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ProbeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *IsSpanEmptyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *IsSpanEmptyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *PutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Inline {
		n += 2
	}
	if m.Blind {
		n += 2
	}
	if m.MustAcquireExclusiveLock {
		n += 2
	}
	l = m.ExpectExclusionSince.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *PutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ConditionalPutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Blind {
		n += 2
	}
	if m.AllowIfDoesNotExist {
		n += 2
	}
	l = len(m.ExpBytes)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Inline {
		n += 2
	}
	l = m.OriginTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ConditionalPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *IncrementRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Increment != 0 {
		n += 1 + sovApi(uint64(m.Increment))
	}
	return n
}

func (m *IncrementResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.NewValue != 0 {
		n += 1 + sovApi(uint64(m.NewValue))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MustAcquireExclusiveLock {
		n += 2
	}
	l = m.ExpectExclusionSince.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.FoundKey {
		n += 2
	}
	return n
}

func (m *DeleteRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ReturnKeys {
		n += 2
	}
	if m.Inline {
		n += 2
	}
	if m.UseRangeTombstone {
		n += 2
	}
	l = m.Predicates.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.IdempotentTombstone {
		n += 2
	}
	if m.UpdateRangeDeleteGCHint {
		n += 2
	}
	return n
}

func (m *DeleteRangePredicates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImportEpoch != 0 {
		n += 1 + sovApi(uint64(m.ImportEpoch))
	}
	l = m.StartTime.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *DeleteRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ClearRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Deadline.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ClearRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RevertRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.TargetTime.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.IgnoreGcThreshold {
		n += 2
	}
	return n
}

func (m *RevertRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ScanFormat != 0 {
		n += 1 + sovApi(uint64(m.ScanFormat))
	}
	if m.KeyLockingStrength != 0 {
		n += 1 + sovApi(uint64(m.KeyLockingStrength))
	}
	if m.KeyLockingDurability != 0 {
		n += 1 + sovApi(uint64(m.KeyLockingDurability))
	}
	if m.ReturnRawMVCCValues {
		n += 2
	}
	return n
}

func (m *ScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.IntentRows) > 0 {
		for _, e := range m.IntentRows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BatchResponses) > 0 {
		for _, b := range m.BatchResponses {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.ColBatches.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ExciseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ExciseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ReverseScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ScanFormat != 0 {
		n += 1 + sovApi(uint64(m.ScanFormat))
	}
	if m.KeyLockingStrength != 0 {
		n += 1 + sovApi(uint64(m.KeyLockingStrength))
	}
	if m.KeyLockingDurability != 0 {
		n += 1 + sovApi(uint64(m.KeyLockingDurability))
	}
	if m.ReturnRawMVCCValues {
		n += 2
	}
	return n
}

func (m *ReverseScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.IntentRows) > 0 {
		for _, e := range m.IntentRows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BatchResponses) > 0 {
		for _, b := range m.BatchResponses {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.ColBatches.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *CheckConsistencyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Mode != 0 {
		n += 1 + sovApi(uint64(m.Mode))
	}
	return n
}

func (m *CheckConsistencyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *CheckConsistencyResponse_Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RecomputeStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DryRun {
		n += 2
	}
	return n
}

func (m *RecomputeStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.AddedDelta.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *EndTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Commit {
		n += 2
	}
	l = m.Deadline.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.InternalCommitTrigger != nil {
		l = m.InternalCommitTrigger.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.LockSpans) > 0 {
		for _, e := range m.LockSpans {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Require1PC {
		n += 2
	}
	if m.Poison {
		n += 2
	}
	if m.Disable1PC {
		n += 2
	}
	if m.Prepare {
		n += 2
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *EndTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.OnePhaseCommit {
		n += 2
	}
	l = m.StagingTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.ReplicatedLocalLocksReleasedOnCommit) > 0 {
		for _, e := range m.ReplicatedLocalLocksReleasedOnCommit {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.ExpirationTime.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.PredicateKeys) > 0 {
		for _, b := range m.PredicateKeys {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminUnsplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminUnsplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminMergeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminMergeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminTransferLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Target != 0 {
		n += 1 + sovApi(uint64(m.Target))
	}
	if m.BypassSafetyChecks {
		n += 2
	}
	return n
}

func (m *AdminTransferLeaseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ReplicationChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovApi(uint64(m.ChangeType))
	}
	l = m.Target.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminChangeReplicasRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DeprecatedChangeType != 0 {
		n += 1 + sovApi(uint64(m.DeprecatedChangeType))
	}
	if len(m.DeprecatedTargets) > 0 {
		for _, e := range m.DeprecatedTargets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.ExpDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.InternalChanges) > 0 {
		for _, e := range m.InternalChanges {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminChangeReplicasResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Desc.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminRelocateRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.VoterTargets) > 0 {
		for _, e := range m.VoterTargets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.NonVoterTargets) > 0 {
		for _, e := range m.NonVoterTargets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.TransferLeaseToFirstVoter {
		n += 2
	}
	if m.TransferLeaseToFirstVoterAccurate {
		n += 2
	}
	return n
}

func (m *AdminRelocateRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *HeartbeatTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Now.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *HeartbeatTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.Threshold.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.RangeKeys) > 0 {
		for _, e := range m.RangeKeys {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.ClearRange != nil {
		l = m.ClearRange.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GCRequest_GCKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCRequest_GCRangeKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCRequest_GCClearRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.StartKeyTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *PushTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PusherTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PusheeTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PushTo.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.PushType != 0 {
		n += 1 + sovApi(uint64(m.PushType))
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *PushTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PusheeTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.AmbiguousAbort {
		n += 2
	}
	return n
}

func (m *RecoverTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ImplicitlyCommitted {
		n += 2
	}
	return n
}

func (m *RecoverTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RecoveredTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *QueryTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.WaitForUpdate {
		n += 2
	}
	if len(m.KnownWaitingTxns) > 0 {
		for _, e := range m.KnownWaitingTxns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *QueryTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.QueriedTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.WaitingTxns) > 0 {
		for _, e := range m.WaitingTxns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.TxnRecordExists {
		n += 2
	}
	return n
}

func (m *QueryIntentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ErrorIfMissing {
		n += 2
	}
	if m.Strength != 0 {
		n += 1 + sovApi(uint64(m.Strength))
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *QueryIntentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.FoundUnpushedIntent {
		n += 2
	}
	if m.FoundIntent {
		n += 2
	}
	return n
}

func (m *QueryLocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.IncludeUncontended {
		n += 2
	}
	return n
}

func (m *QueryLocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ResolveIntentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.IntentTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Poison {
		n += 2
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.ClockWhilePending.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ResolveIntentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ReplicatedLocksReleasedCommitTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ResolveIntentRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.IntentTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Poison {
		n += 2
	}
	l = m.MinTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.ClockWhilePending.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ResolveIntentRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ReplicatedLocksReleasedCommitTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *MergeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *MergeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *TruncateLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	if m.ExpectedFirstIndex != 0 {
		n += 1 + sovApi(uint64(m.ExpectedFirstIndex))
	}
	return n
}

func (m *TruncateLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RequestLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PrevLease.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.RevokePrevAndForwardExpiration {
		n += 2
	}
	return n
}

func (m *TransferLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PrevLease.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.BypassSafetyChecks {
		n += 2
	}
	return n
}

func (m *LeaseInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *LeaseInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.CurrentLease != nil {
		l = m.CurrentLease.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EvaluatedBy != 0 {
		n += 1 + sovApi(uint64(m.EvaluatedBy))
	}
	return n
}

func (m *RequestLeaseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ComputeChecksumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.Mode != 0 {
		n += 1 + sovApi(uint64(m.Mode))
	}
	if m.Checkpoint {
		n += 2
	}
	if len(m.Terminate) > 0 {
		for _, e := range m.Terminate {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ComputeChecksumResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ChecksumID.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RetryTracingEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AttemptNumber != 0 {
		n += 1 + sovApi(uint64(m.AttemptNumber))
	}
	l = len(m.RetryError)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *FileEncryptionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ExportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.StartTime.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MVCCFilter != 0 {
		n += 1 + sovApi(uint64(m.MVCCFilter))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TargetFileSize != 0 {
		n += 1 + sovApi(uint64(m.TargetFileSize))
	}
	l = m.ResumeKeyTS.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.SplitMidKey {
		n += 2
	}
	if m.ExportFingerprint {
		n += 2
	}
	l = m.FingerprintOptions.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.IncludeMVCCValueHeader {
		n += 3
	}
	return n
}

func (m *FingerprintOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StripIndexPrefixAndTimestamp {
		n += 2
	}
	return n
}

func (m *BulkOpSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataSize != 0 {
		n += 1 + sovApi(uint64(m.DataSize))
	}
	if len(m.EntryCounts) > 0 {
		for k, v := range m.EntryCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.SSTDataSize != 0 {
		n += 1 + sovApi(uint64(m.SSTDataSize))
	}
	return n
}

func (m *ExportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.StartTime.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ExportResponse_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Exported.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.SST)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LocalityKV)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.EndKeyTS.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Fingerprint != 0 {
		n += 1 + sovApi(uint64(m.Fingerprint))
	}
	return n
}

func (m *AdminScatterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.RandomizeLeases {
		n += 2
	}
	if m.MaxSize != 0 {
		n += 1 + sovApi(uint64(m.MaxSize))
	}
	return n
}

func (m *AdminScatterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.RangeInfos) > 0 {
		for _, e := range m.RangeInfos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.MVCCStats.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ReplicasScatteredBytes != 0 {
		n += 1 + sovApi(uint64(m.ReplicasScatteredBytes))
	}
	return n
}

func (m *AdminScatterResponse_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AddSSTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MVCCStats != nil {
		l = m.MVCCStats.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IngestAsWrites {
		n += 2
	}
	l = m.SSTTimestampToRequestTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DisallowConflicts {
		n += 2
	}
	l = m.DisallowShadowingBelow.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ReturnFollowingLikelyNonEmptySpanStart {
		n += 2
	}
	l = m.IgnoreKeysAboveTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ComputeStatsDiff {
		n += 2
	}
	return n
}

func (m *AddSSTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RangeSpan.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.AvailableBytes != 0 {
		n += 1 + sovApi(uint64(m.AvailableBytes))
	}
	l = len(m.FollowingLikelyNonEmptySpanStart)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *LinkExternalSSTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ExternalFile.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *LinkExternalSSTableRequest_ExternalFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Locator)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BackingFileSize != 0 {
		n += 1 + sovApi(uint64(m.BackingFileSize))
	}
	if m.ApproximatePhysicalSize != 0 {
		n += 1 + sovApi(uint64(m.ApproximatePhysicalSize))
	}
	l = len(m.SyntheticPrefix)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UseSyntheticSuffix {
		n += 2
	}
	if m.MVCCStats != nil {
		l = m.MVCCStats.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *LinkExternalSSTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RefreshFrom.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RefreshFrom.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *SubsumeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.LeftDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.PreserveUnreplicatedLocks {
		n += 2
	}
	return n
}

func (m *SubsumeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.MVCCStats.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.LeaseAppliedIndex != 0 {
		n += 1 + sovApi(uint64(m.LeaseAppliedIndex))
	}
	l = m.FreezeStart.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ClosedTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ReadSummary != nil {
		l = m.ReadSummary.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.RangeIDLocalMVCCStats.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.MVCCStats.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RangeInfo.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MaxQueriesPerSecond != 0 {
		n += 9
	}
	if m.MaxQueriesPerSecondSet {
		n += 2
	}
	if m.MaxCPUPerSecond != 0 {
		n += 9
	}
	return n
}

func (m *MigrateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Version.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *MigrateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *QueryResolvedTimestampRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *QueryResolvedTimestampResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ResolvedTS.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *BarrierRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.WithLeaseAppliedIndex {
		n += 2
	}
	return n
}

func (m *BarrierResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.LeaseAppliedIndex != 0 {
		n += 1 + sovApi(uint64(m.LeaseAppliedIndex))
	}
	l = m.RangeDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *FlushLockTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *FlushLockTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.LocksWritten != 0 {
		n += 1 + sovApi(uint64(m.LocksWritten))
	}
	return n
}

func (m *RequestUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *RequestUnion_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ConditionalPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Increment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_DeleteRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Scan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_EndTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndTxn != nil {
		l = m.EndTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminSplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminSplit != nil {
		l = m.AdminSplit.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminMerge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminMerge != nil {
		l = m.AdminMerge.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_HeartbeatTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeartbeatTxn != nil {
		l = m.HeartbeatTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Gc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gc != nil {
		l = m.Gc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_PushTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PushTxn != nil {
		l = m.PushTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ResolveIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntent != nil {
		l = m.ResolveIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ResolveIntentRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntentRange != nil {
		l = m.ResolveIntentRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_TruncateLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateLog != nil {
		l = m.TruncateLog.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RequestLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestLease != nil {
		l = m.RequestLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ReverseScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReverseScan != nil {
		l = m.ReverseScan.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ComputeChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ComputeChecksum != nil {
		l = m.ComputeChecksum.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_CheckConsistency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConsistency != nil {
		l = m.CheckConsistency.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_TransferLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransferLease != nil {
		l = m.TransferLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminTransferLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminTransferLease != nil {
		l = m.AdminTransferLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_LeaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaseInfo != nil {
		l = m.LeaseInfo.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Export) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Export != nil {
		l = m.Export.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_QueryTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryTxn != nil {
		l = m.QueryTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminChangeReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminChangeReplicas != nil {
		l = m.AdminChangeReplicas.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminScatter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminScatter != nil {
		l = m.AdminScatter.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AddSstable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddSstable != nil {
		l = m.AddSstable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ClearRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearRange != nil {
		l = m.ClearRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RecomputeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecomputeStats != nil {
		l = m.RecomputeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Refresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refresh != nil {
		l = m.Refresh.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RefreshRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefreshRange != nil {
		l = m.RefreshRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_QueryIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryIntent != nil {
		l = m.QueryIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Subsume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subsume != nil {
		l = m.Subsume.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RangeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeStats != nil {
		l = m.RangeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminRelocateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminRelocateRange != nil {
		l = m.AdminRelocateRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RecoverTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecoverTxn != nil {
		l = m.RecoverTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminUnsplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminUnsplit != nil {
		l = m.AdminUnsplit.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RevertRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevertRange != nil {
		l = m.RevertRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Migrate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Migrate != nil {
		l = m.Migrate.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_QueryResolvedTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryResolvedTimestamp != nil {
		l = m.QueryResolvedTimestamp.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Barrier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Barrier != nil {
		l = m.Barrier.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Probe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Probe != nil {
		l = m.Probe.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_QueryLocks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryLocks != nil {
		l = m.QueryLocks.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_IsSpanEmpty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSpanEmpty != nil {
		l = m.IsSpanEmpty.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_LinkExternalSstable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkExternalSstable != nil {
		l = m.LinkExternalSstable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Excise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Excise != nil {
		l = m.Excise.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_FlushLockTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlushLockTable != nil {
		l = m.FlushLockTable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ResponseUnion_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ConditionalPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Increment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_DeleteRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Scan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_EndTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndTxn != nil {
		l = m.EndTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminSplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminSplit != nil {
		l = m.AdminSplit.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminMerge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminMerge != nil {
		l = m.AdminMerge.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_HeartbeatTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeartbeatTxn != nil {
		l = m.HeartbeatTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Gc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gc != nil {
		l = m.Gc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_PushTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PushTxn != nil {
		l = m.PushTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ResolveIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntent != nil {
		l = m.ResolveIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ResolveIntentRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntentRange != nil {
		l = m.ResolveIntentRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_TruncateLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateLog != nil {
		l = m.TruncateLog.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RequestLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestLease != nil {
		l = m.RequestLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ReverseScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReverseScan != nil {
		l = m.ReverseScan.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ComputeChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ComputeChecksum != nil {
		l = m.ComputeChecksum.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_CheckConsistency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConsistency != nil {
		l = m.CheckConsistency.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminTransferLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminTransferLease != nil {
		l = m.AdminTransferLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_LeaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaseInfo != nil {
		l = m.LeaseInfo.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Export) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Export != nil {
		l = m.Export.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_QueryTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryTxn != nil {
		l = m.QueryTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminChangeReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminChangeReplicas != nil {
		l = m.AdminChangeReplicas.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminScatter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminScatter != nil {
		l = m.AdminScatter.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AddSstable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddSstable != nil {
		l = m.AddSstable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ClearRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearRange != nil {
		l = m.ClearRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RecomputeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecomputeStats != nil {
		l = m.RecomputeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Refresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refresh != nil {
		l = m.Refresh.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RefreshRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefreshRange != nil {
		l = m.RefreshRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_QueryIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryIntent != nil {
		l = m.QueryIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Subsume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subsume != nil {
		l = m.Subsume.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RangeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeStats != nil {
		l = m.RangeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminRelocateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminRelocateRange != nil {
		l = m.AdminRelocateRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RecoverTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecoverTxn != nil {
		l = m.RecoverTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminUnsplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminUnsplit != nil {
		l = m.AdminUnsplit.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RevertRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevertRange != nil {
		l = m.RevertRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Migrate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Migrate != nil {
		l = m.Migrate.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_QueryResolvedTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryResolvedTimestamp != nil {
		l = m.QueryResolvedTimestamp.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Barrier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Barrier != nil {
		l = m.Barrier.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Probe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Probe != nil {
		l = m.Probe.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_QueryLocks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryLocks != nil {
		l = m.QueryLocks.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_IsSpanEmpty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSpanEmpty != nil {
		l = m.IsSpanEmpty.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_LinkExternalSstable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkExternalSstable != nil {
		l = m.LinkExternalSstable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Excise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Excise != nil {
		l = m.Excise.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_FlushLockTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlushLockTable != nil {
		l = m.FlushLockTable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Replica.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	if m.UserPriority != 0 {
		n += 9
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ReadConsistency != 0 {
		n += 1 + sovApi(uint64(m.ReadConsistency))
	}
	if m.MaxSpanRequestKeys != 0 {
		n += 1 + sovApi(uint64(m.MaxSpanRequestKeys))
	}
	if m.DistinctSpans {
		n += 2
	}
	if m.GatewayNodeID != 0 {
		n += 1 + sovApi(uint64(m.GatewayNodeID))
	}
	if m.AsyncConsensus {
		n += 2
	}
	if m.TargetBytes != 0 {
		n += 1 + sovApi(uint64(m.TargetBytes))
	}
	if m.CanForwardReadTimestamp {
		n += 3
	}
	l = m.ClientRangeInfo.Size()
	n += 2 + l + sovApi(uint64(l))
	if m.WaitPolicy != 0 {
		n += 2 + sovApi(uint64(m.WaitPolicy))
	}
	if m.RoutingPolicy != 0 {
		n += 2 + sovApi(uint64(m.RoutingPolicy))
	}
	if m.LockTimeout != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.LockTimeout)
		n += 2 + l + sovApi(uint64(l))
	}
	if m.BoundedStaleness != nil {
		l = m.BoundedStaleness.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.AllowEmpty {
		n += 3
	}
	if m.TraceInfo != nil {
		l = m.TraceInfo.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.WholeRowsOfSize != 0 {
		n += 2 + sovApi(uint64(m.WholeRowsOfSize))
	}
	if m.TimestampFromServerClock != nil {
		l = m.TimestampFromServerClock.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	l = m.Now.Size()
	n += 2 + l + sovApi(uint64(l))
	if m.IndexFetchSpec != nil {
		l = m.IndexFetchSpec.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ReturnElasticCPUResumeSpans {
		n += 3
	}
	if len(m.ProfileLabels) > 0 {
		for _, s := range m.ProfileLabels {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.AmbiguousReplayProtection {
		n += 3
	}
	if m.ConnectionClass != 0 {
		n += 2 + sovApi(uint64(m.ConnectionClass))
	}
	if m.ProxyRangeInfo != nil {
		l = m.ProxyRangeInfo.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.WriteOptions != nil {
		l = m.WriteOptions.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.DeadlockTimeout != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeadlockTimeout)
		n += 2 + l + sovApi(uint64(l))
	}
	if m.HasBufferedAllPrecedingWrites {
		n += 3
	}
	if m.IsReverse {
		n += 3
	}
	return n
}

func (m *WriteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OriginID != 0 {
		n += 1 + sovApi(uint64(m.OriginID))
	}
	l = m.OriginTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *BoundedStalenessHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MinTimestampBound.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MinTimestampBoundStrict {
		n += 2
	}
	l = m.MaxTimestampBound.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdmissionHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovApi(uint64(m.Priority))
	}
	if m.CreateTime != 0 {
		n += 1 + sovApi(uint64(m.CreateTime))
	}
	if m.Source != 0 {
		n += 1 + sovApi(uint64(m.Source))
	}
	if m.SourceLocation != 0 {
		n += 1 + sovApi(uint64(m.SourceLocation))
	}
	if m.NoMemoryReservedAtSource {
		n += 2
	}
	return n
}

func (m *BatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.AdmissionHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *BatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BatchResponse_Header.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *BatchResponse_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Now.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.CollectedSpans) > 0 {
		for _, e := range m.CollectedSpans {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RangeInfos) > 0 {
		for _, e := range m.RangeInfos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *RangeLookupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ReadConsistency != 0 {
		n += 1 + sovApi(uint64(m.ReadConsistency))
	}
	if m.PrefetchNum != 0 {
		n += 1 + sovApi(uint64(m.PrefetchNum))
	}
	if m.PrefetchReverse {
		n += 2
	}
	return n
}

func (m *RangeLookupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.PrefetchedDescriptors) > 0 {
		for _, e := range m.PrefetchedDescriptors {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RangeFeedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.WithDiff {
		n += 2
	}
	l = m.AdmissionHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.StreamID != 0 {
		n += 1 + sovApi(uint64(m.StreamID))
	}
	if m.CloseStream {
		n += 2
	}
	if m.WithFiltering {
		n += 2
	}
	if len(m.WithMatchingOriginIDs) > 0 {
		l = 0
		for _, e := range m.WithMatchingOriginIDs {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.ConsumerID != 0 {
		n += 1 + sovApi(uint64(m.ConsumerID))
	}
	if m.WithBulkDelivery {
		n += 2
	}
	return n
}

func (m *RangeFeedValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PrevValue.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedBulkEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *RangeFeedCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ResolvedTS.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedSSTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.WriteTS.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedDeleteRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.FromManualSplit {
		n += 2
	}
	l = len(m.ParentStartKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RangeFeedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SST != nil {
		l = m.SST.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BulkEvents != nil {
		l = m.BulkEvents.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *MuxRangeFeedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RangeFeedEvent.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	if m.StreamID != 0 {
		n += 1 + sovApi(uint64(m.StreamID))
	}
	return n
}

func (m *ResetQuorumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	return n
}

func (m *ResetQuorumResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GossipSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Patterns) > 0 {
		for _, s := range m.Patterns {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GossipSubscriptionEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Content.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.PatternMatched)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TenantSettingsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TenantID.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *TenantSettingsEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Precedence != 0 {
		n += 1 + sovApi(uint64(m.Precedence))
	}
	if m.Incremental {
		n += 2
	}
	if len(m.Overrides) > 0 {
		for _, e := range m.Overrides {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.Error.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Capabilities != nil {
		l = m.Capabilities.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DataState != 0 {
		n += 1 + sovApi(uint64(m.DataState))
	}
	if m.ServiceMode != 0 {
		n += 1 + sovApi(uint64(m.ServiceMode))
	}
	if m.ClusterInitGracePeriodEndTS != 0 {
		n += 1 + sovApi(uint64(m.ClusterInitGracePeriodEndTS))
	}
	return n
}

func (m *TenantSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InternalKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *TenantConsumption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RU != 0 {
		n += 9
	}
	if m.ReadRequests != 0 {
		n += 1 + sovApi(uint64(m.ReadRequests))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovApi(uint64(m.ReadBytes))
	}
	if m.WriteRequests != 0 {
		n += 1 + sovApi(uint64(m.WriteRequests))
	}
	if m.WriteBytes != 0 {
		n += 1 + sovApi(uint64(m.WriteBytes))
	}
	if m.SQLPodsCPUSeconds != 0 {
		n += 9
	}
	if m.PGWireEgressBytes != 0 {
		n += 1 + sovApi(uint64(m.PGWireEgressBytes))
	}
	if m.KVRU != 0 {
		n += 9
	}
	if m.ExternalIOIngressBytes != 0 {
		n += 1 + sovApi(uint64(m.ExternalIOIngressBytes))
	}
	if m.ExternalIOEgressBytes != 0 {
		n += 1 + sovApi(uint64(m.ExternalIOEgressBytes))
	}
	if m.ReadBatches != 0 {
		n += 1 + sovApi(uint64(m.ReadBatches))
	}
	if m.WriteBatches != 0 {
		n += 1 + sovApi(uint64(m.WriteBatches))
	}
	if m.CrossRegionNetworkRU != 0 {
		n += 9
	}
	if m.EstimatedCPUSeconds != 0 {
		n += 9
	}
	return n
}

func (m *TenantConsumptionRates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WriteBatchRate != 0 {
		n += 9
	}
	if m.EstimatedCPURate != 0 {
		n += 9
	}
	return n
}

func (m *TokenBucketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ConsumptionSinceLastRequest.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.TenantID != 0 {
		n += 1 + sovApi(uint64(m.TenantID))
	}
	if m.InstanceID != 0 {
		n += 1 + sovApi(uint64(m.InstanceID))
	}
	l = len(m.InstanceLease)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RequestedTokens != 0 {
		n += 9
	}
	if m.TargetRequestPeriod != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TargetRequestPeriod)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovApi(uint64(m.SeqNum))
	}
	if m.NextLiveInstanceID != 0 {
		n += 1 + sovApi(uint64(m.NextLiveInstanceID))
	}
	if m.ConsumptionPeriod != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.ConsumptionPeriod)
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TokenBucketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.GrantedTokens != 0 {
		n += 9
	}
	if m.TrickleDuration != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TrickleDuration)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FallbackRate != 0 {
		n += 9
	}
	l = m.ConsumptionRates.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *JoinNodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinaryVersion != nil {
		l = m.BinaryVersion.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *JoinNodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NodeID != 0 {
		n += 1 + sovApi(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovApi(uint64(m.StoreID))
	}
	if m.ActiveVersion != nil {
		l = m.ActiveVersion.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetRangeDescriptorsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.BatchSize != 0 {
		n += 1 + sovApi(uint64(m.BatchSize))
	}
	return n
}

func (m *GetRangeDescriptorsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RangeDescriptors) > 0 {
		for _, e := range m.RangeDescriptors {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ContentionEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.TxnMeta.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Duration != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Duration)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsLatch {
		n += 2
	}
	return n
}

func (m *ScanStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumInterfaceSeeks != 0 {
		n += 1 + sovApi(uint64(m.NumInterfaceSeeks))
	}
	if m.NumInternalSeeks != 0 {
		n += 1 + sovApi(uint64(m.NumInternalSeeks))
	}
	if m.NumInterfaceSteps != 0 {
		n += 1 + sovApi(uint64(m.NumInterfaceSteps))
	}
	if m.NumInternalSteps != 0 {
		n += 1 + sovApi(uint64(m.NumInternalSteps))
	}
	if m.BlockBytes != 0 {
		n += 1 + sovApi(uint64(m.BlockBytes))
	}
	if m.BlockBytesInCache != 0 {
		n += 1 + sovApi(uint64(m.BlockBytesInCache))
	}
	if m.KeyBytes != 0 {
		n += 1 + sovApi(uint64(m.KeyBytes))
	}
	if m.ValueBytes != 0 {
		n += 1 + sovApi(uint64(m.ValueBytes))
	}
	if m.PointCount != 0 {
		n += 1 + sovApi(uint64(m.PointCount))
	}
	if m.PointsCoveredByRangeTombstones != 0 {
		n += 1 + sovApi(uint64(m.PointsCoveredByRangeTombstones))
	}
	if m.RangeKeyCount != 0 {
		n += 1 + sovApi(uint64(m.RangeKeyCount))
	}
	if m.RangeKeyContainedPoints != 0 {
		n += 1 + sovApi(uint64(m.RangeKeyContainedPoints))
	}
	if m.RangeKeySkippedPoints != 0 {
		n += 1 + sovApi(uint64(m.RangeKeySkippedPoints))
	}
	if m.SeparatedPointCount != 0 {
		n += 1 + sovApi(uint64(m.SeparatedPointCount))
	}
	if m.SeparatedPointValueBytes != 0 {
		n += 1 + sovApi(uint64(m.SeparatedPointValueBytes))
	}
	if m.SeparatedPointValueBytesFetched != 0 {
		n += 2 + sovApi(uint64(m.SeparatedPointValueBytesFetched))
	}
	if m.NumGets != 0 {
		n += 2 + sovApi(uint64(m.NumGets))
	}
	if m.NumScans != 0 {
		n += 2 + sovApi(uint64(m.NumScans))
	}
	if m.NumReverseScans != 0 {
		n += 2 + sovApi(uint64(m.NumReverseScans))
	}
	if m.BlockReadDuration != 0 {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.BlockReadDuration)
		n += 2 + l + sovApi(uint64(l))
	}
	if m.NodeID != 0 {
		n += 2 + sovApi(uint64(m.NodeID))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.SeparatedPointValueCountFetched != 0 {
		n += 2 + sovApi(uint64(m.SeparatedPointValueCountFetched))
	}
	if m.SeparatedPointValueReaderCacheMisses != 0 {
		n += 2 + sovApi(uint64(m.SeparatedPointValueReaderCacheMisses))
	}
	return n
}

func (m *UsedFollowerRead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovApi(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RangeFeedEvent) GetValue() interface{} {
	if this.Val != nil {
		return this.Val
	}
	if this.Checkpoint != nil {
		return this.Checkpoint
	}
	if this.Error != nil {
		return this.Error
	}
	if this.SST != nil {
		return this.SST
	}
	if this.DeleteRange != nil {
		return this.DeleteRange
	}
	if this.Metadata != nil {
		return this.Metadata
	}
	if this.BulkEvents != nil {
		return this.BulkEvents
	}
	return nil
}

func (this *RangeFeedEvent) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *RangeFeedValue:
		this.Val = vt
	case *RangeFeedCheckpoint:
		this.Checkpoint = vt
	case *RangeFeedError:
		this.Error = vt
	case *RangeFeedSSTable:
		this.SST = vt
	case *RangeFeedDeleteRange:
		this.DeleteRange = vt
	case *RangeFeedMetadata:
		this.Metadata = vt
	case *RangeFeedBulkEvents:
		this.BulkEvents = vt
	default:
		return false
	}
	return true
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KVNemesisSeq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KVNemesisSeq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestHeader_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &roachpb.Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumeSpan == nil {
				m.ResumeSpan = &roachpb.Span{}
			}
			if err := m.ResumeSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKeys", wireType)
			}
			m.NumKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumKeys |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeReason", wireType)
			}
			m.ResumeReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResumeReason |= ResumeReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeNextBytes", wireType)
			}
			m.ResumeNextBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResumeNextBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLockingStrength", wireType)
			}
			m.KeyLockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLockingStrength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLockingDurability", wireType)
			}
			m.KeyLockingDurability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLockingDurability |= lock.Durability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnRawMVCCValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnRawMVCCValues = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockNonExisting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockNonExisting = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectExclusionSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectExclusionSince.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &roachpb.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntentValue == nil {
				m.IntentValue = &roachpb.Value{}
			}
			if err := m.IntentValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsSpanEmptyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsSpanEmptyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsSpanEmptyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsSpanEmptyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsSpanEmptyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsSpanEmptyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustAcquireExclusiveLock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustAcquireExclusiveLock = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectExclusionSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectExclusionSince.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowIfDoesNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowIfDoesNotExist = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpBytes = append(m.ExpBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExpBytes == nil {
				m.ExpBytes = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			m.Increment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Increment |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValue", wireType)
			}
			m.NewValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustAcquireExclusiveLock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustAcquireExclusiveLock = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectExclusionSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectExclusionSince.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoundKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnKeys = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRangeTombstone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRangeTombstone = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Predicates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdempotentTombstone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IdempotentTombstone = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateRangeDeleteGCHint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateRangeDeleteGCHint = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangePredicates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangePredicates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangePredicates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportEpoch", wireType)
			}
			m.ImportEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImportEpoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deadline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevertRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevertRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevertRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreGcThreshold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreGcThreshold = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevertRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevertRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevertRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanFormat", wireType)
			}
			m.ScanFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanFormat |= ScanFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLockingStrength", wireType)
			}
			m.KeyLockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLockingStrength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLockingDurability", wireType)
			}
			m.KeyLockingDurability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLockingDurability |= lock.Durability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnRawMVCCValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnRawMVCCValues = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, roachpb.KeyValue{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentRows = append(m.IntentRows, roachpb.KeyValue{})
			if err := m.IntentRows[len(m.IntentRows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchResponses = append(m.BatchResponses, make([]byte, postIndex-iNdEx))
			copy(m.BatchResponses[len(m.BatchResponses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColBatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ColBatches.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExciseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExciseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExciseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExciseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExciseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExciseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReverseScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReverseScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReverseScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanFormat", wireType)
			}
			m.ScanFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanFormat |= ScanFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLockingStrength", wireType)
			}
			m.KeyLockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLockingStrength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLockingDurability", wireType)
			}
			m.KeyLockingDurability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLockingDurability |= lock.Durability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnRawMVCCValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnRawMVCCValues = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReverseScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReverseScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReverseScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, roachpb.KeyValue{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentRows = append(m.IntentRows, roachpb.KeyValue{})
			if err := m.IntentRows[len(m.IntentRows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchResponses = append(m.BatchResponses, make([]byte, postIndex-iNdEx))
			copy(m.BatchResponses[len(m.BatchResponses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColBatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ColBatches.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConsistencyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConsistencyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConsistencyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ChecksumMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConsistencyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConsistencyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConsistencyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, CheckConsistencyResponse_Result{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConsistencyResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CheckConsistencyResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecomputeStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecomputeStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecomputeStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecomputeStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecomputeStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecomputeStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddedDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Commit = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deadline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalCommitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalCommitTrigger == nil {
				m.InternalCommitTrigger = &roachpb.InternalCommitTrigger{}
			}
			if err := m.InternalCommitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockSpans = append(m.LockSpans, roachpb.Span{})
			if err := m.LockSpans[len(m.LockSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Require1PC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Require1PC = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poison = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable1PC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable1PC = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prepare = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, roachpb.SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnePhaseCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnePhaseCommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StagingTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StagingTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedLocalLocksReleasedOnCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicatedLocalLocksReleasedOnCommit = append(m.ReplicatedLocalLocksReleasedOnCommit, roachpb.Span{})
			if err := m.ReplicatedLocalLocksReleasedOnCommit[len(m.ReplicatedLocalLocksReleasedOnCommit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpirationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateKeys = append(m.PredicateKeys, make([]byte, postIndex-iNdEx))
			copy(m.PredicateKeys[len(m.PredicateKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminUnsplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminUnsplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminUnsplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminUnsplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminUnsplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminUnsplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminMergeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminMergeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminMergeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminMergeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminMergeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminMergeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminTransferLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminTransferLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminTransferLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassSafetyChecks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BypassSafetyChecks = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminTransferLeaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminTransferLeaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminTransferLeaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= roachpb.ReplicaChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminChangeReplicasRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminChangeReplicasRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminChangeReplicasRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedChangeType", wireType)
			}
			m.DeprecatedChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedChangeType |= roachpb.ReplicaChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedTargets = append(m.DeprecatedTargets, roachpb.ReplicationTarget{})
			if err := m.DeprecatedTargets[len(m.DeprecatedTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalChanges = append(m.InternalChanges, ReplicationChange{})
			if err := m.InternalChanges[len(m.InternalChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminChangeReplicasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminChangeReplicasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminChangeReplicasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminRelocateRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminRelocateRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminRelocateRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoterTargets = append(m.VoterTargets, roachpb.ReplicationTarget{})
			if err := m.VoterTargets[len(m.VoterTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonVoterTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonVoterTargets = append(m.NonVoterTargets, roachpb.ReplicationTarget{})
			if err := m.NonVoterTargets[len(m.NonVoterTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeaseToFirstVoter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransferLeaseToFirstVoter = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeaseToFirstVoterAccurate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransferLeaseToFirstVoterAccurate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminRelocateRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminRelocateRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminRelocateRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, GCRequest_GCKey{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeKeys = append(m.RangeKeys, GCRequest_GCRangeKey{})
			if err := m.RangeKeys[len(m.RangeKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClearRange == nil {
				m.ClearRange = &GCRequest_GCClearRange{}
			}
			if err := m.ClearRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest_GCKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest_GCRangeKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCRangeKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCRangeKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest_GCClearRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCClearRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCClearRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKeyTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartKeyTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusherTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusherTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PushTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushType", wireType)
			}
			m.PushType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushType |= PushTxnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbiguousAbort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AmbiguousAbort = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitlyCommitted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitlyCommitted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveredTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecoveredTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitForUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaitForUpdate = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownWaitingTxns", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.KnownWaitingTxns = append(m.KnownWaitingTxns, v)
			if err := m.KnownWaitingTxns[len(m.KnownWaitingTxns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriedTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QueriedTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitingTxns", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.WaitingTxns = append(m.WaitingTxns, v)
			if err := m.WaitingTxns[len(m.WaitingTxns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecordExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxnRecordExists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIntentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIntentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIntentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorIfMissing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorIfMissing = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIntentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIntentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIntentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundUnpushedIntent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoundUnpushedIntent = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundIntent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoundIntent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeUncontended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeUncontended = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, roachpb.LockStateInfo{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntentTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= roachpb.TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poison = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockWhilePending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClockWhilePending.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedLocksReleasedCommitTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicatedLocksReleasedCommitTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntentTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= roachpb.TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poison = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockWhilePending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClockWhilePending.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedLocksReleasedCommitTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicatedLocksReleasedCommitTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedFirstIndex", wireType)
			}
			m.ExpectedFirstIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedFirstIndex |= RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokePrevAndForwardExpiration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RevokePrevAndForwardExpiration = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassSafetyChecks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BypassSafetyChecks = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentLease == nil {
				m.CurrentLease = &roachpb.Lease{}
			}
			if err := m.CurrentLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluatedBy", wireType)
			}
			m.EvaluatedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvaluatedBy |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLeaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLeaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLeaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeChecksumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeChecksumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeChecksumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ChecksumMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkpoint = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terminate = append(m.Terminate, roachpb.ReplicaDescriptor{})
			if err := m.Terminate[len(m.Terminate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeChecksumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeChecksumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeChecksumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChecksumID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryTracingEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryTracingEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryTracingEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttemptNumber", wireType)
			}
			m.AttemptNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttemptNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileEncryptionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileEncryptionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileEncryptionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCFilter", wireType)
			}
			m.MVCCFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MVCCFilter |= MVCCFilter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetFileSize", wireType)
			}
			m.TargetFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeKeyTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResumeKeyTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitMidKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SplitMidKey = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportFingerprint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExportFingerprint = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerprintOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FingerprintOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeMVCCValueHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeMVCCValueHeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FingerprintOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FingerprintOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FingerprintOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripIndexPrefixAndTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripIndexPrefixAndTimestamp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkOpSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkOpSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkOpSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSize", wireType)
			}
			m.DataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EntryCounts == nil {
				m.EntryCounts = make(map[uint64]int64)
			}
			var mapkey uint64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EntryCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTDataSize", wireType)
			}
			m.SSTDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSTDataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, ExportResponse_File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportResponse_File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exported.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SST", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SST = append(m.SST[:0], dAtA[iNdEx:postIndex]...)
			if m.SST == nil {
				m.SST = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityKV", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityKV = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKeyTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndKeyTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			m.Fingerprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fingerprint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminScatterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminScatterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminScatterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomizeLeases", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomizeLeases = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminScatterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminScatterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminScatterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeInfos = append(m.RangeInfos, roachpb.RangeInfo{})
			if err := m.RangeInfos[len(m.RangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasScatteredBytes", wireType)
			}
			m.ReplicasScatteredBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicasScatteredBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminScatterResponse_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddSSTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSSTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSSTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MVCCStats == nil {
				m.MVCCStats = &enginepb.MVCCStats{}
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestAsWrites", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IngestAsWrites = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTTimestampToRequestTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SSTTimestampToRequestTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowConflicts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisallowConflicts = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowShadowingBelow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DisallowShadowingBelow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnFollowingLikelyNonEmptySpanStart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnFollowingLikelyNonEmptySpanStart = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreKeysAboveTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IgnoreKeysAboveTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeStatsDiff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ComputeStatsDiff = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddSSTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSSTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSSTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableBytes", wireType)
			}
			m.AvailableBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowingLikelyNonEmptySpanStart", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FollowingLikelyNonEmptySpanStart = append(m.FollowingLikelyNonEmptySpanStart[:0], dAtA[iNdEx:postIndex]...)
			if m.FollowingLikelyNonEmptySpanStart == nil {
				m.FollowingLikelyNonEmptySpanStart = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkExternalSSTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkExternalSSTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkExternalSSTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExternalFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkExternalSSTableRequest_ExternalFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingFileSize", wireType)
			}
			m.BackingFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackingFileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximatePhysicalSize", wireType)
			}
			m.ApproximatePhysicalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximatePhysicalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyntheticPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyntheticPrefix = append(m.SyntheticPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.SyntheticPrefix == nil {
				m.SyntheticPrefix = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSyntheticSuffix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSyntheticSuffix = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MVCCStats == nil {
				m.MVCCStats = &enginepb.MVCCStats{}
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkExternalSSTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkExternalSSTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkExternalSSTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefreshFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefreshFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubsumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubsumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubsumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreserveUnreplicatedLocks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreserveUnreplicatedLocks = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubsumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubsumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubsumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseAppliedIndex", wireType)
			}
			m.LeaseAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseAppliedIndex |= LeaseAppliedIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreezeStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FreezeStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClosedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadSummary == nil {
				m.ReadSummary = &rspb.ReadSummary{}
			}
			if err := m.ReadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDLocalMVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeIDLocalMVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxQueriesPerSecond = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueriesPerSecondSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxQueriesPerSecondSet = bool(v != 0)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCPUPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxCPUPerSecond = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolvedTimestampRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolvedTimestampRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolvedTimestampRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolvedTimestampResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolvedTimestampResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolvedTimestampResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolvedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BarrierRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BarrierRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BarrierRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithLeaseAppliedIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithLeaseAppliedIndex = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BarrierResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BarrierResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BarrierResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseAppliedIndex", wireType)
			}
			m.LeaseAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseAppliedIndex |= LeaseAppliedIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushLockTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushLockTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushLockTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushLockTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushLockTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushLockTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocksWritten", wireType)
			}
			m.LocksWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocksWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Get
				field GetRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Get = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Put
				field PutRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Put = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_ConditionalPut
				field ConditionalPutRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ConditionalPut = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Increment
				field IncrementRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Increment = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Delete
				field DeleteRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Delete = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_DeleteRange
				field DeleteRangeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DeleteRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Scan
				field ScanRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Scan = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_EndTxn
				field EndTxnRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.EndTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminSplit
				field AdminSplitRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminSplit = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminMerge
				field AdminMergeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminMerge = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_HeartbeatTxn
				field HeartbeatTxnRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.HeartbeatTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Gc
				field GCRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Gc = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_PushTxn
				field PushTxnRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PushTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_ResolveIntent
				field ResolveIntentRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ResolveIntent = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntentRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_ResolveIntentRange
				field ResolveIntentRangeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ResolveIntentRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Merge
				field MergeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Merge = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_TruncateLog
				field TruncateLogRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TruncateLog = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_RequestLease
				field RequestLeaseRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RequestLease = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_ReverseScan
				field ReverseScanRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ReverseScan = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeChecksum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_ComputeChecksum
				field ComputeChecksumRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ComputeChecksum = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_CheckConsistency
				field CheckConsistencyRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CheckConsistency = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_TransferLease
				field TransferLeaseRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TransferLease = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminTransferLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminTransferLease
				field AdminTransferLeaseRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminTransferLease = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_LeaseInfo
				field LeaseInfoRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.LeaseInfo = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Export", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Export
				field ExportRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Export = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_QueryTxn
				field QueryTxnRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminChangeReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminChangeReplicas
				field AdminChangeReplicasRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminChangeReplicas = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminScatter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminScatter
				field AdminScatterRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminScatter = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSstable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AddSstable
				field AddSSTableRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AddSstable = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_ClearRange
				field ClearRangeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ClearRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecomputeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_RecomputeStats
				field RecomputeStatsRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RecomputeStats = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Refresh
				field RefreshRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Refresh = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_RefreshRange
				field RefreshRangeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RefreshRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_QueryIntent
				field QueryIntentRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryIntent = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Subsume
				field SubsumeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Subsume = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_RangeStats
				field RangeStatsRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RangeStats = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminRelocateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminRelocateRange
				field AdminRelocateRangeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminRelocateRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_RecoverTxn
				field RecoverTxnRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RecoverTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUnsplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_AdminUnsplit
				field AdminUnsplitRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminUnsplit = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_RevertRange
				field RevertRangeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RevertRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Migrate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Migrate
				field MigrateRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Migrate = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryResolvedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_QueryResolvedTimestamp
				field QueryResolvedTimestampRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryResolvedTimestamp = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Barrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Barrier
				field BarrierRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Barrier = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Probe
				field ProbeRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Probe = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryLocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_QueryLocks
				field QueryLocksRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryLocks = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpanEmpty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_IsSpanEmpty
				field IsSpanEmptyRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IsSpanEmpty = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkExternalSstable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_LinkExternalSstable
				field LinkExternalSSTableRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.LinkExternalSstable = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Excise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_Excise
				field ExciseRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Excise = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushLockTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RequestUnion_FlushLockTable
				field FlushLockTableRequest
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FlushLockTable = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Get
				field GetResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Get = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Put
				field PutResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Put = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_ConditionalPut
				field ConditionalPutResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ConditionalPut = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Increment
				field IncrementResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Increment = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Delete
				field DeleteResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Delete = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_DeleteRange
				field DeleteRangeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DeleteRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Scan
				field ScanResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Scan = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_EndTxn
				field EndTxnResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.EndTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminSplit
				field AdminSplitResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminSplit = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminMerge
				field AdminMergeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminMerge = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_HeartbeatTxn
				field HeartbeatTxnResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.HeartbeatTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Gc
				field GCResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Gc = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_PushTxn
				field PushTxnResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PushTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_ResolveIntent
				field ResolveIntentResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ResolveIntent = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntentRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_ResolveIntentRange
				field ResolveIntentRangeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ResolveIntentRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Merge
				field MergeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Merge = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_TruncateLog
				field TruncateLogResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TruncateLog = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_RequestLease
				field RequestLeaseResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RequestLease = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_ReverseScan
				field ReverseScanResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ReverseScan = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeChecksum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_ComputeChecksum
				field ComputeChecksumResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ComputeChecksum = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_CheckConsistency
				field CheckConsistencyResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CheckConsistency = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminTransferLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminTransferLease
				field AdminTransferLeaseResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminTransferLease = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_LeaseInfo
				field LeaseInfoResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.LeaseInfo = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Export", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Export
				field ExportResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Export = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_QueryTxn
				field QueryTxnResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminChangeReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminChangeReplicas
				field AdminChangeReplicasResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminChangeReplicas = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminScatter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminScatter
				field AdminScatterResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminScatter = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSstable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AddSstable
				field AddSSTableResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AddSstable = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_ClearRange
				field ClearRangeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ClearRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecomputeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_RecomputeStats
				field RecomputeStatsResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RecomputeStats = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Refresh
				field RefreshResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Refresh = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_RefreshRange
				field RefreshRangeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RefreshRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_QueryIntent
				field QueryIntentResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryIntent = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Subsume
				field SubsumeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Subsume = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_RangeStats
				field RangeStatsResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RangeStats = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminRelocateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminRelocateRange
				field AdminRelocateRangeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminRelocateRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_RecoverTxn
				field RecoverTxnResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RecoverTxn = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUnsplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_AdminUnsplit
				field AdminUnsplitResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AdminUnsplit = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_RevertRange
				field RevertRangeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RevertRange = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Migrate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Migrate
				field MigrateResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Migrate = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryResolvedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_QueryResolvedTimestamp
				field QueryResolvedTimestampResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryResolvedTimestamp = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Barrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Barrier
				field BarrierResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Barrier = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Probe
				field ProbeResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Probe = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryLocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_QueryLocks
				field QueryLocksResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.QueryLocks = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpanEmpty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_IsSpanEmpty
				field IsSpanEmptyResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IsSpanEmpty = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkExternalSstable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_LinkExternalSstable
				field LinkExternalSSTableResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.LinkExternalSstable = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Excise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_Excise
				field ExciseResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Excise = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushLockTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ResponseUnion_FlushLockTable
				field FlushLockTableResponse
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FlushLockTable = &alloc.field
			m.Value = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPriority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UserPriority = github_com_cockroachdb_cockroach_pkg_roachpb.UserPriority(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &roachpb.Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			m.ReadConsistency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadConsistency |= ReadConsistencyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSpanRequestKeys", wireType)
			}
			m.MaxSpanRequestKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSpanRequestKeys |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinctSpans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DistinctSpans = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayNodeID", wireType)
			}
			m.GatewayNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayNodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncConsensus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsyncConsensus = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBytes", wireType)
			}
			m.TargetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanForwardReadTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanForwardReadTimestamp = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClientRangeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitPolicy", wireType)
			}
			m.WaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitPolicy |= lock.WaitPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingPolicy", wireType)
			}
			m.RoutingPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoutingPolicy |= RoutingPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.LockTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundedStaleness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundedStaleness == nil {
				m.BoundedStaleness = &BoundedStalenessHeader{}
			}
			if err := m.BoundedStaleness.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowEmpty = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceInfo == nil {
				m.TraceInfo = &tracingpb.TraceInfo{}
			}
			if err := m.TraceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WholeRowsOfSize", wireType)
			}
			m.WholeRowsOfSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WholeRowsOfSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFromServerClock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimestampFromServerClock == nil {
				m.TimestampFromServerClock = &github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp{}
			}
			if err := m.TimestampFromServerClock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexFetchSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexFetchSpec == nil {
				m.IndexFetchSpec = &fetchpb.IndexFetchSpec{}
			}
			if err := m.IndexFetchSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnElasticCPUResumeSpans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnElasticCPUResumeSpans = bool(v != 0)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileLabels = append(m.ProfileLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbiguousReplayProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AmbiguousReplayProtection = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionClass", wireType)
			}
			m.ConnectionClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionClass |= rpcpb.ConnectionClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyRangeInfo == nil {
				m.ProxyRangeInfo = &roachpb.RangeInfo{}
			}
			if err := m.ProxyRangeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteOptions == nil {
				m.WriteOptions = &WriteOptions{}
			}
			if err := m.WriteOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlockTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeadlockTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasBufferedAllPrecedingWrites", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasBufferedAllPrecedingWrites = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginID", wireType)
			}
			m.OriginID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoundedStalenessHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundedStalenessHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundedStalenessHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestampBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinTimestampBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestampBoundStrict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinTimestampBoundStrict = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestampBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTimestampBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdmissionHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdmissionHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdmissionHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= AdmissionHeader_Source(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLocation", wireType)
			}
			m.SourceLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceLocation |= AdmissionHeader_SourceLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoMemoryReservedAtSource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoMemoryReservedAtSource = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, RequestUnion{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdmissionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponse_Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchResponse_Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, ResponseUnion{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResponse_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &roachpb.Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedSpans = append(m.CollectedSpans, tracingpb.RecordedSpan{})
			if err := m.CollectedSpans[len(m.CollectedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeInfos = append(m.RangeInfos, roachpb.RangeInfo{})
			if err := m.RangeInfos[len(m.RangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLookupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeLookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeLookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			m.ReadConsistency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadConsistency |= ReadConsistencyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchNum", wireType)
			}
			m.PrefetchNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefetchNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchReverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrefetchReverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLookupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeLookupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeLookupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, roachpb.RangeDescriptor{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchedDescriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefetchedDescriptors = append(m.PrefetchedDescriptors, roachpb.RangeDescriptor{})
			if err := m.PrefetchedDescriptors[len(m.PrefetchedDescriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDiff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithDiff = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdmissionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseStream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseStream = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithFiltering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithFiltering = bool(v != 0)
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WithMatchingOriginIDs = append(m.WithMatchingOriginIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.WithMatchingOriginIDs == nil {
						m.WithMatchingOriginIDs = make([]uint32, 0, elementCount)
					} else {
						m.WithMatchingOriginIDs = slices.Grow(m.WithMatchingOriginIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WithMatchingOriginIDs = append(m.WithMatchingOriginIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WithMatchingOriginIDs", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerID", wireType)
			}
			m.ConsumerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsumerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBulkDelivery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBulkDelivery = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedBulkEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedBulkEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedBulkEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &RangeFeedEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolvedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedSSTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedSSTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedSSTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WriteTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedDeleteRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedDeleteRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedDeleteRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromManualSplit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromManualSplit = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentStartKey = append(m.ParentStartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentStartKey == nil {
				m.ParentStartKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &RangeFeedValue{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &RangeFeedCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &RangeFeedError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SST", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SST == nil {
				m.SST = &RangeFeedSSTable{}
			}
			if err := m.SST.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteRange == nil {
				m.DeleteRange = &RangeFeedDeleteRange{}
			}
			if err := m.DeleteRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &RangeFeedMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulkEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BulkEvents == nil {
				m.BulkEvents = &RangeFeedBulkEvents{}
			}
			if err := m.BulkEvents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MuxRangeFeedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MuxRangeFeedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MuxRangeFeedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeFeedEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeFeedEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetQuorumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetQuorumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetQuorumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetQuorumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetQuorumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetQuorumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patterns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patterns = append(m.Patterns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipSubscriptionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipSubscriptionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipSubscriptionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternMatched", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternMatched = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantSettingsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantSettingsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantSettingsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantSettingsEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantSettingsEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantSettingsEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precedence", wireType)
			}
			m.Precedence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precedence |= TenantSettingsEvent_Precedence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overrides = append(m.Overrides, TenantSetting{})
			if err := m.Overrides[len(m.Overrides)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= TenantSettingsEvent_EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = github_com_cockroachdb_cockroach_pkg_roachpb.TenantName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capabilities == nil {
				m.Capabilities = &tenantcapabilitiespb.TenantCapabilities{}
			}
			if err := m.Capabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataState", wireType)
			}
			m.DataState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataState |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceMode", wireType)
			}
			m.ServiceMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInitGracePeriodEndTS", wireType)
			}
			m.ClusterInitGracePeriodEndTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterInitGracePeriodEndTS |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalKey = github_com_cockroachdb_cockroach_pkg_settings.InternalKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantConsumption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantConsumption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantConsumption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RU", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RU = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadRequests", wireType)
			}
			m.ReadRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteRequests", wireType)
			}
			m.WriteRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			m.WriteBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLPodsCPUSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SQLPodsCPUSeconds = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PGWireEgressBytes", wireType)
			}
			m.PGWireEgressBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PGWireEgressBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KVRU", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KVRU = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIOIngressBytes", wireType)
			}
			m.ExternalIOIngressBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalIOIngressBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIOEgressBytes", wireType)
			}
			m.ExternalIOEgressBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalIOEgressBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBatches", wireType)
			}
			m.ReadBatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBatches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBatches", wireType)
			}
			m.WriteBatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteBatches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossRegionNetworkRU", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CrossRegionNetworkRU = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedCPUSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EstimatedCPUSeconds = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantConsumptionRates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantConsumptionRates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantConsumptionRates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBatchRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WriteBatchRate = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedCPURate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EstimatedCPURate = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenBucketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenBucketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenBucketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumptionSinceLastRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConsumptionSinceLastRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			m.InstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceLease", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceLease = append(m.InstanceLease[:0], dAtA[iNdEx:postIndex]...)
			if m.InstanceLease == nil {
				m.InstanceLease = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedTokens", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RequestedTokens = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRequestPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TargetRequestPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLiveInstanceID", wireType)
			}
			m.NextLiveInstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLiveInstanceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumptionPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.ConsumptionPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenBucketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenBucketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenBucketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantedTokens", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GrantedTokens = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrickleDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TrickleDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FallbackRate = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumptionRates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConsumptionRates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryVersion == nil {
				m.BinaryVersion = &roachpb.Version{}
			}
			if err := m.BinaryVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = append(m.ClusterID[:0], dAtA[iNdEx:postIndex]...)
			if m.ClusterID == nil {
				m.ClusterID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveVersion == nil {
				m.ActiveVersion = &roachpb.Version{}
			}
			if err := m.ActiveVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRangeDescriptorsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRangeDescriptorsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRangeDescriptorsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRangeDescriptorsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRangeDescriptorsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRangeDescriptorsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDescriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeDescriptors = append(m.RangeDescriptors, roachpb.RangeDescriptor{})
			if err := m.RangeDescriptors[len(m.RangeDescriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Duration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInterfaceSeeks", wireType)
			}
			m.NumInterfaceSeeks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInterfaceSeeks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInternalSeeks", wireType)
			}
			m.NumInternalSeeks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInternalSeeks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInterfaceSteps", wireType)
			}
			m.NumInterfaceSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInterfaceSteps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInternalSteps", wireType)
			}
			m.NumInternalSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInternalSteps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytes", wireType)
			}
			m.BlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytesInCache", wireType)
			}
			m.BlockBytesInCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockBytesInCache |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			m.KeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			m.ValueBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointCount", wireType)
			}
			m.PointCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsCoveredByRangeTombstones", wireType)
			}
			m.PointsCoveredByRangeTombstones = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointsCoveredByRangeTombstones |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyCount", wireType)
			}
			m.RangeKeyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeyCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyContainedPoints", wireType)
			}
			m.RangeKeyContainedPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeyContainedPoints |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeySkippedPoints", wireType)
			}
			m.RangeKeySkippedPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeySkippedPoints |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeparatedPointCount", wireType)
			}
			m.SeparatedPointCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeparatedPointCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeparatedPointValueBytes", wireType)
			}
			m.SeparatedPointValueBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeparatedPointValueBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeparatedPointValueBytesFetched", wireType)
			}
			m.SeparatedPointValueBytesFetched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeparatedPointValueBytesFetched |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumGets", wireType)
			}
			m.NumGets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumGets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumScans", wireType)
			}
			m.NumScans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumScans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReverseScans", wireType)
			}
			m.NumReverseScans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReverseScans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockReadDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.BlockReadDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeparatedPointValueCountFetched", wireType)
			}
			m.SeparatedPointValueCountFetched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeparatedPointValueCountFetched |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeparatedPointValueReaderCacheMisses", wireType)
			}
			m.SeparatedPointValueReaderCacheMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeparatedPointValueReaderCacheMisses |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsedFollowerRead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsedFollowerRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsedFollowerRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)

