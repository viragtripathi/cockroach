// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/log/eventpb/telemetry.proto

package eventpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	logpb "github.com/cockroachdb/cockroach/pkg/util/log/logpb"
	github_com_cockroachdb_redact "github.com/cockroachdb/redact"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SampledQuery is the SQL query event logged to the telemetry channel. It
// contains common SQL event/execution details.
//
// Note: in version 26.1, these events will be moved to the `SQL_EXEC` channel.
// To test compatability before this, set the cluster setting
// `log.channel_compatibility_mode.enabled` to false. This will send the
// events to `SQL_EXEC` instead of `TELEMETRY`.
type SampledQuery struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	CommonSQLEventDetails    `protobuf:"bytes,2,opt,name=sql,proto3,embedded=sql" json:""`
	CommonSQLExecDetails     `protobuf:"bytes,3,opt,name=exec,proto3,embedded=exec" json:""`
	// skipped_queries indicate how many SQL statements were not
	// considered for sampling prior to this one. If the field is
	// omitted, or its value is zero, this indicates that no statement
	// was omitted since the last event.
	SkippedQueries uint64 `protobuf:"varint,4,opt,name=skipped_queries,json=skippedQueries,proto3" json:",omitempty"`
	// Cost of the query as estimated by the optimizer.
	CostEstimate float64 `protobuf:"fixed64,5,opt,name=cost_estimate,json=costEstimate,proto3" json:",omitempty"`
	// The distribution of the DistSQL query plan (local, full, or partial).
	Distribution string `protobuf:"bytes,6,opt,name=distribution,proto3" json:",omitempty" redact:"nonsensitive"`
	// The query's plan gist bytes as a base64 encoded string.
	PlanGist string `protobuf:"bytes,7,opt,name=plan_gist,json=planGist,proto3" json:",omitempty" redact:"nonsensitive"`
	// SessionID is the ID of the session that initiated the query.
	SessionID string `protobuf:"bytes,8,opt,name=session_id,json=sessionId,proto3" json:",omitempty" redact:"nonsensitive"`
	// Name of the database that initiated the query.
	Database string `protobuf:"bytes,9,opt,name=database,proto3" json:",omitempty" redact:"nonsensitive"`
	// Statement ID of the query.
	StatementID string `protobuf:"bytes,10,opt,name=statement_id,json=statementId,proto3" json:",omitempty" redact:"nonsensitive"`
	// Transaction ID of the query.
	TransactionID string `protobuf:"bytes,11,opt,name=transaction_id,json=transactionId,proto3" json:",omitempty" redact:"nonsensitive"`
	// Maximum number of rows scanned by a full scan, as estimated by the
	// optimizer.
	MaxFullScanRowsEstimate float64 `protobuf:"fixed64,14,opt,name=max_full_scan_rows_estimate,json=maxFullScanRowsEstimate,proto3" json:",omitempty"`
	// Total number of rows read by all scans in the query, as estimated by the
	// optimizer.
	TotalScanRowsEstimate float64 `protobuf:"fixed64,15,opt,name=total_scan_rows_estimate,json=totalScanRowsEstimate,proto3" json:",omitempty"`
	// The number of rows output by the query, as estimated by the optimizer.
	OutputRowsEstimate float64 `protobuf:"fixed64,16,opt,name=output_rows_estimate,json=outputRowsEstimate,proto3" json:",omitempty"`
	// Whether table statistics were available to the optimizer when planning the
	// query.
	StatsAvailable bool `protobuf:"varint,17,opt,name=stats_available,json=statsAvailable,proto3" json:",omitempty"`
	// The maximum number of nanoseconds that have passed since stats were
	// collected on any table scanned by this query.
	NanosSinceStatsCollected int64 `protobuf:"varint,18,opt,name=nanos_since_stats_collected,json=nanosSinceStatsCollected,proto3" json:",omitempty"`
	// The number of bytes read from disk.
	BytesRead int64 `protobuf:"varint,19,opt,name=bytes_read,json=bytesRead,proto3" json:",omitempty"`
	// The number of rows read from disk.
	RowsRead int64 `protobuf:"varint,20,opt,name=rows_read,json=rowsRead,proto3" json:",omitempty"`
	// The number of rows written.
	RowsWritten int64 `protobuf:"varint,21,opt,name=rows_written,json=rowsWritten,proto3" json:",omitempty"`
	// The number of inner joins in the query plan.
	InnerJoinCount int64 `protobuf:"varint,22,opt,name=inner_join_count,json=innerJoinCount,proto3" json:",omitempty"`
	// The number of left (or right) outer joins in the query plan.
	LeftOuterJoinCount int64 `protobuf:"varint,23,opt,name=left_outer_join_count,json=leftOuterJoinCount,proto3" json:",omitempty"`
	// The number of full outer joins in the query plan.
	FullOuterJoinCount int64 `protobuf:"varint,24,opt,name=full_outer_join_count,json=fullOuterJoinCount,proto3" json:",omitempty"`
	// The number of semi joins in the query plan.
	SemiJoinCount int64 `protobuf:"varint,25,opt,name=semi_join_count,json=semiJoinCount,proto3" json:",omitempty"`
	// The number of anti joins in the query plan.
	AntiJoinCount int64 `protobuf:"varint,26,opt,name=anti_join_count,json=antiJoinCount,proto3" json:",omitempty"`
	// The number of intersect all joins in the query plan.
	IntersectAllJoinCount int64 `protobuf:"varint,27,opt,name=intersect_all_join_count,json=intersectAllJoinCount,proto3" json:",omitempty"`
	// The number of except all joins in the query plan.
	ExceptAllJoinCount int64 `protobuf:"varint,28,opt,name=except_all_join_count,json=exceptAllJoinCount,proto3" json:",omitempty"`
	// The number of hash joins in the query plan.
	HashJoinCount int64 `protobuf:"varint,29,opt,name=hash_join_count,json=hashJoinCount,proto3" json:",omitempty"`
	// The number of cross joins in the query plan.
	CrossJoinCount int64 `protobuf:"varint,30,opt,name=cross_join_count,json=crossJoinCount,proto3" json:",omitempty"`
	// The number of index joins in the query plan.
	IndexJoinCount int64 `protobuf:"varint,31,opt,name=index_join_count,json=indexJoinCount,proto3" json:",omitempty"`
	// The number of lookup joins in the query plan.
	LookupJoinCount int64 `protobuf:"varint,32,opt,name=lookup_join_count,json=lookupJoinCount,proto3" json:",omitempty"`
	// The number of merge joins in the query plan.
	MergeJoinCount int64 `protobuf:"varint,33,opt,name=merge_join_count,json=mergeJoinCount,proto3" json:",omitempty"`
	// The number of inverted joins in the query plan.
	InvertedJoinCount int64 `protobuf:"varint,34,opt,name=inverted_join_count,json=invertedJoinCount,proto3" json:",omitempty"`
	// The number of apply joins in the query plan.
	ApplyJoinCount int64 `protobuf:"varint,35,opt,name=apply_join_count,json=applyJoinCount,proto3" json:",omitempty"`
	// The number of zig zag joins in the query plan.
	ZigZagJoinCount int64 `protobuf:"varint,36,opt,name=zig_zag_join_count,json=zigZagJoinCount,proto3" json:",omitempty"`
	// The duration of time in nanoseconds that the query experienced contention.
	ContentionNanos int64 `protobuf:"varint,37,opt,name=contention_nanos,json=contentionNanos,proto3" json:",omitempty"`
	// The regions of the nodes where SQL processors ran.
	Regions []string `protobuf:"bytes,38,rep,name=regions,proto3" json:",omitempty" redact:"nonsensitive"`
	// The number of network bytes by DistSQL components.
	NetworkBytesSent int64 `protobuf:"varint,39,opt,name=network_bytes_sent,json=networkBytesSent,proto3" json:",omitempty"`
	// The maximum amount of memory usage by nodes for this query.
	MaxMemUsage int64 `protobuf:"varint,40,opt,name=max_mem_usage,json=maxMemUsage,proto3" json:",omitempty"`
	// The maximum amount of disk usage by nodes for this query.
	MaxDiskUsage int64 `protobuf:"varint,41,opt,name=max_disk_usage,json=maxDiskUsage,proto3" json:",omitempty"`
	// The number of bytes read at the KV layer for this query.
	KVBytesRead int64 `protobuf:"varint,42,opt,name=kv_bytes_read,json=kvBytesRead,proto3" json:",omitempty"`
	// The number of key-value pairs read at the KV layer for this query.
	KVPairsRead int64 `protobuf:"varint,75,opt,name=kv_pairs_read,json=kvPairsRead,proto3" json:",omitempty"`
	// The number of rows read at the KV layer for this query.
	KVRowsRead int64 `protobuf:"varint,43,opt,name=kv_rows_read,json=kvRowsRead,proto3" json:",omitempty"`
	// The number of network messages sent by nodes for this query by DistSQL
	// components.
	NetworkMessages int64 `protobuf:"varint,44,opt,name=network_messages,json=networkMessages,proto3" json:",omitempty"`
	// Generated index recommendations for this query.
	IndexRecommendations []string `protobuf:"bytes,45,rep,name=index_recommendations,json=indexRecommendations,proto3" json:",omitempty" redact:"nonsensitive"`
	// The number of scans in the query plan.
	ScanCount int64 `protobuf:"varint,46,opt,name=scan_count,json=scanCount,proto3" json:",omitempty"`
	// The number of scans using statistics (including forecasted statistics) in
	// the query plan.
	ScanWithStatsCount int64 `protobuf:"varint,47,opt,name=scan_with_stats_count,json=scanWithStatsCount,proto3" json:",omitempty"`
	// The number of scans using forecasted statistics in the query plan.
	ScanWithStatsForecastCount int64 `protobuf:"varint,48,opt,name=scan_with_stats_forecast_count,json=scanWithStatsForecastCount,proto3" json:",omitempty"`
	// Total number of rows read by all scans in the query, as estimated by the
	// optimizer without using forecasts.
	TotalScanRowsWithoutForecastsEstimate float64 `protobuf:"fixed64,49,opt,name=total_scan_rows_without_forecasts_estimate,json=totalScanRowsWithoutForecastsEstimate,proto3" json:",omitempty"`
	// The greatest quantity of nanoseconds that have passed since the forecast
	// time (or until the forecast time, if it is in the future, in which case it
	// will be negative) for any table with forecasted stats scanned by this
	// query.
	NanosSinceStatsForecasted int64 `protobuf:"varint,50,opt,name=nanos_since_stats_forecasted,json=nanosSinceStatsForecasted,proto3" json:",omitempty"`
	// The list of indexes used by this query.
	Indexes []string `protobuf:"bytes,51,rep,name=indexes,proto3" json:",omitempty" redact:"nonsensitive"`
	// Collects the cumulative CPU time spent executing SQL operations in
	// nanoseconds. Currently, it is only collected for statements without
	// mutations that have a vectorized plan.
	CpuTimeNanos int64 `protobuf:"varint,52,opt,name=cpu_time_nanos,json=cpuTimeNanos,proto3" json:",omitempty"`
	// The number of grpc calls done to get data form KV nodes
	KvGrpcCalls int64 `protobuf:"varint,53,opt,name=kv_grpc_calls,json=kvGrpcCalls,proto3" json:",omitempty"`
	// Cumulated time spent waiting for a KV request. This includes disk IO time
	// and potentially network time (if any of the keys are not local).
	KvTimeNanos int64 `protobuf:"varint,54,opt,name=kv_time_nanos,json=kvTimeNanos,proto3" json:",omitempty"`
	// The time to service the query, from start of parse to end of execute.
	ServiceLatencyNanos int64 `protobuf:"varint,56,opt,name=service_latency_nanos,json=serviceLatencyNanos,proto3" json:",omitempty"`
	// The difference between service latency and the sum of parse latency + plan latency + run latency .
	OverheadLatencyNanos int64 `protobuf:"varint,57,opt,name=overhead_latency_nanos,json=overheadLatencyNanos,proto3" json:",omitempty"`
	// The time to run the query and fetch or compute the result rows.
	RunLatencyNanos int64 `protobuf:"varint,58,opt,name=run_latency_nanos,json=runLatencyNanos,proto3" json:",omitempty"`
	// The time to transform the AST into a logical query plan.
	PlanLatencyNanos int64 `protobuf:"varint,59,opt,name=plan_latency_nanos,json=planLatencyNanos,proto3" json:",omitempty"`
	// The time between statement executions in a transaction
	IdleLatencyNanos int64 `protobuf:"varint,60,opt,name=idle_latency_nanos,json=idleLatencyNanos,proto3" json:",omitempty"`
	// The time to transform the SQL string into an abstract syntax tree (AST).
	ParseLatencyNanos int64 `protobuf:"varint,61,opt,name=parse_latency_nanos,json=parseLatencyNanos,proto3" json:",omitempty"`
	// StepCount collects the number of times the iterator moved forward or backward over the
	// DB's underlying storage keyspace.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	MvccStepCount int64 `protobuf:"varint,62,opt,name=mvcc_step_count,json=mvccStepCount,proto3" json:",omitempty"`
	// StepCountInternal collects the number of times the iterator moved forward or backward
	// over LSM internal keys.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	MvccStepCountInternal int64 `protobuf:"varint,63,opt,name=mvcc_step_count_internal,json=mvccStepCountInternal,proto3" json:",omitempty"`
	// SeekCount collects the number of times the iterator moved to a specific key/value pair
	// in the DB's underlying storage keyspace.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	MvccSeekCount int64 `protobuf:"varint,64,opt,name=mvcc_seek_count,json=mvccSeekCount,proto3" json:",omitempty"`
	// SeekCountInternal collects the number of times the iterator moved to a specific LSM
	// internal key.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	MvccSeekCountInternal int64 `protobuf:"varint,65,opt,name=mvcc_seek_count_internal,json=mvccSeekCountInternal,proto3" json:",omitempty"`
	// BlockBytes collects the bytes in the loaded SSTable data blocks.
	// For details, see pebble.InternalIteratorStats.
	MvccBlockBytes int64 `protobuf:"varint,66,opt,name=mvcc_block_bytes,json=mvccBlockBytes,proto3" json:",omitempty"`
	// BlockBytesInCache collects the subset of BlockBytes in the block cache.
	// For details, see pebble.InternalIteratorStats.
	MvccBlockBytesInCache int64 `protobuf:"varint,67,opt,name=mvcc_block_bytes_in_cache,json=mvccBlockBytesInCache,proto3" json:",omitempty"`
	// KeyBytes collects the bytes in keys that were iterated over.
	// For details, see pebble.InternalIteratorStats.
	MvccKeyBytes int64 `protobuf:"varint,68,opt,name=mvcc_key_bytes,json=mvccKeyBytes,proto3" json:",omitempty"`
	// ValueBytes collects the bytes in values that were iterated over.
	// For details, see pebble.InternalIteratorStats.
	MvccValueBytes int64 `protobuf:"varint,69,opt,name=mvcc_value_bytes,json=mvccValueBytes,proto3" json:",omitempty"`
	// PointCount collects the count of point keys iterated over.
	// For details, see pebble.InternalIteratorStats.
	MvccPointCount int64 `protobuf:"varint,70,opt,name=mvcc_point_count,json=mvccPointCount,proto3" json:",omitempty"`
	// PointsCoveredByRangeTombstones collects the count of point keys that were iterated over that
	// were covered by range tombstones.
	// For details, see pebble.InternalIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	MvccPointsCoveredByRangeTombstones int64 `protobuf:"varint,71,opt,name=mvcc_points_covered_by_range_tombstones,json=mvccPointsCoveredByRangeTombstones,proto3" json:",omitempty"`
	// RangeKeyCount collects the count of range keys encountered during iteration.
	// For details, see pebble.RangeKeyIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	MvccRangeKeyCount int64 `protobuf:"varint,72,opt,name=mvcc_range_key_count,json=mvccRangeKeyCount,proto3" json:",omitempty"`
	// RangeKeyContainedPoints collects the count of point keys encountered within the bounds of
	// a range key.
	// For details, see pebble.RangeKeyIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	MvccRangeKeyContainedPoints int64 `protobuf:"varint,73,opt,name=mvcc_range_key_contained_points,json=mvccRangeKeyContainedPoints,proto3" json:",omitempty"`
	// RangeKeySkippedPoints collects the count of the subset of ContainedPoints point keys that
	// were skipped during iteration due to range-key masking.
	// For details, see pkg/storage/engine.go, pebble.RangeKeyIteratorStats, and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	MvccRangeKeySkippedPoints int64 `protobuf:"varint,74,opt,name=mvcc_range_key_skipped_points,json=mvccRangeKeySkippedPoints,proto3" json:",omitempty"`
	// SchemaChangerMode is the mode that was used to execute the schema change,
	// if any.
	SchemaChangerMode string `protobuf:"bytes,76,opt,name=schema_changer_mode,json=schemaChangerMode,proto3" json:",omitempty" redact:"nonsensitive"`
	// SQLInstanceIDs is a list of all the SQL instances used in this statement's
	// execution.
	SQLInstanceIDs []int32 `protobuf:"varint,77,rep,packed,name=sql_instance_ids,json=sqlInstanceIds,proto3" json:",omitempty" redact:"nonsensitive"`
	// KVNodeIDs is a list of all the KV nodes used in this statement's execution.
	KVNodeIDs []int32 `protobuf:"varint,78,rep,packed,name=kv_node_ids,json=kvNodeIds,proto3" json:",omitempty" redact:"nonsensitive"`
	// Statement fingerprint ID of the query.
	StatementFingerprintID string `protobuf:"bytes,79,opt,name=statement_fingerprint_id,json=statementFingerprintId,proto3" json:",omitempty" redact:"nonsensitive"`
	// UsedFollowerRead indicates whether at least some reads were served by the
	// follower replicas.
	UsedFollowerRead bool `protobuf:"varint,80,opt,name=used_follower_read,json=usedFollowerRead,proto3" json:",omitempty" redact:"nonsensitive"`
}

func (m *SampledQuery) Reset()         { *m = SampledQuery{} }
func (m *SampledQuery) String() string { return proto.CompactTextString(m) }
func (*SampledQuery) ProtoMessage()    {}
func (*SampledQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{0}
}
func (m *SampledQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampledQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SampledQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampledQuery.Merge(m, src)
}
func (m *SampledQuery) XXX_Size() int {
	return m.Size()
}
func (m *SampledQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_SampledQuery.DiscardUnknown(m)
}

var xxx_messageInfo_SampledQuery proto.InternalMessageInfo

// SampledExecStats contains execution statistics that apply to both statements
// and transactions. These stats as a whole are collected using a sampling approach.
// These exec stats are meant to contain the same fields as ExecStats in
// apps_stats.proto but are for a single execution rather than aggregated executions.
// Fields in this struct should be updated in sync with apps_stats.proto.
type SampledExecStats struct {
	// NetworkBytes collects the number of bytes sent over the network by DistSQL
	// components.
	NetworkBytes int64 `protobuf:"varint,1,opt,name=network_bytes,json=networkBytes,proto3" json:",includeempty"`
	// MaxMemUsage collects the maximum memory usage that occurred on a node.
	MaxMemUsage int64 `protobuf:"varint,2,opt,name=max_mem_usage,json=maxMemUsage,proto3" json:",includeempty"`
	// ContentionTime collects the time in seconds statements in the transaction spent contending.
	ContentionTime int64 `protobuf:"varint,3,opt,name=contention_time,json=contentionTime,proto3" json:",omitempty"`
	// NetworkMessages collects the number of messages that were sent over the
	// network by DistSQL components.
	NetworkMessages int64 `protobuf:"varint,4,opt,name=network_messages,json=networkMessages,proto3" json:",includeempty"`
	// MaxDiskUsage collects the maximum temporary disk usage that occurred. This
	// is set in cases where a query had to spill to disk, e.g. when performing a
	// large sort where not all of the tuples fit in memory.
	MaxDiskUsage int64 `protobuf:"varint,5,opt,name=max_disk_usage,json=maxDiskUsage,proto3" json:",includeempty"`
	// CPUSQLNanos collects the CPU time spent executing SQL operations in
	// nanoseconds. Currently, it is only collected for statements without
	// mutations that have a vectorized plan.
	CPUSQLNanos int64 `protobuf:"varint,6,opt,name=cpu_sql_nanos,json=cpuSqlNanos,proto3" json:"CPUSQLNanos,includeempty"`
	// Internal storage iteration statistics.
	MVCCIteratorStats MVCCIteratorStats `protobuf:"bytes,7,opt,name=mvcc_iterator_stats,json=mvccIteratorStats,proto3" json:"mvcc_iterator_stats"`
}

func (m *SampledExecStats) Reset()         { *m = SampledExecStats{} }
func (m *SampledExecStats) String() string { return proto.CompactTextString(m) }
func (*SampledExecStats) ProtoMessage()    {}
func (*SampledExecStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{1}
}
func (m *SampledExecStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampledExecStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SampledExecStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampledExecStats.Merge(m, src)
}
func (m *SampledExecStats) XXX_Size() int {
	return m.Size()
}
func (m *SampledExecStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SampledExecStats.DiscardUnknown(m)
}

var xxx_messageInfo_SampledExecStats proto.InternalMessageInfo

// Internal storage iteration statistics for a single execution.
type MVCCIteratorStats struct {
	// StepCount collects the number of times the iterator moved forward or backward over the
	// DB's underlying storage keyspace.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	StepCount int64 `protobuf:"varint,1,opt,name=step_count,json=stepCount,proto3" json:",includeempty"`
	// StepCountInternal collects the number of times the iterator moved forward or backward
	// over LSM internal keys.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	StepCountInternal int64 `protobuf:"varint,2,opt,name=step_count_internal,json=stepCountInternal,proto3" json:",includeempty"`
	// SeekCount collects the number of times the iterator moved to a specific key/value pair
	// in the DB's underlying storage keyspace.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	SeekCount int64 `protobuf:"varint,3,opt,name=seek_count,json=seekCount,proto3" json:",includeempty"`
	// SeekCountInternal collects the number of times the iterator moved to a specific LSM
	// internal key.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	SeekCountInternal int64 `protobuf:"varint,4,opt,name=seek_count_internal,json=seekCountInternal,proto3" json:",includeempty"`
	// BlockBytes collects the bytes in the loaded SSTable data blocks.
	// For details, see pebble.InternalIteratorStats.
	BlockBytes int64 `protobuf:"varint,5,opt,name=block_bytes,json=blockBytes,proto3" json:",includeempty"`
	// BlockBytesInCache collects the subset of BlockBytes in the block cache.
	// For details, see pebble.InternalIteratorStats.
	BlockBytesInCache int64 `protobuf:"varint,6,opt,name=block_bytes_in_cache,json=blockBytesInCache,proto3" json:",includeempty"`
	// KeyBytes collects the bytes in keys that were iterated over.
	// For details, see pebble.InternalIteratorStats.
	KeyBytes int64 `protobuf:"varint,7,opt,name=key_bytes,json=keyBytes,proto3" json:",includeempty"`
	// ValueBytes collects the bytes in values that were iterated over.
	// For details, see pebble.InternalIteratorStats.
	ValueBytes int64 `protobuf:"varint,8,opt,name=value_bytes,json=valueBytes,proto3" json:",includeempty"`
	// PointCount collects the count of point keys iterated over.
	// For details, see pebble.InternalIteratorStats.
	PointCount int64 `protobuf:"varint,9,opt,name=point_count,json=pointCount,proto3" json:",includeempty"`
	// PointsCoveredByRangeTombstones collects the count of point keys that were iterated over that
	// were covered by range tombstones.
	// For details, see pebble.InternalIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	PointsCoveredByRangeTombstones int64 `protobuf:"varint,10,opt,name=points_covered_by_range_tombstones,json=pointsCoveredByRangeTombstones,proto3" json:",includeempty"`
	// RangeKeyCount collects the count of range keys encountered during iteration.
	// For details, see pebble.RangeKeyIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	RangeKeyCount int64 `protobuf:"varint,11,opt,name=range_key_count,json=rangeKeyCount,proto3" json:",includeempty"`
	// RangeKeyContainedPoints collects the count of point keys encountered within the bounds of
	// a range key.
	// For details, see pebble.RangeKeyIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	RangeKeyContainedPoints int64 `protobuf:"varint,12,opt,name=range_key_contained_points,json=rangeKeyContainedPoints,proto3" json:",includeempty"`
	// RangeKeySkippedPoints collects the count of the subset of ContainedPoints point keys that
	// were skipped during iteration due to range-key masking.
	// For details, see pkg/storage/engine.go, pebble.RangeKeyIteratorStats, and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	RangeKeySkippedPoints int64 `protobuf:"varint,13,opt,name=range_key_skipped_points,json=rangeKeySkippedPoints,proto3" json:",includeempty"`
}

func (m *MVCCIteratorStats) Reset()         { *m = MVCCIteratorStats{} }
func (m *MVCCIteratorStats) String() string { return proto.CompactTextString(m) }
func (*MVCCIteratorStats) ProtoMessage()    {}
func (*MVCCIteratorStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{2}
}
func (m *MVCCIteratorStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCIteratorStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MVCCIteratorStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCIteratorStats.Merge(m, src)
}
func (m *MVCCIteratorStats) XXX_Size() int {
	return m.Size()
}
func (m *MVCCIteratorStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCIteratorStats.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCIteratorStats proto.InternalMessageInfo

// SampledTransaction is the event logged to telemetry at the end of transaction execution.
//
// Note: in version 26.1, these events will be moved to the `SQL_EXEC` channel.
// To test compatability before this, set the cluster setting
// `log.channel_compatibility_mode.enabled` to false. This will send the
// events to `SQL_EXEC` instead of `TELEMETRY`.
type SampledTransaction struct {
	// Common contains common event details shared by all log events.
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// User is the user account that triggered the transaction.
	// The special usernames `root` and `node` are not considered sensitive.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:",includeempty" redact:"safeif:root|node"`
	// ApplicationName is the application name for the session where the transaction was executed.
	// This is included in the event to ease filtering of logging output by application.
	ApplicationName string `protobuf:"bytes,3,opt,name=application_name,json=applicationName,proto3" json:",includeempty" redact:"nonsensitive"`
	// TxnCounter is the sequence number of the SQL transaction inside its session.
	TxnCounter uint32 `protobuf:"varint,4,opt,name=txn_counter,json=txnCounter,proto3" json:",omitempty"`
	// SessionID is the ID of the session that initiated the transaction.
	SessionID string `protobuf:"bytes,5,opt,name=session_id,json=sessionId,proto3" json:",includeemepty" redact:"nonsensitive"`
	// TransactionID is the id of the transaction.
	TransactionID string `protobuf:"bytes,6,opt,name=transaction_id,json=transactionId,proto3" json:",includeempty" redact:"nonsensitive"`
	// Committed indicates if the transaction committed successfully. We want to include this value even if it is false.
	Committed bool `protobuf:"varint,8,opt,name=committed,proto3" json:",includeempty"`
	// ImplicitTxn indicates if the transaction was an implicit one. We want to include this value even if it is false.
	ImplicitTxn bool `protobuf:"varint,9,opt,name=implicit_txn,json=implicitTxn,proto3" json:",includeempty"`
	// StartTimeUnixNanos is the time the transaction was started. Expressed as unix time in nanoseconds.
	StartTimeUnixNanos int64 `protobuf:"varint,10,opt,name=start_time_unix_nanos,json=startTimeUnixNanos,proto3" json:",includeempty"`
	// EndTimeUnixNanos the time the transaction finished (either committed or aborted).
	// Expressed as unix time in nanoseconds.
	EndTimeUnixNanos int64 `protobuf:"varint,11,opt,name=end_time_unix_nanos,json=endTimeUnixNanos,proto3" json:",includeempty"`
	// ServiceLatNanos is the time to service the whole transaction, from start to end of execution.
	ServiceLatNanos int64 `protobuf:"varint,12,opt,name=service_lat_nanos,json=serviceLatNanos,proto3" json:",includeempty"`
	// SQLSTATE is the SQLSTATE code for the error, if an error was encountered. Empty/omitted if no error.
	SQLSTATE string `protobuf:"bytes,13,opt,name=sqlstate,proto3" json:",omitempty" redact:"nonsensitive"`
	// ErrorText is the text of the error if any.
	ErrorText github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,14,opt,name=error_text,json=errorText,proto3,customtype=github.com/cockroachdb/redact.RedactableString" json:",omitempty" redact:"mixed"`
	// NumRetries is the number of time when the txn was retried automatically by the server.
	NumRetries int64 `protobuf:"varint,15,opt,name=num_retries,json=numRetries,proto3" json:",omitempty"`
	// LastAutoRetryReason is a string containing the reason for the last automatic retry.
	LastAutoRetryReason github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,16,opt,name=last_auto_retry_reason,json=lastAutoRetryReason,proto3,customtype=github.com/cockroachdb/redact.RedactableString" json:",omitempty" redact:"mixed"`
	// NumRows is the total number of rows returned across all statements.
	NumRows int64 `protobuf:"varint,18,opt,name=num_rows,json=numRows,proto3" json:",includeempty"`
	// RetryLatNanos is the amount of time spent retrying the transaction.
	RetryLatNanos int64 `protobuf:"varint,19,opt,name=retry_lat_nanos,json=retryLatNanos,proto3" json:",omitempty"`
	// CommitLatNanos is the amount of time spent committing the transaction after all statement operations.
	CommitLatNanos int64 `protobuf:"varint,20,opt,name=commit_lat_nanos,json=commitLatNanos,proto3" json:",includeempty"`
	// IdleLatNanos is the amount of time spent waiting for the client to send statements
	// while the transaction is open.
	IdleLatNanos int64 `protobuf:"varint,21,opt,name=idle_lat_nanos,json=idleLatNanos,proto3" json:",includeempty"`
	// BytesRead is the number of bytes read from disk.
	BytesRead int64 `protobuf:"varint,22,opt,name=bytes_read,json=bytesRead,proto3" json:",includeempty"`
	// RowsRead is the number of rows read from disk.
	RowsRead int64 `protobuf:"varint,23,opt,name=rows_read,json=rowsRead,proto3" json:",includeempty"`
	// RowsWritten is the number of rows written to disk.
	RowsWritten int64 `protobuf:"varint,24,opt,name=rows_written,json=rowsWritten,proto3" json:",includeempty"`
	// SampledExecStats is a nested field containing execution statistics.
	// This field will be omitted if the stats were not sampled.
	SampledExecStats *SampledExecStats `protobuf:"bytes,25,opt,name=sampled_exec_stats,json=sampledExecStats,proto3" json:",omitempty"`
	// SkippedTransactions is the number of transactions that were skipped as part of sampling prior to
	// this one. We only count skipped transactions when telemetry logging is enabled and the sampling
	// mode is set to "transaction".
	SkippedTransactions int64 `protobuf:"varint,26,opt,name=skipped_transactions,json=skippedTransactions,proto3" json:",omitempty"`
	// TransactionFingerprintID is the fingerprint ID of the transaction.
	// This can be used to find the transaction in the console.
	TransactionFingerprintID string `protobuf:"bytes,27,opt,name=transaction_fingerprint_id,json=transactionFingerprintId,proto3" json:"TransactionFingerprintID," redact:"nonsensitive"`
	// StatementFingerprintIDs is an array of statement fingerprint IDs belonging to this transaction.
	StatementFingerprintIDs []string `protobuf:"bytes,28,rep,name=statement_fingerprint_ids,json=statementFingerprintIds,proto3" json:",omitempty" redact:"nonsensitive"`
}

func (m *SampledTransaction) Reset()         { *m = SampledTransaction{} }
func (m *SampledTransaction) String() string { return proto.CompactTextString(m) }
func (*SampledTransaction) ProtoMessage()    {}
func (*SampledTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{3}
}
func (m *SampledTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampledTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SampledTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampledTransaction.Merge(m, src)
}
func (m *SampledTransaction) XXX_Size() int {
	return m.Size()
}
func (m *SampledTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_SampledTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_SampledTransaction proto.InternalMessageInfo

// CapturedIndexUsageStats
type CapturedIndexUsageStats struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// TotalReadCount is the number of times the index has been read.
	TotalReadCount uint64 `protobuf:"varint,2,opt,name=total_read_count,json=totalReadCount,proto3" json:"total_read_count,omitempty"`
	// LastRead is the timestamp at which the index was last read.
	LastRead string `protobuf:"bytes,3,opt,name=last_read,json=lastRead,proto3" json:",omitempty" redact:"nonsensitive"`
	// TableID is the ID of the table on which the index was created. This is same as
	// descpb.TableID and is unique within the cluster.
	TableID uint32 `protobuf:"varint,4,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// IndexID is the ID of the index within the scope of the given table.
	IndexID uint32 `protobuf:"varint,5,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// DatabaseName is the name of the database in which the index was created.
	DatabaseName string `protobuf:"bytes,6,opt,name=database_name,json=databaseName,proto3" json:",omitempty" redact:"nonsensitive"`
	// TableName is the name of the table on which the index was created.
	TableName string `protobuf:"bytes,7,opt,name=table_name,json=tableName,proto3" json:",omitempty" redact:"nonsensitive"`
	// IndexName is the name of the index within the scope of the given table.
	IndexName string `protobuf:"bytes,8,opt,name=index_name,json=indexName,proto3" json:",omitempty" redact:"nonsensitive"`
	// IndexType is the type of the index. Index types include "primary" and "secondary".
	IndexType string `protobuf:"bytes,9,opt,name=index_type,json=indexType,proto3" json:",omitempty" redact:"nonsensitive"`
	// IsUnique indicates if the index has a UNIQUE constraint.
	IsUnique bool `protobuf:"varint,10,opt,name=is_unique,json=isUnique,proto3" json:",omitempty"`
	// IsInverted indicates if the index is an inverted index.
	IsInverted bool `protobuf:"varint,11,opt,name=is_inverted,json=isInverted,proto3" json:",omitempty"`
	// CreatedAt is the timestamp at which the index was created.
	CreatedAt string `protobuf:"bytes,12,opt,name=created_at,json=createdAt,proto3" json:",omitempty" redact:"nonsensitive"`
	// SchemaName is the name of the schema in which the index was created.
	SchemaName string `protobuf:"bytes,13,opt,name=schema_name,json=schemaName,proto3" json:",omitempty" redact:"nonsensitive"`
}

func (m *CapturedIndexUsageStats) Reset()         { *m = CapturedIndexUsageStats{} }
func (m *CapturedIndexUsageStats) String() string { return proto.CompactTextString(m) }
func (*CapturedIndexUsageStats) ProtoMessage()    {}
func (*CapturedIndexUsageStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{4}
}
func (m *CapturedIndexUsageStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapturedIndexUsageStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CapturedIndexUsageStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapturedIndexUsageStats.Merge(m, src)
}
func (m *CapturedIndexUsageStats) XXX_Size() int {
	return m.Size()
}
func (m *CapturedIndexUsageStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CapturedIndexUsageStats.DiscardUnknown(m)
}

var xxx_messageInfo_CapturedIndexUsageStats proto.InternalMessageInfo

// RecoveryEvent is an event that is logged on every invocation of BACKUP,
// RESTORE, and on every BACKUP schedule creation, with the appropriate subset
// of fields populated depending on the type of event. This event is is also
// logged whenever a BACKUP and RESTORE job completes or fails.
type RecoveryEvent struct {
	// Common fields for all events.
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// RecoveryType is the type of recovery described by this event, which is one of
	// - backup
	// - scheduled_backup
	// - create_schedule
	// - restore
	//
	// It can also be a job event corresponding to the recovery, which is one of
	// - backup_job
	// - scheduled_backup_job
	// - restore_job
	RecoveryType RecoveryEventType `protobuf:"bytes,2,opt,name=recovery_type,json=recoveryType,proto3,customtype=RecoveryEventType" json:",omitempty" redact:"nonsensitive"`
	// TargetScope is the largest scope of the targets that the user is backing up
	// or restoring based on the following order:
	// table < schema < database < full cluster.
	TargetScope string `protobuf:"bytes,3,opt,name=target_scope,json=targetScope,proto3" json:",omitempty" redact:"nonsensitive"`
	// IsMultiregionTarget is true if any of the targets contain objects with
	// multi-region primitives.
	IsMultiregionTarget bool `protobuf:"varint,4,opt,name=is_multiregion_target,json=isMultiregionTarget,proto3" json:",omitempty"`
	// TargetCount is the number of targets the in the BACKUP/RESTORE.
	TargetCount uint32 `protobuf:"varint,5,opt,name=target_count,json=targetCount,proto3" json:",omitempty"`
	// DestinationSubdirType is
	// - latest: if using the latest subdir
	// - standard: if using a date-based subdir
	// - custom: if using a custom subdir that's not date-based
	DestinationSubdirType string `protobuf:"bytes,6,opt,name=destination_subdir_type,json=destinationSubdirType,proto3" json:",omitempty" redact:"nonsensitive"`
	// DestinationStorageTypes are the types of storage that the user is backing
	// up to or restoring from.
	DestinationStorageTypes []string `protobuf:"bytes,7,rep,name=destination_storage_types,json=destinationStorageTypes,proto3" json:",omitempty" redact:"nonsensitive"`
	// DestinationAuthTypes are the types of authentication methods that the user
	// is using to access the destination storage.
	DestinationAuthTypes []string `protobuf:"bytes,8,rep,name=destination_auth_types,json=destinationAuthTypes,proto3" json:",omitempty" redact:"nonsensitive"`
	// IsLocalityAware indicates if the BACKUP or RESTORE is locality aware.
	IsLocalityAware bool `protobuf:"varint,9,opt,name=is_locality_aware,json=isLocalityAware,proto3" json:",omitempty"`
	// AsOfInterval is the time interval in nanoseconds between the statement
	// timestamp and the timestamp resolved by the AS OF SYSTEM TIME expression.
	// The interval is expressed in nanoseconds.
	AsOfInterval int64 `protobuf:"varint,10,opt,name=as_of_interval,json=asOfInterval,proto3" json:",omitempty"`
	// WithRevisionHistory is true if the BACKUP includes revision history.
	WithRevisionHistory bool `protobuf:"varint,11,opt,name=with_revision_history,json=withRevisionHistory,proto3" json:",omitempty"`
	// HasEncryptionPassphrase is true if the user provided an encryption
	// passphrase to encrypt/decrypt their backup.
	HasEncryptionPassphrase bool `protobuf:"varint,13,opt,name=has_encryption_passphrase,json=hasEncryptionPassphrase,proto3" json:",omitempty"`
	// KMSType is the type of KMS the user is using to encrypt/decrypt their
	// backup.
	KMSType string `protobuf:"bytes,14,opt,name=kms_type,json=kmsType,proto3" json:",omitempty" redact:"nonsensitive"`
	// KMSCount is the number of KMS the user is using.
	KMSCount uint32 `protobuf:"varint,15,opt,name=kms_count,json=kmsCount,proto3" json:",omitempty"`
	// Options contain all the names of the options specified by the user in the
	// BACKUP or RESTORE statement. For options that are accompanied by a value,
	// only those with non-empty values will be present.
	//
	// It's important to note that there are no option values anywhere in the
	// event payload. Future changes to telemetry should refrain from adding
	// values to the payload unless they are properly redacted.
	Options []string `protobuf:"bytes,16,rep,name=options,proto3" json:",omitempty" redact:"nonsensitive"`
	// DebugPauseOn is the type of event that the restore should pause on for
	// debugging purposes. Currently only "error" is supported.
	DebugPauseOn string `protobuf:"bytes,17,opt,name=debug_pause_on,json=debugPauseOn,proto3" json:",omitempty" redact:"nonsensitive"`
	// JobID is the ID of the BACKUP/RESTORE job.
	JobID uint64 `protobuf:"varint,18,opt,name=job_id,json=jobId,proto3" json:",omitempty"`
	// ResultStatus indicates whether the job succeeded or failed.
	ResultStatus string `protobuf:"bytes,20,opt,name=result_status,json=resultStatus,proto3" json:",omitempty" redact:"nonsensitive"`
	// ErrorText is the text of the error that caused the job to fail.
	ErrorText github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,21,opt,name=error_text,json=errorText,proto3,customtype=github.com/cockroachdb/redact.RedactableString" json:",omitempty" redact:"mixed"`
	// RecurringCron is the crontab for the incremental backup.
	RecurringCron string `protobuf:"bytes,24,opt,name=recurring_cron,json=recurringCron,proto3" json:",omitempty" redact:"nonsensitive"`
	// FullBackupCron is the crontab for the full backup.
	FullBackupCron string `protobuf:"bytes,25,opt,name=full_backup_cron,json=fullBackupCron,proto3" json:",omitempty" redact:"nonsensitive"`
	// CustomFirstRunTime is the timestamp for the user configured first run time.
	// Expressed as nanoseconds since the Unix epoch.
	CustomFirstRunTime int64 `protobuf:"varint,26,opt,name=custom_first_run_time,json=customFirstRunTime,proto3" json:",omitempty"`
	// OnExecutionFailure describes the desired behavior if the schedule fails to
	// execute.
	OnExecutionFailure string `protobuf:"bytes,27,opt,name=on_execution_failure,json=onExecutionFailure,proto3" json:",omitempty" redact:"nonsensitive"`
	// OnPreviousRunning describes the desired behavior if the previously
	// scheduled BACKUP is still running.
	OnPreviousRunning string `protobuf:"bytes,28,opt,name=on_previous_running,json=onPreviousRunning,proto3" json:",omitempty" redact:"nonsensitive"`
	// IgnoreExistingBackup is true iff the BACKUP schedule should still be
	// created even if a backup is already present in its destination.
	IgnoreExistingBackup bool `protobuf:"varint,29,opt,name=ignore_existing_backup,json=ignoreExistingBackup,proto3" json:",omitempty"`
	// The application name for the session where recovery event was created.
	ApplicationName string `protobuf:"bytes,30,opt,name=application_name,json=applicationName,proto3" json:",omitempty" redact:"nonsensitive"`
	// NumRows is the number of rows successfully imported, backed up or restored.
	NumRows int64 `protobuf:"varint,31,opt,name=num_rows,json=numRows,proto3" json:",omitempty"`
}

func (m *RecoveryEvent) Reset()         { *m = RecoveryEvent{} }
func (m *RecoveryEvent) String() string { return proto.CompactTextString(m) }
func (*RecoveryEvent) ProtoMessage()    {}
func (*RecoveryEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{5}
}
func (m *RecoveryEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryEvent.Merge(m, src)
}
func (m *RecoveryEvent) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryEvent proto.InternalMessageInfo

// SchemaDescriptor is an event for schema telemetry, whose purpose is
// to take periodic snapshots of the cluster's SQL schema and publish them in
// the telemetry log channel. For all intents and purposes, the data in such a
// snapshot can be thought of the outer join of certain system tables:
// namespace, descriptor, and at some point perhaps zones, etc.
//
// Snapshots are too large to conveniently be published as a single log event,
// so instead they're broken down into SchemaDescriptor events which
// contain the data in one record of this outer join projection. These events
// are prefixed by a header (a SchemaSnapshotMetadata event).
type SchemaDescriptor struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// SnapshotID is the unique identifier of the snapshot that this event
	// is part of.
	SnapshotID string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty" redact:"nonsensitive"`
	// ParentDatabaseID matches the same key column in system.namespace.
	ParentDatabaseID uint32 `protobuf:"varint,3,opt,name=parent_database_id,json=parentDatabaseId,proto3" json:",omitempty"`
	// ParentSchemaID matches the same key column in system.namespace.
	ParentSchemaID uint32 `protobuf:"varint,4,opt,name=parent_schema_id,json=parentSchemaId,proto3" json:",omitempty"`
	// Name matches the same key column in system.namespace.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty" redact:"nonsensitive"`
	// DescID matches the 'id' column in system.namespace and system.descriptor.
	DescID uint32 `protobuf:"varint,6,opt,name=desc_id,json=descId,proto3" json:",omitempty"`
	// Desc matches the 'descriptor' column in system.descriptor.
	// Some contents of the descriptor may be redacted to prevent leaking PII.
	Desc *descpb.Descriptor `protobuf:"bytes,7,opt,name=desc,proto3" json:",omitempty" redact:"nonsensitive"`
}

func (m *SchemaDescriptor) Reset()         { *m = SchemaDescriptor{} }
func (m *SchemaDescriptor) String() string { return proto.CompactTextString(m) }
func (*SchemaDescriptor) ProtoMessage()    {}
func (*SchemaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{6}
}
func (m *SchemaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaDescriptor.Merge(m, src)
}
func (m *SchemaDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SchemaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaDescriptor proto.InternalMessageInfo

// SchemaSnapshotMetadata is an event describing a schema snapshot, which
// is a set of SchemaDescriptor messages sharing the same SnapshotID.
type SchemaSnapshotMetadata struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// SnapshotID is the unique identifier of this snapshot.
	SnapshotID string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty" redact:"nonsensitive"`
	// NumRecords is how many SchemaDescriptor events are in the
	// snapshot.
	NumRecords uint32 `protobuf:"varint,3,opt,name=num_records,json=numRecords,proto3" json:"num_records,omitempty"`
	// AsOfTimestamp is when the snapshot was taken.
	// This is equivalent to the timestamp given in the AS OF SYSTEM TIME
	// clause when querying the namespace and descriptor tables in the
	// system database.
	// Expressed as nanoseconds since the Unix epoch.
	AsOfTimestamp int64 `protobuf:"varint,4,opt,name=as_of_timestamp,json=asOfTimestamp,proto3" json:",omitempty"`
	// Errors records any errors encountered when post-processing this snapshot,
	// which includes the redaction of any potential PII.
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:",omitempty"`
}

func (m *SchemaSnapshotMetadata) Reset()         { *m = SchemaSnapshotMetadata{} }
func (m *SchemaSnapshotMetadata) String() string { return proto.CompactTextString(m) }
func (*SchemaSnapshotMetadata) ProtoMessage()    {}
func (*SchemaSnapshotMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{7}
}
func (m *SchemaSnapshotMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaSnapshotMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaSnapshotMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaSnapshotMetadata.Merge(m, src)
}
func (m *SchemaSnapshotMetadata) XXX_Size() int {
	return m.Size()
}
func (m *SchemaSnapshotMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaSnapshotMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaSnapshotMetadata proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SampledQuery)(nil), "cockroach.util.log.eventpb.SampledQuery")
	proto.RegisterType((*SampledExecStats)(nil), "cockroach.util.log.eventpb.SampledExecStats")
	proto.RegisterType((*MVCCIteratorStats)(nil), "cockroach.util.log.eventpb.MVCCIteratorStats")
	proto.RegisterType((*SampledTransaction)(nil), "cockroach.util.log.eventpb.SampledTransaction")
	proto.RegisterType((*CapturedIndexUsageStats)(nil), "cockroach.util.log.eventpb.CapturedIndexUsageStats")
	proto.RegisterType((*RecoveryEvent)(nil), "cockroach.util.log.eventpb.RecoveryEvent")
	proto.RegisterType((*SchemaDescriptor)(nil), "cockroach.util.log.eventpb.SchemaDescriptor")
	proto.RegisterType((*SchemaSnapshotMetadata)(nil), "cockroach.util.log.eventpb.SchemaSnapshotMetadata")
}

func init() { proto.RegisterFile("util/log/eventpb/telemetry.proto", fileDescriptor_3d317b4ad74be4f7) }

var fileDescriptor_3d317b4ad74be4f7 = []byte{
	// 3899 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5b, 0x4f, 0x73, 0x1b, 0x47,
	0x7e, 0x15, 0x2d, 0x8a, 0x04, 0x9a, 0x04, 0x08, 0x36, 0x49, 0x71, 0x28, 0xd9, 0x04, 0x97, 0x9b,
	0xb5, 0x64, 0x5b, 0x26, 0x2d, 0x59, 0x96, 0x6c, 0xd9, 0xeb, 0x35, 0x41, 0x4a, 0x32, 0x29, 0x52,
	0xa2, 0x00, 0x4a, 0xaa, 0xdd, 0xca, 0x66, 0xaa, 0x31, 0xd3, 0x04, 0xdb, 0x98, 0x99, 0x1e, 0x76,
	0xf7, 0x80, 0x80, 0x93, 0xca, 0x07, 0x48, 0x2e, 0xfb, 0x01, 0xf2, 0x25, 0x72, 0x4e, 0xe5, 0x94,
	0x8b, 0x8f, 0x3e, 0x6e, 0xe5, 0x80, 0x4a, 0xe0, 0x9b, 0x8f, 0x7b, 0xce, 0x21, 0xd5, 0x7f, 0x00,
	0xcc, 0x00, 0x33, 0x2a, 0xa2, 0xca, 0x49, 0xed, 0x41, 0x45, 0x6a, 0xfa, 0xbd, 0xd7, 0xbf, 0xe9,
	0x7f, 0xef, 0xd7, 0xdd, 0x43, 0xb0, 0x11, 0x09, 0xe2, 0x6d, 0x7b, 0xb4, 0xb1, 0x8d, 0x5b, 0x38,
	0x10, 0x61, 0x7d, 0x5b, 0x60, 0x0f, 0xfb, 0x58, 0xb0, 0xce, 0x56, 0xc8, 0xa8, 0xa0, 0xf0, 0x86,
	0x43, 0x9d, 0x26, 0xa3, 0xc8, 0x39, 0xdb, 0x92, 0xd8, 0x2d, 0x8f, 0x36, 0xb6, 0x0c, 0xf6, 0xc6,
	0x72, 0x83, 0x36, 0xa8, 0x82, 0x6d, 0xcb, 0xdf, 0x34, 0xe3, 0xc6, 0xaf, 0xf9, 0xb9, 0xb7, 0xed,
	0x20, 0x81, 0xa4, 0xac, 0x8b, 0xb9, 0x13, 0xd6, 0xb7, 0xb9, 0x60, 0x91, 0x23, 0x22, 0x86, 0x5d,
	0x03, 0x7a, 0x6f, 0xac, 0x62, 0xf5, 0x93, 0x9b, 0xe2, 0x5b, 0x63, 0xc5, 0xfc, 0xdc, 0xb3, 0x51,
	0xe4, 0x12, 0x61, 0x27, 0x80, 0x37, 0x06, 0x40, 0x8f, 0x36, 0xfa, 0x2a, 0xba, 0x6c, 0xf3, 0xdf,
	0x3e, 0x00, 0xf3, 0x35, 0xe4, 0x87, 0x1e, 0x76, 0x5f, 0x46, 0x98, 0x75, 0xe0, 0x21, 0x98, 0x71,
	0xa8, 0xef, 0xd3, 0xc0, 0x9a, 0xda, 0x98, 0xba, 0x3d, 0x77, 0xef, 0xfd, 0xad, 0x94, 0x97, 0xdb,
	0x55, 0x88, 0xc7, 0x52, 0x67, 0x0f, 0x0b, 0x44, 0x3c, 0x5e, 0x99, 0xff, 0xa1, 0x5b, 0xbe, 0xf2,
	0x63, 0xb7, 0x3c, 0xf5, 0x73, 0xb7, 0x7c, 0xa5, 0x6a, 0x34, 0xe0, 0x4b, 0x70, 0x95, 0x9f, 0x7b,
	0xd6, 0x3b, 0x4a, 0xea, 0xee, 0x56, 0x76, 0x3b, 0x19, 0xc9, 0xda, 0xcb, 0xc3, 0xb7, 0xa8, 0x4a,
	0x2d, 0x58, 0x05, 0xd3, 0xb8, 0x8d, 0x1d, 0xeb, 0xaa, 0xd2, 0xfc, 0xe4, 0x72, 0x9a, 0x6d, 0xec,
	0xa4, 0x4b, 0x2a, 0x2d, 0xf8, 0x10, 0x2c, 0xf0, 0x26, 0x09, 0x43, 0xec, 0xda, 0xe7, 0x11, 0x66,
	0x04, 0x73, 0x6b, 0x7a, 0x63, 0xea, 0xf6, 0x74, 0xa5, 0xf8, 0x73, 0xb7, 0x0c, 0xee, 0x50, 0x9f,
	0x08, 0xec, 0x87, 0xa2, 0x53, 0x2d, 0x1a, 0xd8, 0x4b, 0x8d, 0x82, 0x9f, 0x82, 0x82, 0x43, 0xb9,
	0xb0, 0x31, 0x17, 0xc4, 0x47, 0x02, 0x5b, 0xd7, 0x36, 0xa6, 0x6e, 0x4f, 0x8d, 0xd1, 0xe6, 0x25,
	0xe8, 0xb1, 0xc1, 0xc0, 0x67, 0x60, 0xde, 0x25, 0x5c, 0x30, 0x52, 0x8f, 0x04, 0xa1, 0x81, 0x35,
	0xb3, 0x31, 0x75, 0x3b, 0x5f, 0xb9, 0x95, 0xe4, 0xfc, 0xa5, 0x5b, 0x5e, 0x61, 0xd8, 0x45, 0x8e,
	0x78, 0xb4, 0x19, 0xd0, 0x80, 0xe3, 0x80, 0x13, 0x41, 0x5a, 0x78, 0xb3, 0x9a, 0x20, 0xc3, 0x3d,
	0x90, 0x0f, 0x3d, 0x14, 0xd8, 0x0d, 0xc2, 0x85, 0x35, 0x3b, 0x99, 0x52, 0x4e, 0x32, 0x9f, 0x12,
	0x2e, 0x60, 0x0d, 0x00, 0x8e, 0x39, 0x27, 0x34, 0xb0, 0x89, 0x6b, 0xe5, 0x94, 0xcc, 0xfd, 0x5e,
	0xb7, 0x9c, 0xaf, 0xe9, 0xa7, 0xfb, 0x7b, 0x97, 0xd5, 0xcc, 0x1b, 0x9d, 0x7d, 0x17, 0xee, 0x82,
	0x9c, 0x8b, 0x04, 0xaa, 0x23, 0x8e, 0xad, 0xfc, 0x84, 0x91, 0xf5, 0x89, 0xf0, 0xf7, 0x60, 0x9e,
	0x0b, 0x24, 0xb0, 0x8f, 0x03, 0x21, 0x63, 0x03, 0x4a, 0xe8, 0x41, 0xaf, 0x5b, 0x9e, 0xab, 0xf5,
	0x9f, 0x5f, 0x3e, 0xba, 0xb9, 0x81, 0xd6, 0xbe, 0x0b, 0x6d, 0x50, 0x14, 0x0c, 0x05, 0x1c, 0x39,
	0xc2, 0xbc, 0xf8, 0x9c, 0x12, 0xff, 0xbc, 0xd7, 0x2d, 0x17, 0x4e, 0x86, 0x25, 0x97, 0x97, 0x2f,
	0xc4, 0xf4, 0xf6, 0x5d, 0x78, 0x08, 0x6e, 0xfa, 0xa8, 0x6d, 0x9f, 0x46, 0x9e, 0x67, 0x73, 0x07,
	0x05, 0x36, 0xa3, 0x17, 0x7c, 0x38, 0x56, 0x8a, 0xa9, 0x63, 0x65, 0xd5, 0x47, 0xed, 0x27, 0x91,
	0xe7, 0xd5, 0x1c, 0x14, 0x54, 0xe9, 0x05, 0x1f, 0x0c, 0x9b, 0xa7, 0xc0, 0x12, 0x54, 0xa0, 0x54,
	0xa9, 0x85, 0x54, 0xa9, 0x15, 0x85, 0x1f, 0x13, 0xfa, 0x06, 0x2c, 0xd3, 0x48, 0x84, 0x91, 0x18,
	0x11, 0x29, 0xa5, 0x8a, 0x40, 0x8d, 0x4d, 0x28, 0xc8, 0xf9, 0x22, 0x90, 0xe0, 0x36, 0x6a, 0x21,
	0xe2, 0xa1, 0xba, 0x87, 0xad, 0xc5, 0x8d, 0xa9, 0xdb, 0xb9, 0x94, 0xf9, 0x22, 0x61, 0x3b, 0x7d,
	0x14, 0x3c, 0x02, 0x37, 0x03, 0x14, 0x50, 0x6e, 0x73, 0x12, 0x38, 0xd8, 0xd6, 0x22, 0x0e, 0xf5,
	0x3c, 0xec, 0x08, 0xec, 0x5a, 0x70, 0x63, 0xea, 0xf6, 0xd5, 0x31, 0x11, 0x4b, 0x51, 0x6a, 0x92,
	0x21, 0xbb, 0x9c, 0xef, 0xf6, 0xf1, 0xf0, 0x63, 0x00, 0xea, 0x1d, 0x81, 0xb9, 0xcd, 0x30, 0x72,
	0xad, 0xa5, 0x54, 0x76, 0x5e, 0x21, 0xaa, 0x18, 0xb9, 0xf0, 0x23, 0x90, 0x57, 0x6f, 0xac, 0xd0,
	0xcb, 0xa9, 0xe8, 0x9c, 0x04, 0x28, 0xf0, 0x5d, 0x30, 0xaf, 0xc0, 0x17, 0x8c, 0x08, 0x81, 0x03,
	0x6b, 0x25, 0x15, 0x3f, 0x27, 0x31, 0x6f, 0x34, 0x04, 0x7e, 0x0e, 0x4a, 0x24, 0x08, 0x30, 0xb3,
	0xbf, 0xa3, 0x24, 0xb0, 0x1d, 0x1a, 0x05, 0xc2, 0xba, 0x9e, 0x4a, 0x2b, 0x2a, 0xdc, 0x01, 0x25,
	0xc1, 0xae, 0x44, 0xc1, 0x1d, 0xb0, 0xe2, 0xe1, 0x53, 0x61, 0xd3, 0x48, 0x24, 0xe9, 0xab, 0xa9,
	0x74, 0x28, 0xc1, 0x2f, 0x24, 0x36, 0x21, 0xa1, 0x06, 0xda, 0x98, 0x84, 0x95, 0x2e, 0x21, 0xc1,
	0x23, 0x12, 0x0f, 0xc0, 0x02, 0xc7, 0x3e, 0x89, 0x93, 0xd7, 0x52, 0xc9, 0x05, 0x09, 0x4b, 0xf0,
	0x50, 0x20, 0x12, 0xbc, 0x1b, 0xe9, 0x3c, 0x09, 0x1b, 0xf2, 0x9e, 0x02, 0x8b, 0x04, 0x02, 0x33,
	0x8e, 0x1d, 0x61, 0x23, 0xcf, 0x8b, 0x0b, 0xdc, 0x4c, 0x15, 0x58, 0x19, 0xe0, 0x77, 0x3c, 0x2f,
	0xf1, 0xee, 0xb8, 0xed, 0xe0, 0x70, 0x4c, 0xe5, 0xdd, 0xf4, 0x77, 0xd7, 0xe0, 0x84, 0xc4, 0x03,
	0xb0, 0x70, 0x86, 0xf8, 0x59, 0x9c, 0xfc, 0x5e, 0xfa, 0x3b, 0x48, 0xd8, 0x90, 0xf7, 0x39, 0x28,
	0x39, 0x8c, 0x72, 0x1e, 0x27, 0xae, 0xa7, 0xf7, 0xb9, 0xc2, 0x25, 0x98, 0x24, 0x70, 0x71, 0x3b,
	0xce, 0x2c, 0x67, 0x8d, 0x16, 0x17, 0xb7, 0x87, 0xcc, 0x47, 0x60, 0xd1, 0xa3, 0xb4, 0x19, 0x85,
	0x71, 0xea, 0x46, 0x2a, 0x75, 0x41, 0x03, 0x13, 0xb5, 0xfa, 0x98, 0x35, 0x70, 0x9c, 0xfa, 0xab,
	0xf4, 0x5a, 0x15, 0x6e, 0xc8, 0xfc, 0x1a, 0x2c, 0x91, 0xa0, 0x85, 0x99, 0xc0, 0x6e, 0x9c, 0xbc,
	0x99, 0x4a, 0x5e, 0xec, 0x43, 0x13, 0x35, 0xa3, 0x30, 0xf4, 0x3a, 0x71, 0xf2, 0xaf, 0xd3, 0x6b,
	0x56, 0xb8, 0x21, 0xf3, 0x4b, 0x00, 0xbf, 0x27, 0x0d, 0xfb, 0x7b, 0xd4, 0x88, 0x73, 0xff, 0x26,
	0xfd, 0x85, 0xbf, 0x27, 0x8d, 0x3f, 0xa0, 0xc6, 0x90, 0xfc, 0x05, 0x28, 0x39, 0x34, 0x10, 0x38,
	0x50, 0x8b, 0xbc, 0x5a, 0x4a, 0xac, 0xdf, 0xa4, 0x53, 0x87, 0xb8, 0xe7, 0x12, 0x06, 0x77, 0xc0,
	0x2c, 0xc3, 0x0d, 0x42, 0x03, 0x6e, 0xbd, 0xbf, 0x71, 0x75, 0x12, 0xff, 0xea, 0xf3, 0xe0, 0x57,
	0x00, 0x06, 0x58, 0x5c, 0x50, 0xd6, 0xb4, 0xf5, 0x4a, 0xc5, 0x71, 0x20, 0xac, 0x5b, 0xa9, 0xf5,
	0x97, 0x0c, 0xb2, 0x22, 0x81, 0x35, 0x1c, 0x08, 0x78, 0x0f, 0x14, 0xa4, 0x81, 0xf8, 0xd8, 0xb7,
	0x23, 0x8e, 0x1a, 0xd8, 0xba, 0x9d, 0xbe, 0x08, 0xf9, 0xa8, 0x7d, 0x84, 0xfd, 0x57, 0x12, 0x02,
	0xef, 0x83, 0xa2, 0xe4, 0xb8, 0x84, 0x37, 0x0d, 0xe9, 0x83, 0x54, 0xd2, 0xbc, 0x8f, 0xda, 0x7b,
	0x84, 0x37, 0x35, 0x6b, 0x07, 0x14, 0x9a, 0x2d, 0x3b, 0xb6, 0x98, 0x7e, 0xa8, 0x48, 0xef, 0x49,
	0x9f, 0x7d, 0xf6, 0xba, 0xd2, 0x5f, 0x42, 0x47, 0x2b, 0x6e, 0xb6, 0x06, 0x45, 0x46, 0x22, 0x44,
	0x84, 0x19, 0x89, 0x67, 0x71, 0x89, 0x63, 0xf9, 0x3c, 0x5d, 0x62, 0x50, 0x04, 0xbf, 0x06, 0xf3,
	0xcd, 0x96, 0x3d, 0x5c, 0xa3, 0x3f, 0x52, 0x0a, 0xef, 0xf6, 0xba, 0x65, 0xf0, 0xec, 0x75, 0xd5,
	0xac, 0xcc, 0x23, 0x02, 0xa0, 0xd9, 0xea, 0x97, 0xc8, 0xbe, 0xee, 0xb7, 0xb6, 0x8f, 0xb9, 0x7c,
	0x31, 0x6e, 0xdd, 0x49, 0xef, 0x6b, 0x83, 0x3b, 0x32, 0x30, 0xf8, 0xb7, 0x60, 0x45, 0xcf, 0x46,
	0x86, 0x65, 0xee, 0x8a, 0x03, 0x17, 0x09, 0xd5, 0xf3, 0x1f, 0x4f, 0xd6, 0xf3, 0xcb, 0x4a, 0xa5,
	0x9a, 0x14, 0x91, 0x46, 0xa5, 0x5c, 0x5b, 0x8f, 0xdc, 0xad, 0x74, 0xa3, 0x92, 0x88, 0xc1, 0x7a,
	0xa6, 0xe0, 0x17, 0x44, 0x9c, 0x0d, 0x4c, 0x52, 0x32, 0xb7, 0xd3, 0xd7, 0x33, 0x09, 0x7e, 0x43,
	0xc4, 0x99, 0xb1, 0x47, 0x29, 0x51, 0x05, 0xeb, 0xa3, 0x12, 0xa7, 0x94, 0x61, 0x07, 0x71, 0x61,
	0xb4, 0x3e, 0x49, 0xd5, 0xba, 0x91, 0xd0, 0x7a, 0x62, 0x28, 0x5a, 0x93, 0x80, 0x0f, 0x47, 0x33,
	0x10, 0x29, 0x4f, 0x23, 0x31, 0xd0, 0x8e, 0xa5, 0x13, 0x77, 0x53, 0xd3, 0x89, 0xdf, 0x24, 0x72,
	0x92, 0x37, 0x9a, 0xde, 0xaf, 0x66, 0x98, 0x61, 0xbc, 0x00, 0xef, 0x8e, 0x27, 0x0a, 0xfd, 0x4a,
	0xb0, 0x6b, 0xdd, 0x4b, 0x0d, 0x7e, 0x6d, 0x24, 0x53, 0x78, 0x32, 0x20, 0xc8, 0xb9, 0xac, 0x7a,
	0x06, 0x73, 0xeb, 0xd3, 0x09, 0xe7, 0xb2, 0xe1, 0xc9, 0x99, 0xe5, 0x84, 0x91, 0x2d, 0x88, 0x8f,
	0xcd, 0x3a, 0x72, 0x3f, 0x7d, 0x66, 0x39, 0x61, 0x74, 0x42, 0x7c, 0xac, 0x17, 0x91, 0x7b, 0x6a,
	0x5a, 0x34, 0x58, 0xe8, 0xd8, 0x0e, 0xf2, 0x3c, 0x6e, 0x7d, 0x96, 0x3e, 0x87, 0x9b, 0xad, 0xa7,
	0x2c, 0x74, 0x76, 0x25, 0xc4, 0x70, 0x62, 0x15, 0x3d, 0xc8, 0xe2, 0x0c, 0xeb, 0xa9, 0x80, 0x15,
	0x8e, 0x59, 0x8b, 0x38, 0xd8, 0xf6, 0x90, 0xc0, 0x81, 0xd3, 0x31, 0xdc, 0xcf, 0x53, 0xb9, 0x4b,
	0x06, 0x7c, 0xa8, 0xb1, 0x5a, 0x63, 0x0f, 0x5c, 0xa7, 0x2d, 0xcc, 0xce, 0x30, 0x72, 0x47, 0x44,
	0xbe, 0x48, 0x15, 0x59, 0xee, 0xa3, 0x13, 0x2a, 0x8f, 0xc0, 0x22, 0x8b, 0x82, 0x11, 0x81, 0x47,
	0xe9, 0xd3, 0x90, 0x45, 0x41, 0x82, 0xfb, 0x15, 0x80, 0x6a, 0x3b, 0x93, 0x24, 0x7f, 0x99, 0xbe,
	0x5e, 0x4a, 0xe4, 0x28, 0x9b, 0xb8, 0xde, 0x68, 0x03, 0x7c, 0x95, 0xce, 0x96, 0xc8, 0x04, 0xfb,
	0x6b, 0xb0, 0x14, 0x22, 0xc6, 0x47, 0xe9, 0xbf, 0x4d, 0x37, 0x38, 0x05, 0x4d, 0xf0, 0x1f, 0x80,
	0x05, 0xbf, 0xe5, 0x38, 0x36, 0x17, 0x38, 0x34, 0x73, 0xec, 0xeb, 0xf4, 0x14, 0x42, 0xc2, 0x6a,
	0x02, 0x87, 0x83, 0x34, 0x68, 0x84, 0x67, 0xab, 0x34, 0x27, 0x40, 0x9e, 0xf5, 0xbb, 0xf4, 0x34,
	0x28, 0x21, 0xb0, 0x6f, 0xc0, 0xc3, 0x00, 0x30, 0x6e, 0x9a, 0x00, 0xbe, 0x79, 0x4b, 0x00, 0x18,
	0x37, 0x47, 0x02, 0x18, 0xf0, 0x86, 0x01, 0xec, 0xbc, 0x25, 0x80, 0xbe, 0xc0, 0x20, 0x00, 0x99,
	0x5c, 0x48, 0xa1, 0xba, 0x47, 0x1d, 0x63, 0x78, 0x56, 0x25, 0x23, 0xb9, 0x68, 0x39, 0x4e, 0x45,
	0xc2, 0x94, 0x81, 0xc0, 0x6f, 0xc1, 0xda, 0x28, 0xd3, 0x96, 0x4e, 0x8f, 0x9c, 0x33, 0x6c, 0xed,
	0x66, 0xc7, 0x30, 0x94, 0xd8, 0x0f, 0x76, 0x25, 0x58, 0xf9, 0x9f, 0x54, 0x6a, 0xe2, 0x8e, 0x89,
	0x60, 0x2f, 0xc3, 0xff, 0x5a, 0x8e, 0xf3, 0x0c, 0x77, 0x74, 0xfd, 0xfd, 0xc8, 0x5b, 0xc8, 0x8b,
	0xb0, 0xe1, 0x3d, 0xce, 0x8e, 0xfc, 0xb5, 0x84, 0x25, 0x99, 0x21, 0x25, 0x41, 0x7f, 0x69, 0x7d,
	0x92, 0xcd, 0x3c, 0x96, 0x30, 0xdd, 0xec, 0x0e, 0xb8, 0x35, 0x64, 0xca, 0x15, 0xbe, 0x85, 0x19,
	0x76, 0xed, 0x7a, 0xc7, 0x66, 0x28, 0x68, 0x60, 0x5b, 0x50, 0xbf, 0xce, 0x05, 0x0d, 0x30, 0xb7,
	0x9e, 0xa6, 0x0a, 0x6e, 0x0e, 0x04, 0xf9, 0xae, 0x26, 0x57, 0x3a, 0x55, 0x49, 0x3d, 0x19, 0x30,
	0xe1, 0xef, 0xc0, 0xb2, 0xaa, 0x44, 0x4b, 0xca, 0x46, 0xd1, 0x21, 0x7e, 0x9b, 0x3e, 0xaa, 0x25,
	0x56, 0x49, 0x3c, 0xc3, 0x1d, 0x1d, 0xe5, 0x09, 0x28, 0x8f, 0x09, 0x04, 0x02, 0x91, 0x00, 0xbb,
	0x26, 0x72, 0x6b, 0x3f, 0x55, 0xeb, 0x66, 0x52, 0xcb, 0x70, 0x74, 0xb8, 0xf0, 0x18, 0xbc, 0x37,
	0xa2, 0xda, 0x3f, 0x80, 0x31, 0x9a, 0x07, 0xe9, 0x0b, 0x7c, 0x5c, 0xb3, 0xa6, 0x19, 0x46, 0xf1,
	0x0d, 0x58, 0xe2, 0xce, 0x19, 0xf6, 0x91, 0xed, 0x9c, 0x49, 0x00, 0xb3, 0x7d, 0xea, 0x62, 0xeb,
	0x70, 0xb2, 0x83, 0x87, 0x45, 0xad, 0xb1, 0xab, 0x25, 0x8e, 0xa8, 0x8b, 0xa1, 0x03, 0x4a, 0xfc,
	0xdc, 0xb3, 0x49, 0xc0, 0x05, 0x92, 0x5e, 0x44, 0x5c, 0x6e, 0x1d, 0x6d, 0x5c, 0xbd, 0x7d, 0xad,
	0xf2, 0x45, 0xaf, 0x5b, 0x2e, 0xd6, 0x5e, 0x1e, 0xee, 0x9b, 0xa2, 0xfd, 0x3d, 0x7e, 0xd9, 0x7a,
	0x8a, 0xfc, 0xdc, 0x1b, 0xd0, 0x5c, 0x0e, 0x4f, 0xc0, 0x5c, 0xb3, 0x65, 0x07, 0xd4, 0xd5, 0xfa,
	0xcf, 0x95, 0xbe, 0x3a, 0x81, 0x79, 0xf6, 0xfa, 0x39, 0x75, 0x27, 0x91, 0xce, 0x37, 0x5b, 0x8a,
	0xe1, 0x72, 0xf8, 0xf7, 0xc0, 0x1a, 0x1e, 0x9e, 0x9c, 0x12, 0xf9, 0x4a, 0x21, 0x23, 0xfa, 0x20,
	0xe5, 0x85, 0x6a, 0x98, 0x9d, 0x5e, 0xb7, 0x7c, 0x7d, 0x70, 0x90, 0xf2, 0x64, 0x08, 0xb9, 0xfc,
	0xa1, 0xc7, 0x75, 0x9e, 0x46, 0x77, 0xe1, 0x2b, 0x00, 0x23, 0x8e, 0x5d, 0xfb, 0x94, 0x7a, 0x1e,
	0xbd, 0xc0, 0x4c, 0xa7, 0x74, 0xc7, 0xea, 0x9c, 0xe0, 0xd2, 0xfd, 0x51, 0x92, 0x12, 0x4f, 0x8c,
	0x82, 0xcc, 0xf1, 0x0e, 0xa6, 0x73, 0xf3, 0xa5, 0xc2, 0xc1, 0x74, 0xae, 0x50, 0x2a, 0x6e, 0xfe,
	0xcf, 0x55, 0x50, 0x32, 0xa7, 0x97, 0x8f, 0xdb, 0xd8, 0x51, 0x9e, 0x0f, 0x1f, 0x80, 0x42, 0x22,
	0xe5, 0x56, 0x07, 0x99, 0x57, 0x2b, 0x8b, 0x3f, 0x77, 0xcb, 0x85, 0x3b, 0x24, 0x70, 0xbc, 0xc8,
	0xc5, 0x66, 0x09, 0x88, 0x27, 0xdc, 0xf0, 0xb3, 0xd1, 0x64, 0xfb, 0x9d, 0x2c, 0x5e, 0x22, 0xdf,
	0x7e, 0x08, 0x62, 0xfb, 0x06, 0xe5, 0xd9, 0xea, 0x68, 0x32, 0x6d, 0xff, 0x37, 0x80, 0x49, 0xd7,
	0x86, 0x5f, 0xa5, 0x24, 0xab, 0xd3, 0x59, 0x55, 0x8e, 0xe5, 0xab, 0x0f, 0xc7, 0xd2, 0xfc, 0x6b,
	0x99, 0xaf, 0x99, 0xc8, 0xf4, 0x5f, 0x80, 0x82, 0xcc, 0x62, 0xe4, 0x90, 0xd6, 0xfe, 0x36, 0xa3,
	0x78, 0x1f, 0xc9, 0x34, 0x7d, 0xf7, 0xf8, 0x55, 0xed, 0xe5, 0xa1, 0x72, 0xb3, 0x9f, 0xbb, 0x65,
	0x2b, 0xf6, 0xdf, 0x91, 0x06, 0x70, 0xc2, 0xa8, 0x76, 0xee, 0x69, 0xdb, 0x6b, 0x83, 0x25, 0x35,
	0x95, 0x89, 0xc0, 0x0c, 0x09, 0xca, 0x74, 0xb2, 0xa6, 0xce, 0x22, 0xe7, 0xee, 0x7d, 0xfc, 0xb6,
	0xf3, 0xd9, 0xa3, 0xd7, 0xbb, 0xbb, 0xfb, 0x86, 0xa5, 0xfa, 0xae, 0xb2, 0xf6, 0x43, 0xb7, 0x7c,
	0xa5, 0xd7, 0x2d, 0x2f, 0x8e, 0x15, 0xe9, 0xa5, 0x29, 0xf1, 0x68, 0xf3, 0x3f, 0x66, 0xc0, 0x38,
	0x10, 0x7e, 0x02, 0x40, 0xcc, 0x81, 0x33, 0x3b, 0x3f, 0xcf, 0x07, 0x06, 0xbc, 0x03, 0x96, 0xd2,
	0xbc, 0x37, 0xb3, 0xff, 0x17, 0xf9, 0x98, 0xf5, 0xca, 0x4a, 0x87, 0xae, 0x7b, 0x35, 0xbb, 0xd2,
	0x81, 0xe9, 0xca, 0x4a, 0x53, 0xfc, 0x76, 0x3a, 0xbb, 0xd2, 0x31, 0xbb, 0xbd, 0x07, 0xe6, 0xe2,
	0x4e, 0x9b, 0x39, 0x00, 0x40, 0x7d, 0x68, 0xb4, 0x15, 0xb0, 0x9c, 0xea, 0xb1, 0x33, 0x99, 0xf5,
	0xd6, 0xc7, 0x2c, 0x76, 0x0b, 0xe4, 0x87, 0xee, 0x3a, 0x9b, 0x45, 0xcc, 0x35, 0xfb, 0xe6, 0x7a,
	0x0f, 0xcc, 0xc5, 0x7d, 0x35, 0x97, 0x19, 0x67, 0x6b, 0x68, 0xab, 0xf7, 0xc0, 0x5c, 0xdc, 0x51,
	0xf3, 0x99, 0x9c, 0x70, 0x68, 0xa8, 0x7f, 0x04, 0x9b, 0x97, 0xf0, 0x52, 0x90, 0x25, 0xb5, 0x1e,
	0xbe, 0xdd, 0x4a, 0xbf, 0x00, 0x0b, 0xa3, 0x2e, 0x3a, 0x97, 0xa5, 0x55, 0x60, 0x09, 0x13, 0x7d,
	0x0e, 0x6e, 0xbc, 0xc5, 0x3f, 0xe7, 0xb3, 0x54, 0x56, 0x59, 0x86, 0x7d, 0x1e, 0x00, 0x2b, 0xd3,
	0x39, 0x0b, 0x59, 0x6a, 0x2b, 0x2c, 0xcd, 0x38, 0x37, 0x7b, 0x0b, 0x00, 0x9a, 0x45, 0x34, 0x76,
	0xe8, 0xfd, 0x0b, 0x5f, 0x04, 0x55, 0xc0, 0x74, 0xc4, 0x31, 0x53, 0x73, 0x2a, 0x5f, 0xd9, 0x1a,
	0x0b, 0xee, 0x2f, 0xdd, 0xf2, 0x5a, 0xdf, 0x01, 0x38, 0x3a, 0xc5, 0xe4, 0xf4, 0x11, 0xa3, 0x54,
	0xfc, 0x83, 0x74, 0xc4, 0xcd, 0xaa, 0xe2, 0xc2, 0x57, 0xfa, 0x00, 0x89, 0x38, 0xc8, 0x1c, 0xe5,
	0x98, 0xa5, 0x36, 0x5f, 0xf9, 0x30, 0x4d, 0x2f, 0xc3, 0x51, 0x16, 0x62, 0x1a, 0xcf, 0x91, 0x8f,
	0xe1, 0x36, 0x98, 0x13, 0x6d, 0xb3, 0x35, 0xc7, 0x4c, 0x4d, 0xc0, 0xc2, 0xd8, 0xe2, 0x0d, 0x44,
	0x5b, 0xef, 0xcd, 0x31, 0x83, 0x6f, 0x12, 0x97, 0x25, 0xd7, 0x06, 0x77, 0x06, 0x89, 0xcb, 0x92,
	0xe2, 0x30, 0x1c, 0x7c, 0xd9, 0x0b, 0x93, 0xfa, 0xd8, 0x85, 0x84, 0xbe, 0x1a, 0xfa, 0x32, 0xed,
	0x42, 0xe2, 0xb2, 0xef, 0x3b, 0x72, 0x27, 0xb1, 0x0d, 0xf2, 0xb2, 0x4b, 0x88, 0x90, 0xbb, 0xe8,
	0x9c, 0x32, 0xe3, 0xb4, 0x75, 0x6a, 0x80, 0x81, 0xf7, 0xc1, 0x3c, 0xf1, 0x65, 0x8b, 0x11, 0x61,
	0x8b, 0x76, 0xa0, 0x66, 0x62, 0x2a, 0x67, 0xae, 0x0f, 0x3b, 0x69, 0x07, 0x70, 0x0f, 0xac, 0x70,
	0x81, 0x98, 0xd0, 0x9b, 0xd8, 0x28, 0x20, 0x6d, 0xe3, 0x36, 0x99, 0xb3, 0x0f, 0x2a, 0xbc, 0x74,
	0xc6, 0x57, 0x01, 0x69, 0x6b, 0x6b, 0xf9, 0x06, 0x2c, 0xe1, 0xc0, 0x1d, 0xd3, 0xc8, 0x9c, 0x75,
	0x25, 0x1c, 0xb8, 0x49, 0x85, 0xdf, 0x82, 0xc5, 0xd8, 0xae, 0xd8, 0xf0, 0x33, 0xe7, 0xdb, 0xc2,
	0x70, 0x53, 0xac, 0xe9, 0x2f, 0x40, 0x8e, 0x9f, 0x7b, 0x2a, 0xc1, 0x51, 0xf3, 0x2a, 0x5f, 0xf9,
	0xb4, 0xd7, 0x2d, 0xe7, 0x6a, 0x2f, 0x0f, 0x6b, 0x27, 0x3b, 0x27, 0x8f, 0x2f, 0x7d, 0x9d, 0xd5,
	0x17, 0x81, 0x11, 0x00, 0x98, 0x31, 0xca, 0x6c, 0x81, 0xdb, 0x42, 0xdd, 0x00, 0xe5, 0x2b, 0xaf,
	0xe5, 0x8c, 0xf9, 0xcf, 0x6e, 0x79, 0xab, 0x41, 0xc4, 0x59, 0x54, 0xdf, 0x72, 0xa8, 0xbf, 0x3d,
	0x98, 0x6b, 0x6e, 0x7d, 0x5b, 0x6b, 0x6e, 0x55, 0xd5, 0x0f, 0x54, 0xf7, 0x70, 0x4d, 0x30, 0x12,
	0x34, 0xc6, 0x2a, 0x2f, 0xf6, 0x2b, 0xf7, 0x49, 0x1b, 0xbb, 0x9b, 0xd5, 0xbc, 0xaa, 0xe9, 0x04,
	0xb7, 0x85, 0x1c, 0xe3, 0x41, 0xe4, 0xdb, 0x0c, 0x0b, 0x75, 0xb9, 0xb9, 0x90, 0x9a, 0xa0, 0x80,
	0x20, 0xf2, 0xab, 0x1a, 0x01, 0xff, 0x79, 0x0a, 0x5c, 0xf7, 0x10, 0x17, 0x36, 0x8a, 0x04, 0x55,
	0xbc, 0x8e, 0xcc, 0xdf, 0x38, 0x0d, 0xd4, 0x35, 0xd1, 0xff, 0x5d, 0xd0, 0x4b, 0xb2, 0xd6, 0x9d,
	0x48, 0x50, 0x19, 0x49, 0xa7, 0xaa, 0xaa, 0x84, 0x77, 0x40, 0x4e, 0x85, 0x4f, 0x2f, 0xb8, 0xb9,
	0x23, 0x4a, 0xe9, 0xbc, 0x59, 0x19, 0x3e, 0xbd, 0x50, 0xfb, 0x70, 0x1d, 0xf0, 0xb0, 0xc7, 0xd3,
	0xaf, 0x86, 0x0a, 0x0a, 0x36, 0xe8, 0xec, 0x2f, 0x41, 0x49, 0x0f, 0xfb, 0x18, 0x71, 0x39, 0xab,
	0xb6, 0xa2, 0x86, 0x0e, 0xc8, 0x0f, 0x41, 0xb1, 0x7f, 0xf4, 0x60, 0xa8, 0x2b, 0x99, 0xf9, 0x98,
	0x39, 0x79, 0xd0, 0xc4, 0x4f, 0x12, 0x77, 0x58, 0xd7, 0x33, 0x33, 0x87, 0xe1, 0x35, 0xd6, 0x56,
	0xfc, 0x1a, 0x6b, 0x35, 0xd3, 0x7e, 0x07, 0x37, 0x59, 0xf7, 0x47, 0x6e, 0xb2, 0xac, 0xcc, 0xbc,
	0x36, 0x7e, 0x99, 0xf5, 0x1d, 0x80, 0x5c, 0xbb, 0x82, 0x8d, 0xdb, 0xd8, 0x31, 0x59, 0xdd, 0x9a,
	0xf2, 0x82, 0x3b, 0x6f, 0xcb, 0xea, 0x46, 0x13, 0xf2, 0xf1, 0x93, 0x17, 0x3e, 0x9a, 0xb2, 0xef,
	0x80, 0xe5, 0xbe, 0x89, 0xc5, 0x56, 0x2b, 0x9e, 0x71, 0x8b, 0xb4, 0x64, 0xb0, 0xb1, 0x15, 0x91,
	0xc3, 0x3f, 0x4d, 0x81, 0x1b, 0xf1, 0xc5, 0x73, 0x64, 0xb7, 0x73, 0x53, 0x0d, 0xda, 0x6a, 0xaf,
	0x5b, 0xb6, 0x62, 0xb4, 0xd1, 0xfd, 0xce, 0x5a, 0x56, 0xd9, 0x9d, 0xec, 0xb9, 0x6d, 0x89, 0x74,
	0x8e, 0x0b, 0xff, 0x11, 0xac, 0x65, 0xed, 0xbe, 0xb8, 0xf5, 0xae, 0x3a, 0x84, 0xac, 0xf4, 0xba,
	0xe5, 0xd5, 0xf4, 0xed, 0xd7, 0xa5, 0xf7, 0x7b, 0xab, 0xe9, 0xfb, 0x2f, 0x7e, 0x30, 0x9d, 0x9b,
	0x2d, 0xe5, 0x0e, 0xa6, 0x73, 0x8b, 0x25, 0xb8, 0xf9, 0xef, 0x33, 0x60, 0x75, 0x17, 0x85, 0xea,
	0xf3, 0x92, 0xfd, 0xc0, 0xc5, 0x6d, 0xb5, 0x19, 0xd0, 0xad, 0xff, 0xcb, 0x3a, 0xfd, 0x6d, 0x50,
	0xd2, 0x87, 0xc4, 0x72, 0x78, 0x9a, 0x34, 0x49, 0xba, 0xfe, 0x74, 0xb5, 0xa8, 0x9e, 0xcb, 0x21,
	0xa9, 0x93, 0xa2, 0x3d, 0x90, 0x57, 0x4b, 0x8c, 0x1a, 0xc7, 0x57, 0x27, 0xfc, 0x40, 0x40, 0x32,
	0xd5, 0xe8, 0x7e, 0x1f, 0xe4, 0xd4, 0xfa, 0x22, 0x7b, 0x59, 0x7b, 0xf7, 0x5c, 0xaf, 0x5b, 0x9e,
	0x3d, 0x91, 0xcf, 0xf6, 0xf7, 0xaa, 0xb3, 0xaa, 0x70, 0x5f, 0xe1, 0xf4, 0x01, 0xbf, 0xf1, 0x6c,
	0x83, 0x53, 0x8d, 0x21, 0x71, 0xaa, 0x50, 0x5d, 0xda, 0x17, 0xfa, 0x1f, 0x1f, 0xe8, 0x14, 0x63,
	0xe2, 0xcf, 0x33, 0x0c, 0x5b, 0x25, 0x17, 0x4f, 0x00, 0xd0, 0xd1, 0x29, 0xa9, 0x09, 0xbf, 0xcf,
	0xc8, 0x2b, 0x6a, 0x5f, 0x47, 0x47, 0xaf, 0x74, 0x72, 0x13, 0xea, 0x28, 0x6a, 0x52, 0x47, 0x74,
	0xc2, 0x89, 0xbf, 0xca, 0xd0, 0x3a, 0x27, 0x9d, 0x10, 0xc3, 0x8f, 0x40, 0x9e, 0x70, 0xe9, 0xc9,
	0xe7, 0x11, 0x56, 0x9e, 0x3e, 0x7e, 0xf7, 0x9f, 0x23, 0xfc, 0x95, 0x2a, 0x97, 0xee, 0x43, 0xe4,
	0x56, 0x43, 0xdf, 0x08, 0x2a, 0xfb, 0x1e, 0x87, 0x03, 0xc2, 0xf7, 0x0d, 0x42, 0x46, 0xe9, 0x30,
	0x8c, 0x04, 0x76, 0x6d, 0x24, 0x94, 0x5d, 0x4f, 0x12, 0xa5, 0xa1, 0xee, 0x08, 0xf8, 0x2d, 0x98,
	0x33, 0x67, 0x42, 0xaa, 0xd9, 0x0a, 0x93, 0x09, 0x01, 0xcd, 0x95, 0xed, 0xb6, 0xf9, 0x2f, 0x25,
	0x50, 0xa8, 0x62, 0xb5, 0xad, 0xe8, 0xa8, 0x49, 0xf0, 0x0b, 0xcf, 0x1a, 0x0c, 0x0a, 0xcc, 0xc8,
	0xeb, 0xae, 0xd1, 0x89, 0xf2, 0x37, 0xc6, 0x65, 0x17, 0x13, 0x75, 0xcb, 0x1e, 0xb8, 0xf4, 0x70,
	0xec, 0xcb, 0xaa, 0x6e, 0x3b, 0x00, 0xf3, 0x02, 0xb1, 0x06, 0x16, 0x36, 0x77, 0x68, 0x88, 0x27,
	0x9d, 0x75, 0x73, 0x9a, 0x5c, 0x93, 0x5c, 0x58, 0x01, 0x2b, 0x84, 0xdb, 0x7e, 0xe4, 0x09, 0xa2,
	0x6f, 0x3b, 0x6d, 0x5d, 0xaa, 0x66, 0xe1, 0x78, 0xff, 0x2e, 0x11, 0x7e, 0x34, 0xc4, 0x9e, 0x28,
	0x28, 0xbc, 0x3b, 0x88, 0x47, 0x2f, 0x14, 0xd7, 0x52, 0x93, 0x6f, 0x53, 0xad, 0x5e, 0x35, 0x6c,
	0xb0, 0xea, 0x62, 0x2e, 0x48, 0xa0, 0x77, 0x01, 0x3c, 0xaa, 0xbb, 0x84, 0xe9, 0x36, 0x9b, 0x70,
	0xa6, 0xae, 0xc4, 0x74, 0x6a, 0x4a, 0x46, 0xb5, 0x91, 0x03, 0xd6, 0x12, 0x15, 0x08, 0xca, 0x90,
	0xdc, 0x41, 0x76, 0x42, 0xb5, 0xdb, 0x9d, 0xe8, 0xee, 0x28, 0x1e, 0x6a, 0x4d, 0x0b, 0xc9, 0x3a,
	0x38, 0xfc, 0x23, 0xb8, 0x1e, 0xaf, 0x04, 0x45, 0xe2, 0xcc, 0xd4, 0x90, 0x9b, 0xf0, 0xbe, 0x31,
	0x26, 0xb3, 0x13, 0x89, 0x33, 0x2d, 0xff, 0x08, 0x2c, 0x12, 0x6e, 0x7b, 0xd4, 0x41, 0x1e, 0x11,
	0x1d, 0x1b, 0x5d, 0x20, 0x86, 0x4d, 0xe6, 0x3e, 0x76, 0x05, 0x43, 0xf8, 0xa1, 0xc1, 0xed, 0x48,
	0x18, 0xbc, 0x0f, 0x8a, 0x88, 0xdb, 0xf4, 0x54, 0x9f, 0x49, 0xb4, 0x90, 0x67, 0x72, 0xf6, 0xb1,
	0x03, 0x74, 0xc4, 0x5f, 0x9c, 0xee, 0x1b, 0x8c, 0x1c, 0x0d, 0xea, 0xaa, 0x91, 0xe1, 0x16, 0x51,
	0x5b, 0xa3, 0x33, 0x22, 0x5b, 0xae, 0x93, 0x31, 0xdb, 0x97, 0x24, 0xb8, 0x6a, 0xb0, 0xdf, 0x6a,
	0x28, 0x3c, 0x00, 0x6b, 0x67, 0x88, 0xdb, 0x38, 0x70, 0x58, 0x27, 0x54, 0xed, 0x12, 0x22, 0xce,
	0xc3, 0x33, 0x86, 0xb8, 0x9e, 0xbc, 0xe3, 0x3a, 0xab, 0x67, 0x88, 0x3f, 0x1e, 0xe0, 0x8f, 0x07,
	0x70, 0x78, 0x04, 0x72, 0x4d, 0x9f, 0xeb, 0x71, 0xa1, 0xd3, 0xec, 0x7b, 0x72, 0xb9, 0x7f, 0x76,
	0x54, 0x9b, 0x64, 0xf6, 0xcc, 0x36, 0x7d, 0xae, 0x06, 0xc5, 0x43, 0x90, 0x97, 0x72, 0x7a, 0x94,
	0x2e, 0xa8, 0x51, 0x7a, 0x43, 0xee, 0x04, 0x9e, 0x1d, 0xd5, 0xd4, 0xb0, 0x1c, 0x5d, 0xfb, 0x9a,
	0x3e, 0xef, 0x1f, 0xf3, 0xcc, 0xd2, 0x50, 0x67, 0x33, 0xa5, 0x09, 0xef, 0x1d, 0x0d, 0x0f, 0x1e,
	0x81, 0xa2, 0x8b, 0xeb, 0x51, 0xc3, 0x0e, 0x51, 0xc4, 0xb1, 0x4d, 0x03, 0xf5, 0xb1, 0xd5, 0x44,
	0x96, 0x24, 0xe9, 0xc7, 0x92, 0xfd, 0x22, 0x80, 0x5b, 0x60, 0xe6, 0x3b, 0x5a, 0x97, 0x36, 0x08,
	0xd5, 0x37, 0x8e, 0xab, 0xbd, 0x6e, 0xf9, 0xda, 0x01, 0xad, 0x8f, 0x9e, 0xf8, 0x56, 0xaf, 0x7d,
	0x47, 0xeb, 0xda, 0x10, 0x19, 0xe6, 0x91, 0x27, 0x54, 0x0a, 0x18, 0xe9, 0x9c, 0x78, 0x92, 0xda,
	0x35, 0xbb, 0xa6, 0xc8, 0x23, 0x1b, 0xa0, 0x95, 0xff, 0xaf, 0x0d, 0xd0, 0x73, 0x50, 0x64, 0xd8,
	0x89, 0x98, 0xe4, 0xd9, 0x0e, 0xa3, 0x3a, 0x0b, 0x9e, 0xe0, 0x2d, 0x0a, 0x03, 0xfa, 0x2e, 0x53,
	0x1f, 0xb6, 0x96, 0xd4, 0xd7, 0x56, 0x75, 0xe4, 0x34, 0xa3, 0x50, 0x2b, 0xae, 0x4d, 0xa6, 0x58,
	0x94, 0x02, 0x15, 0xc5, 0x57, 0x92, 0x3b, 0x60, 0xc5, 0x89, 0xb8, 0xa0, 0xbe, 0x7d, 0x4a, 0x98,
	0x4c, 0x8b, 0x22, 0x73, 0x9c, 0x9c, 0x9e, 0x05, 0x43, 0x0d, 0x7e, 0x22, 0xb1, 0xd5, 0x48, 0x1f,
	0x29, 0xff, 0x1e, 0x2c, 0xd3, 0x40, 0xa5, 0xeb, 0x91, 0x4e, 0x82, 0x11, 0xf1, 0x22, 0x86, 0x4d,
	0xf6, 0x7b, 0xe9, 0xc8, 0x20, 0x0d, 0x1e, 0xf7, 0x35, 0x9e, 0x68, 0x09, 0xf8, 0x06, 0x2c, 0xc9,
	0xf9, 0x28, 0xa7, 0x37, 0x8d, 0xb8, 0x0c, 0x2e, 0x20, 0x41, 0x43, 0x7d, 0x60, 0x35, 0xc9, 0xf5,
	0x0a, 0x0d, 0x8e, 0x8d, 0x44, 0x55, 0x2b, 0xc0, 0x3d, 0x70, 0x9d, 0x34, 0x02, 0xca, 0xb0, 0x8d,
	0xdb, 0x44, 0x2e, 0x65, 0x0d, 0xd3, 0xa8, 0xea, 0xfb, 0xab, 0xf1, 0x19, 0xbf, 0xac, 0xd1, 0x8f,
	0x0d, 0x58, 0x37, 0x20, 0xac, 0xa6, 0x9c, 0x0d, 0xad, 0x4f, 0x16, 0xdb, 0xd8, 0xc1, 0xd0, 0x07,
	0xb1, 0x5d, 0x67, 0xfa, 0x87, 0x59, 0xfd, 0x2d, 0xe7, 0xe6, 0x3f, 0x4d, 0x83, 0x52, 0x4d, 0x65,
	0x0b, 0x7b, 0x98, 0x3b, 0x8c, 0x84, 0x82, 0xb2, 0x5f, 0x38, 0x43, 0x90, 0xb9, 0x4c, 0x80, 0x42,
	0x7e, 0x46, 0xd5, 0x86, 0x46, 0xe7, 0x07, 0xb7, 0x7a, 0xdd, 0x32, 0xa8, 0x99, 0xc7, 0xfb, 0x7b,
	0x6f, 0xcb, 0x65, 0xfa, 0x20, 0x17, 0x1e, 0x03, 0x18, 0x22, 0x26, 0x37, 0x25, 0x83, 0x44, 0x97,
	0xe8, 0x04, 0xbc, 0x50, 0xd9, 0xec, 0x75, 0xcb, 0xa5, 0x63, 0x55, 0xba, 0x67, 0x0a, 0xc7, 0xd6,
	0x85, 0x52, 0x98, 0x2c, 0x77, 0xe1, 0x01, 0x30, 0xcf, 0x6c, 0x93, 0x6e, 0x0d, 0x72, 0xf1, 0x8d,
	0x5e, 0xb7, 0x5c, 0xd4, 0x7a, 0xba, 0x7d, 0xc6, 0xd4, 0x8a, 0x61, 0xbc, 0xd4, 0x85, 0x1f, 0x83,
	0x69, 0xd5, 0x7b, 0xfa, 0x5c, 0x6d, 0x2d, 0xfb, 0x95, 0x14, 0x0c, 0xde, 0x05, 0xb3, 0x2e, 0xe6,
	0x4e, 0xff, 0xb0, 0xac, 0x50, 0xb1, 0x7a, 0xdd, 0xf2, 0x8c, 0xec, 0x85, 0xb1, 0x9a, 0x66, 0x24,
	0x70, 0xdf, 0x85, 0x7f, 0x07, 0xa6, 0xe5, 0x6f, 0xe6, 0x86, 0xe2, 0x57, 0xb1, 0x5e, 0xe1, 0xe7,
	0x9e, 0xfc, 0x27, 0xdf, 0x6a, 0x6b, 0xd8, 0x91, 0x97, 0x1f, 0x42, 0x4a, 0x77, 0xf3, 0x5f, 0xdf,
	0x01, 0xd7, 0xf5, 0xeb, 0xf4, 0x7b, 0xe6, 0x08, 0x0b, 0x24, 0xdb, 0xfa, 0xaf, 0x76, 0x48, 0x94,
	0xfb, 0xe7, 0x43, 0x0e, 0x65, 0x2e, 0xd7, 0x63, 0xc1, 0x9c, 0x07, 0xa9, 0x27, 0xea, 0x13, 0x4f,
	0x95, 0x14, 0xc8, 0x15, 0x89, 0x0b, 0xe4, 0x87, 0xe6, 0xa6, 0x62, 0xfc, 0x13, 0x4f, 0xfe, 0xe2,
	0xf4, 0xa4, 0x0f, 0x82, 0xef, 0x83, 0x19, 0xb5, 0x08, 0x73, 0xeb, 0x9a, 0x72, 0xbf, 0x51, 0xb8,
	0x29, 0xad, 0xbc, 0xf9, 0xe1, 0xbf, 0xd7, 0xaf, 0xfc, 0xd0, 0x5b, 0x9f, 0xfa, 0xb1, 0xb7, 0x3e,
	0xf5, 0xe7, 0xde, 0xfa, 0xd4, 0x7f, 0xf5, 0xd6, 0xa7, 0xfe, 0xf4, 0xd3, 0xfa, 0x95, 0x1f, 0x7f,
	0x5a, 0xbf, 0xf2, 0xe7, 0x9f, 0xd6, 0xaf, 0xfc, 0xe1, 0xb3, 0x0c, 0x73, 0x18, 0xfc, 0xbe, 0x1d,
	0x36, 0x1b, 0xdb, 0xa3, 0x7f, 0x13, 0x51, 0x9f, 0x51, 0x7f, 0xe7, 0xf0, 0xe9, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0x27, 0xc7, 0x42, 0xe0, 0xc6, 0x31, 0x00, 0x00,
}

func (m *SampledQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampledQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampledQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsedFollowerRead {
		i--
		if m.UsedFollowerRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.StatementFingerprintID) > 0 {
		i -= len(m.StatementFingerprintID)
		copy(dAtA[i:], m.StatementFingerprintID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.StatementFingerprintID)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xfa
	}
	if len(m.KVNodeIDs) > 0 {
		l := 0
		for _, e := range m.KVNodeIDs {
			l += sovTelemetry(uint64(e))
		}
		i -= l
		if l == len(m.KVNodeIDs) {
			dest := dAtA[i : i+len(m.KVNodeIDs)]
			for k, num := range m.KVNodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j1 := i
			for _, num1 := range m.KVNodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
		}
		i = encodeVarintTelemetry(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
	}
	if len(m.SQLInstanceIDs) > 0 {
		l := 0
		for _, e := range m.SQLInstanceIDs {
			l += sovTelemetry(uint64(e))
		}
		i -= l
		if l == len(m.SQLInstanceIDs) {
			dest := dAtA[i : i+len(m.SQLInstanceIDs)]
			for k, num := range m.SQLInstanceIDs {
				dest[k] = uint8(num)
			}
		} else {
			j2 := i
			for _, num1 := range m.SQLInstanceIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j2] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j2++
				}
				dAtA[j2] = uint8(num)
				j2++
			}
		}
		i = encodeVarintTelemetry(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xea
	}
	if len(m.SchemaChangerMode) > 0 {
		i -= len(m.SchemaChangerMode)
		copy(dAtA[i:], m.SchemaChangerMode)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SchemaChangerMode)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe2
	}
	if m.KVPairsRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KVPairsRead))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.MvccRangeKeySkippedPoints != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccRangeKeySkippedPoints))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.MvccRangeKeyContainedPoints != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccRangeKeyContainedPoints))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc8
	}
	if m.MvccRangeKeyCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccRangeKeyCount))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc0
	}
	if m.MvccPointsCoveredByRangeTombstones != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccPointsCoveredByRangeTombstones))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.MvccPointCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccPointCount))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if m.MvccValueBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccValueBytes))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa8
	}
	if m.MvccKeyBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccKeyBytes))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.MvccBlockBytesInCache != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccBlockBytesInCache))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.MvccBlockBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccBlockBytes))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.MvccSeekCountInternal != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccSeekCountInternal))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.MvccSeekCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccSeekCount))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.MvccStepCountInternal != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccStepCountInternal))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.MvccStepCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MvccStepCount))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.ParseLatencyNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ParseLatencyNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.IdleLatencyNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IdleLatencyNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.PlanLatencyNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.PlanLatencyNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.RunLatencyNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RunLatencyNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.OverheadLatencyNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.OverheadLatencyNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.ServiceLatencyNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ServiceLatencyNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.KvTimeNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KvTimeNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.KvGrpcCalls != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KvGrpcCalls))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.CpuTimeNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CpuTimeNanos))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Indexes[iNdEx])
			copy(dAtA[i:], m.Indexes[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Indexes[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.NanosSinceStatsForecasted != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NanosSinceStatsForecasted))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.TotalScanRowsWithoutForecastsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalScanRowsWithoutForecastsEstimate))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x89
	}
	if m.ScanWithStatsForecastCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ScanWithStatsForecastCount))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.ScanWithStatsCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ScanWithStatsCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.ScanCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ScanCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if len(m.IndexRecommendations) > 0 {
		for iNdEx := len(m.IndexRecommendations) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexRecommendations[iNdEx])
			copy(dAtA[i:], m.IndexRecommendations[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.IndexRecommendations[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if m.NetworkMessages != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NetworkMessages))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.KVRowsRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KVRowsRead))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.KVBytesRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KVBytesRead))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.MaxDiskUsage != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MaxDiskUsage))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxMemUsage != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MaxMemUsage))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.NetworkBytesSent != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NetworkBytesSent))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ContentionNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ContentionNanos))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.ZigZagJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ZigZagJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.ApplyJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApplyJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.InvertedJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.InvertedJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.MergeJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MergeJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.LookupJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.LookupJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.IndexJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IndexJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CrossJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CrossJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.HashJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.HashJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ExceptAllJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ExceptAllJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.IntersectAllJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IntersectAllJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.AntiJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.AntiJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.SemiJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SemiJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.FullOuterJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.FullOuterJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.LeftOuterJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.LeftOuterJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.InnerJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.InnerJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RowsWritten != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RowsWritten))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RowsRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RowsRead))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.BytesRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NanosSinceStatsCollected != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NanosSinceStatsCollected))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.StatsAvailable {
		i--
		if m.StatsAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.OutputRowsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OutputRowsEstimate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.TotalScanRowsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalScanRowsEstimate))))
		i--
		dAtA[i] = 0x79
	}
	if m.MaxFullScanRowsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFullScanRowsEstimate))))
		i--
		dAtA[i] = 0x71
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.StatementID) > 0 {
		i -= len(m.StatementID)
		copy(dAtA[i:], m.StatementID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.StatementID)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PlanGist) > 0 {
		i -= len(m.PlanGist)
		copy(dAtA[i:], m.PlanGist)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.PlanGist)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Distribution) > 0 {
		i -= len(m.Distribution)
		copy(dAtA[i:], m.Distribution)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Distribution)))
		i--
		dAtA[i] = 0x32
	}
	if m.CostEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CostEstimate))))
		i--
		dAtA[i] = 0x29
	}
	if m.SkippedQueries != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SkippedQueries))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.CommonSQLExecDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.CommonSQLEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SampledExecStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampledExecStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampledExecStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MVCCIteratorStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.CPUSQLNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CPUSQLNanos))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxDiskUsage != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MaxDiskUsage))
		i--
		dAtA[i] = 0x28
	}
	if m.NetworkMessages != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NetworkMessages))
		i--
		dAtA[i] = 0x20
	}
	if m.ContentionTime != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ContentionTime))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxMemUsage != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MaxMemUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.NetworkBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NetworkBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MVCCIteratorStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCIteratorStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MVCCIteratorStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeKeySkippedPoints != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RangeKeySkippedPoints))
		i--
		dAtA[i] = 0x68
	}
	if m.RangeKeyContainedPoints != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RangeKeyContainedPoints))
		i--
		dAtA[i] = 0x60
	}
	if m.RangeKeyCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RangeKeyCount))
		i--
		dAtA[i] = 0x58
	}
	if m.PointsCoveredByRangeTombstones != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.PointsCoveredByRangeTombstones))
		i--
		dAtA[i] = 0x50
	}
	if m.PointCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.PointCount))
		i--
		dAtA[i] = 0x48
	}
	if m.ValueBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ValueBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.KeyBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.BlockBytesInCache != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.BlockBytesInCache))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockBytes != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.BlockBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.SeekCountInternal != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SeekCountInternal))
		i--
		dAtA[i] = 0x20
	}
	if m.SeekCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SeekCount))
		i--
		dAtA[i] = 0x18
	}
	if m.StepCountInternal != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.StepCountInternal))
		i--
		dAtA[i] = 0x10
	}
	if m.StepCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.StepCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SampledTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampledTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampledTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatementFingerprintIDs) > 0 {
		for iNdEx := len(m.StatementFingerprintIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StatementFingerprintIDs[iNdEx])
			copy(dAtA[i:], m.StatementFingerprintIDs[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.StatementFingerprintIDs[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.TransactionFingerprintID) > 0 {
		i -= len(m.TransactionFingerprintID)
		copy(dAtA[i:], m.TransactionFingerprintID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TransactionFingerprintID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.SkippedTransactions != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SkippedTransactions))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.SampledExecStats != nil {
		{
			size, err := m.SampledExecStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.RowsWritten != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RowsWritten))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.RowsRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RowsRead))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.BytesRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IdleLatNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IdleLatNanos))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CommitLatNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CommitLatNanos))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RetryLatNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RetryLatNanos))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NumRows != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NumRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.LastAutoRetryReason) > 0 {
		i -= len(m.LastAutoRetryReason)
		copy(dAtA[i:], m.LastAutoRetryReason)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.LastAutoRetryReason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.NumRetries != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NumRetries))
		i--
		dAtA[i] = 0x78
	}
	if len(m.ErrorText) > 0 {
		i -= len(m.ErrorText)
		copy(dAtA[i:], m.ErrorText)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ErrorText)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SQLSTATE) > 0 {
		i -= len(m.SQLSTATE)
		copy(dAtA[i:], m.SQLSTATE)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SQLSTATE)))
		i--
		dAtA[i] = 0x6a
	}
	if m.ServiceLatNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ServiceLatNanos))
		i--
		dAtA[i] = 0x60
	}
	if m.EndTimeUnixNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.EndTimeUnixNanos))
		i--
		dAtA[i] = 0x58
	}
	if m.StartTimeUnixNanos != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.StartTimeUnixNanos))
		i--
		dAtA[i] = 0x50
	}
	if m.ImplicitTxn {
		i--
		if m.ImplicitTxn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Committed {
		i--
		if m.Committed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TxnCounter != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TxnCounter))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ApplicationName) > 0 {
		i -= len(m.ApplicationName)
		copy(dAtA[i:], m.ApplicationName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ApplicationName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CapturedIndexUsageStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapturedIndexUsageStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapturedIndexUsageStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x62
	}
	if m.IsInverted {
		i--
		if m.IsInverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.IndexType) > 0 {
		i -= len(m.IndexType)
		copy(dAtA[i:], m.IndexType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.IndexType)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x32
	}
	if m.IndexID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x28
	}
	if m.TableID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LastRead) > 0 {
		i -= len(m.LastRead)
		copy(dAtA[i:], m.LastRead)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.LastRead)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TotalReadCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TotalReadCount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoveryEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumRows != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NumRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.ApplicationName) > 0 {
		i -= len(m.ApplicationName)
		copy(dAtA[i:], m.ApplicationName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ApplicationName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.IgnoreExistingBackup {
		i--
		if m.IgnoreExistingBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.OnPreviousRunning) > 0 {
		i -= len(m.OnPreviousRunning)
		copy(dAtA[i:], m.OnPreviousRunning)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.OnPreviousRunning)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.OnExecutionFailure) > 0 {
		i -= len(m.OnExecutionFailure)
		copy(dAtA[i:], m.OnExecutionFailure)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.OnExecutionFailure)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.CustomFirstRunTime != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CustomFirstRunTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.FullBackupCron) > 0 {
		i -= len(m.FullBackupCron)
		copy(dAtA[i:], m.FullBackupCron)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.FullBackupCron)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.RecurringCron) > 0 {
		i -= len(m.RecurringCron)
		copy(dAtA[i:], m.RecurringCron)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.RecurringCron)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.ErrorText) > 0 {
		i -= len(m.ErrorText)
		copy(dAtA[i:], m.ErrorText)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ErrorText)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ResultStatus) > 0 {
		i -= len(m.ResultStatus)
		copy(dAtA[i:], m.ResultStatus)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ResultStatus)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.JobID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.JobID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.DebugPauseOn) > 0 {
		i -= len(m.DebugPauseOn)
		copy(dAtA[i:], m.DebugPauseOn)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DebugPauseOn)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.KMSCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KMSCount))
		i--
		dAtA[i] = 0x78
	}
	if len(m.KMSType) > 0 {
		i -= len(m.KMSType)
		copy(dAtA[i:], m.KMSType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.KMSType)))
		i--
		dAtA[i] = 0x72
	}
	if m.HasEncryptionPassphrase {
		i--
		if m.HasEncryptionPassphrase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.WithRevisionHistory {
		i--
		if m.WithRevisionHistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AsOfInterval != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.AsOfInterval))
		i--
		dAtA[i] = 0x50
	}
	if m.IsLocalityAware {
		i--
		if m.IsLocalityAware {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.DestinationAuthTypes) > 0 {
		for iNdEx := len(m.DestinationAuthTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DestinationAuthTypes[iNdEx])
			copy(dAtA[i:], m.DestinationAuthTypes[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DestinationAuthTypes[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DestinationStorageTypes) > 0 {
		for iNdEx := len(m.DestinationStorageTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DestinationStorageTypes[iNdEx])
			copy(dAtA[i:], m.DestinationStorageTypes[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DestinationStorageTypes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DestinationSubdirType) > 0 {
		i -= len(m.DestinationSubdirType)
		copy(dAtA[i:], m.DestinationSubdirType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DestinationSubdirType)))
		i--
		dAtA[i] = 0x32
	}
	if m.TargetCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TargetCount))
		i--
		dAtA[i] = 0x28
	}
	if m.IsMultiregionTarget {
		i--
		if m.IsMultiregionTarget {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.TargetScope) > 0 {
		i -= len(m.TargetScope)
		copy(dAtA[i:], m.TargetScope)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TargetScope)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RecoveryType) > 0 {
		i -= len(m.RecoveryType)
		copy(dAtA[i:], m.RecoveryType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.RecoveryType)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SchemaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DescID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DescID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ParentSchemaID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ParentSchemaID))
		i--
		dAtA[i] = 0x20
	}
	if m.ParentDatabaseID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ParentDatabaseID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SchemaSnapshotMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaSnapshotMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaSnapshotMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AsOfTimestamp != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.AsOfTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.NumRecords != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NumRecords))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SampledQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.CommonSQLEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.CommonSQLExecDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if m.SkippedQueries != 0 {
		n += 1 + sovTelemetry(uint64(m.SkippedQueries))
	}
	if m.CostEstimate != 0 {
		n += 9
	}
	l = len(m.Distribution)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.PlanGist)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.StatementID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.MaxFullScanRowsEstimate != 0 {
		n += 9
	}
	if m.TotalScanRowsEstimate != 0 {
		n += 9
	}
	if m.OutputRowsEstimate != 0 {
		n += 10
	}
	if m.StatsAvailable {
		n += 3
	}
	if m.NanosSinceStatsCollected != 0 {
		n += 2 + sovTelemetry(uint64(m.NanosSinceStatsCollected))
	}
	if m.BytesRead != 0 {
		n += 2 + sovTelemetry(uint64(m.BytesRead))
	}
	if m.RowsRead != 0 {
		n += 2 + sovTelemetry(uint64(m.RowsRead))
	}
	if m.RowsWritten != 0 {
		n += 2 + sovTelemetry(uint64(m.RowsWritten))
	}
	if m.InnerJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.InnerJoinCount))
	}
	if m.LeftOuterJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.LeftOuterJoinCount))
	}
	if m.FullOuterJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.FullOuterJoinCount))
	}
	if m.SemiJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.SemiJoinCount))
	}
	if m.AntiJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.AntiJoinCount))
	}
	if m.IntersectAllJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.IntersectAllJoinCount))
	}
	if m.ExceptAllJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ExceptAllJoinCount))
	}
	if m.HashJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.HashJoinCount))
	}
	if m.CrossJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.CrossJoinCount))
	}
	if m.IndexJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.IndexJoinCount))
	}
	if m.LookupJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.LookupJoinCount))
	}
	if m.MergeJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.MergeJoinCount))
	}
	if m.InvertedJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.InvertedJoinCount))
	}
	if m.ApplyJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ApplyJoinCount))
	}
	if m.ZigZagJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ZigZagJoinCount))
	}
	if m.ContentionNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.ContentionNanos))
	}
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 2 + l + sovTelemetry(uint64(l))
		}
	}
	if m.NetworkBytesSent != 0 {
		n += 2 + sovTelemetry(uint64(m.NetworkBytesSent))
	}
	if m.MaxMemUsage != 0 {
		n += 2 + sovTelemetry(uint64(m.MaxMemUsage))
	}
	if m.MaxDiskUsage != 0 {
		n += 2 + sovTelemetry(uint64(m.MaxDiskUsage))
	}
	if m.KVBytesRead != 0 {
		n += 2 + sovTelemetry(uint64(m.KVBytesRead))
	}
	if m.KVRowsRead != 0 {
		n += 2 + sovTelemetry(uint64(m.KVRowsRead))
	}
	if m.NetworkMessages != 0 {
		n += 2 + sovTelemetry(uint64(m.NetworkMessages))
	}
	if len(m.IndexRecommendations) > 0 {
		for _, s := range m.IndexRecommendations {
			l = len(s)
			n += 2 + l + sovTelemetry(uint64(l))
		}
	}
	if m.ScanCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ScanCount))
	}
	if m.ScanWithStatsCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ScanWithStatsCount))
	}
	if m.ScanWithStatsForecastCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ScanWithStatsForecastCount))
	}
	if m.TotalScanRowsWithoutForecastsEstimate != 0 {
		n += 10
	}
	if m.NanosSinceStatsForecasted != 0 {
		n += 2 + sovTelemetry(uint64(m.NanosSinceStatsForecasted))
	}
	if len(m.Indexes) > 0 {
		for _, s := range m.Indexes {
			l = len(s)
			n += 2 + l + sovTelemetry(uint64(l))
		}
	}
	if m.CpuTimeNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.CpuTimeNanos))
	}
	if m.KvGrpcCalls != 0 {
		n += 2 + sovTelemetry(uint64(m.KvGrpcCalls))
	}
	if m.KvTimeNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.KvTimeNanos))
	}
	if m.ServiceLatencyNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.ServiceLatencyNanos))
	}
	if m.OverheadLatencyNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.OverheadLatencyNanos))
	}
	if m.RunLatencyNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.RunLatencyNanos))
	}
	if m.PlanLatencyNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.PlanLatencyNanos))
	}
	if m.IdleLatencyNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.IdleLatencyNanos))
	}
	if m.ParseLatencyNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.ParseLatencyNanos))
	}
	if m.MvccStepCount != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccStepCount))
	}
	if m.MvccStepCountInternal != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccStepCountInternal))
	}
	if m.MvccSeekCount != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccSeekCount))
	}
	if m.MvccSeekCountInternal != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccSeekCountInternal))
	}
	if m.MvccBlockBytes != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccBlockBytes))
	}
	if m.MvccBlockBytesInCache != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccBlockBytesInCache))
	}
	if m.MvccKeyBytes != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccKeyBytes))
	}
	if m.MvccValueBytes != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccValueBytes))
	}
	if m.MvccPointCount != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccPointCount))
	}
	if m.MvccPointsCoveredByRangeTombstones != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccPointsCoveredByRangeTombstones))
	}
	if m.MvccRangeKeyCount != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccRangeKeyCount))
	}
	if m.MvccRangeKeyContainedPoints != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccRangeKeyContainedPoints))
	}
	if m.MvccRangeKeySkippedPoints != 0 {
		n += 2 + sovTelemetry(uint64(m.MvccRangeKeySkippedPoints))
	}
	if m.KVPairsRead != 0 {
		n += 2 + sovTelemetry(uint64(m.KVPairsRead))
	}
	l = len(m.SchemaChangerMode)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if len(m.SQLInstanceIDs) > 0 {
		l = 0
		for _, e := range m.SQLInstanceIDs {
			l += sovTelemetry(uint64(e))
		}
		n += 2 + sovTelemetry(uint64(l)) + l
	}
	if len(m.KVNodeIDs) > 0 {
		l = 0
		for _, e := range m.KVNodeIDs {
			l += sovTelemetry(uint64(e))
		}
		n += 2 + sovTelemetry(uint64(l)) + l
	}
	l = len(m.StatementFingerprintID)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.UsedFollowerRead {
		n += 3
	}
	return n
}

func (m *SampledExecStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkBytes != 0 {
		n += 1 + sovTelemetry(uint64(m.NetworkBytes))
	}
	if m.MaxMemUsage != 0 {
		n += 1 + sovTelemetry(uint64(m.MaxMemUsage))
	}
	if m.ContentionTime != 0 {
		n += 1 + sovTelemetry(uint64(m.ContentionTime))
	}
	if m.NetworkMessages != 0 {
		n += 1 + sovTelemetry(uint64(m.NetworkMessages))
	}
	if m.MaxDiskUsage != 0 {
		n += 1 + sovTelemetry(uint64(m.MaxDiskUsage))
	}
	if m.CPUSQLNanos != 0 {
		n += 1 + sovTelemetry(uint64(m.CPUSQLNanos))
	}
	l = m.MVCCIteratorStats.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}

func (m *MVCCIteratorStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepCount != 0 {
		n += 1 + sovTelemetry(uint64(m.StepCount))
	}
	if m.StepCountInternal != 0 {
		n += 1 + sovTelemetry(uint64(m.StepCountInternal))
	}
	if m.SeekCount != 0 {
		n += 1 + sovTelemetry(uint64(m.SeekCount))
	}
	if m.SeekCountInternal != 0 {
		n += 1 + sovTelemetry(uint64(m.SeekCountInternal))
	}
	if m.BlockBytes != 0 {
		n += 1 + sovTelemetry(uint64(m.BlockBytes))
	}
	if m.BlockBytesInCache != 0 {
		n += 1 + sovTelemetry(uint64(m.BlockBytesInCache))
	}
	if m.KeyBytes != 0 {
		n += 1 + sovTelemetry(uint64(m.KeyBytes))
	}
	if m.ValueBytes != 0 {
		n += 1 + sovTelemetry(uint64(m.ValueBytes))
	}
	if m.PointCount != 0 {
		n += 1 + sovTelemetry(uint64(m.PointCount))
	}
	if m.PointsCoveredByRangeTombstones != 0 {
		n += 1 + sovTelemetry(uint64(m.PointsCoveredByRangeTombstones))
	}
	if m.RangeKeyCount != 0 {
		n += 1 + sovTelemetry(uint64(m.RangeKeyCount))
	}
	if m.RangeKeyContainedPoints != 0 {
		n += 1 + sovTelemetry(uint64(m.RangeKeyContainedPoints))
	}
	if m.RangeKeySkippedPoints != 0 {
		n += 1 + sovTelemetry(uint64(m.RangeKeySkippedPoints))
	}
	return n
}

func (m *SampledTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.ApplicationName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.TxnCounter != 0 {
		n += 1 + sovTelemetry(uint64(m.TxnCounter))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Committed {
		n += 2
	}
	if m.ImplicitTxn {
		n += 2
	}
	if m.StartTimeUnixNanos != 0 {
		n += 1 + sovTelemetry(uint64(m.StartTimeUnixNanos))
	}
	if m.EndTimeUnixNanos != 0 {
		n += 1 + sovTelemetry(uint64(m.EndTimeUnixNanos))
	}
	if m.ServiceLatNanos != 0 {
		n += 1 + sovTelemetry(uint64(m.ServiceLatNanos))
	}
	l = len(m.SQLSTATE)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.ErrorText)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.NumRetries != 0 {
		n += 1 + sovTelemetry(uint64(m.NumRetries))
	}
	l = len(m.LastAutoRetryReason)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.NumRows != 0 {
		n += 2 + sovTelemetry(uint64(m.NumRows))
	}
	if m.RetryLatNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.RetryLatNanos))
	}
	if m.CommitLatNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.CommitLatNanos))
	}
	if m.IdleLatNanos != 0 {
		n += 2 + sovTelemetry(uint64(m.IdleLatNanos))
	}
	if m.BytesRead != 0 {
		n += 2 + sovTelemetry(uint64(m.BytesRead))
	}
	if m.RowsRead != 0 {
		n += 2 + sovTelemetry(uint64(m.RowsRead))
	}
	if m.RowsWritten != 0 {
		n += 2 + sovTelemetry(uint64(m.RowsWritten))
	}
	if m.SampledExecStats != nil {
		l = m.SampledExecStats.Size()
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.SkippedTransactions != 0 {
		n += 2 + sovTelemetry(uint64(m.SkippedTransactions))
	}
	l = len(m.TransactionFingerprintID)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if len(m.StatementFingerprintIDs) > 0 {
		for _, s := range m.StatementFingerprintIDs {
			l = len(s)
			n += 2 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CapturedIndexUsageStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if m.TotalReadCount != 0 {
		n += 1 + sovTelemetry(uint64(m.TotalReadCount))
	}
	l = len(m.LastRead)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.TableID != 0 {
		n += 1 + sovTelemetry(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovTelemetry(uint64(m.IndexID))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.IndexType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.IsUnique {
		n += 2
	}
	if m.IsInverted {
		n += 2
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *RecoveryEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.RecoveryType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TargetScope)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.IsMultiregionTarget {
		n += 2
	}
	if m.TargetCount != 0 {
		n += 1 + sovTelemetry(uint64(m.TargetCount))
	}
	l = len(m.DestinationSubdirType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.DestinationStorageTypes) > 0 {
		for _, s := range m.DestinationStorageTypes {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.DestinationAuthTypes) > 0 {
		for _, s := range m.DestinationAuthTypes {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.IsLocalityAware {
		n += 2
	}
	if m.AsOfInterval != 0 {
		n += 1 + sovTelemetry(uint64(m.AsOfInterval))
	}
	if m.WithRevisionHistory {
		n += 2
	}
	if m.HasEncryptionPassphrase {
		n += 2
	}
	l = len(m.KMSType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KMSCount != 0 {
		n += 1 + sovTelemetry(uint64(m.KMSCount))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 2 + l + sovTelemetry(uint64(l))
		}
	}
	l = len(m.DebugPauseOn)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.JobID != 0 {
		n += 2 + sovTelemetry(uint64(m.JobID))
	}
	l = len(m.ResultStatus)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.ErrorText)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.RecurringCron)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.FullBackupCron)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.CustomFirstRunTime != 0 {
		n += 2 + sovTelemetry(uint64(m.CustomFirstRunTime))
	}
	l = len(m.OnExecutionFailure)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.OnPreviousRunning)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.IgnoreExistingBackup {
		n += 3
	}
	l = len(m.ApplicationName)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.NumRows != 0 {
		n += 2 + sovTelemetry(uint64(m.NumRows))
	}
	return n
}

func (m *SchemaDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ParentDatabaseID != 0 {
		n += 1 + sovTelemetry(uint64(m.ParentDatabaseID))
	}
	if m.ParentSchemaID != 0 {
		n += 1 + sovTelemetry(uint64(m.ParentSchemaID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DescID != 0 {
		n += 1 + sovTelemetry(uint64(m.DescID))
	}
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *SchemaSnapshotMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.NumRecords != 0 {
		n += 1 + sovTelemetry(uint64(m.NumRecords))
	}
	if m.AsOfTimestamp != 0 {
		n += 1 + sovTelemetry(uint64(m.AsOfTimestamp))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SampledQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampledQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampledQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonSQLEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonSQLEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonSQLExecDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonSQLExecDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkippedQueries", wireType)
			}
			m.SkippedQueries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkippedQueries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CostEstimate = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distribution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Distribution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanGist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanGist = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFullScanRowsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFullScanRowsEstimate = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScanRowsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalScanRowsEstimate = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRowsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OutputRowsEstimate = float64(math.Float64frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatsAvailable = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanosSinceStatsCollected", wireType)
			}
			m.NanosSinceStatsCollected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanosSinceStatsCollected |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsRead", wireType)
			}
			m.RowsRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsWritten", wireType)
			}
			m.RowsWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsWritten |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerJoinCount", wireType)
			}
			m.InnerJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOuterJoinCount", wireType)
			}
			m.LeftOuterJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftOuterJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullOuterJoinCount", wireType)
			}
			m.FullOuterJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullOuterJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiJoinCount", wireType)
			}
			m.SemiJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SemiJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AntiJoinCount", wireType)
			}
			m.AntiJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AntiJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntersectAllJoinCount", wireType)
			}
			m.IntersectAllJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntersectAllJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptAllJoinCount", wireType)
			}
			m.ExceptAllJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExceptAllJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashJoinCount", wireType)
			}
			m.HashJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossJoinCount", wireType)
			}
			m.CrossJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexJoinCount", wireType)
			}
			m.IndexJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupJoinCount", wireType)
			}
			m.LookupJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookupJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeJoinCount", wireType)
			}
			m.MergeJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergeJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedJoinCount", wireType)
			}
			m.InvertedJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyJoinCount", wireType)
			}
			m.ApplyJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigZagJoinCount", wireType)
			}
			m.ZigZagJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZigZagJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentionNanos", wireType)
			}
			m.ContentionNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentionNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBytesSent", wireType)
			}
			m.NetworkBytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkBytesSent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemUsage", wireType)
			}
			m.MaxMemUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMemUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiskUsage", wireType)
			}
			m.MaxDiskUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDiskUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KVBytesRead", wireType)
			}
			m.KVBytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KVBytesRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KVRowsRead", wireType)
			}
			m.KVRowsRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KVRowsRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMessages", wireType)
			}
			m.NetworkMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMessages |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexRecommendations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexRecommendations = append(m.IndexRecommendations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanCount", wireType)
			}
			m.ScanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanWithStatsCount", wireType)
			}
			m.ScanWithStatsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanWithStatsCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanWithStatsForecastCount", wireType)
			}
			m.ScanWithStatsForecastCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanWithStatsForecastCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScanRowsWithoutForecastsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalScanRowsWithoutForecastsEstimate = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanosSinceStatsForecasted", wireType)
			}
			m.NanosSinceStatsForecasted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanosSinceStatsForecasted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuTimeNanos", wireType)
			}
			m.CpuTimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuTimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvGrpcCalls", wireType)
			}
			m.KvGrpcCalls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KvGrpcCalls |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvTimeNanos", wireType)
			}
			m.KvTimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KvTimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceLatencyNanos", wireType)
			}
			m.ServiceLatencyNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceLatencyNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverheadLatencyNanos", wireType)
			}
			m.OverheadLatencyNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverheadLatencyNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunLatencyNanos", wireType)
			}
			m.RunLatencyNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunLatencyNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanLatencyNanos", wireType)
			}
			m.PlanLatencyNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanLatencyNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleLatencyNanos", wireType)
			}
			m.IdleLatencyNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleLatencyNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseLatencyNanos", wireType)
			}
			m.ParseLatencyNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParseLatencyNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccStepCount", wireType)
			}
			m.MvccStepCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccStepCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccStepCountInternal", wireType)
			}
			m.MvccStepCountInternal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccStepCountInternal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccSeekCount", wireType)
			}
			m.MvccSeekCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccSeekCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccSeekCountInternal", wireType)
			}
			m.MvccSeekCountInternal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccSeekCountInternal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccBlockBytes", wireType)
			}
			m.MvccBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccBlockBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccBlockBytesInCache", wireType)
			}
			m.MvccBlockBytesInCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccBlockBytesInCache |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccKeyBytes", wireType)
			}
			m.MvccKeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccKeyBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 69:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccValueBytes", wireType)
			}
			m.MvccValueBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccValueBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccPointCount", wireType)
			}
			m.MvccPointCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccPointCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccPointsCoveredByRangeTombstones", wireType)
			}
			m.MvccPointsCoveredByRangeTombstones = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccPointsCoveredByRangeTombstones |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccRangeKeyCount", wireType)
			}
			m.MvccRangeKeyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccRangeKeyCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccRangeKeyContainedPoints", wireType)
			}
			m.MvccRangeKeyContainedPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccRangeKeyContainedPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccRangeKeySkippedPoints", wireType)
			}
			m.MvccRangeKeySkippedPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MvccRangeKeySkippedPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KVPairsRead", wireType)
			}
			m.KVPairsRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KVPairsRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 76:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChangerMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaChangerMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 77:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SQLInstanceIDs = append(m.SQLInstanceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTelemetry
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.SQLInstanceIDs == nil {
						m.SQLInstanceIDs = make([]int32, 0, elementCount)
					} else {
						m.SQLInstanceIDs = slices.Grow(m.SQLInstanceIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SQLInstanceIDs = append(m.SQLInstanceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLInstanceIDs", wireType)
			}
		case 78:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KVNodeIDs = append(m.KVNodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTelemetry
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.KVNodeIDs == nil {
						m.KVNodeIDs = make([]int32, 0, elementCount)
					} else {
						m.KVNodeIDs = slices.Grow(m.KVNodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KVNodeIDs = append(m.KVNodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KVNodeIDs", wireType)
			}
		case 79:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprintID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprintID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedFollowerRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsedFollowerRead = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampledExecStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampledExecStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampledExecStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBytes", wireType)
			}
			m.NetworkBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemUsage", wireType)
			}
			m.MaxMemUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMemUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentionTime", wireType)
			}
			m.ContentionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentionTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMessages", wireType)
			}
			m.NetworkMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMessages |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiskUsage", wireType)
			}
			m.MaxDiskUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDiskUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUSQLNanos", wireType)
			}
			m.CPUSQLNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CPUSQLNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCIteratorStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCIteratorStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCIteratorStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCIteratorStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCIteratorStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepCount", wireType)
			}
			m.StepCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepCountInternal", wireType)
			}
			m.StepCountInternal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepCountInternal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekCount", wireType)
			}
			m.SeekCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeekCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekCountInternal", wireType)
			}
			m.SeekCountInternal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeekCountInternal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytes", wireType)
			}
			m.BlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytesInCache", wireType)
			}
			m.BlockBytesInCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockBytesInCache |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			m.KeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			m.ValueBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointCount", wireType)
			}
			m.PointCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsCoveredByRangeTombstones", wireType)
			}
			m.PointsCoveredByRangeTombstones = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointsCoveredByRangeTombstones |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyCount", wireType)
			}
			m.RangeKeyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeyCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyContainedPoints", wireType)
			}
			m.RangeKeyContainedPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeyContainedPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeySkippedPoints", wireType)
			}
			m.RangeKeySkippedPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeySkippedPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampledTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampledTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampledTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnCounter", wireType)
			}
			m.TxnCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Committed = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitTxn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitTxn = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNanos", wireType)
			}
			m.StartTimeUnixNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimeUnixNanos", wireType)
			}
			m.EndTimeUnixNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimeUnixNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceLatNanos", wireType)
			}
			m.ServiceLatNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceLatNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLSTATE", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SQLSTATE = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorText = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			m.NumRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRetries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAutoRetryReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastAutoRetryReason = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			m.NumRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryLatNanos", wireType)
			}
			m.RetryLatNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryLatNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitLatNanos", wireType)
			}
			m.CommitLatNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitLatNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleLatNanos", wireType)
			}
			m.IdleLatNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleLatNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsRead", wireType)
			}
			m.RowsRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsWritten", wireType)
			}
			m.RowsWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsWritten |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampledExecStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SampledExecStats == nil {
				m.SampledExecStats = &SampledExecStats{}
			}
			if err := m.SampledExecStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkippedTransactions", wireType)
			}
			m.SkippedTransactions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkippedTransactions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionFingerprintID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionFingerprintID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprintIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprintIDs = append(m.StatementFingerprintIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapturedIndexUsageStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapturedIndexUsageStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapturedIndexUsageStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReadCount", wireType)
			}
			m.TotalReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalReadCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastRead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryType = RecoveryEventType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultiregionTarget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultiregionTarget = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCount", wireType)
			}
			m.TargetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubdirType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubdirType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationStorageTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationStorageTypes = append(m.DestinationStorageTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationAuthTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationAuthTypes = append(m.DestinationAuthTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocalityAware", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocalityAware = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfInterval", wireType)
			}
			m.AsOfInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithRevisionHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithRevisionHistory = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEncryptionPassphrase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasEncryptionPassphrase = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KMSType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSCount", wireType)
			}
			m.KMSCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KMSCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugPauseOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugPauseOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorText = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurringCron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecurringCron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullBackupCron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullBackupCron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFirstRunTime", wireType)
			}
			m.CustomFirstRunTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomFirstRunTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExecutionFailure", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnExecutionFailure = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnPreviousRunning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnPreviousRunning = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreExistingBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreExistingBackup = bool(v != 0)
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			m.NumRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentDatabaseID", wireType)
			}
			m.ParentDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentDatabaseID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSchemaID", wireType)
			}
			m.ParentSchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentSchemaID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			m.DescID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &descpb.Descriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaSnapshotMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaSnapshotMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaSnapshotMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRecords", wireType)
			}
			m.NumRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfTimestamp", wireType)
			}
			m.AsOfTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTelemetry = fmt.Errorf("proto: unexpected end of group")
)

