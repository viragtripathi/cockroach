// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: multitenant/tenantcapabilitiespb/capabilities.proto

package tenantcapabilitiespb

import (
	fmt "fmt"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TenantCapabilities encapsulates a set of capabilities[1] for a specific
// tenant. Capabilities for a specific tenant are stored in the system.tenants
// table and are checked against in KV when the tenant performs a privileged
// operation.
//
// [1] Certain requests in the system are considered "privileged", and as such,
// tenants are only allowed to perform them if they have the appropriate
// capability. For example, performing an AdminSplit.
//
// When adding new capabilities to this list, please make sure to add support
// for the new values to `show_tenant.go` and `tenant_capability.go` in order to
// integrate them with the SQL infrastructure for managing capabilities.
type TenantCapabilities struct {
	// DisableAdminSplit, if set to true, revokes the tenants ability to
	// successfully perform `AdminSplit` requests.
	//
	// This field uses the "disabled" verbiage, unlike the other fields on this
	// proto. Doing so ensures the zero value translates to `AdminSplits` being
	// allowed by default for secondary tenants. This is because splits and
	// scatters are integral to the performance of IMPORT/RESTORE.
	DisableAdminSplit bool `protobuf:"varint,1,opt,name=disable_admin_split,json=disableAdminSplit,proto3" json:"disable_admin_split,omitempty"`
	// DisableAdminScatter, if set to true, revokes a tenant's the ability to
	// successfully perform `AdminScatter` requests.
	//
	// This field uses the "disabled" verbiage, unlike the other fields on this
	// proto. Doing so ensures the zero value translates to `AdminScatters` being
	// allowed by default for secondary tenants. This is because splits and
	// scatters are integral to the performance of IMPORT/RESTORE.
	DisableAdminScatter bool `protobuf:"varint,6,opt,name=disable_admin_scatter,json=disableAdminScatter,proto3" json:"disable_admin_scatter,omitempty"`
	// CanViewNodeInfo, if set to true, grants the tenant the ability
	// retrieve node-level observability data at endpoints such as `_status/nodes`
	// and in the DB Console overview page.
	CanViewNodeInfo bool `protobuf:"varint,2,opt,name=can_view_node_info,json=canViewNodeInfo,proto3" json:"can_view_node_info,omitempty"`
	// CanViewTSDBMetrics, if set to true, grants the tenant the ability to
	// make arbitrary queries of the TSDB of the entire cluster. Currently,
	// we do not store per-tenant metrics so this will surface system metrics
	// to the tenant.
	// TODO(davidh): Revise this once tenant-scoped metrics are implemented in
	// https://github.com/cockroachdb/cockroach/issues/96438
	CanViewTSDBMetrics bool `protobuf:"varint,3,opt,name=can_view_tsdb_metrics,json=canViewTsdbMetrics,proto3" json:"can_view_tsdb_metrics,omitempty"`
	// SpanConfigBounds, if set, bound the allowable values of span
	// configurations enacted by the tenant. Note that the tenant can install
	// span configs which do not conform to its bounds; the bounds result in
	// post-hoc clamping of the span configs to conform. This model diverges
	// from other capabilities because the span config infrastructure is
	// stateful and asynchronous. The bounds may change after a span config
	// has been accepted, in which case no error would flow to the user.
	// Furthermore the span config reconciliation infrastructure is poorly
	// positioned to surface errors to the user.
	SpanConfigBounds *SpanConfigBounds `protobuf:"bytes,4,opt,name=span_config_bounds,json=spanConfigBounds,proto3" json:"span_config_bounds,omitempty"`
	// CanAdminUnsplit if, set to true, grants the tenant the ability to
	// successfully perform `AdminUnsplit` requests.
	CanAdminUnsplit bool `protobuf:"varint,5,opt,name=can_admin_unsplit,json=canAdminUnsplit,proto3" json:"can_admin_unsplit,omitempty"`
	// CanAdminRelocateRange if set to true, grants the tenant the ability to
	// successfully perform `AdminChangeReplicas`, `AdminRelocateRange`,
	// `AdminTransferLease` requests.
	CanAdminRelocateRange bool `protobuf:"varint,7,opt,name=can_admin_relocate_range,json=canAdminRelocateRange,proto3" json:"can_admin_relocate_range,omitempty"`
	// ExemptFromRateLimiting, if set to true, exempts the tenant from the KV-side tenant
	// rate limiter.
	ExemptFromRateLimiting bool `protobuf:"varint,8,opt,name=exempt_from_rate_limiting,json=exemptFromRateLimiting,proto3" json:"exempt_from_rate_limiting,omitempty"`
	// CanUseNodelocalStorage if set to true, grants the tenant the ability
	// to use nodelocal storage  on any KV node.
	CanUseNodelocalStorage bool `protobuf:"varint,9,opt,name=can_use_nodelocal_storage,json=canUseNodelocalStorage,proto3" json:"can_use_nodelocal_storage,omitempty"`
	// CanCheckConsistency if set to true, grants the tenant the ability to run
	// range consistency checks.
	CanCheckConsistency bool `protobuf:"varint,10,opt,name=can_check_consistency,json=canCheckConsistency,proto3" json:"can_check_consistency,omitempty"`
	// CanDebugProcess, if set to true, grants the tenant the ability to
	// set vmodule on the process and run pprof profiles and tools.
	CanDebugProcess bool `protobuf:"varint,11,opt,name=can_debug_process,json=canDebugProcess,proto3" json:"can_debug_process,omitempty"`
	// CanViewAllMetrics, if set to true, grants the tenant the ability
	// to query any metrics from the host.
	CanViewAllMetrics bool `protobuf:"varint,12,opt,name=can_view_all_metrics,json=canViewAllMetrics,proto3" json:"can_view_all_metrics,omitempty"`
	// CanPrepareTxns, if set to true, grants the tenant the ability to prepare
	// transactions as part of the XA two-phase commit protocol.
	CanPrepareTxns bool `protobuf:"varint,13,opt,name=can_prepare_txns,json=canPrepareTxns,proto3" json:"can_prepare_txns,omitempty"`
}

func (m *TenantCapabilities) Reset()         { *m = TenantCapabilities{} }
func (m *TenantCapabilities) String() string { return proto.CompactTextString(m) }
func (*TenantCapabilities) ProtoMessage()    {}
func (*TenantCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_f3e336cfc2a93c48, []int{0}
}
func (m *TenantCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantCapabilities.Merge(m, src)
}
func (m *TenantCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *TenantCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_TenantCapabilities proto.InternalMessageInfo

// SpanConfigBound is used to constrain the possible values a SpanConfig may
// contain.
type SpanConfigBounds struct {
	// GcTtlSeconds bounds the configuration of gc.ttl_seconds.
	GCTTLSeconds *SpanConfigBounds_Int32Range `protobuf:"bytes,1,opt,name=gc_ttl_seconds,json=gcTtlSeconds,proto3" json:"gc_ttl_seconds,omitempty"`
	// RangeMaxSize bounds the configuration of range_max_bytes.
	RangeMaxBytes *SpanConfigBounds_Int64Range `protobuf:"bytes,2,opt,name=range_max_bytes,json=rangeMaxBytes,proto3" json:"range_max_bytes,omitempty"`
	// RangeMinSize bounds the configuration of range_min_bytes.
	RangeMinBytes *SpanConfigBounds_Int64Range `protobuf:"bytes,3,opt,name=range_min_bytes,json=rangeMinBytes,proto3" json:"range_min_bytes,omitempty"`
	// NumReplicas bounds the configuration of num_replicas.
	NumReplicas *SpanConfigBounds_Int32Range `protobuf:"bytes,4,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// NumVoters bounds the configuration of num_voters.
	NumVoters *SpanConfigBounds_Int32Range `protobuf:"bytes,5,opt,name=num_voters,json=numVoters,proto3" json:"num_voters,omitempty"`
	// ConstraintBounds is used to bound the replication constraint fields of
	// a span config: constraints, voter_constraints, and
	// leaseholder_preferences.
	ConstraintBounds *SpanConfigBounds_ConstraintBounds `protobuf:"bytes,6,opt,name=constraint_bounds,json=constraintBounds,proto3" json:"constraint_bounds,omitempty"`
}

func (m *SpanConfigBounds) Reset()         { *m = SpanConfigBounds{} }
func (m *SpanConfigBounds) String() string { return proto.CompactTextString(m) }
func (*SpanConfigBounds) ProtoMessage()    {}
func (*SpanConfigBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_f3e336cfc2a93c48, []int{1}
}
func (m *SpanConfigBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigBounds.Merge(m, src)
}
func (m *SpanConfigBounds) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigBounds.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigBounds proto.InternalMessageInfo

// Int32Range is an interval of int32 representing [start, end].
// If end is less than start, it is interpreted to be equal
// start; there is no invalid representation.
type SpanConfigBounds_Int32Range struct {
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanConfigBounds_Int32Range) Reset()         { *m = SpanConfigBounds_Int32Range{} }
func (m *SpanConfigBounds_Int32Range) String() string { return proto.CompactTextString(m) }
func (*SpanConfigBounds_Int32Range) ProtoMessage()    {}
func (*SpanConfigBounds_Int32Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_f3e336cfc2a93c48, []int{1, 0}
}
func (m *SpanConfigBounds_Int32Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigBounds_Int32Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigBounds_Int32Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigBounds_Int32Range.Merge(m, src)
}
func (m *SpanConfigBounds_Int32Range) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigBounds_Int32Range) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigBounds_Int32Range.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigBounds_Int32Range proto.InternalMessageInfo

// Int64Range is an interval of int64 representing [start, end].
// If end is less than start, it is interpreted to be equal
// start; there is no invalid representation.
type SpanConfigBounds_Int64Range struct {
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanConfigBounds_Int64Range) Reset()         { *m = SpanConfigBounds_Int64Range{} }
func (m *SpanConfigBounds_Int64Range) String() string { return proto.CompactTextString(m) }
func (*SpanConfigBounds_Int64Range) ProtoMessage()    {}
func (*SpanConfigBounds_Int64Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_f3e336cfc2a93c48, []int{1, 1}
}
func (m *SpanConfigBounds_Int64Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigBounds_Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigBounds_Int64Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigBounds_Int64Range.Merge(m, src)
}
func (m *SpanConfigBounds_Int64Range) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigBounds_Int64Range) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigBounds_Int64Range.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigBounds_Int64Range proto.InternalMessageInfo

// ConstraintsConjunction is like the roachpb equivalent with the same name,
// but lacking a num_replicas field. This message is used when clamping a
// SpanConfig constraint which is out of conformance.
type SpanConfigBounds_ConstraintsConjunction struct {
	Constraints []roachpb.Constraint `protobuf:"bytes,1,rep,name=constraints,proto3" json:"constraints"`
}

func (m *SpanConfigBounds_ConstraintsConjunction) Reset() {
	*m = SpanConfigBounds_ConstraintsConjunction{}
}
func (m *SpanConfigBounds_ConstraintsConjunction) String() string { return proto.CompactTextString(m) }
func (*SpanConfigBounds_ConstraintsConjunction) ProtoMessage()    {}
func (*SpanConfigBounds_ConstraintsConjunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_f3e336cfc2a93c48, []int{1, 2}
}
func (m *SpanConfigBounds_ConstraintsConjunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigBounds_ConstraintsConjunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigBounds_ConstraintsConjunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigBounds_ConstraintsConjunction.Merge(m, src)
}
func (m *SpanConfigBounds_ConstraintsConjunction) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigBounds_ConstraintsConjunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigBounds_ConstraintsConjunction.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigBounds_ConstraintsConjunction proto.InternalMessageInfo

// ConstraintBounds represents bounds on voter_constraints, constraints,
// and lease_preferences. These fields are bound by the same constraints,
// because they need to be internally consistent.
//
// The basic structure is that these fields will be checked against
// the allowed constraint bounds, and, if the values fall outside
// those bounds, they will be clamped using the values in fallback.
// See spanconfigbounds/doc.go for more discussion.
//
// Note: the fallback constraints should conform to the allowed constraints,
// but if they do not, then a clamped configuration may not conform.
//
// TODO(ajwerner): Perhaps add a fallback rule on conformance to say that
// a constraint conforms if its constraints exactly match fallback. If we
// did that, then we would be able to say that a clamped constraint always
// conforms and we wouldn't have any sort of invalid state.
type SpanConfigBounds_ConstraintBounds struct {
	// Constraints is a *sorted* slice of permitted constraints.
	//
	// If a constraint in a SpanConfig does not match a constraint in this
	// slice, the entire field is considered invalid and will be clamped.
	//
	// The logic for clamping is to mirror the structure of the existing
	// distribution of replicas, to the extent possible, but as applied to
	// the fallback constraints.
	Allowed []roachpb.Constraint `protobuf:"bytes,1,rep,name=allowed,proto3" json:"allowed"`
	// FallbackConstraints are used to determine the constraints to use when
	// clamping a configuration which is out of conformance.
	//
	// If the existing constraint had just one entry with no numeric bound,
	// the first element will be used as the constraint.
	//
	// If the existing constraint had just one entry with a numeric constraint,
	// we'll clamp this to the num_replicas/2.
	//
	// If the existing constraint had more than one entry with numeric
	// constraints, we'll clamp accordingly.
	Fallback []SpanConfigBounds_ConstraintsConjunction `protobuf:"bytes,2,rep,name=fallback,proto3" json:"fallback"`
}

func (m *SpanConfigBounds_ConstraintBounds) Reset()         { *m = SpanConfigBounds_ConstraintBounds{} }
func (m *SpanConfigBounds_ConstraintBounds) String() string { return proto.CompactTextString(m) }
func (*SpanConfigBounds_ConstraintBounds) ProtoMessage()    {}
func (*SpanConfigBounds_ConstraintBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_f3e336cfc2a93c48, []int{1, 3}
}
func (m *SpanConfigBounds_ConstraintBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigBounds_ConstraintBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigBounds_ConstraintBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigBounds_ConstraintBounds.Merge(m, src)
}
func (m *SpanConfigBounds_ConstraintBounds) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigBounds_ConstraintBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigBounds_ConstraintBounds.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigBounds_ConstraintBounds proto.InternalMessageInfo

func init() {
	proto.RegisterType((*TenantCapabilities)(nil), "cockroach.multitenant.tenantcapabilitiespb.TenantCapabilities")
	proto.RegisterType((*SpanConfigBounds)(nil), "cockroach.multitenant.tenantcapabilitiespb.SpanConfigBounds")
	proto.RegisterType((*SpanConfigBounds_Int32Range)(nil), "cockroach.multitenant.tenantcapabilitiespb.SpanConfigBounds.Int32Range")
	proto.RegisterType((*SpanConfigBounds_Int64Range)(nil), "cockroach.multitenant.tenantcapabilitiespb.SpanConfigBounds.Int64Range")
	proto.RegisterType((*SpanConfigBounds_ConstraintsConjunction)(nil), "cockroach.multitenant.tenantcapabilitiespb.SpanConfigBounds.ConstraintsConjunction")
	proto.RegisterType((*SpanConfigBounds_ConstraintBounds)(nil), "cockroach.multitenant.tenantcapabilitiespb.SpanConfigBounds.ConstraintBounds")
}

func init() {
	proto.RegisterFile("multitenant/tenantcapabilitiespb/capabilities.proto", fileDescriptor_f3e336cfc2a93c48)
}

var fileDescriptor_f3e336cfc2a93c48 = []byte{
	// 888 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x41, 0x6f, 0xdb, 0x36,
	0x18, 0xb5, 0xea, 0x38, 0x4d, 0xe9, 0xb4, 0x75, 0xd8, 0x24, 0x50, 0x03, 0xcc, 0x29, 0x7a, 0x0a,
	0x3a, 0xc0, 0x06, 0x92, 0x61, 0xc3, 0x8a, 0xed, 0x50, 0xbb, 0x5d, 0x11, 0xa0, 0x29, 0x0a, 0xd9,
	0xed, 0x61, 0x17, 0x82, 0xa2, 0x68, 0x85, 0x09, 0x45, 0x0a, 0x24, 0xd5, 0xb8, 0xbb, 0xec, 0x2f,
	0xec, 0x27, 0xec, 0xe7, 0xe4, 0x34, 0xf4, 0xd8, 0x53, 0xb0, 0x39, 0x97, 0xfd, 0x84, 0x01, 0xbb,
	0x0c, 0x24, 0x65, 0x59, 0x35, 0x0a, 0x6c, 0x43, 0xd2, 0x4b, 0x22, 0x7d, 0x8f, 0xef, 0xbd, 0x4f,
	0xdf, 0x23, 0x25, 0x83, 0x83, 0xac, 0xe0, 0x86, 0x19, 0x2a, 0xb0, 0x30, 0x7d, 0xff, 0x8f, 0xe0,
	0x1c, 0xc7, 0x8c, 0x33, 0xc3, 0xa8, 0xce, 0xe3, 0x7e, 0xfd, 0xb6, 0x97, 0x2b, 0x69, 0x24, 0x7c,
	0x44, 0x24, 0x39, 0x55, 0x12, 0x93, 0xe3, 0x5e, 0x8d, 0xde, 0xfb, 0x14, 0x7d, 0x67, 0x33, 0x95,
	0xa9, 0x74, 0xb4, 0xbe, 0xbd, 0xf2, 0x0a, 0x3b, 0xf7, 0x1d, 0x3b, 0x8f, 0xfb, 0x3a, 0xc7, 0x02,
	0x11, 0x29, 0x26, 0x2c, 0xf5, 0xd0, 0xc3, 0xbf, 0x5a, 0x00, 0x8e, 0x9d, 0xd2, 0xb0, 0xa6, 0x04,
	0x7b, 0xe0, 0x5e, 0xc2, 0x34, 0x8e, 0x39, 0x45, 0x38, 0xc9, 0x98, 0x40, 0x3a, 0xe7, 0xcc, 0x84,
	0xc1, 0x83, 0x60, 0x6f, 0x2d, 0xda, 0x28, 0xa1, 0x27, 0x16, 0x19, 0x59, 0x00, 0xee, 0x83, 0xad,
	0xa5, 0xf5, 0x04, 0x1b, 0x43, 0x55, 0xb8, 0xea, 0x18, 0xf7, 0x3e, 0x62, 0x78, 0x08, 0x7e, 0x09,
	0x20, 0xc1, 0x02, 0xbd, 0x65, 0xf4, 0x0c, 0x09, 0x99, 0x50, 0xc4, 0xc4, 0x44, 0x86, 0x37, 0x1c,
	0xe1, 0x2e, 0xc1, 0xe2, 0x0d, 0xa3, 0x67, 0x2f, 0x65, 0x42, 0x0f, 0xc5, 0x44, 0xc2, 0x43, 0xb0,
	0x55, 0x2d, 0x36, 0x3a, 0x89, 0x51, 0x46, 0x8d, 0x62, 0x44, 0x87, 0x4d, 0xbb, 0x7e, 0xb0, 0x3d,
	0xbb, 0xd8, 0x85, 0x43, 0xcf, 0x19, 0x8f, 0x9e, 0x0e, 0x8e, 0x3c, 0x1a, 0xc1, 0x52, 0x67, 0xac,
	0x93, 0xb8, 0xac, 0xc1, 0x13, 0x00, 0x6b, 0x73, 0x40, 0xb1, 0x2c, 0x44, 0xa2, 0xc3, 0x95, 0x07,
	0xc1, 0x5e, 0x7b, 0xff, 0xbb, 0xde, 0x7f, 0x1f, 0x76, 0x6f, 0x94, 0x63, 0x31, 0x74, 0x22, 0x03,
	0xa7, 0x11, 0x75, 0xf4, 0x52, 0x05, 0x3e, 0x02, 0x1b, 0xb6, 0x6d, 0x3f, 0x93, 0x42, 0xf8, 0x29,
	0xb6, 0xaa, 0x47, 0x74, 0xf3, 0x78, 0xed, 0xcb, 0xf0, 0x1b, 0x10, 0x2e, 0xd6, 0x2a, 0xca, 0x25,
	0xc1, 0x86, 0x22, 0x85, 0x45, 0x4a, 0xc3, 0x9b, 0x8e, 0xb2, 0x35, 0xa7, 0x44, 0x25, 0x1a, 0x59,
	0x10, 0x7e, 0x0b, 0xee, 0xd3, 0x29, 0xcd, 0x72, 0x83, 0x26, 0x4a, 0x66, 0x48, 0x59, 0x1a, 0x67,
	0x19, 0x33, 0x4c, 0xa4, 0xe1, 0x9a, 0x63, 0x6e, 0xfb, 0x05, 0x3f, 0x28, 0x99, 0x45, 0xd8, 0xd0,
	0x17, 0x25, 0x6a, 0xa9, 0xd6, 0xb3, 0xd0, 0xd4, 0x45, 0x60, 0x55, 0x39, 0xd2, 0x46, 0x2a, 0x9c,
	0xd2, 0xf0, 0x96, 0xa7, 0x12, 0x2c, 0x5e, 0x6b, 0xfa, 0x72, 0x0e, 0x8f, 0x3c, 0x6a, 0x23, 0xb7,
	0x54, 0x72, 0x4c, 0xc9, 0xa9, 0x9d, 0xa5, 0x66, 0xda, 0x50, 0x41, 0xde, 0x85, 0xc0, 0x47, 0x4e,
	0xb0, 0x18, 0x5a, 0x6c, 0xb8, 0x80, 0xe6, 0xe3, 0x48, 0x68, 0x5c, 0xa4, 0x28, 0x57, 0x92, 0x50,
	0xad, 0xc3, 0x76, 0x35, 0x8e, 0xa7, 0xb6, 0xfe, 0xca, 0x97, 0x61, 0x1f, 0x6c, 0x56, 0x89, 0x63,
	0xce, 0xab, 0xc0, 0xd7, 0xfd, 0x1e, 0x2c, 0x83, 0x7d, 0xc2, 0xf9, 0x3c, 0xd7, 0x3d, 0xd0, 0xb1,
	0x84, 0x5c, 0xd1, 0x1c, 0x2b, 0x8a, 0xcc, 0x54, 0xe8, 0xf0, 0xb6, 0x5b, 0x7c, 0x87, 0x60, 0xf1,
	0xca, 0x97, 0xc7, 0x53, 0xa1, 0x1f, 0xaf, 0xfc, 0xf9, 0xeb, 0x6e, 0xf0, 0xf0, 0xef, 0x35, 0xd0,
	0x59, 0x8e, 0x10, 0xfe, 0x0c, 0xee, 0xa4, 0x04, 0x19, 0xc3, 0x91, 0xa6, 0x44, 0xda, 0x8d, 0x11,
	0xb8, 0x8d, 0xf1, 0xfc, 0x2a, 0x1b, 0xa3, 0x77, 0x28, 0xcc, 0xc1, 0xbe, 0x0b, 0x6b, 0xd0, 0x99,
	0x5d, 0xec, 0xae, 0x3f, 0x1f, 0x8e, 0xc7, 0x2f, 0x46, 0xde, 0x20, 0x5a, 0x4f, 0xc9, 0xd8, 0xf0,
	0xf2, 0x0e, 0x4a, 0x70, 0xd7, 0x45, 0x8e, 0x32, 0x3c, 0x45, 0xf1, 0x3b, 0x43, 0xb5, 0x3b, 0x12,
	0xd7, 0xd0, 0xc1, 0xd7, 0x5f, 0xb9, 0x0e, 0xa2, 0xdb, 0x4e, 0xff, 0x08, 0x4f, 0x07, 0x56, 0xbd,
	0x66, 0xc8, 0x44, 0x69, 0xd8, 0xfc, 0x2c, 0x86, 0x4c, 0x78, 0xc3, 0x13, 0xb0, 0x2e, 0x8a, 0x0c,
	0x29, 0x9a, 0x73, 0x46, 0xf0, 0xfc, 0xe4, 0x5d, 0xd7, 0x80, 0xa3, 0xb6, 0x28, 0xb2, 0xa8, 0xd4,
	0x86, 0x13, 0x00, 0xac, 0xd7, 0x5b, 0x69, 0xa8, 0xd2, 0xee, 0xe0, 0x5d, 0xa3, 0xd3, 0x2d, 0x51,
	0x64, 0x6f, 0x9c, 0x32, 0xfc, 0x09, 0x6c, 0xd8, 0x23, 0x60, 0x14, 0x66, 0xc2, 0xcc, 0x5f, 0x29,
	0xab, 0xce, 0xee, 0xe8, 0x4a, 0x76, 0xc3, 0x4a, 0x75, 0xfe, 0x8e, 0x21, 0x4b, 0x95, 0x9d, 0xc7,
	0x00, 0x2c, 0x9a, 0x82, 0x9b, 0xa0, 0xa5, 0x0d, 0x56, 0xfe, 0x5d, 0xdd, 0x8a, 0xfc, 0x0d, 0xec,
	0x80, 0x26, 0x15, 0x89, 0xdb, 0x49, 0xad, 0xc8, 0x5e, 0xfa, 0x33, 0x50, 0x72, 0xcb, 0xa0, 0x3e,
	0xe6, 0x36, 0x3f, 0xc1, 0x6d, 0xd6, 0xb9, 0x14, 0x6c, 0x2f, 0xba, 0xd3, 0x43, 0x29, 0x4e, 0x0a,
	0x41, 0x0c, 0x93, 0x02, 0x3e, 0x03, 0xed, 0x45, 0x97, 0xf6, 0x04, 0x35, 0xf7, 0xda, 0xfb, 0x5f,
	0xd4, 0xe6, 0x50, 0x7e, 0x8f, 0xea, 0x4f, 0xb7, 0x72, 0x7e, 0xb1, 0xdb, 0x88, 0xea, 0xbc, 0xd2,
	0xe6, 0xb7, 0x00, 0x74, 0x96, 0xa7, 0x00, 0xbf, 0x07, 0x37, 0x31, 0xe7, 0xf2, 0x8c, 0x26, 0xff,
	0x47, 0x7d, 0xce, 0x81, 0x05, 0x58, 0x9b, 0x60, 0xce, 0x63, 0x4c, 0x4e, 0xc3, 0x1b, 0x8e, 0x3f,
	0xba, 0xa6, 0x94, 0xea, 0x73, 0x28, 0x5d, 0x2b, 0x2b, 0xff, 0x40, 0xfe, 0xef, 0x20, 0x3d, 0xff,
	0xa3, 0xdb, 0x38, 0x9f, 0x75, 0x83, 0xf7, 0xb3, 0x6e, 0xf0, 0x61, 0xd6, 0x0d, 0x7e, 0x9f, 0x75,
	0x83, 0x5f, 0x2e, 0xbb, 0x8d, 0xf7, 0x97, 0xdd, 0xc6, 0x87, 0xcb, 0x6e, 0xe3, 0xc7, 0x67, 0x29,
	0x33, 0xc7, 0x45, 0xdc, 0x23, 0x32, 0xeb, 0x57, 0xcd, 0x25, 0xf1, 0xe2, 0xba, 0x9f, 0x9f, 0xa6,
	0xfd, 0x7f, 0xfb, 0x45, 0x11, 0xaf, 0xba, 0x0f, 0xfd, 0xc1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x60, 0xf1, 0xfc, 0xbb, 0x7c, 0x08, 0x00, 0x00,
}

func (this *TenantCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TenantCapabilities)
	if !ok {
		that2, ok := that.(TenantCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DisableAdminSplit != that1.DisableAdminSplit {
		return false
	}
	if this.DisableAdminScatter != that1.DisableAdminScatter {
		return false
	}
	if this.CanViewNodeInfo != that1.CanViewNodeInfo {
		return false
	}
	if this.CanViewTSDBMetrics != that1.CanViewTSDBMetrics {
		return false
	}
	if !this.SpanConfigBounds.Equal(that1.SpanConfigBounds) {
		return false
	}
	if this.CanAdminUnsplit != that1.CanAdminUnsplit {
		return false
	}
	if this.CanAdminRelocateRange != that1.CanAdminRelocateRange {
		return false
	}
	if this.ExemptFromRateLimiting != that1.ExemptFromRateLimiting {
		return false
	}
	if this.CanUseNodelocalStorage != that1.CanUseNodelocalStorage {
		return false
	}
	if this.CanCheckConsistency != that1.CanCheckConsistency {
		return false
	}
	if this.CanDebugProcess != that1.CanDebugProcess {
		return false
	}
	if this.CanViewAllMetrics != that1.CanViewAllMetrics {
		return false
	}
	if this.CanPrepareTxns != that1.CanPrepareTxns {
		return false
	}
	return true
}
func (this *SpanConfigBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfigBounds)
	if !ok {
		that2, ok := that.(SpanConfigBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GCTTLSeconds.Equal(that1.GCTTLSeconds) {
		return false
	}
	if !this.RangeMaxBytes.Equal(that1.RangeMaxBytes) {
		return false
	}
	if !this.RangeMinBytes.Equal(that1.RangeMinBytes) {
		return false
	}
	if !this.NumReplicas.Equal(that1.NumReplicas) {
		return false
	}
	if !this.NumVoters.Equal(that1.NumVoters) {
		return false
	}
	if !this.ConstraintBounds.Equal(that1.ConstraintBounds) {
		return false
	}
	return true
}
func (this *SpanConfigBounds_Int32Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfigBounds_Int32Range)
	if !ok {
		that2, ok := that.(SpanConfigBounds_Int32Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *SpanConfigBounds_Int64Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfigBounds_Int64Range)
	if !ok {
		that2, ok := that.(SpanConfigBounds_Int64Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *SpanConfigBounds_ConstraintsConjunction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfigBounds_ConstraintsConjunction)
	if !ok {
		that2, ok := that.(SpanConfigBounds_ConstraintsConjunction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *SpanConfigBounds_ConstraintBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfigBounds_ConstraintBounds)
	if !ok {
		that2, ok := that.(SpanConfigBounds_ConstraintBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Allowed) != len(that1.Allowed) {
		return false
	}
	for i := range this.Allowed {
		if !this.Allowed[i].Equal(&that1.Allowed[i]) {
			return false
		}
	}
	if len(this.Fallback) != len(that1.Fallback) {
		return false
	}
	for i := range this.Fallback {
		if !this.Fallback[i].Equal(&that1.Fallback[i]) {
			return false
		}
	}
	return true
}
func (m *TenantCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanPrepareTxns {
		i--
		if m.CanPrepareTxns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.CanViewAllMetrics {
		i--
		if m.CanViewAllMetrics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.CanDebugProcess {
		i--
		if m.CanDebugProcess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.CanCheckConsistency {
		i--
		if m.CanCheckConsistency {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.CanUseNodelocalStorage {
		i--
		if m.CanUseNodelocalStorage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ExemptFromRateLimiting {
		i--
		if m.ExemptFromRateLimiting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.CanAdminRelocateRange {
		i--
		if m.CanAdminRelocateRange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DisableAdminScatter {
		i--
		if m.DisableAdminScatter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CanAdminUnsplit {
		i--
		if m.CanAdminUnsplit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SpanConfigBounds != nil {
		{
			size, err := m.SpanConfigBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CanViewTSDBMetrics {
		i--
		if m.CanViewTSDBMetrics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CanViewNodeInfo {
		i--
		if m.CanViewNodeInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.DisableAdminSplit {
		i--
		if m.DisableAdminSplit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConstraintBounds != nil {
		{
			size, err := m.ConstraintBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.NumVoters != nil {
		{
			size, err := m.NumVoters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.NumReplicas != nil {
		{
			size, err := m.NumReplicas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RangeMinBytes != nil {
		{
			size, err := m.RangeMinBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RangeMaxBytes != nil {
		{
			size, err := m.RangeMaxBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GCTTLSeconds != nil {
		{
			size, err := m.GCTTLSeconds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCapabilities(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigBounds_Int32Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigBounds_Int32Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigBounds_Int32Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintCapabilities(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintCapabilities(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigBounds_Int64Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigBounds_Int64Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigBounds_Int64Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintCapabilities(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintCapabilities(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigBounds_ConstraintsConjunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigBounds_ConstraintsConjunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigBounds_ConstraintsConjunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapabilities(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigBounds_ConstraintBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigBounds_ConstraintBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigBounds_ConstraintBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fallback) > 0 {
		for iNdEx := len(m.Fallback) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fallback[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapabilities(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Allowed) > 0 {
		for iNdEx := len(m.Allowed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allowed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCapabilities(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCapabilities(dAtA []byte, offset int, v uint64) int {
	offset -= sovCapabilities(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TenantCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableAdminSplit {
		n += 2
	}
	if m.CanViewNodeInfo {
		n += 2
	}
	if m.CanViewTSDBMetrics {
		n += 2
	}
	if m.SpanConfigBounds != nil {
		l = m.SpanConfigBounds.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	if m.CanAdminUnsplit {
		n += 2
	}
	if m.DisableAdminScatter {
		n += 2
	}
	if m.CanAdminRelocateRange {
		n += 2
	}
	if m.ExemptFromRateLimiting {
		n += 2
	}
	if m.CanUseNodelocalStorage {
		n += 2
	}
	if m.CanCheckConsistency {
		n += 2
	}
	if m.CanDebugProcess {
		n += 2
	}
	if m.CanViewAllMetrics {
		n += 2
	}
	if m.CanPrepareTxns {
		n += 2
	}
	return n
}

func (m *SpanConfigBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GCTTLSeconds != nil {
		l = m.GCTTLSeconds.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	if m.RangeMaxBytes != nil {
		l = m.RangeMaxBytes.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	if m.RangeMinBytes != nil {
		l = m.RangeMinBytes.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	if m.NumReplicas != nil {
		l = m.NumReplicas.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	if m.NumVoters != nil {
		l = m.NumVoters.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	if m.ConstraintBounds != nil {
		l = m.ConstraintBounds.Size()
		n += 1 + l + sovCapabilities(uint64(l))
	}
	return n
}

func (m *SpanConfigBounds_Int32Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCapabilities(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCapabilities(uint64(m.End))
	}
	return n
}

func (m *SpanConfigBounds_Int64Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCapabilities(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCapabilities(uint64(m.End))
	}
	return n
}

func (m *SpanConfigBounds_ConstraintsConjunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovCapabilities(uint64(l))
		}
	}
	return n
}

func (m *SpanConfigBounds_ConstraintBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allowed) > 0 {
		for _, e := range m.Allowed {
			l = e.Size()
			n += 1 + l + sovCapabilities(uint64(l))
		}
	}
	if len(m.Fallback) > 0 {
		for _, e := range m.Fallback {
			l = e.Size()
			n += 1 + l + sovCapabilities(uint64(l))
		}
	}
	return n
}

func sovCapabilities(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozCapabilities(x uint64) (n int) {
	return sovCapabilities(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TenantCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAdminSplit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAdminSplit = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanViewNodeInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanViewNodeInfo = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanViewTSDBMetrics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanViewTSDBMetrics = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanConfigBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanConfigBounds == nil {
				m.SpanConfigBounds = &SpanConfigBounds{}
			}
			if err := m.SpanConfigBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAdminUnsplit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAdminUnsplit = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAdminScatter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAdminScatter = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAdminRelocateRange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAdminRelocateRange = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemptFromRateLimiting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExemptFromRateLimiting = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUseNodelocalStorage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanUseNodelocalStorage = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanCheckConsistency", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanCheckConsistency = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDebugProcess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDebugProcess = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanViewAllMetrics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanViewAllMetrics = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPrepareTxns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPrepareTxns = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCapabilities(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapabilities
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfigBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfigBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCTTLSeconds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GCTTLSeconds == nil {
				m.GCTTLSeconds = &SpanConfigBounds_Int32Range{}
			}
			if err := m.GCTTLSeconds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMaxBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeMaxBytes == nil {
				m.RangeMaxBytes = &SpanConfigBounds_Int64Range{}
			}
			if err := m.RangeMaxBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMinBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeMinBytes == nil {
				m.RangeMinBytes = &SpanConfigBounds_Int64Range{}
			}
			if err := m.RangeMinBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NumReplicas == nil {
				m.NumReplicas = &SpanConfigBounds_Int32Range{}
			}
			if err := m.NumReplicas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumVoters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NumVoters == nil {
				m.NumVoters = &SpanConfigBounds_Int32Range{}
			}
			if err := m.NumVoters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConstraintBounds == nil {
				m.ConstraintBounds = &SpanConfigBounds_ConstraintBounds{}
			}
			if err := m.ConstraintBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapabilities(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapabilities
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigBounds_Int32Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCapabilities(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapabilities
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigBounds_Int64Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCapabilities(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapabilities
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigBounds_ConstraintsConjunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintsConjunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintsConjunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, roachpb.Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapabilities(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapabilities
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigBounds_ConstraintBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allowed = append(m.Allowed, roachpb.Constraint{})
			if err := m.Allowed[len(m.Allowed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fallback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCapabilities
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCapabilities
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fallback = append(m.Fallback, SpanConfigBounds_ConstraintsConjunction{})
			if err := m.Fallback[len(m.Fallback)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCapabilities(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCapabilities
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCapabilities(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCapabilities
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCapabilities
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCapabilities
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCapabilities
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCapabilities
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCapabilities        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCapabilities          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCapabilities = fmt.Errorf("proto: unexpected end of group")
)

