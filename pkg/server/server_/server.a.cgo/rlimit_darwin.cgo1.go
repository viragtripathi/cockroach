// Code generated by cmd/cgo; DO NOT EDIT.

//line com_github_cockroachdb_cockroach/pkg/server/rlimit_darwin.go:1:1
// Copyright 2019 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

//go:build !windows && !freebsd && !dragonfly

package server; import _cgo_unsafe "unsafe"

import (
	"unsafe"

	"golang.org/x/sys/unix"
)

// #include <sys/types.h>
// #include <sys/sysctl.h>
import _ "unsafe"

func setRlimitNoFile(limits *rlimit) error {
	return unix.Setrlimit(unix.RLIMIT_NOFILE, (*unix.Rlimit)(limits))
}

func getRlimitNoFile(limits *rlimit) error {
	if err := unix.Getrlimit(unix.RLIMIT_NOFILE, (*unix.Rlimit)(limits)); err != nil {
		return err
	}
	// On macOS, the true hard open file limit is
	// min(sysctl("kern.maxfiles"),
	//     sysctl("kern.maxfilesperproc"),
	//     getrlimit(RLIMIT_NOFILE))
	// This does not appear to be documented and may be incomplete.
	//
	// See https://github.com/golang/go/issues/30401 for more context.
	sysctlMaxFiles, err := getSysctlMaxFiles()
	if err != nil {
		return err
	}
	if limits.Max > sysctlMaxFiles {
		limits.Max = sysctlMaxFiles
	}
	sysctlMaxFilesPerProc, err := getSysctlMaxFilesPerProc()
	if err != nil {
		return err
	}
	if limits.Max > sysctlMaxFilesPerProc {
		limits.Max = sysctlMaxFilesPerProc
	}
	return nil
}

func getSysctlMaxFiles() (uint64, error) {
	return getSysctl(( /*line :53:19*/_Ciconst_CTL_KERN /*line :53:28*/), ( /*line :53:31*/_Ciconst_KERN_MAXFILES /*line :53:45*/)) // identifies the "kern.maxfiles" sysctl
}

func getSysctlMaxFilesPerProc() (uint64, error) {
	return getSysctl(( /*line :57:19*/_Ciconst_CTL_KERN /*line :57:28*/), ( /*line :57:31*/_Ciconst_KERN_MAXFILESPERPROC /*line :57:52*/)) // identifies the "kern.maxfilesperproc" sysctl
}

func getSysctl(x, y  /*line :60:21*/_Ctype_int /*line :60:26*/) (uint64, error) {
	var out int32
	outLen :=  /*line :62:12*/_Ctype_size_t /*line :62:20*/(unsafe.Sizeof(out))
	sysctlMib := [...] /*line :63:20*/_Ctype_int /*line :63:25*/{x, y}
	r, errno := func() (_Ctype_int, error){ var _cgo0 *_Ctype_int = /*line :64:23*/&sysctlMib[0]; var _cgo1 _Ctype_u_int = _Ctype_u_int /*line :64:45*/(len(sysctlMib)); _cgoBase2 := /*line :64:78*/&out; _cgo2 := /*line :64:63*/unsafe.Pointer(_cgoBase2); var _cgo3 *_Ctype_size_t = /*line :64:85*/&outLen; var _cgo4 _cgo_unsafe.Pointer = /*line :65:3*/nil; var _cgo5 _Ctype_size_t = /*line :65:19*/0; _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :65:34*/_C2func_sysctl(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if r != 0 {
		return 0, errno
	}
	return uint64(out), nil
}
