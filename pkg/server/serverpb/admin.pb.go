// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/serverpb/admin.proto

package serverpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	zonepb "github.com/cockroachdb/cockroach/pkg/config/zonepb"
	jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	kvserverpb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/kvserverpb"
	livenesspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/liveness/livenesspb"
	loqrecoverypb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/loqrecovery/loqrecoverypb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	catalog "github.com/cockroachdb/cockroach/pkg/ts/catalog"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	metric "github.com/cockroachdb/cockroach/pkg/util/metric"
	github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb "github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb"
	tracingpb "github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ZoneConfigurationLevel indicates, for objects with a Zone Configuration,
// the object level at which the configuration is defined. This is needed
// because objects without a specifically indicated Zone Configuration will
// inherit the configuration of their "parent".
type ZoneConfigurationLevel int32

const (
	ZoneConfigurationLevel_UNKNOWN ZoneConfigurationLevel = 0
	// CLUSTER indicates that this object uses the cluster default Zone Configuration.
	ZoneConfigurationLevel_CLUSTER ZoneConfigurationLevel = 1
	// DATABASE indicates that this object uses a database-level Zone Configuration.
	ZoneConfigurationLevel_DATABASE ZoneConfigurationLevel = 2
	// TABLE indicates that this object uses a table-level Zone Configuration.
	ZoneConfigurationLevel_TABLE ZoneConfigurationLevel = 3
)

var ZoneConfigurationLevel_name = map[int32]string{
	0: "UNKNOWN",
	1: "CLUSTER",
	2: "DATABASE",
	3: "TABLE",
}

var ZoneConfigurationLevel_value = map[string]int32{
	"UNKNOWN":  0,
	"CLUSTER":  1,
	"DATABASE": 2,
	"TABLE":    3,
}

func (x ZoneConfigurationLevel) String() string {
	return proto.EnumName(ZoneConfigurationLevel_name, int32(x))
}

func (ZoneConfigurationLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{0}
}

type DecommissionPreCheckResponse_NodeReadiness int32

const (
	DecommissionPreCheckResponse_UNKNOWN                DecommissionPreCheckResponse_NodeReadiness = 0
	DecommissionPreCheckResponse_READY                  DecommissionPreCheckResponse_NodeReadiness = 1
	DecommissionPreCheckResponse_ALREADY_DECOMMISSIONED DecommissionPreCheckResponse_NodeReadiness = 2
	DecommissionPreCheckResponse_ALLOCATION_ERRORS      DecommissionPreCheckResponse_NodeReadiness = 3
)

var DecommissionPreCheckResponse_NodeReadiness_name = map[int32]string{
	0: "UNKNOWN",
	1: "READY",
	2: "ALREADY_DECOMMISSIONED",
	3: "ALLOCATION_ERRORS",
}

var DecommissionPreCheckResponse_NodeReadiness_value = map[string]int32{
	"UNKNOWN":                0,
	"READY":                  1,
	"ALREADY_DECOMMISSIONED": 2,
	"ALLOCATION_ERRORS":      3,
}

func (DecommissionPreCheckResponse_NodeReadiness) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{23, 0}
}

// DatabasesRequest requests a list of databases.
type DatabasesRequest struct {
}

func (m *DatabasesRequest) Reset()         { *m = DatabasesRequest{} }
func (m *DatabasesRequest) String() string { return proto.CompactTextString(m) }
func (*DatabasesRequest) ProtoMessage()    {}
func (*DatabasesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{0}
}
func (m *DatabasesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabasesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabasesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabasesRequest.Merge(m, src)
}
func (m *DatabasesRequest) XXX_Size() int {
	return m.Size()
}
func (m *DatabasesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabasesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabasesRequest proto.InternalMessageInfo

// DatabasesResponse contains a list of databases.
type DatabasesResponse struct {
	Databases []string `protobuf:"bytes,1,rep,name=databases,proto3" json:"databases,omitempty"`
}

func (m *DatabasesResponse) Reset()         { *m = DatabasesResponse{} }
func (m *DatabasesResponse) String() string { return proto.CompactTextString(m) }
func (*DatabasesResponse) ProtoMessage()    {}
func (*DatabasesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{1}
}
func (m *DatabasesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabasesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabasesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabasesResponse.Merge(m, src)
}
func (m *DatabasesResponse) XXX_Size() int {
	return m.Size()
}
func (m *DatabasesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabasesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DatabasesResponse proto.InternalMessageInfo

// DatabaseDetailsRequest requests detailed information about the specified
// database
type DatabaseDetailsRequest struct {
	// database is the name of the database we are querying.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// Setting this flag includes a computationally-expensive stats field
	// in the response.
	IncludeStats bool `protobuf:"varint,2,opt,name=include_stats,json=includeStats,proto3" json:"include_stats,omitempty"`
}

func (m *DatabaseDetailsRequest) Reset()         { *m = DatabaseDetailsRequest{} }
func (m *DatabaseDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*DatabaseDetailsRequest) ProtoMessage()    {}
func (*DatabaseDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{2}
}
func (m *DatabaseDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseDetailsRequest.Merge(m, src)
}
func (m *DatabaseDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseDetailsRequest proto.InternalMessageInfo

// DatabaseDetailsResponse contains grant information, table names,
// zone configuration, and size statistics for a database.
type DatabaseDetailsResponse struct {
	// grants are the results of SHOW GRANTS for this database.
	Grants []DatabaseDetailsResponse_Grant `protobuf:"bytes,1,rep,name=grants,proto3" json:"grants"`
	// table_names contains the names of all tables in this database. Note that
	// all responses will be schema-qualified (schema.table) and that every schema
	// or table that contains a "sql unsafe character" such as uppercase letters
	// or dots will be surrounded with double quotes, such as "naughty schema".table.
	TableNames []string `protobuf:"bytes,2,rep,name=table_names,json=tableNames,proto3" json:"table_names,omitempty"`
	// descriptor_id is an identifier used to uniquely identify this database.
	DescriptorID int64 `protobuf:"varint,3,opt,name=descriptor_id,json=descriptorId,proto3" json:"descriptor_id,omitempty"`
	// The zone configuration in effect for this database.
	ZoneConfig zonepb.ZoneConfig `protobuf:"bytes,4,opt,name=zone_config,json=zoneConfig,proto3" json:"zone_config"`
	// The level at which this object's zone configuration is set.
	ZoneConfigLevel ZoneConfigurationLevel `protobuf:"varint,5,opt,name=zone_config_level,json=zoneConfigLevel,proto3,enum=cockroach.server.serverpb.ZoneConfigurationLevel" json:"zone_config_level,omitempty"`
	// Size information about the database, present only when explicitly requested.
	Stats *DatabaseDetailsResponse_Stats `protobuf:"bytes,6,opt,name=stats,proto3" json:"stats,omitempty"`
}

func (m *DatabaseDetailsResponse) Reset()         { *m = DatabaseDetailsResponse{} }
func (m *DatabaseDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*DatabaseDetailsResponse) ProtoMessage()    {}
func (*DatabaseDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{3}
}
func (m *DatabaseDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseDetailsResponse.Merge(m, src)
}
func (m *DatabaseDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseDetailsResponse proto.InternalMessageInfo

type DatabaseDetailsResponse_Grant struct {
	// user is the user that this grant applies to.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// privileges are the abilities this grant gives to the user.
	Privileges []string `protobuf:"bytes,2,rep,name=privileges,proto3" json:"privileges,omitempty"`
}

func (m *DatabaseDetailsResponse_Grant) Reset()         { *m = DatabaseDetailsResponse_Grant{} }
func (m *DatabaseDetailsResponse_Grant) String() string { return proto.CompactTextString(m) }
func (*DatabaseDetailsResponse_Grant) ProtoMessage()    {}
func (*DatabaseDetailsResponse_Grant) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{3, 0}
}
func (m *DatabaseDetailsResponse_Grant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseDetailsResponse_Grant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseDetailsResponse_Grant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseDetailsResponse_Grant.Merge(m, src)
}
func (m *DatabaseDetailsResponse_Grant) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseDetailsResponse_Grant) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseDetailsResponse_Grant.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseDetailsResponse_Grant proto.InternalMessageInfo

type DatabaseDetailsResponse_Stats struct {
	// A list of tables that exist in the database, but for which stats could
	// not be loaded due to failures during this request.
	MissingTables []*DatabaseDetailsResponse_Stats_MissingTable `protobuf:"bytes,1,rep,name=missing_tables,json=missingTables,proto3" json:"missing_tables,omitempty"`
	// The number of ranges, as determined from a query of range meta keys,
	// across all tables.
	RangeCount int64 `protobuf:"varint,2,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	// An approximation of the disk space (in bytes) used for all replicas
	// of all tables across the cluster.
	ApproximateDiskBytes uint64 `protobuf:"varint,3,opt,name=approximate_disk_bytes,json=approximateDiskBytes,proto3" json:"approximate_disk_bytes,omitempty"`
	// node_ids is the ordered list of node ids on which data is stored.
	NodeIDs                 []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,4,rep,packed,name=node_ids,json=nodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_ids,omitempty"`
	NumIndexRecommendations int32                                                 `protobuf:"varint,5,opt,name=num_index_recommendations,json=numIndexRecommendations,proto3" json:"num_index_recommendations,omitempty"`
}

func (m *DatabaseDetailsResponse_Stats) Reset()         { *m = DatabaseDetailsResponse_Stats{} }
func (m *DatabaseDetailsResponse_Stats) String() string { return proto.CompactTextString(m) }
func (*DatabaseDetailsResponse_Stats) ProtoMessage()    {}
func (*DatabaseDetailsResponse_Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{3, 1}
}
func (m *DatabaseDetailsResponse_Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseDetailsResponse_Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseDetailsResponse_Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseDetailsResponse_Stats.Merge(m, src)
}
func (m *DatabaseDetailsResponse_Stats) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseDetailsResponse_Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseDetailsResponse_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseDetailsResponse_Stats proto.InternalMessageInfo

// A table which exists in the database, but for which we could not load stats
// during this request.
type DatabaseDetailsResponse_Stats_MissingTable struct {
	// The name of the table for which we could not load stats.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The error message that resulted when the request for this table failed.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DatabaseDetailsResponse_Stats_MissingTable) Reset() {
	*m = DatabaseDetailsResponse_Stats_MissingTable{}
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) String() string {
	return proto.CompactTextString(m)
}
func (*DatabaseDetailsResponse_Stats_MissingTable) ProtoMessage() {}
func (*DatabaseDetailsResponse_Stats_MissingTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{3, 1, 0}
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseDetailsResponse_Stats_MissingTable.Merge(m, src)
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseDetailsResponse_Stats_MissingTable.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseDetailsResponse_Stats_MissingTable proto.InternalMessageInfo

// TableDetailsRequest is a request for detailed information about a table.
type TableDetailsRequest struct {
	// database is the name of the database that contains the table we're
	// interested in.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// table is the name of the table that we're querying. Table may be
	// schema-qualified (schema.table) and each name component that contains
	// sql unsafe characters such as . or uppercase letters must be surrounded
	// in double quotes like "naughty schema".table.
	Table string `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
}

func (m *TableDetailsRequest) Reset()         { *m = TableDetailsRequest{} }
func (m *TableDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*TableDetailsRequest) ProtoMessage()    {}
func (*TableDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{4}
}
func (m *TableDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDetailsRequest.Merge(m, src)
}
func (m *TableDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *TableDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TableDetailsRequest proto.InternalMessageInfo

// TableDetailsResponse contains grants, column names, and indexes for
// a table.
type TableDetailsResponse struct {
	Grants  []TableDetailsResponse_Grant  `protobuf:"bytes,1,rep,name=grants,proto3" json:"grants"`
	Columns []TableDetailsResponse_Column `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns"`
	Indexes []TableDetailsResponse_Index  `protobuf:"bytes,3,rep,name=indexes,proto3" json:"indexes"`
	// range_count is the size of the table in ranges. This provides a rough
	// estimate of the storage requirements for the table.
	// TODO(mrtracy): The TableStats method also returns a range_count field which
	// is more accurate than this one; TableDetails calculates this number using
	// a potentially faster method that is subject to cache staleness. We should
	// consider removing or renaming this field to reflect that difference. See
	// GitHub issue #5435 for more information.
	RangeCount int64 `protobuf:"varint,4,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	// create_table_statement is the output of "SHOW CREATE" for this table;
	// it is a SQL statement that would re-create the table's current schema if
	// executed.
	CreateTableStatement string `protobuf:"bytes,5,opt,name=create_table_statement,json=createTableStatement,proto3" json:"create_table_statement,omitempty"`
	// The zone configuration in effect for this table.
	ZoneConfig zonepb.ZoneConfig `protobuf:"bytes,6,opt,name=zone_config,json=zoneConfig,proto3" json:"zone_config"`
	// The level at which this object's zone configuration is set.
	ZoneConfigLevel ZoneConfigurationLevel `protobuf:"varint,7,opt,name=zone_config_level,json=zoneConfigLevel,proto3,enum=cockroach.server.serverpb.ZoneConfigurationLevel" json:"zone_config_level,omitempty"`
	// descriptor_id is an identifier used to uniquely identify this table.
	DescriptorID int64 `protobuf:"varint,8,opt,name=descriptor_id,json=descriptorId,proto3" json:"descriptor_id,omitempty"`
	// configure_zone_statement is the output of "SHOW ZONE CONFIGURATION FOR TABLE"
	// for this table. It is a SQL statement that would re-configure the table's current
	// zone if executed.
	ConfigureZoneStatement string `protobuf:"bytes,9,opt,name=configure_zone_statement,json=configureZoneStatement,proto3" json:"configure_zone_statement,omitempty"`
	// stats_last_created_at is the time at which statistics were last created.
	StatsLastCreatedAt *time.Time `protobuf:"bytes,10,opt,name=stats_last_created_at,json=statsLastCreatedAt,proto3,stdtime" json:"stats_last_created_at,omitempty"`
	// has_index_recommendations notifies if the there are index recommendations
	// on this table.
	HasIndexRecommendations bool `protobuf:"varint,11,opt,name=has_index_recommendations,json=hasIndexRecommendations,proto3" json:"has_index_recommendations,omitempty"`
	// data_total_bytes is the size in bytes of live and non-live data on the table.
	DataTotalBytes int64 `protobuf:"varint,12,opt,name=data_total_bytes,json=dataTotalBytes,proto3" json:"data_total_bytes,omitempty"`
	// data_live_bytes is the size in bytes of live (non MVCC) data on the table.
	DataLiveBytes int64 `protobuf:"varint,13,opt,name=data_live_bytes,json=dataLiveBytes,proto3" json:"data_live_bytes,omitempty"`
	// data_live_percentage is the percentage of live (non MVCC) data on the table.
	DataLivePercentage float32 `protobuf:"fixed32,14,opt,name=data_live_percentage,json=dataLivePercentage,proto3" json:"data_live_percentage,omitempty"`
}

func (m *TableDetailsResponse) Reset()         { *m = TableDetailsResponse{} }
func (m *TableDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse) ProtoMessage()    {}
func (*TableDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{5}
}
func (m *TableDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDetailsResponse.Merge(m, src)
}
func (m *TableDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *TableDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TableDetailsResponse proto.InternalMessageInfo

// Grant is an entry from SHOW GRANTS.
type TableDetailsResponse_Grant struct {
	// user is the user that this grant applies to.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// privileges are the abilities this grant gives to the user.
	Privileges []string `protobuf:"bytes,2,rep,name=privileges,proto3" json:"privileges,omitempty"`
}

func (m *TableDetailsResponse_Grant) Reset()         { *m = TableDetailsResponse_Grant{} }
func (m *TableDetailsResponse_Grant) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse_Grant) ProtoMessage()    {}
func (*TableDetailsResponse_Grant) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{5, 0}
}
func (m *TableDetailsResponse_Grant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDetailsResponse_Grant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableDetailsResponse_Grant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDetailsResponse_Grant.Merge(m, src)
}
func (m *TableDetailsResponse_Grant) XXX_Size() int {
	return m.Size()
}
func (m *TableDetailsResponse_Grant) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDetailsResponse_Grant.DiscardUnknown(m)
}

var xxx_messageInfo_TableDetailsResponse_Grant proto.InternalMessageInfo

type TableDetailsResponse_Column struct {
	// name is the name of the column.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// type is the SQL type (INT, STRING, etc.) of this column.
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// nullable is whether this column can contain NULL.
	Nullable bool `protobuf:"varint,3,opt,name=nullable,proto3" json:"nullable,omitempty"`
	// default_value is the default value of this column.
	DefaultValue string `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	// generation_expression is the generator expression if the column is computed.
	GenerationExpression string `protobuf:"bytes,5,opt,name=generation_expression,json=generationExpression,proto3" json:"generation_expression,omitempty"`
	// hidden is whether this column is hidden.
	Hidden bool `protobuf:"varint,6,opt,name=hidden,proto3" json:"hidden,omitempty"`
}

func (m *TableDetailsResponse_Column) Reset()         { *m = TableDetailsResponse_Column{} }
func (m *TableDetailsResponse_Column) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse_Column) ProtoMessage()    {}
func (*TableDetailsResponse_Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{5, 1}
}
func (m *TableDetailsResponse_Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDetailsResponse_Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableDetailsResponse_Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDetailsResponse_Column.Merge(m, src)
}
func (m *TableDetailsResponse_Column) XXX_Size() int {
	return m.Size()
}
func (m *TableDetailsResponse_Column) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDetailsResponse_Column.DiscardUnknown(m)
}

var xxx_messageInfo_TableDetailsResponse_Column proto.InternalMessageInfo

type TableDetailsResponse_Index struct {
	// name is the name of this index.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// unique is whether this a unique index (i.e. CREATE UNIQUE INDEX).
	Unique bool `protobuf:"varint,2,opt,name=unique,proto3" json:"unique,omitempty"`
	// seq is an internal variable that's passed along.
	Seq int64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// column is the column that this index indexes.
	Column string `protobuf:"bytes,4,opt,name=column,proto3" json:"column,omitempty"`
	// direction is either "ASC" (ascending) or "DESC" (descending).
	Direction string `protobuf:"bytes,5,opt,name=direction,proto3" json:"direction,omitempty"`
	// storing is an internal variable that's passed along.
	Storing bool `protobuf:"varint,6,opt,name=storing,proto3" json:"storing,omitempty"`
	// implicit is an internal variable that's passed along.
	Implicit bool `protobuf:"varint,7,opt,name=implicit,proto3" json:"implicit,omitempty"`
}

func (m *TableDetailsResponse_Index) Reset()         { *m = TableDetailsResponse_Index{} }
func (m *TableDetailsResponse_Index) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse_Index) ProtoMessage()    {}
func (*TableDetailsResponse_Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{5, 2}
}
func (m *TableDetailsResponse_Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDetailsResponse_Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableDetailsResponse_Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDetailsResponse_Index.Merge(m, src)
}
func (m *TableDetailsResponse_Index) XXX_Size() int {
	return m.Size()
}
func (m *TableDetailsResponse_Index) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDetailsResponse_Index.DiscardUnknown(m)
}

var xxx_messageInfo_TableDetailsResponse_Index proto.InternalMessageInfo

// TableStatsRequest is a request for detailed, computationally expensive
// information about a table.
type TableStatsRequest struct {
	// database is the name of the database that contains the table we're
	// interested in.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// table is the name of the table that we're querying. Table may be
	// schema-qualified (schema.table) and each name component that contains
	// sql unsafe characters such as . or uppercase letters must be surrounded
	// in double quotes like "naughty schema".table.
	Table string `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
}

func (m *TableStatsRequest) Reset()         { *m = TableStatsRequest{} }
func (m *TableStatsRequest) String() string { return proto.CompactTextString(m) }
func (*TableStatsRequest) ProtoMessage()    {}
func (*TableStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{6}
}
func (m *TableStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatsRequest.Merge(m, src)
}
func (m *TableStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *TableStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatsRequest proto.InternalMessageInfo

// TableStatsResponse contains detailed, computationally expensive information
// about a table.
type TableStatsResponse struct {
	// range_count is the number of ranges, as determined from a query of range
	// meta keys.
	RangeCount int64 `protobuf:"varint,1,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	// replica_count is the number of replicas of any range of this table, as
	// found by querying nodes which are known to have replicas. When compared
	// with range_count, this can be used to estimate the current replication
	// factor of the table.
	ReplicaCount int64 `protobuf:"varint,2,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// node_count is the number of nodes which contain data for this table,
	// according to a query of range meta keys.
	NodeCount int64 `protobuf:"varint,3,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// stats is the summation of MVCCStats for all replicas of this table
	// across the cluster.
	Stats enginepb.MVCCStats `protobuf:"bytes,4,opt,name=stats,proto3" json:"stats"`
	// approximate_disk_bytes is an approximation of the disk space (in bytes)
	// used for all replicas of this table across the cluster.
	ApproximateDiskBytes uint64 `protobuf:"varint,6,opt,name=approximate_disk_bytes,json=approximateDiskBytes,proto3" json:"approximate_disk_bytes,omitempty"`
	// A list of nodes which should contain data for this table (according to
	// cluster metadata), but could not be contacted during this request.
	MissingNodes []TableStatsResponse_MissingNode `protobuf:"bytes,5,rep,name=missing_nodes,json=missingNodes,proto3" json:"missing_nodes"`
	// node_ids is the ordered list of node ids on which the table data is stored.
	NodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,7,rep,packed,name=node_ids,json=nodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_ids,omitempty"`
}

func (m *TableStatsResponse) Reset()         { *m = TableStatsResponse{} }
func (m *TableStatsResponse) String() string { return proto.CompactTextString(m) }
func (*TableStatsResponse) ProtoMessage()    {}
func (*TableStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{7}
}
func (m *TableStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatsResponse.Merge(m, src)
}
func (m *TableStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *TableStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatsResponse proto.InternalMessageInfo

// MissingNode represents information on a node which should contain data
// for this table, but could not be contacted during this request.
type TableStatsResponse_MissingNode struct {
	// The ID of the missing node.
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The error message that resulted when the query sent to this node failed.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *TableStatsResponse_MissingNode) Reset()         { *m = TableStatsResponse_MissingNode{} }
func (m *TableStatsResponse_MissingNode) String() string { return proto.CompactTextString(m) }
func (*TableStatsResponse_MissingNode) ProtoMessage()    {}
func (*TableStatsResponse_MissingNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{7, 0}
}
func (m *TableStatsResponse_MissingNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatsResponse_MissingNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableStatsResponse_MissingNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatsResponse_MissingNode.Merge(m, src)
}
func (m *TableStatsResponse_MissingNode) XXX_Size() int {
	return m.Size()
}
func (m *TableStatsResponse_MissingNode) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatsResponse_MissingNode.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatsResponse_MissingNode proto.InternalMessageInfo

// NonTableStatsRequest requests statistics on cluster data ranges that do not
// belong to SQL tables.
type NonTableStatsRequest struct {
}

func (m *NonTableStatsRequest) Reset()         { *m = NonTableStatsRequest{} }
func (m *NonTableStatsRequest) String() string { return proto.CompactTextString(m) }
func (*NonTableStatsRequest) ProtoMessage()    {}
func (*NonTableStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{8}
}
func (m *NonTableStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NonTableStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NonTableStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonTableStatsRequest.Merge(m, src)
}
func (m *NonTableStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *NonTableStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NonTableStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NonTableStatsRequest proto.InternalMessageInfo

// NonTableStatsResponse returns statistics on various cluster data ranges
// that do not belong to SQL tables. The statistics for each range are returned
// as a TableStatsResponse.
type NonTableStatsResponse struct {
	// Information on time series ranges.
	TimeSeriesStats *TableStatsResponse `protobuf:"bytes,1,opt,name=time_series_stats,json=timeSeriesStats,proto3" json:"time_series_stats,omitempty"`
	// Information for remaining (non-table, non-time-series) ranges.
	InternalUseStats *TableStatsResponse `protobuf:"bytes,2,opt,name=internal_use_stats,json=internalUseStats,proto3" json:"internal_use_stats,omitempty"`
}

func (m *NonTableStatsResponse) Reset()         { *m = NonTableStatsResponse{} }
func (m *NonTableStatsResponse) String() string { return proto.CompactTextString(m) }
func (*NonTableStatsResponse) ProtoMessage()    {}
func (*NonTableStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{9}
}
func (m *NonTableStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NonTableStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NonTableStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonTableStatsResponse.Merge(m, src)
}
func (m *NonTableStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *NonTableStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NonTableStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NonTableStatsResponse proto.InternalMessageInfo

// UsersRequest requests a list of users.
type UsersRequest struct {
}

func (m *UsersRequest) Reset()         { *m = UsersRequest{} }
func (m *UsersRequest) String() string { return proto.CompactTextString(m) }
func (*UsersRequest) ProtoMessage()    {}
func (*UsersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{10}
}
func (m *UsersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UsersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsersRequest.Merge(m, src)
}
func (m *UsersRequest) XXX_Size() int {
	return m.Size()
}
func (m *UsersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UsersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UsersRequest proto.InternalMessageInfo

// UsersResponse returns a list of users.
type UsersResponse struct {
	// usernames is a list of users for the CockroachDB cluster.
	Users []UsersResponse_User `protobuf:"bytes,1,rep,name=users,proto3" json:"users"`
}

func (m *UsersResponse) Reset()         { *m = UsersResponse{} }
func (m *UsersResponse) String() string { return proto.CompactTextString(m) }
func (*UsersResponse) ProtoMessage()    {}
func (*UsersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{11}
}
func (m *UsersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UsersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsersResponse.Merge(m, src)
}
func (m *UsersResponse) XXX_Size() int {
	return m.Size()
}
func (m *UsersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UsersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UsersResponse proto.InternalMessageInfo

// User is a CockroachDB user.
type UsersResponse_User struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *UsersResponse_User) Reset()         { *m = UsersResponse_User{} }
func (m *UsersResponse_User) String() string { return proto.CompactTextString(m) }
func (*UsersResponse_User) ProtoMessage()    {}
func (*UsersResponse_User) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{11, 0}
}
func (m *UsersResponse_User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsersResponse_User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UsersResponse_User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsersResponse_User.Merge(m, src)
}
func (m *UsersResponse_User) XXX_Size() int {
	return m.Size()
}
func (m *UsersResponse_User) XXX_DiscardUnknown() {
	xxx_messageInfo_UsersResponse_User.DiscardUnknown(m)
}

var xxx_messageInfo_UsersResponse_User proto.InternalMessageInfo

// EventsRequest is a request for event log entries, optionally filtered
// by the specified event type.
type EventsRequest struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// limit is the total number of results that are retrieved by the query. If
	// this is omitted or set to 0, the default maximum number of results are
	// returned. When set to > 0, at most only that number of results are
	// returned. When set to < 0, an unlimited number of results are returned.
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// unredacted_events indicates that the values in the events should
	// not be redacted. The default is to redact, so that older versions
	// of `cockroach zip` do not see un-redacted values by default.
	// For good security, this field is only obeyed by the server after
	// checking that the client of the RPC is an admin user.
	UnredactedEvents bool `protobuf:"varint,4,opt,name=unredacted_events,json=unredactedEvents,proto3" json:"unredacted_events,omitempty"`
}

func (m *EventsRequest) Reset()         { *m = EventsRequest{} }
func (m *EventsRequest) String() string { return proto.CompactTextString(m) }
func (*EventsRequest) ProtoMessage()    {}
func (*EventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{12}
}
func (m *EventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsRequest.Merge(m, src)
}
func (m *EventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventsRequest proto.InternalMessageInfo

// EventsResponse contains a set of event log entries. This is always limited
// to the latest N entries (N is enforced in the associated endpoint).
type EventsResponse struct {
	Events []EventsResponse_Event `protobuf:"bytes,1,rep,name=events,proto3" json:"events"`
}

func (m *EventsResponse) Reset()         { *m = EventsResponse{} }
func (m *EventsResponse) String() string { return proto.CompactTextString(m) }
func (*EventsResponse) ProtoMessage()    {}
func (*EventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{13}
}
func (m *EventsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsResponse.Merge(m, src)
}
func (m *EventsResponse) XXX_Size() int {
	return m.Size()
}
func (m *EventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EventsResponse proto.InternalMessageInfo

type EventsResponse_Event struct {
	// timestamp is the time at which the event occurred.
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// event_type is the type of the event (e.g. "create_table", "drop_table".
	EventType string `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// reporting_id is the reporting ID for this event.
	ReportingID int64 `protobuf:"varint,4,opt,name=reporting_id,json=reportingId,proto3" json:"reporting_id,omitempty"`
	// info has more detailed information for the event. The contents vary
	// depending on the event.
	Info string `protobuf:"bytes,5,opt,name=info,proto3" json:"info,omitempty"`
	// unique_id is a unique identifier for this event.
	UniqueID []byte `protobuf:"bytes,6,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *EventsResponse_Event) Reset()         { *m = EventsResponse_Event{} }
func (m *EventsResponse_Event) String() string { return proto.CompactTextString(m) }
func (*EventsResponse_Event) ProtoMessage()    {}
func (*EventsResponse_Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{13, 0}
}
func (m *EventsResponse_Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsResponse_Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventsResponse_Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsResponse_Event.Merge(m, src)
}
func (m *EventsResponse_Event) XXX_Size() int {
	return m.Size()
}
func (m *EventsResponse_Event) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsResponse_Event.DiscardUnknown(m)
}

var xxx_messageInfo_EventsResponse_Event proto.InternalMessageInfo

// SetUIDataRequest stores the given key/value pairs in the system.ui table.
type SetUIDataRequest struct {
	// key_values is a map of keys to bytes values. Each key will be stored
	// with its corresponding value as a separate row in system.ui.
	KeyValues map[string][]byte `protobuf:"bytes,1,rep,name=key_values,json=keyValues,proto3" json:"key_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SetUIDataRequest) Reset()         { *m = SetUIDataRequest{} }
func (m *SetUIDataRequest) String() string { return proto.CompactTextString(m) }
func (*SetUIDataRequest) ProtoMessage()    {}
func (*SetUIDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{14}
}
func (m *SetUIDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetUIDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SetUIDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetUIDataRequest.Merge(m, src)
}
func (m *SetUIDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetUIDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetUIDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetUIDataRequest proto.InternalMessageInfo

// SetUIDataResponse is currently an empty response.
type SetUIDataResponse struct {
}

func (m *SetUIDataResponse) Reset()         { *m = SetUIDataResponse{} }
func (m *SetUIDataResponse) String() string { return proto.CompactTextString(m) }
func (*SetUIDataResponse) ProtoMessage()    {}
func (*SetUIDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{15}
}
func (m *SetUIDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetUIDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SetUIDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetUIDataResponse.Merge(m, src)
}
func (m *SetUIDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetUIDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetUIDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetUIDataResponse proto.InternalMessageInfo

// GETUIDataRequest requests the values for the given keys from the system.ui
// table.
type GetUIDataRequest struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *GetUIDataRequest) Reset()         { *m = GetUIDataRequest{} }
func (m *GetUIDataRequest) String() string { return proto.CompactTextString(m) }
func (*GetUIDataRequest) ProtoMessage()    {}
func (*GetUIDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{16}
}
func (m *GetUIDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUIDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetUIDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUIDataRequest.Merge(m, src)
}
func (m *GetUIDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUIDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUIDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUIDataRequest proto.InternalMessageInfo

// GetUIDataResponse contains the requested values and the times at which
// the values were last updated.
type GetUIDataResponse struct {
	// key_values maps keys to their retrieved values. If this doesn't contain a
	// a requested key, that key was not found.
	KeyValues map[string]GetUIDataResponse_Value `protobuf:"bytes,1,rep,name=key_values,json=keyValues,proto3" json:"key_values" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetUIDataResponse) Reset()         { *m = GetUIDataResponse{} }
func (m *GetUIDataResponse) String() string { return proto.CompactTextString(m) }
func (*GetUIDataResponse) ProtoMessage()    {}
func (*GetUIDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{17}
}
func (m *GetUIDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUIDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetUIDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUIDataResponse.Merge(m, src)
}
func (m *GetUIDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUIDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUIDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUIDataResponse proto.InternalMessageInfo

type GetUIDataResponse_Value struct {
	// value is the value of the requested key.
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// last_updated is the time at which the value was last updated.
	LastUpdated time.Time `protobuf:"bytes,2,opt,name=last_updated,json=lastUpdated,proto3,stdtime" json:"last_updated"`
}

func (m *GetUIDataResponse_Value) Reset()         { *m = GetUIDataResponse_Value{} }
func (m *GetUIDataResponse_Value) String() string { return proto.CompactTextString(m) }
func (*GetUIDataResponse_Value) ProtoMessage()    {}
func (*GetUIDataResponse_Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{17, 0}
}
func (m *GetUIDataResponse_Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUIDataResponse_Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetUIDataResponse_Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUIDataResponse_Value.Merge(m, src)
}
func (m *GetUIDataResponse_Value) XXX_Size() int {
	return m.Size()
}
func (m *GetUIDataResponse_Value) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUIDataResponse_Value.DiscardUnknown(m)
}

var xxx_messageInfo_GetUIDataResponse_Value proto.InternalMessageInfo

// ClusterRequest requests metadata for the cluster.
type ClusterRequest struct {
}

func (m *ClusterRequest) Reset()         { *m = ClusterRequest{} }
func (m *ClusterRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterRequest) ProtoMessage()    {}
func (*ClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{18}
}
func (m *ClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterRequest.Merge(m, src)
}
func (m *ClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterRequest proto.InternalMessageInfo

// ClusterResponse contains metadata for the cluster.
type ClusterResponse struct {
	// The unique ID used to identify this cluster.
	ClusterID string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// True if diagnostics reporting is enabled for the cluster.
	ReportingEnabled bool `protobuf:"varint,2,opt,name=reporting_enabled,json=reportingEnabled,proto3" json:"reporting_enabled,omitempty"`
	// True if enterprise features are enabled for the cluster.
	EnterpriseEnabled bool `protobuf:"varint,3,opt,name=enterprise_enabled,json=enterpriseEnabled,proto3" json:"enterprise_enabled,omitempty"`
}

func (m *ClusterResponse) Reset()         { *m = ClusterResponse{} }
func (m *ClusterResponse) String() string { return proto.CompactTextString(m) }
func (*ClusterResponse) ProtoMessage()    {}
func (*ClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{19}
}
func (m *ClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterResponse.Merge(m, src)
}
func (m *ClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterResponse proto.InternalMessageInfo

// DrainRequest instructs the receiving node to drain.
type DrainRequest struct {
	// When true, terminates the process after the server has started draining.
	// Setting both shutdown and do_drain to false causes
	// the request to only operate as a probe.
	// Setting do_drain to false and shutdown to true causes
	// the server to shut down immediately without
	// first draining.
	Shutdown bool `protobuf:"varint,3,opt,name=shutdown,proto3" json:"shutdown,omitempty"`
	// When true, perform the drain phase. See the comment above on
	// shutdown for an explanation of the interaction between the two.
	// do_drain is also implied by a non-nil deprecated_probe_indicator.
	DoDrain bool `protobuf:"varint,4,opt,name=do_drain,json=doDrain,proto3" json:"do_drain,omitempty"`
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	// For compatibility with v21.2 nodes, an empty node_id is
	// interpreted as "local". This behavior might be removed
	// in subsequent versions.
	NodeId string `protobuf:"bytes,5,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// When true, more detailed information is logged during the range lease drain phase.
	Verbose bool `protobuf:"varint,6,opt,name=verbose,proto3" json:"verbose,omitempty"`
}

func (m *DrainRequest) Reset()         { *m = DrainRequest{} }
func (m *DrainRequest) String() string { return proto.CompactTextString(m) }
func (*DrainRequest) ProtoMessage()    {}
func (*DrainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{20}
}
func (m *DrainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DrainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DrainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DrainRequest.Merge(m, src)
}
func (m *DrainRequest) XXX_Size() int {
	return m.Size()
}
func (m *DrainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DrainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DrainRequest proto.InternalMessageInfo

// DrainResponse is the response to a successful DrainRequest.
type DrainResponse struct {
	// is_draining is set to true iff the server is currently draining.
	// This is set to true in response to a request where skip_drain
	// is false; but it can also be set to true in response
	// to a probe request (!shutdown && skip_drain) if another
	// drain request has been issued prior or asynchronously.
	IsDraining bool `protobuf:"varint,2,opt,name=is_draining,json=isDraining,proto3" json:"is_draining,omitempty"`
	// drain_remaining_indicator measures, at the time of starting to
	// process the corresponding drain request, how many actions to
	// fully drain the node were deemed to be necessary. Some, but not
	// all, of these actions may already have been carried out by the
	// time this indicator is received by the client. The client should
	// issue requests until this indicator first reaches zero, which
	// indicates that the node is fully drained.
	//
	// The API contract is the following:
	//
	// - upon a first Drain call with do_drain set, the remaining
	//   indicator will have some value >=0. If >0, it indicates that
	//   drain is pushing state away from the node. (What this state
	//   precisely means is left unspecified for this field. See below
	//   for details.)
	//
	// - upon a subsequent Drain call with do_drain set, the remaining
	//   indicator should have reduced in value. The drain process does best
	//   effort at shedding state away from the node; hopefully, all the
	//   state is shed away upon the first call and the progress
	//   indicator can be zero as early as the second call. However,
	//   if there was a lot of state to shed, it is possible for
	//   timeout to be encountered upon the first call. In that case, the
	//   second call will do some more work and return a non-zero value
	//   as well.
	//
	// - eventually, in an iterated sequence of DrainRequests with
	//   do_drain set, the remaining indicator should reduce to zero. At
	//   that point the client can conclude that no state is left to
	//   shed, and it should be safe to shut down the node with a
	//   DrainRequest with shutdown = true.
	//
	// Note that this field is left unpopulated (and thus remains at
	// zero) for pre-20.1 nodes. A client can recognize this by
	// observing is_draining to be false after a request with do_drain =
	// true: the is_draining field is also left unpopulated by pre-20.1
	// nodes.
	DrainRemainingIndicator uint64 `protobuf:"varint,3,opt,name=drain_remaining_indicator,json=drainRemainingIndicator,proto3" json:"drain_remaining_indicator,omitempty"`
	// drain_remaining_description is an informal (= not
	// machine-parsable) string that explains the progress of the drain
	// process to human eyes. This is intended for use mainly for
	// troubleshooting.
	//
	// The field is only populated if do_drain is true in the
	// request.
	DrainRemainingDescription string `protobuf:"bytes,4,opt,name=drain_remaining_description,json=drainRemainingDescription,proto3" json:"drain_remaining_description,omitempty"`
}

func (m *DrainResponse) Reset()         { *m = DrainResponse{} }
func (m *DrainResponse) String() string { return proto.CompactTextString(m) }
func (*DrainResponse) ProtoMessage()    {}
func (*DrainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{21}
}
func (m *DrainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DrainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DrainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DrainResponse.Merge(m, src)
}
func (m *DrainResponse) XXX_Size() int {
	return m.Size()
}
func (m *DrainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DrainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DrainResponse proto.InternalMessageInfo

// DecommissionPreCheckRequest requests that preliminary checks be run to
// ensure that the specified node(s) can be decommissioned successfully.
type DecommissionPreCheckRequest struct {
	NodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,rep,packed,name=node_ids,json=nodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_ids,omitempty"`
	// The maximum number of ranges for which to report errors.
	NumReplicaReport int32 `protobuf:"varint,2,opt,name=num_replica_report,json=numReplicaReport,proto3" json:"num_replica_report,omitempty"`
	// If true, all ranges on the checked nodes must only need replacement or
	// removal for decommissioning.
	StrictReadiness bool `protobuf:"varint,3,opt,name=strict_readiness,json=strictReadiness,proto3" json:"strict_readiness,omitempty"`
	// If true, collect traces for each range checked.
	// Requires num_replica_report > 0.
	CollectTraces bool `protobuf:"varint,4,opt,name=collect_traces,json=collectTraces,proto3" json:"collect_traces,omitempty"`
}

func (m *DecommissionPreCheckRequest) Reset()         { *m = DecommissionPreCheckRequest{} }
func (m *DecommissionPreCheckRequest) String() string { return proto.CompactTextString(m) }
func (*DecommissionPreCheckRequest) ProtoMessage()    {}
func (*DecommissionPreCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{22}
}
func (m *DecommissionPreCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionPreCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionPreCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionPreCheckRequest.Merge(m, src)
}
func (m *DecommissionPreCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionPreCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionPreCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionPreCheckRequest proto.InternalMessageInfo

// DecommissionPreCheckResponse returns the number of replicas that encountered
// errors when running preliminary decommissioning checks, as well as the
// associated error messages and traces, for each node.
type DecommissionPreCheckResponse struct {
	// Status of the preliminary decommission checks across nodes.
	CheckedNodes []DecommissionPreCheckResponse_NodeCheckResult `protobuf:"bytes,1,rep,name=checked_nodes,json=checkedNodes,proto3" json:"checked_nodes"`
}

func (m *DecommissionPreCheckResponse) Reset()         { *m = DecommissionPreCheckResponse{} }
func (m *DecommissionPreCheckResponse) String() string { return proto.CompactTextString(m) }
func (*DecommissionPreCheckResponse) ProtoMessage()    {}
func (*DecommissionPreCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{23}
}
func (m *DecommissionPreCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionPreCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionPreCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionPreCheckResponse.Merge(m, src)
}
func (m *DecommissionPreCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionPreCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionPreCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionPreCheckResponse proto.InternalMessageInfo

// The result of checking a range's readiness for the decommission.
type DecommissionPreCheckResponse_RangeCheckResult struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// The action determined by the allocator that is needed for the range.
	Action string `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	// All trace events collected while checking the range.
	Events []*TraceEvent `protobuf:"bytes,3,rep,name=events,proto3" json:"events,omitempty"`
	// The error message from the allocator's processing, if any.
	Error string `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *DecommissionPreCheckResponse_RangeCheckResult) Reset() {
	*m = DecommissionPreCheckResponse_RangeCheckResult{}
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) String() string {
	return proto.CompactTextString(m)
}
func (*DecommissionPreCheckResponse_RangeCheckResult) ProtoMessage() {}
func (*DecommissionPreCheckResponse_RangeCheckResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{23, 0}
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionPreCheckResponse_RangeCheckResult.Merge(m, src)
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionPreCheckResponse_RangeCheckResult.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionPreCheckResponse_RangeCheckResult proto.InternalMessageInfo

// The result of checking a single node's readiness for decommission.
type DecommissionPreCheckResponse_NodeCheckResult struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// The node's decommission readiness status.
	DecommissionReadiness DecommissionPreCheckResponse_NodeReadiness `protobuf:"varint,2,opt,name=decommission_readiness,json=decommissionReadiness,proto3,enum=cockroach.server.serverpb.DecommissionPreCheckResponse_NodeReadiness" json:"decommission_readiness,omitempty"`
	// The number of total replicas on the node, computed by scanning range
	// descriptors.
	ReplicaCount int64 `protobuf:"varint,4,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// The details and recorded traces from preprocessing each range with a
	// replica on the checked nodes that resulted in error, up to the maximum
	// specified in the request.
	CheckedRanges []DecommissionPreCheckResponse_RangeCheckResult `protobuf:"bytes,5,rep,name=checked_ranges,json=checkedRanges,proto3" json:"checked_ranges"`
}

func (m *DecommissionPreCheckResponse_NodeCheckResult) Reset() {
	*m = DecommissionPreCheckResponse_NodeCheckResult{}
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) String() string {
	return proto.CompactTextString(m)
}
func (*DecommissionPreCheckResponse_NodeCheckResult) ProtoMessage() {}
func (*DecommissionPreCheckResponse_NodeCheckResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{23, 1}
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionPreCheckResponse_NodeCheckResult.Merge(m, src)
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionPreCheckResponse_NodeCheckResult.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionPreCheckResponse_NodeCheckResult proto.InternalMessageInfo

// DecommissionStatusRequest requests the decommissioning status for the
// specified or, if none are specified, all nodes.
type DecommissionStatusRequest struct {
	NodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,rep,packed,name=node_ids,json=nodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_ids,omitempty"`
	// The number of decommissioning replicas to be reported.
	NumReplicaReport int32 `protobuf:"varint,2,opt,name=num_replica_report,json=numReplicaReport,proto3" json:"num_replica_report,omitempty"`
}

func (m *DecommissionStatusRequest) Reset()         { *m = DecommissionStatusRequest{} }
func (m *DecommissionStatusRequest) String() string { return proto.CompactTextString(m) }
func (*DecommissionStatusRequest) ProtoMessage()    {}
func (*DecommissionStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{24}
}
func (m *DecommissionStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionStatusRequest.Merge(m, src)
}
func (m *DecommissionStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionStatusRequest proto.InternalMessageInfo

// DecommissionRequest requests the server to set the membership status on
// all nodes specified by NodeIDs to the value of TargetMembership.
//
// If no NodeIDs are given, it targets the recipient node.
type DecommissionRequest struct {
	NodeIDs          []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,rep,packed,name=node_ids,json=nodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_ids,omitempty"`
	TargetMembership livenesspb.MembershipStatus                           `protobuf:"varint,2,opt,name=target_membership,json=targetMembership,proto3,enum=cockroach.kv.kvserver.liveness.livenesspb.MembershipStatus" json:"target_membership,omitempty"`
	// The number of decommissioning replicas to be reported.
	NumReplicaReport int32 `protobuf:"varint,3,opt,name=num_replica_report,json=numReplicaReport,proto3" json:"num_replica_report,omitempty"`
}

func (m *DecommissionRequest) Reset()         { *m = DecommissionRequest{} }
func (m *DecommissionRequest) String() string { return proto.CompactTextString(m) }
func (*DecommissionRequest) ProtoMessage()    {}
func (*DecommissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{25}
}
func (m *DecommissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionRequest.Merge(m, src)
}
func (m *DecommissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionRequest proto.InternalMessageInfo

// DecommissionStatusResponse lists decommissioning statuses for a number of NodeIDs.
type DecommissionStatusResponse struct {
	// Status of all affected nodes.
	Status []DecommissionStatusResponse_Status `protobuf:"bytes,2,rep,name=status,proto3" json:"status"`
}

func (m *DecommissionStatusResponse) Reset()         { *m = DecommissionStatusResponse{} }
func (m *DecommissionStatusResponse) String() string { return proto.CompactTextString(m) }
func (*DecommissionStatusResponse) ProtoMessage()    {}
func (*DecommissionStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{26}
}
func (m *DecommissionStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionStatusResponse.Merge(m, src)
}
func (m *DecommissionStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionStatusResponse proto.InternalMessageInfo

type DecommissionStatusResponse_Replica struct {
	ReplicaID github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"replica_id,omitempty"`
	RangeID   github_com_cockroachdb_cockroach_pkg_roachpb.RangeID   `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
}

func (m *DecommissionStatusResponse_Replica) Reset()         { *m = DecommissionStatusResponse_Replica{} }
func (m *DecommissionStatusResponse_Replica) String() string { return proto.CompactTextString(m) }
func (*DecommissionStatusResponse_Replica) ProtoMessage()    {}
func (*DecommissionStatusResponse_Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{26, 0}
}
func (m *DecommissionStatusResponse_Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionStatusResponse_Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionStatusResponse_Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionStatusResponse_Replica.Merge(m, src)
}
func (m *DecommissionStatusResponse_Replica) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionStatusResponse_Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionStatusResponse_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionStatusResponse_Replica proto.InternalMessageInfo

type DecommissionStatusResponse_Status struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	IsLive bool                                                `protobuf:"varint,2,opt,name=is_live,json=isLive,proto3" json:"is_live,omitempty"`
	// The number of replicas on the node, computed by scanning meta2 ranges.
	ReplicaCount int64 `protobuf:"varint,3,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// The membership status of the given node.
	Membership livenesspb.MembershipStatus `protobuf:"varint,4,opt,name=membership,proto3,enum=cockroach.kv.kvserver.liveness.livenesspb.MembershipStatus" json:"membership,omitempty"`
	Draining   bool                        `protobuf:"varint,5,opt,name=draining,proto3" json:"draining,omitempty"`
	// Decommissioning replicas on the given node to be reported.
	// How many replicas are reported is determined by what was specified in the
	// request.
	ReportedReplicas []*DecommissionStatusResponse_Replica `protobuf:"bytes,6,rep,name=reported_replicas,json=reportedReplicas,proto3" json:"reported_replicas,omitempty"`
}

func (m *DecommissionStatusResponse_Status) Reset()         { *m = DecommissionStatusResponse_Status{} }
func (m *DecommissionStatusResponse_Status) String() string { return proto.CompactTextString(m) }
func (*DecommissionStatusResponse_Status) ProtoMessage()    {}
func (*DecommissionStatusResponse_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{26, 1}
}
func (m *DecommissionStatusResponse_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecommissionStatusResponse_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DecommissionStatusResponse_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecommissionStatusResponse_Status.Merge(m, src)
}
func (m *DecommissionStatusResponse_Status) XXX_Size() int {
	return m.Size()
}
func (m *DecommissionStatusResponse_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_DecommissionStatusResponse_Status.DiscardUnknown(m)
}

var xxx_messageInfo_DecommissionStatusResponse_Status proto.InternalMessageInfo

// SettingsRequest inquires what are the current settings in the cluster.
type SettingsRequest struct {
	// The array of setting keys or names to retrieve.
	// An empty keys array means "all".
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *SettingsRequest) Reset()         { *m = SettingsRequest{} }
func (m *SettingsRequest) String() string { return proto.CompactTextString(m) }
func (*SettingsRequest) ProtoMessage()    {}
func (*SettingsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{27}
}
func (m *SettingsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SettingsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SettingsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SettingsRequest.Merge(m, src)
}
func (m *SettingsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SettingsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SettingsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SettingsRequest proto.InternalMessageInfo

// SettingsResponse is the response to SettingsRequest.
type SettingsResponse struct {
	KeyValues map[string]SettingsResponse_Value `protobuf:"bytes,1,rep,name=key_values,json=keyValues,proto3" json:"key_values" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SettingsResponse) Reset()         { *m = SettingsResponse{} }
func (m *SettingsResponse) String() string { return proto.CompactTextString(m) }
func (*SettingsResponse) ProtoMessage()    {}
func (*SettingsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{28}
}
func (m *SettingsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SettingsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SettingsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SettingsResponse.Merge(m, src)
}
func (m *SettingsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SettingsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SettingsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SettingsResponse proto.InternalMessageInfo

type SettingsResponse_Value struct {
	// The value of the setting.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The type of the setting.
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// An extended description text.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Whether the setting is public or reserved.
	Public bool `protobuf:"varint,4,opt,name=public,proto3" json:"public,omitempty"`
	// When the setting was last updated.
	LastUpdated *time.Time `protobuf:"bytes,5,opt,name=last_updated,json=lastUpdated,proto3,stdtime" json:"last_updated,omitempty"`
	// The setting name for display purposes.
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *SettingsResponse_Value) Reset()         { *m = SettingsResponse_Value{} }
func (m *SettingsResponse_Value) String() string { return proto.CompactTextString(m) }
func (*SettingsResponse_Value) ProtoMessage()    {}
func (*SettingsResponse_Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{28, 0}
}
func (m *SettingsResponse_Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SettingsResponse_Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SettingsResponse_Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SettingsResponse_Value.Merge(m, src)
}
func (m *SettingsResponse_Value) XXX_Size() int {
	return m.Size()
}
func (m *SettingsResponse_Value) XXX_DiscardUnknown() {
	xxx_messageInfo_SettingsResponse_Value.DiscardUnknown(m)
}

var xxx_messageInfo_SettingsResponse_Value proto.InternalMessageInfo

// HealthRequest requests a liveness or readiness check.
//
// A liveness check is triggered via ready set to false. In this mode,
// an empty response is returned immediately, that is, the caller merely
// learns that the process is running.
//
// A readiness check (ready == true) is suitable for determining whether
// user traffic should be directed at a given node, for example by a load
// balancer. In this mode, a successful response is returned only if the
// node:
//
//   - is not in the process of shutting down or booting up (including
//     waiting for cluster bootstrap);
//   - is regarded as healthy by the cluster via the recent broadcast of
//     a liveness beacon. Absent either of these conditions, an error
//     code will result.
//
// API: PUBLIC
type HealthRequest struct {
	// ready specifies whether the client wants to know whether the
	// target node is ready to receive traffic. If a node is unready, an
	// error will be returned.
	// API: PUBLIC
	Ready bool `protobuf:"varint,1,opt,name=ready,proto3" json:"ready,omitempty"`
}

func (m *HealthRequest) Reset()         { *m = HealthRequest{} }
func (m *HealthRequest) String() string { return proto.CompactTextString(m) }
func (*HealthRequest) ProtoMessage()    {}
func (*HealthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{29}
}
func (m *HealthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HealthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthRequest.Merge(m, src)
}
func (m *HealthRequest) XXX_Size() int {
	return m.Size()
}
func (m *HealthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HealthRequest proto.InternalMessageInfo

// HealthResponse is the response to HealthRequest. It currently does not
// contain any information.
// API: PUBLIC
type HealthResponse struct {
}

func (m *HealthResponse) Reset()         { *m = HealthResponse{} }
func (m *HealthResponse) String() string { return proto.CompactTextString(m) }
func (*HealthResponse) ProtoMessage()    {}
func (*HealthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{30}
}
func (m *HealthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HealthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthResponse.Merge(m, src)
}
func (m *HealthResponse) XXX_Size() int {
	return m.Size()
}
func (m *HealthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HealthResponse proto.InternalMessageInfo

// LivenessRequest requests liveness data for all nodes on the cluster.
type LivenessRequest struct {
}

func (m *LivenessRequest) Reset()         { *m = LivenessRequest{} }
func (m *LivenessRequest) String() string { return proto.CompactTextString(m) }
func (*LivenessRequest) ProtoMessage()    {}
func (*LivenessRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{31}
}
func (m *LivenessRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LivenessRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LivenessRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LivenessRequest.Merge(m, src)
}
func (m *LivenessRequest) XXX_Size() int {
	return m.Size()
}
func (m *LivenessRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LivenessRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LivenessRequest proto.InternalMessageInfo

// LivenessResponse contains the liveness status of each node on the cluster.
type LivenessResponse struct {
	Livenesses []livenesspb.Liveness                                                                 `protobuf:"bytes,1,rep,name=livenesses,proto3" json:"livenesses"`
	Statuses   map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus `protobuf:"bytes,2,rep,name=statuses,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"statuses" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=cockroach.kv.kvserver.liveness.livenesspb.NodeLivenessStatus"`
}

func (m *LivenessResponse) Reset()         { *m = LivenessResponse{} }
func (m *LivenessResponse) String() string { return proto.CompactTextString(m) }
func (*LivenessResponse) ProtoMessage()    {}
func (*LivenessResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{32}
}
func (m *LivenessResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LivenessResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LivenessResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LivenessResponse.Merge(m, src)
}
func (m *LivenessResponse) XXX_Size() int {
	return m.Size()
}
func (m *LivenessResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LivenessResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LivenessResponse proto.InternalMessageInfo

// JobsRequest requests system job information of the given status and type.
type JobsRequest struct {
	Limit  int32       `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Status string      `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	Type   jobspb.Type `protobuf:"varint,3,opt,name=type,proto3,enum=cockroach.sql.jobs.jobspb.Type" json:"type,omitempty"`
}

func (m *JobsRequest) Reset()         { *m = JobsRequest{} }
func (m *JobsRequest) String() string { return proto.CompactTextString(m) }
func (*JobsRequest) ProtoMessage()    {}
func (*JobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{33}
}
func (m *JobsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobsRequest.Merge(m, src)
}
func (m *JobsRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobsRequest proto.InternalMessageInfo

// JobsResponse contains the job record for each matching job.
type JobsResponse struct {
	Jobs                 []JobResponse `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs"`
	EarliestRetainedTime time.Time     `protobuf:"bytes,2,opt,name=earliest_retained_time,json=earliestRetainedTime,proto3,stdtime" json:"earliest_retained_time"`
}

func (m *JobsResponse) Reset()         { *m = JobsResponse{} }
func (m *JobsResponse) String() string { return proto.CompactTextString(m) }
func (*JobsResponse) ProtoMessage()    {}
func (*JobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{34}
}
func (m *JobsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobsResponse.Merge(m, src)
}
func (m *JobsResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobsResponse proto.InternalMessageInfo

// JobRequest requests system job information for the given job_id.
type JobRequest struct {
	JobId int64 `protobuf:"varint,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *JobRequest) Reset()         { *m = JobRequest{} }
func (m *JobRequest) String() string { return proto.CompactTextString(m) }
func (*JobRequest) ProtoMessage()    {}
func (*JobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{35}
}
func (m *JobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRequest.Merge(m, src)
}
func (m *JobRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobRequest proto.InternalMessageInfo

type JobMessage struct {
	Kind      string    `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Timestamp time.Time `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Message   string    `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *JobMessage) Reset()         { *m = JobMessage{} }
func (m *JobMessage) String() string { return proto.CompactTextString(m) }
func (*JobMessage) ProtoMessage()    {}
func (*JobMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{36}
}
func (m *JobMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobMessage.Merge(m, src)
}
func (m *JobMessage) XXX_Size() int {
	return m.Size()
}
func (m *JobMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_JobMessage.DiscardUnknown(m)
}

var xxx_messageInfo_JobMessage proto.InternalMessageInfo

// JobResponse contains the job record for a job.
type JobResponse struct {
	ID                int64                                                        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type              string                                                       `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Description       string                                                       `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Statement         string                                                       `protobuf:"bytes,16,opt,name=statement,proto3" json:"statement,omitempty"`
	Username          string                                                       `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	DescriptorIDs     []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,5,rep,packed,name=descriptor_ids,json=descriptorIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"descriptor_ids,omitempty"`
	Status            string                                                       `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	Created           *time.Time                                                   `protobuf:"bytes,7,opt,name=created,proto3,stdtime" json:"created,omitempty"`
	Started           *time.Time                                                   `protobuf:"bytes,8,opt,name=started,proto3,stdtime" json:"started,omitempty"`
	Finished          *time.Time                                                   `protobuf:"bytes,9,opt,name=finished,proto3,stdtime" json:"finished,omitempty"`
	Modified          *time.Time                                                   `protobuf:"bytes,10,opt,name=modified,proto3,stdtime" json:"modified,omitempty"`
	FractionCompleted float32                                                      `protobuf:"fixed32,11,opt,name=fraction_completed,json=fractionCompleted,proto3" json:"fraction_completed,omitempty"`
	Error             string                                                       `protobuf:"bytes,12,opt,name=error,proto3" json:"error,omitempty"`
	// highwater_timestamp is the highwater timestamp returned as normal
	// timestamp. This is appropriate for display to humans.
	HighwaterTimestamp *time.Time `protobuf:"bytes,13,opt,name=highwater_timestamp,json=highwaterTimestamp,proto3,stdtime" json:"highwater_timestamp,omitempty"`
	// highwater_decimal is the highwater timestamp in the proprietary decimal
	// form used by logical timestamps internally. This is appropriate to pass
	// to a "AS OF SYSTEM TIME" SQL statement.
	HighwaterDecimal string     `protobuf:"bytes,14,opt,name=highwater_decimal,json=highwaterDecimal,proto3" json:"highwater_decimal,omitempty"`
	RunningStatus    string     `protobuf:"bytes,15,opt,name=running_status,json=runningStatus,proto3" json:"running_status,omitempty"`
	LastRun          *time.Time `protobuf:"bytes,17,opt,name=last_run,json=lastRun,proto3,stdtime" json:"last_run,omitempty"`
	NextRun          *time.Time `protobuf:"bytes,18,opt,name=next_run,json=nextRun,proto3,stdtime" json:"next_run,omitempty"`
	NumRuns          int64      `protobuf:"varint,19,opt,name=num_runs,json=numRuns,proto3" json:"num_runs,omitempty"`
	// ExecutionFailures is a log of execution failures of the job. It is not
	// guaranteed to contain all execution failures and some execution failures
	// may not contain an error or end.
	ExecutionFailures []*JobResponse_ExecutionFailure `protobuf:"bytes,20,rep,name=execution_failures,json=executionFailures,proto3" json:"execution_failures,omitempty"`
	// coordinator_id identifies the node coordinating the job. This value will
	// only be present for jobs that are currently running or recently ran.
	CoordinatorID int64        `protobuf:"varint,21,opt,name=coordinator_id,json=coordinatorId,proto3" json:"coordinator_id,omitempty"`
	Messages      []JobMessage `protobuf:"bytes,22,rep,name=messages,proto3" json:"messages"`
}

func (m *JobResponse) Reset()         { *m = JobResponse{} }
func (m *JobResponse) String() string { return proto.CompactTextString(m) }
func (*JobResponse) ProtoMessage()    {}
func (*JobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{37}
}
func (m *JobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobResponse.Merge(m, src)
}
func (m *JobResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobResponse proto.InternalMessageInfo

// ExecutionFailure corresponds to a failure to execute the job with the
// attempt starting at start and ending at end.
type JobResponse_ExecutionFailure struct {
	// Status is the status of the job during the execution.
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Start is the time at which the execution started.
	Start *time.Time `protobuf:"bytes,2,opt,name=start,proto3,stdtime" json:"start,omitempty"`
	// End is the time at which the error occurred.
	End *time.Time `protobuf:"bytes,3,opt,name=end,proto3,stdtime" json:"end,omitempty"`
	// Error is the error which occurred.
	Error string `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *JobResponse_ExecutionFailure) Reset()         { *m = JobResponse_ExecutionFailure{} }
func (m *JobResponse_ExecutionFailure) String() string { return proto.CompactTextString(m) }
func (*JobResponse_ExecutionFailure) ProtoMessage()    {}
func (*JobResponse_ExecutionFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{37, 0}
}
func (m *JobResponse_ExecutionFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobResponse_ExecutionFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobResponse_ExecutionFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobResponse_ExecutionFailure.Merge(m, src)
}
func (m *JobResponse_ExecutionFailure) XXX_Size() int {
	return m.Size()
}
func (m *JobResponse_ExecutionFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_JobResponse_ExecutionFailure.DiscardUnknown(m)
}

var xxx_messageInfo_JobResponse_ExecutionFailure proto.InternalMessageInfo

// LocationsRequest requests system locality location information.
type LocationsRequest struct {
}

func (m *LocationsRequest) Reset()         { *m = LocationsRequest{} }
func (m *LocationsRequest) String() string { return proto.CompactTextString(m) }
func (*LocationsRequest) ProtoMessage()    {}
func (*LocationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{38}
}
func (m *LocationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationsRequest.Merge(m, src)
}
func (m *LocationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LocationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LocationsRequest proto.InternalMessageInfo

// JobsResponse contains the job record for each matching job.
type LocationsResponse struct {
	Locations []LocationsResponse_Location `protobuf:"bytes,1,rep,name=locations,proto3" json:"locations"`
}

func (m *LocationsResponse) Reset()         { *m = LocationsResponse{} }
func (m *LocationsResponse) String() string { return proto.CompactTextString(m) }
func (*LocationsResponse) ProtoMessage()    {}
func (*LocationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{39}
}
func (m *LocationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationsResponse.Merge(m, src)
}
func (m *LocationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *LocationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LocationsResponse proto.InternalMessageInfo

type LocationsResponse_Location struct {
	LocalityKey   string  `protobuf:"bytes,1,opt,name=locality_key,json=localityKey,proto3" json:"locality_key,omitempty"`
	LocalityValue string  `protobuf:"bytes,2,opt,name=locality_value,json=localityValue,proto3" json:"locality_value,omitempty"`
	Latitude      float64 `protobuf:"fixed64,3,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude     float64 `protobuf:"fixed64,4,opt,name=longitude,proto3" json:"longitude,omitempty"`
}

func (m *LocationsResponse_Location) Reset()         { *m = LocationsResponse_Location{} }
func (m *LocationsResponse_Location) String() string { return proto.CompactTextString(m) }
func (*LocationsResponse_Location) ProtoMessage()    {}
func (*LocationsResponse_Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{39, 0}
}
func (m *LocationsResponse_Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationsResponse_Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocationsResponse_Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationsResponse_Location.Merge(m, src)
}
func (m *LocationsResponse_Location) XXX_Size() int {
	return m.Size()
}
func (m *LocationsResponse_Location) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationsResponse_Location.DiscardUnknown(m)
}

var xxx_messageInfo_LocationsResponse_Location proto.InternalMessageInfo

// RangeLogRequest request the history of a range from the range log.
type RangeLogRequest struct {
	// TODO(tamird): use [(gogoproto.customname) = "RangeID"] below. Need to
	// figure out how to teach grpc-gateway about custom names.
	// If RangeID is 0, returns range log history without filtering by range.
	RangeId int64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	// limit is the total number of results that are retrieved by the query. If
	// this is omitted or set to 0, the default maximum number of results are
	// returned. When set to > 0, at most only that number of results are
	// returned. When set to < 0, an unlimited number of results are returned.
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *RangeLogRequest) Reset()         { *m = RangeLogRequest{} }
func (m *RangeLogRequest) String() string { return proto.CompactTextString(m) }
func (*RangeLogRequest) ProtoMessage()    {}
func (*RangeLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{40}
}
func (m *RangeLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLogRequest.Merge(m, src)
}
func (m *RangeLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLogRequest proto.InternalMessageInfo

// RangeLogResponse contains a list of entries from the range log table.
type RangeLogResponse struct {
	Events []RangeLogResponse_Event `protobuf:"bytes,2,rep,name=events,proto3" json:"events"`
}

func (m *RangeLogResponse) Reset()         { *m = RangeLogResponse{} }
func (m *RangeLogResponse) String() string { return proto.CompactTextString(m) }
func (*RangeLogResponse) ProtoMessage()    {}
func (*RangeLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{41}
}
func (m *RangeLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLogResponse.Merge(m, src)
}
func (m *RangeLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLogResponse proto.InternalMessageInfo

// To avoid porting the pretty printing of keys and descriptors to
// javascript, they will be precomputed on the serverside.
type RangeLogResponse_PrettyInfo struct {
	UpdatedDesc    string `protobuf:"bytes,1,opt,name=updated_desc,json=updatedDesc,proto3" json:"updated_desc,omitempty"`
	NewDesc        string `protobuf:"bytes,2,opt,name=new_desc,json=newDesc,proto3" json:"new_desc,omitempty"`
	AddedReplica   string `protobuf:"bytes,3,opt,name=added_replica,json=addedReplica,proto3" json:"added_replica,omitempty"`
	RemovedReplica string `protobuf:"bytes,4,opt,name=removed_replica,json=removedReplica,proto3" json:"removed_replica,omitempty"`
	Reason         string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	Details        string `protobuf:"bytes,6,opt,name=details,proto3" json:"details,omitempty"`
}

func (m *RangeLogResponse_PrettyInfo) Reset()         { *m = RangeLogResponse_PrettyInfo{} }
func (m *RangeLogResponse_PrettyInfo) String() string { return proto.CompactTextString(m) }
func (*RangeLogResponse_PrettyInfo) ProtoMessage()    {}
func (*RangeLogResponse_PrettyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{41, 0}
}
func (m *RangeLogResponse_PrettyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLogResponse_PrettyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLogResponse_PrettyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLogResponse_PrettyInfo.Merge(m, src)
}
func (m *RangeLogResponse_PrettyInfo) XXX_Size() int {
	return m.Size()
}
func (m *RangeLogResponse_PrettyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLogResponse_PrettyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLogResponse_PrettyInfo proto.InternalMessageInfo

type RangeLogResponse_Event struct {
	Event      kvserverpb.RangeLogEvent    `protobuf:"bytes,1,opt,name=event,proto3" json:"event"`
	PrettyInfo RangeLogResponse_PrettyInfo `protobuf:"bytes,2,opt,name=pretty_info,json=prettyInfo,proto3" json:"pretty_info"`
}

func (m *RangeLogResponse_Event) Reset()         { *m = RangeLogResponse_Event{} }
func (m *RangeLogResponse_Event) String() string { return proto.CompactTextString(m) }
func (*RangeLogResponse_Event) ProtoMessage()    {}
func (*RangeLogResponse_Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{41, 1}
}
func (m *RangeLogResponse_Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLogResponse_Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLogResponse_Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLogResponse_Event.Merge(m, src)
}
func (m *RangeLogResponse_Event) XXX_Size() int {
	return m.Size()
}
func (m *RangeLogResponse_Event) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLogResponse_Event.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLogResponse_Event proto.InternalMessageInfo

// QueryPlanRequest requests the query plans for a SQL string.
type QueryPlanRequest struct {
	// query is the SQL query string.
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *QueryPlanRequest) Reset()         { *m = QueryPlanRequest{} }
func (m *QueryPlanRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPlanRequest) ProtoMessage()    {}
func (*QueryPlanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{42}
}
func (m *QueryPlanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryPlanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPlanRequest.Merge(m, src)
}
func (m *QueryPlanRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPlanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPlanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPlanRequest proto.InternalMessageInfo

// QueryPlanResponse contains the query plans for a SQL string (currently only
// the distsql physical query plan).
type QueryPlanResponse struct {
	DistSQLPhysicalQueryPlan string `protobuf:"bytes,1,opt,name=distsql_physical_query_plan,json=distsqlPhysicalQueryPlan,proto3" json:"distsql_physical_query_plan,omitempty"`
}

func (m *QueryPlanResponse) Reset()         { *m = QueryPlanResponse{} }
func (m *QueryPlanResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPlanResponse) ProtoMessage()    {}
func (*QueryPlanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{43}
}
func (m *QueryPlanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryPlanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPlanResponse.Merge(m, src)
}
func (m *QueryPlanResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPlanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPlanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPlanResponse proto.InternalMessageInfo

type DataDistributionRequest struct {
}

func (m *DataDistributionRequest) Reset()         { *m = DataDistributionRequest{} }
func (m *DataDistributionRequest) String() string { return proto.CompactTextString(m) }
func (*DataDistributionRequest) ProtoMessage()    {}
func (*DataDistributionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{44}
}
func (m *DataDistributionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDistributionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataDistributionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDistributionRequest.Merge(m, src)
}
func (m *DataDistributionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataDistributionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDistributionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataDistributionRequest proto.InternalMessageInfo

type DataDistributionResponse struct {
	// By database name.
	DatabaseInfo map[string]DataDistributionResponse_DatabaseInfo `protobuf:"bytes,1,rep,name=database_info,json=databaseInfo,proto3" json:"database_info" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// By zone name.
	ZoneConfigs map[string]DataDistributionResponse_ZoneConfig `protobuf:"bytes,3,rep,name=zone_configs,json=zoneConfigs,proto3" json:"zone_configs" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DataDistributionResponse) Reset()         { *m = DataDistributionResponse{} }
func (m *DataDistributionResponse) String() string { return proto.CompactTextString(m) }
func (*DataDistributionResponse) ProtoMessage()    {}
func (*DataDistributionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{45}
}
func (m *DataDistributionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDistributionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataDistributionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDistributionResponse.Merge(m, src)
}
func (m *DataDistributionResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataDistributionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDistributionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataDistributionResponse proto.InternalMessageInfo

type DataDistributionResponse_ZoneConfig struct {
	// target is the object the zone config applies to, e.g. "DATABASE db" or
	// "PARTITION north_america OF TABLE users".
	Target string            `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	Config zonepb.ZoneConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
	// config_sql is the SQL representation of config.
	ConfigSQL string `protobuf:"bytes,4,opt,name=config_sql,json=configSql,proto3" json:"config_sql,omitempty"`
}

func (m *DataDistributionResponse_ZoneConfig) Reset()         { *m = DataDistributionResponse_ZoneConfig{} }
func (m *DataDistributionResponse_ZoneConfig) String() string { return proto.CompactTextString(m) }
func (*DataDistributionResponse_ZoneConfig) ProtoMessage()    {}
func (*DataDistributionResponse_ZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{45, 0}
}
func (m *DataDistributionResponse_ZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDistributionResponse_ZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataDistributionResponse_ZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDistributionResponse_ZoneConfig.Merge(m, src)
}
func (m *DataDistributionResponse_ZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *DataDistributionResponse_ZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDistributionResponse_ZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DataDistributionResponse_ZoneConfig proto.InternalMessageInfo

type DataDistributionResponse_TableInfo struct {
	ReplicaCountByNodeId map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64 `protobuf:"bytes,1,rep,name=replica_count_by_node_id,json=replicaCountByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"replica_count_by_node_id,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DroppedAt            *time.Time                                                    `protobuf:"bytes,3,opt,name=dropped_at,json=droppedAt,proto3,stdtime" json:"dropped_at,omitempty"`
}

func (m *DataDistributionResponse_TableInfo) Reset()         { *m = DataDistributionResponse_TableInfo{} }
func (m *DataDistributionResponse_TableInfo) String() string { return proto.CompactTextString(m) }
func (*DataDistributionResponse_TableInfo) ProtoMessage()    {}
func (*DataDistributionResponse_TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{45, 1}
}
func (m *DataDistributionResponse_TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDistributionResponse_TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataDistributionResponse_TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDistributionResponse_TableInfo.Merge(m, src)
}
func (m *DataDistributionResponse_TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *DataDistributionResponse_TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDistributionResponse_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DataDistributionResponse_TableInfo proto.InternalMessageInfo

type DataDistributionResponse_DatabaseInfo struct {
	// By table name.
	TableInfo map[string]DataDistributionResponse_TableInfo `protobuf:"bytes,1,rep,name=table_info,json=tableInfo,proto3" json:"table_info" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DataDistributionResponse_DatabaseInfo) Reset()         { *m = DataDistributionResponse_DatabaseInfo{} }
func (m *DataDistributionResponse_DatabaseInfo) String() string { return proto.CompactTextString(m) }
func (*DataDistributionResponse_DatabaseInfo) ProtoMessage()    {}
func (*DataDistributionResponse_DatabaseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{45, 2}
}
func (m *DataDistributionResponse_DatabaseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDistributionResponse_DatabaseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataDistributionResponse_DatabaseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDistributionResponse_DatabaseInfo.Merge(m, src)
}
func (m *DataDistributionResponse_DatabaseInfo) XXX_Size() int {
	return m.Size()
}
func (m *DataDistributionResponse_DatabaseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDistributionResponse_DatabaseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DataDistributionResponse_DatabaseInfo proto.InternalMessageInfo

// MetricMetadataRequest requests metadata for all metrics.
type MetricMetadataRequest struct {
}

func (m *MetricMetadataRequest) Reset()         { *m = MetricMetadataRequest{} }
func (m *MetricMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*MetricMetadataRequest) ProtoMessage()    {}
func (*MetricMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{46}
}
func (m *MetricMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricMetadataRequest.Merge(m, src)
}
func (m *MetricMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *MetricMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetricMetadataRequest proto.InternalMessageInfo

// MetricMetadataResponse contains the metadata for all metrics.
type MetricMetadataResponse struct {
	Metadata map[string]metric.Metadata `protobuf:"bytes,1,rep,name=metadata,proto3" json:"metadata" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Maps of metric metadata names to the tsdb recorded metric names
	RecordedNames map[string]string `protobuf:"bytes,2,rep,name=recordedNames,proto3" json:"recordedNames" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MetricMetadataResponse) Reset()         { *m = MetricMetadataResponse{} }
func (m *MetricMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MetricMetadataResponse) ProtoMessage()    {}
func (*MetricMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{47}
}
func (m *MetricMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricMetadataResponse.Merge(m, src)
}
func (m *MetricMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MetricMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MetricMetadataResponse proto.InternalMessageInfo

type EnqueueRangeRequest struct {
	// The node on which the queue should process the range. If node_id is 0,
	// the request will be forwarded to all other nodes.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// The name of the replica queue to run the range through. Matched against
	// each queue's name field. See the implementation of baseQueue for details.
	Queue string `protobuf:"bytes,2,opt,name=queue,proto3" json:"queue,omitempty"`
	// The ID of the range to run through the queue.
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,3,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// If set, run the queue's process method without first checking whether the
	// replica should be processed by calling shouldQueue.
	SkipShouldQueue bool `protobuf:"varint,4,opt,name=skip_should_queue,json=skipShouldQueue,proto3" json:"skip_should_queue,omitempty"`
}

func (m *EnqueueRangeRequest) Reset()         { *m = EnqueueRangeRequest{} }
func (m *EnqueueRangeRequest) String() string { return proto.CompactTextString(m) }
func (*EnqueueRangeRequest) ProtoMessage()    {}
func (*EnqueueRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{48}
}
func (m *EnqueueRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnqueueRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnqueueRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnqueueRangeRequest.Merge(m, src)
}
func (m *EnqueueRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *EnqueueRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnqueueRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnqueueRangeRequest proto.InternalMessageInfo

type EnqueueRangeResponse struct {
	Details []*EnqueueRangeResponse_Details `protobuf:"bytes,1,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *EnqueueRangeResponse) Reset()         { *m = EnqueueRangeResponse{} }
func (m *EnqueueRangeResponse) String() string { return proto.CompactTextString(m) }
func (*EnqueueRangeResponse) ProtoMessage()    {}
func (*EnqueueRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{49}
}
func (m *EnqueueRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnqueueRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnqueueRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnqueueRangeResponse.Merge(m, src)
}
func (m *EnqueueRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *EnqueueRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EnqueueRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EnqueueRangeResponse proto.InternalMessageInfo

type EnqueueRangeResponse_Details struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// All trace events collected while processing the range in the queue.
	Events []*TraceEvent `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
	// The error message from the queue's processing, if any.
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *EnqueueRangeResponse_Details) Reset()         { *m = EnqueueRangeResponse_Details{} }
func (m *EnqueueRangeResponse_Details) String() string { return proto.CompactTextString(m) }
func (*EnqueueRangeResponse_Details) ProtoMessage()    {}
func (*EnqueueRangeResponse_Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{49, 0}
}
func (m *EnqueueRangeResponse_Details) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnqueueRangeResponse_Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnqueueRangeResponse_Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnqueueRangeResponse_Details.Merge(m, src)
}
func (m *EnqueueRangeResponse_Details) XXX_Size() int {
	return m.Size()
}
func (m *EnqueueRangeResponse_Details) XXX_DiscardUnknown() {
	xxx_messageInfo_EnqueueRangeResponse_Details.DiscardUnknown(m)
}

var xxx_messageInfo_EnqueueRangeResponse_Details proto.InternalMessageInfo

// ChartCatalogRequest requests returns a catalog of Admin UI charts.
type ChartCatalogRequest struct {
}

func (m *ChartCatalogRequest) Reset()         { *m = ChartCatalogRequest{} }
func (m *ChartCatalogRequest) String() string { return proto.CompactTextString(m) }
func (*ChartCatalogRequest) ProtoMessage()    {}
func (*ChartCatalogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{50}
}
func (m *ChartCatalogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartCatalogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChartCatalogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartCatalogRequest.Merge(m, src)
}
func (m *ChartCatalogRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChartCatalogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartCatalogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChartCatalogRequest proto.InternalMessageInfo

// ChartCatalogResponse returns a catalog of Admin UI charts useful for debugging.
type ChartCatalogResponse struct {
	Catalog []catalog.ChartSection `protobuf:"bytes,1,rep,name=catalog,proto3" json:"catalog"`
}

func (m *ChartCatalogResponse) Reset()         { *m = ChartCatalogResponse{} }
func (m *ChartCatalogResponse) String() string { return proto.CompactTextString(m) }
func (*ChartCatalogResponse) ProtoMessage()    {}
func (*ChartCatalogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{51}
}
func (m *ChartCatalogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartCatalogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChartCatalogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartCatalogResponse.Merge(m, src)
}
func (m *ChartCatalogResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChartCatalogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartCatalogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChartCatalogResponse proto.InternalMessageInfo

type RecoveryCollectReplicaInfoRequest struct {
	// MaxConcurrency is the maximum parallelism that will be used when fanning
	// out RPCs to nodes in the cluster while servicing this request. A value of 0
	// disables concurrency. A negative value configures no limit for concurrency.
	MaxConcurrency int32 `protobuf:"varint,1,opt,name=max_concurrency,json=maxConcurrency,proto3" json:"max_concurrency,omitempty"`
}

func (m *RecoveryCollectReplicaInfoRequest) Reset()         { *m = RecoveryCollectReplicaInfoRequest{} }
func (m *RecoveryCollectReplicaInfoRequest) String() string { return proto.CompactTextString(m) }
func (*RecoveryCollectReplicaInfoRequest) ProtoMessage()    {}
func (*RecoveryCollectReplicaInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{52}
}
func (m *RecoveryCollectReplicaInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCollectReplicaInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryCollectReplicaInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCollectReplicaInfoRequest.Merge(m, src)
}
func (m *RecoveryCollectReplicaInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCollectReplicaInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCollectReplicaInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCollectReplicaInfoRequest proto.InternalMessageInfo

// RecoveryCollectReplicaRestartNodeStream is sent by collector node to client
// if it experiences a transient failure collecting data from one of the nodes.
// This message instructs client to drop any data that it collected locally
// for specified node as streaming for this node would be restarted.
// This mechanism is needed to avoid restarting the whole collection procedure
// in large cluster if one of the nodes fails transiently.
type RecoveryCollectReplicaRestartNodeStream struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
}

func (m *RecoveryCollectReplicaRestartNodeStream) Reset() {
	*m = RecoveryCollectReplicaRestartNodeStream{}
}
func (m *RecoveryCollectReplicaRestartNodeStream) String() string { return proto.CompactTextString(m) }
func (*RecoveryCollectReplicaRestartNodeStream) ProtoMessage()    {}
func (*RecoveryCollectReplicaRestartNodeStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{53}
}
func (m *RecoveryCollectReplicaRestartNodeStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCollectReplicaRestartNodeStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryCollectReplicaRestartNodeStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCollectReplicaRestartNodeStream.Merge(m, src)
}
func (m *RecoveryCollectReplicaRestartNodeStream) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCollectReplicaRestartNodeStream) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCollectReplicaRestartNodeStream.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCollectReplicaRestartNodeStream proto.InternalMessageInfo

type RecoveryCollectReplicaInfoResponse struct {
	// Types that are valid to be assigned to Info:
	//	*RecoveryCollectReplicaInfoResponse_RangeDescriptor
	//	*RecoveryCollectReplicaInfoResponse_ReplicaInfo
	//	*RecoveryCollectReplicaInfoResponse_NodeStreamRestarted
	//	*RecoveryCollectReplicaInfoResponse_Metadata
	Info isRecoveryCollectReplicaInfoResponse_Info `protobuf_oneof:"info"`
}

func (m *RecoveryCollectReplicaInfoResponse) Reset()         { *m = RecoveryCollectReplicaInfoResponse{} }
func (m *RecoveryCollectReplicaInfoResponse) String() string { return proto.CompactTextString(m) }
func (*RecoveryCollectReplicaInfoResponse) ProtoMessage()    {}
func (*RecoveryCollectReplicaInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{54}
}
func (m *RecoveryCollectReplicaInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCollectReplicaInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryCollectReplicaInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCollectReplicaInfoResponse.Merge(m, src)
}
func (m *RecoveryCollectReplicaInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCollectReplicaInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCollectReplicaInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCollectReplicaInfoResponse proto.InternalMessageInfo

type isRecoveryCollectReplicaInfoResponse_Info interface {
	isRecoveryCollectReplicaInfoResponse_Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RecoveryCollectReplicaInfoResponse_RangeDescriptor struct {
	RangeDescriptor *roachpb.RangeDescriptor `protobuf:"bytes,1,opt,name=range_descriptor,json=rangeDescriptor,proto3,oneof" json:"range_descriptor,omitempty"`
}
type RecoveryCollectReplicaInfoResponse_ReplicaInfo struct {
	ReplicaInfo *loqrecoverypb.ReplicaInfo `protobuf:"bytes,2,opt,name=replica_info,json=replicaInfo,proto3,oneof" json:"replica_info,omitempty"`
}
type RecoveryCollectReplicaInfoResponse_NodeStreamRestarted struct {
	NodeStreamRestarted *RecoveryCollectReplicaRestartNodeStream `protobuf:"bytes,3,opt,name=node_stream_restarted,json=nodeStreamRestarted,proto3,oneof" json:"node_stream_restarted,omitempty"`
}
type RecoveryCollectReplicaInfoResponse_Metadata struct {
	Metadata *loqrecoverypb.ClusterMetadata `protobuf:"bytes,4,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}

func (*RecoveryCollectReplicaInfoResponse_RangeDescriptor) isRecoveryCollectReplicaInfoResponse_Info() {
}
func (*RecoveryCollectReplicaInfoResponse_ReplicaInfo) isRecoveryCollectReplicaInfoResponse_Info() {}
func (*RecoveryCollectReplicaInfoResponse_NodeStreamRestarted) isRecoveryCollectReplicaInfoResponse_Info() {
}
func (*RecoveryCollectReplicaInfoResponse_Metadata) isRecoveryCollectReplicaInfoResponse_Info() {}

func (m *RecoveryCollectReplicaInfoResponse) GetInfo() isRecoveryCollectReplicaInfoResponse_Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *RecoveryCollectReplicaInfoResponse) GetRangeDescriptor() *roachpb.RangeDescriptor {
	if x, ok := m.GetInfo().(*RecoveryCollectReplicaInfoResponse_RangeDescriptor); ok {
		return x.RangeDescriptor
	}
	return nil
}

func (m *RecoveryCollectReplicaInfoResponse) GetReplicaInfo() *loqrecoverypb.ReplicaInfo {
	if x, ok := m.GetInfo().(*RecoveryCollectReplicaInfoResponse_ReplicaInfo); ok {
		return x.ReplicaInfo
	}
	return nil
}

func (m *RecoveryCollectReplicaInfoResponse) GetNodeStreamRestarted() *RecoveryCollectReplicaRestartNodeStream {
	if x, ok := m.GetInfo().(*RecoveryCollectReplicaInfoResponse_NodeStreamRestarted); ok {
		return x.NodeStreamRestarted
	}
	return nil
}

func (m *RecoveryCollectReplicaInfoResponse) GetMetadata() *loqrecoverypb.ClusterMetadata {
	if x, ok := m.GetInfo().(*RecoveryCollectReplicaInfoResponse_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RecoveryCollectReplicaInfoResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RecoveryCollectReplicaInfoResponse_RangeDescriptor)(nil),
		(*RecoveryCollectReplicaInfoResponse_ReplicaInfo)(nil),
		(*RecoveryCollectReplicaInfoResponse_NodeStreamRestarted)(nil),
		(*RecoveryCollectReplicaInfoResponse_Metadata)(nil),
	}
}

type RecoveryCollectLocalReplicaInfoRequest struct {
}

func (m *RecoveryCollectLocalReplicaInfoRequest) Reset() {
	*m = RecoveryCollectLocalReplicaInfoRequest{}
}
func (m *RecoveryCollectLocalReplicaInfoRequest) String() string { return proto.CompactTextString(m) }
func (*RecoveryCollectLocalReplicaInfoRequest) ProtoMessage()    {}
func (*RecoveryCollectLocalReplicaInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{55}
}
func (m *RecoveryCollectLocalReplicaInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCollectLocalReplicaInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryCollectLocalReplicaInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCollectLocalReplicaInfoRequest.Merge(m, src)
}
func (m *RecoveryCollectLocalReplicaInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCollectLocalReplicaInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCollectLocalReplicaInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCollectLocalReplicaInfoRequest proto.InternalMessageInfo

type RecoveryCollectLocalReplicaInfoResponse struct {
	ReplicaInfo *loqrecoverypb.ReplicaInfo `protobuf:"bytes,1,opt,name=replica_info,json=replicaInfo,proto3" json:"replica_info,omitempty"`
}

func (m *RecoveryCollectLocalReplicaInfoResponse) Reset() {
	*m = RecoveryCollectLocalReplicaInfoResponse{}
}
func (m *RecoveryCollectLocalReplicaInfoResponse) String() string { return proto.CompactTextString(m) }
func (*RecoveryCollectLocalReplicaInfoResponse) ProtoMessage()    {}
func (*RecoveryCollectLocalReplicaInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{56}
}
func (m *RecoveryCollectLocalReplicaInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCollectLocalReplicaInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryCollectLocalReplicaInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCollectLocalReplicaInfoResponse.Merge(m, src)
}
func (m *RecoveryCollectLocalReplicaInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCollectLocalReplicaInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCollectLocalReplicaInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCollectLocalReplicaInfoResponse proto.InternalMessageInfo

type RecoveryStagePlanRequest struct {
	// Plan is replica update plan to stage for application on next restart. Plan
	// could be empty in that case existing plan is removed if present.
	Plan *loqrecoverypb.ReplicaUpdatePlan `protobuf:"bytes,1,opt,name=plan,proto3" json:"plan,omitempty"`
	// If all nodes is true, then receiver should act as a coordinator and perform
	// a fan-out to stage plan on all nodes of the cluster.
	AllNodes bool `protobuf:"varint,2,opt,name=all_nodes,json=allNodes,proto3" json:"all_nodes,omitempty"`
	// ForcePlan tells receiver to ignore any plan already staged on the node if it
	// is present and replace it with new plan (including empty one).
	ForcePlan bool `protobuf:"varint,3,opt,name=force_plan,json=forcePlan,proto3" json:"force_plan,omitempty"`
	// ForceLocalInternalVersion tells server to update internal component of plan
	// version to the one of active cluster version. This option needs to be set
	// if target cluster is stuck in recovery where only part of nodes were
	// successfully migrated.
	ForceLocalInternalVersion bool `protobuf:"varint,4,opt,name=force_local_internal_version,json=forceLocalInternalVersion,proto3" json:"force_local_internal_version,omitempty"`
	// MaxConcurrency is the maximum parallelism that will be used when fanning
	// out RPCs to nodes in the cluster while servicing this request. A value of 0
	// disables concurrency. A negative value configures no limit for concurrency.
	MaxConcurrency int32 `protobuf:"varint,5,opt,name=max_concurrency,json=maxConcurrency,proto3" json:"max_concurrency,omitempty"`
}

func (m *RecoveryStagePlanRequest) Reset()         { *m = RecoveryStagePlanRequest{} }
func (m *RecoveryStagePlanRequest) String() string { return proto.CompactTextString(m) }
func (*RecoveryStagePlanRequest) ProtoMessage()    {}
func (*RecoveryStagePlanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{57}
}
func (m *RecoveryStagePlanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryStagePlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryStagePlanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryStagePlanRequest.Merge(m, src)
}
func (m *RecoveryStagePlanRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryStagePlanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryStagePlanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryStagePlanRequest proto.InternalMessageInfo

type RecoveryStagePlanResponse struct {
	// Errors contain error messages happened during plan staging.
	Errors []string `protobuf:"bytes,1,rep,name=errors,proto3" json:"errors,omitempty"`
}

func (m *RecoveryStagePlanResponse) Reset()         { *m = RecoveryStagePlanResponse{} }
func (m *RecoveryStagePlanResponse) String() string { return proto.CompactTextString(m) }
func (*RecoveryStagePlanResponse) ProtoMessage()    {}
func (*RecoveryStagePlanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{58}
}
func (m *RecoveryStagePlanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryStagePlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryStagePlanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryStagePlanResponse.Merge(m, src)
}
func (m *RecoveryStagePlanResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryStagePlanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryStagePlanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryStagePlanResponse proto.InternalMessageInfo

type RecoveryNodeStatusRequest struct {
}

func (m *RecoveryNodeStatusRequest) Reset()         { *m = RecoveryNodeStatusRequest{} }
func (m *RecoveryNodeStatusRequest) String() string { return proto.CompactTextString(m) }
func (*RecoveryNodeStatusRequest) ProtoMessage()    {}
func (*RecoveryNodeStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{59}
}
func (m *RecoveryNodeStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryNodeStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryNodeStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryNodeStatusRequest.Merge(m, src)
}
func (m *RecoveryNodeStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryNodeStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryNodeStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryNodeStatusRequest proto.InternalMessageInfo

type RecoveryNodeStatusResponse struct {
	Status loqrecoverypb.NodeRecoveryStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
}

func (m *RecoveryNodeStatusResponse) Reset()         { *m = RecoveryNodeStatusResponse{} }
func (m *RecoveryNodeStatusResponse) String() string { return proto.CompactTextString(m) }
func (*RecoveryNodeStatusResponse) ProtoMessage()    {}
func (*RecoveryNodeStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{60}
}
func (m *RecoveryNodeStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryNodeStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryNodeStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryNodeStatusResponse.Merge(m, src)
}
func (m *RecoveryNodeStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryNodeStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryNodeStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryNodeStatusResponse proto.InternalMessageInfo

type RecoveryVerifyRequest struct {
	// PlanID is ID of the plan to verify.
	PendingPlanID *github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"plan_id,omitempty"`
	// DecommissionedNodeIDs is a set of nodes that should be marked as decommissioned in
	// the cluster when loss of quorum recovery successfully applies.
	DecommissionedNodeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,rep,packed,name=decommissioned_node_ids,json=decommissionedNodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"decommissioned_node_ids,omitempty"`
	// MaxReportedRanges is the maximum number of failed ranges to report.
	// If more unhealthy ranges are found, error will be returned alongside range
	// to indicate that ranges were cut short.
	MaxReportedRanges int32 `protobuf:"varint,3,opt,name=max_reported_ranges,json=maxReportedRanges,proto3" json:"max_reported_ranges,omitempty"`
	// MaxConcurrency is the maximum parallelism that will be used when fanning
	// out RPCs to nodes in the cluster while servicing this request. A value of 0
	// disables concurrency. A negative value configures no limit for concurrency.
	MaxConcurrency int32 `protobuf:"varint,4,opt,name=max_concurrency,json=maxConcurrency,proto3" json:"max_concurrency,omitempty"`
}

func (m *RecoveryVerifyRequest) Reset()         { *m = RecoveryVerifyRequest{} }
func (m *RecoveryVerifyRequest) String() string { return proto.CompactTextString(m) }
func (*RecoveryVerifyRequest) ProtoMessage()    {}
func (*RecoveryVerifyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{61}
}
func (m *RecoveryVerifyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryVerifyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryVerifyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryVerifyRequest.Merge(m, src)
}
func (m *RecoveryVerifyRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryVerifyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryVerifyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryVerifyRequest proto.InternalMessageInfo

type RecoveryVerifyResponse struct {
	// Statuses contain a list of recovery statuses of nodes updated during recovery. It
	// also contains nodes that were expected to be live (not decommissioned by recovery)
	// but failed to return status response.
	Statuses []loqrecoverypb.NodeRecoveryStatus `protobuf:"bytes,1,rep,name=statuses,proto3" json:"statuses"`
	// UnavailableRanges contains information about ranges that failed health check.
	UnavailableRanges RecoveryVerifyResponse_UnavailableRanges `protobuf:"bytes,2,opt,name=unavailable_ranges,json=unavailableRanges,proto3" json:"unavailable_ranges"`
	// DecommissionedNodeStatuses contains a map of requested IDs with their
	// corresponding liveness statuses.
	DecommissionedNodeStatuses map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.MembershipStatus `protobuf:"bytes,3,rep,name=decommissioned_node_statuses,json=decommissionedNodeStatuses,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"decommissioned_node_statuses,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=cockroach.kv.kvserver.liveness.livenesspb.MembershipStatus"`
}

func (m *RecoveryVerifyResponse) Reset()         { *m = RecoveryVerifyResponse{} }
func (m *RecoveryVerifyResponse) String() string { return proto.CompactTextString(m) }
func (*RecoveryVerifyResponse) ProtoMessage()    {}
func (*RecoveryVerifyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{62}
}
func (m *RecoveryVerifyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryVerifyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryVerifyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryVerifyResponse.Merge(m, src)
}
func (m *RecoveryVerifyResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryVerifyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryVerifyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryVerifyResponse proto.InternalMessageInfo

type RecoveryVerifyResponse_UnavailableRanges struct {
	// Ranges contains descriptors of ranges that failed health check.
	// If there are too many ranges to report, error would contain relevant
	// message.
	Ranges []loqrecoverypb.RangeRecoveryStatus `protobuf:"bytes,1,rep,name=ranges,proto3" json:"ranges"`
	// Error contains an optional error if ranges validation can't complete.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RecoveryVerifyResponse_UnavailableRanges) Reset() {
	*m = RecoveryVerifyResponse_UnavailableRanges{}
}
func (m *RecoveryVerifyResponse_UnavailableRanges) String() string { return proto.CompactTextString(m) }
func (*RecoveryVerifyResponse_UnavailableRanges) ProtoMessage()    {}
func (*RecoveryVerifyResponse_UnavailableRanges) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{62, 0}
}
func (m *RecoveryVerifyResponse_UnavailableRanges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryVerifyResponse_UnavailableRanges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryVerifyResponse_UnavailableRanges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryVerifyResponse_UnavailableRanges.Merge(m, src)
}
func (m *RecoveryVerifyResponse_UnavailableRanges) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryVerifyResponse_UnavailableRanges) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryVerifyResponse_UnavailableRanges.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryVerifyResponse_UnavailableRanges proto.InternalMessageInfo

type ListTenantsRequest struct {
}

func (m *ListTenantsRequest) Reset()         { *m = ListTenantsRequest{} }
func (m *ListTenantsRequest) String() string { return proto.CompactTextString(m) }
func (*ListTenantsRequest) ProtoMessage()    {}
func (*ListTenantsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{63}
}
func (m *ListTenantsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTenantsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListTenantsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTenantsRequest.Merge(m, src)
}
func (m *ListTenantsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListTenantsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTenantsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTenantsRequest proto.InternalMessageInfo

type ListTenantsResponse struct {
	Tenants []*Tenant `protobuf:"bytes,1,rep,name=tenants,proto3" json:"tenants,omitempty"`
}

func (m *ListTenantsResponse) Reset()         { *m = ListTenantsResponse{} }
func (m *ListTenantsResponse) String() string { return proto.CompactTextString(m) }
func (*ListTenantsResponse) ProtoMessage()    {}
func (*ListTenantsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{64}
}
func (m *ListTenantsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTenantsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListTenantsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTenantsResponse.Merge(m, src)
}
func (m *ListTenantsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListTenantsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTenantsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTenantsResponse proto.InternalMessageInfo

type Tenant struct {
	TenantId   *roachpb.TenantID `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	TenantName string            `protobuf:"bytes,2,opt,name=tenant_name,json=tenantName,proto3" json:"tenant_name,omitempty"`
	SqlAddr    string            `protobuf:"bytes,3,opt,name=sql_addr,json=sqlAddr,proto3" json:"sql_addr,omitempty"`
	RpcAddr    string            `protobuf:"bytes,4,opt,name=rpc_addr,json=rpcAddr,proto3" json:"rpc_addr,omitempty"`
}

func (m *Tenant) Reset()         { *m = Tenant{} }
func (m *Tenant) String() string { return proto.CompactTextString(m) }
func (*Tenant) ProtoMessage()    {}
func (*Tenant) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{65}
}
func (m *Tenant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tenant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Tenant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tenant.Merge(m, src)
}
func (m *Tenant) XXX_Size() int {
	return m.Size()
}
func (m *Tenant) XXX_DiscardUnknown() {
	xxx_messageInfo_Tenant.DiscardUnknown(m)
}

var xxx_messageInfo_Tenant proto.InternalMessageInfo

// ReadFromTenantInfoRequest requests info, if any, on which tenant the caller
// should read from.
type ReadFromTenantInfoRequest struct {
	// TenantID should always be the ID of the tenant making the request. This
	// duplicates the ID in the auth context that is added implicitly, and must
	// always match that ID when that ID is present, however that ID is absent in
	// insecure test clusters which is why we also specify it explicitly here.
	TenantID roachpb.TenantID `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id"`
}

func (m *ReadFromTenantInfoRequest) Reset()         { *m = ReadFromTenantInfoRequest{} }
func (m *ReadFromTenantInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ReadFromTenantInfoRequest) ProtoMessage()    {}
func (*ReadFromTenantInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{66}
}
func (m *ReadFromTenantInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadFromTenantInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadFromTenantInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadFromTenantInfoRequest.Merge(m, src)
}
func (m *ReadFromTenantInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadFromTenantInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadFromTenantInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadFromTenantInfoRequest proto.InternalMessageInfo

// ReadFromTenantInfoResponse instructs a tenant as to which tenant, if any, it
// should configure itself to read from and the timestamp at which it should do
// so.
type ReadFromTenantInfoResponse struct {
	ReadFrom roachpb.TenantID `protobuf:"bytes,1,opt,name=read_from,json=readFrom,proto3" json:"read_from"`
	ReadAt   hlc.Timestamp    `protobuf:"bytes,2,opt,name=read_at,json=readAt,proto3" json:"read_at"`
}

func (m *ReadFromTenantInfoResponse) Reset()         { *m = ReadFromTenantInfoResponse{} }
func (m *ReadFromTenantInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ReadFromTenantInfoResponse) ProtoMessage()    {}
func (*ReadFromTenantInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{67}
}
func (m *ReadFromTenantInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadFromTenantInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadFromTenantInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadFromTenantInfoResponse.Merge(m, src)
}
func (m *ReadFromTenantInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadFromTenantInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadFromTenantInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadFromTenantInfoResponse proto.InternalMessageInfo

type ListTracingSnapshotsRequest struct {
}

func (m *ListTracingSnapshotsRequest) Reset()         { *m = ListTracingSnapshotsRequest{} }
func (m *ListTracingSnapshotsRequest) String() string { return proto.CompactTextString(m) }
func (*ListTracingSnapshotsRequest) ProtoMessage()    {}
func (*ListTracingSnapshotsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{68}
}
func (m *ListTracingSnapshotsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTracingSnapshotsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListTracingSnapshotsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTracingSnapshotsRequest.Merge(m, src)
}
func (m *ListTracingSnapshotsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListTracingSnapshotsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTracingSnapshotsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTracingSnapshotsRequest proto.InternalMessageInfo

type ListTracingSnapshotsResponse struct {
	Snapshots []*SnapshotInfo `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
}

func (m *ListTracingSnapshotsResponse) Reset()         { *m = ListTracingSnapshotsResponse{} }
func (m *ListTracingSnapshotsResponse) String() string { return proto.CompactTextString(m) }
func (*ListTracingSnapshotsResponse) ProtoMessage()    {}
func (*ListTracingSnapshotsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{69}
}
func (m *ListTracingSnapshotsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTracingSnapshotsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListTracingSnapshotsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTracingSnapshotsResponse.Merge(m, src)
}
func (m *ListTracingSnapshotsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListTracingSnapshotsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTracingSnapshotsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTracingSnapshotsResponse proto.InternalMessageInfo

type SnapshotInfo struct {
	// SnapshotID identifies a specific snapshot which can be requested via a
	// GetTracingSnapshotRequest. Negative IDs are used for "automatic" snapshots.
	SnapshotID int64      `protobuf:"varint,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	CapturedAt *time.Time `protobuf:"bytes,2,opt,name=captured_at,json=capturedAt,proto3,stdtime" json:"captured_at,omitempty"`
}

func (m *SnapshotInfo) Reset()         { *m = SnapshotInfo{} }
func (m *SnapshotInfo) String() string { return proto.CompactTextString(m) }
func (*SnapshotInfo) ProtoMessage()    {}
func (*SnapshotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{70}
}
func (m *SnapshotInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotInfo.Merge(m, src)
}
func (m *SnapshotInfo) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotInfo proto.InternalMessageInfo

type TakeTracingSnapshotRequest struct {
}

func (m *TakeTracingSnapshotRequest) Reset()         { *m = TakeTracingSnapshotRequest{} }
func (m *TakeTracingSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*TakeTracingSnapshotRequest) ProtoMessage()    {}
func (*TakeTracingSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{71}
}
func (m *TakeTracingSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TakeTracingSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TakeTracingSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TakeTracingSnapshotRequest.Merge(m, src)
}
func (m *TakeTracingSnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *TakeTracingSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TakeTracingSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TakeTracingSnapshotRequest proto.InternalMessageInfo

type TakeTracingSnapshotResponse struct {
	Snapshot *SnapshotInfo `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *TakeTracingSnapshotResponse) Reset()         { *m = TakeTracingSnapshotResponse{} }
func (m *TakeTracingSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*TakeTracingSnapshotResponse) ProtoMessage()    {}
func (*TakeTracingSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{72}
}
func (m *TakeTracingSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TakeTracingSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TakeTracingSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TakeTracingSnapshotResponse.Merge(m, src)
}
func (m *TakeTracingSnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *TakeTracingSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TakeTracingSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TakeTracingSnapshotResponse proto.InternalMessageInfo

type GetTracingSnapshotRequest struct {
	// SnapshotId indicates which snapshot is requested. ID may be negative when
	// requesting an "automatic" snapshot; see ListTracingSnapshotsResponse.
	SnapshotId int64 `protobuf:"varint,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
}

func (m *GetTracingSnapshotRequest) Reset()         { *m = GetTracingSnapshotRequest{} }
func (m *GetTracingSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*GetTracingSnapshotRequest) ProtoMessage()    {}
func (*GetTracingSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{73}
}
func (m *GetTracingSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTracingSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetTracingSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTracingSnapshotRequest.Merge(m, src)
}
func (m *GetTracingSnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTracingSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTracingSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTracingSnapshotRequest proto.InternalMessageInfo

type GetTracingSnapshotResponse struct {
	Snapshot *TracingSnapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *GetTracingSnapshotResponse) Reset()         { *m = GetTracingSnapshotResponse{} }
func (m *GetTracingSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*GetTracingSnapshotResponse) ProtoMessage()    {}
func (*GetTracingSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{74}
}
func (m *GetTracingSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTracingSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetTracingSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTracingSnapshotResponse.Merge(m, src)
}
func (m *GetTracingSnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTracingSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTracingSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTracingSnapshotResponse proto.InternalMessageInfo

// GetTrace represents the request of the GetTrace RPC.
type GetTraceRequest struct {
	// If a snapshot is specified, the trace information is returned from that
	// snapshot. If a snapshot is not specified, information about currently
	// opened spans is returned from the active spans registry.
	SnapshotID    int64                                                               `protobuf:"varint,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	TraceID       github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.TraceID `protobuf:"varint,2,opt,name=trace_id,json=traceId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb.TraceID" json:"trace_id"`
	RecordingType tracingpb.RecordingMode                                             `protobuf:"varint,3,opt,name=recording_type,json=recordingType,proto3,enum=cockroach.util.tracing.tracingpb.RecordingMode" json:"recording_type,omitempty"`
}

func (m *GetTraceRequest) Reset()         { *m = GetTraceRequest{} }
func (m *GetTraceRequest) String() string { return proto.CompactTextString(m) }
func (*GetTraceRequest) ProtoMessage()    {}
func (*GetTraceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{75}
}
func (m *GetTraceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTraceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetTraceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTraceRequest.Merge(m, src)
}
func (m *GetTraceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTraceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTraceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTraceRequest proto.InternalMessageInfo

// GetTrace represents the response to the GetTrace RPC.
type GetTraceResponse struct {
	// snapshot_id identifies the snapshot that the trace was retrieved from. If
	// 0, the trace was not retrieved from a registry, but directly from the
	// active spans registry.
	SnapshotID int64                                                               `protobuf:"varint,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	TraceID    github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.TraceID `protobuf:"varint,2,opt,name=trace_id,json=traceId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb.TraceID" json:"trace_id"`
	// still_exists is set if any spans from this trace are currently present in
	// the active spans registry.
	//
	// If snapshot_id is 0, still_exists is always set.
	StillExists bool `protobuf:"varint,3,opt,name=still_exists,json=stillExists,proto3" json:"still_exists,omitempty"`
	// serialized_recording represents the serialization of trace recording. We
	// return the recording already serialized as formatted string for easy
	// consumption in the browser.
	SerializedRecording string `protobuf:"bytes,4,opt,name=serialized_recording,json=serializedRecording,proto3" json:"serialized_recording,omitempty"`
}

func (m *GetTraceResponse) Reset()         { *m = GetTraceResponse{} }
func (m *GetTraceResponse) String() string { return proto.CompactTextString(m) }
func (*GetTraceResponse) ProtoMessage()    {}
func (*GetTraceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{76}
}
func (m *GetTraceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTraceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetTraceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTraceResponse.Merge(m, src)
}
func (m *GetTraceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTraceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTraceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTraceResponse proto.InternalMessageInfo

// TracingSnapshot represents a snapshot of the active spans registry, including
// all the spans that were open at the time when the snapshot was taken.
type TracingSnapshot struct {
	SnapshotID int64          `protobuf:"varint,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	CapturedAt *time.Time     `protobuf:"bytes,2,opt,name=captured_at,json=capturedAt,proto3,stdtime" json:"captured_at,omitempty"`
	Spans      []*TracingSpan `protobuf:"bytes,3,rep,name=spans,proto3" json:"spans,omitempty"`
	// Ideally we'd use int64 to match the goroutine_id type
	// but unfortunately, the way that grpc-gateway parses
	// these objects into Javascript results in odd encodings
	// of Long JS types that are difficult to interact with
	// as map keys. Thus, we settle for string.
	Stacks map[string]string `protobuf:"bytes,4,rep,name=stacks,proto3" json:"stacks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TracingSnapshot) Reset()         { *m = TracingSnapshot{} }
func (m *TracingSnapshot) String() string { return proto.CompactTextString(m) }
func (*TracingSnapshot) ProtoMessage()    {}
func (*TracingSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{77}
}
func (m *TracingSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TracingSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingSnapshot.Merge(m, src)
}
func (m *TracingSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *TracingSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_TracingSnapshot proto.InternalMessageInfo

type NamedOperationMetadata struct {
	Name     string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Metadata tracingpb.OperationMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata"`
}

func (m *NamedOperationMetadata) Reset()         { *m = NamedOperationMetadata{} }
func (m *NamedOperationMetadata) String() string { return proto.CompactTextString(m) }
func (*NamedOperationMetadata) ProtoMessage()    {}
func (*NamedOperationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{78}
}
func (m *NamedOperationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedOperationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NamedOperationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedOperationMetadata.Merge(m, src)
}
func (m *NamedOperationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *NamedOperationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedOperationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_NamedOperationMetadata proto.InternalMessageInfo

// TracingSpan represents a span, in a form slightly processed for the use of
// the tracing UI.
type TracingSpan struct {
	Operation     string     `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	TraceID       uint64     `protobuf:"varint,2,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	SpanID        uint64     `protobuf:"varint,3,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	ParentSpanID  uint64     `protobuf:"varint,4,opt,name=parent_span_id,json=parentSpanId,proto3" json:"parent_span_id,omitempty"`
	Start         time.Time  `protobuf:"bytes,5,opt,name=start,proto3,stdtime" json:"start"`
	GoroutineID   uint64     `protobuf:"varint,6,opt,name=goroutine_id,json=goroutineId,proto3" json:"goroutine_id,omitempty"`
	ProcessedTags []*SpanTag `protobuf:"bytes,7,rep,name=processed_tags,json=processedTags,proto3" json:"processed_tags,omitempty"`
	// current is set if the span is still alive (i.e. still present in the active
	// spans registry).
	Current bool `protobuf:"varint,8,opt,name=current,proto3" json:"current,omitempty"`
	// current_recording_mode represents the span's current recording mode. This is
	// not set if current == false.
	CurrentRecordingMode tracingpb.RecordingMode   `protobuf:"varint,9,opt,name=current_recording_mode,json=currentRecordingMode,proto3,enum=cockroach.util.tracing.tracingpb.RecordingMode" json:"current_recording_mode,omitempty"`
	ChildrenMetadata     []*NamedOperationMetadata `protobuf:"bytes,10,rep,name=children_metadata,json=childrenMetadata,proto3" json:"children_metadata,omitempty"`
}

func (m *TracingSpan) Reset()         { *m = TracingSpan{} }
func (m *TracingSpan) String() string { return proto.CompactTextString(m) }
func (*TracingSpan) ProtoMessage()    {}
func (*TracingSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{79}
}
func (m *TracingSpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TracingSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingSpan.Merge(m, src)
}
func (m *TracingSpan) XXX_Size() int {
	return m.Size()
}
func (m *TracingSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingSpan.DiscardUnknown(m)
}

var xxx_messageInfo_TracingSpan proto.InternalMessageInfo

// SpanTag represents a tag on a tracing span, in a form processed for the use
// of the tracing UI.
type SpanTag struct {
	Key             string          `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Val             string          `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
	Caption         string          `protobuf:"bytes,3,opt,name=caption,proto3" json:"caption,omitempty"`
	Link            string          `protobuf:"bytes,4,opt,name=link,proto3" json:"link,omitempty"`
	Hidden          bool            `protobuf:"varint,5,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Highlight       bool            `protobuf:"varint,6,opt,name=highlight,proto3" json:"highlight,omitempty"`
	Inherit         bool            `protobuf:"varint,7,opt,name=inherit,proto3" json:"inherit,omitempty"`
	Inherited       bool            `protobuf:"varint,8,opt,name=inherited,proto3" json:"inherited,omitempty"`
	PropagateUp     bool            `protobuf:"varint,9,opt,name=propagate_up,json=propagateUp,proto3" json:"propagate_up,omitempty"`
	CopiedFromChild bool            `protobuf:"varint,10,opt,name=copied_from_child,json=copiedFromChild,proto3" json:"copied_from_child,omitempty"`
	Children        []*ChildSpanTag `protobuf:"bytes,11,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *SpanTag) Reset()         { *m = SpanTag{} }
func (m *SpanTag) String() string { return proto.CompactTextString(m) }
func (*SpanTag) ProtoMessage()    {}
func (*SpanTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{80}
}
func (m *SpanTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanTag.Merge(m, src)
}
func (m *SpanTag) XXX_Size() int {
	return m.Size()
}
func (m *SpanTag) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanTag.DiscardUnknown(m)
}

var xxx_messageInfo_SpanTag proto.InternalMessageInfo

type ChildSpanTag struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Val string `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
}

func (m *ChildSpanTag) Reset()         { *m = ChildSpanTag{} }
func (m *ChildSpanTag) String() string { return proto.CompactTextString(m) }
func (*ChildSpanTag) ProtoMessage()    {}
func (*ChildSpanTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{81}
}
func (m *ChildSpanTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChildSpanTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChildSpanTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChildSpanTag.Merge(m, src)
}
func (m *ChildSpanTag) XXX_Size() int {
	return m.Size()
}
func (m *ChildSpanTag) XXX_DiscardUnknown() {
	xxx_messageInfo_ChildSpanTag.DiscardUnknown(m)
}

var xxx_messageInfo_ChildSpanTag proto.InternalMessageInfo

// SetTraceRecordingTypeRequest is the request for SetTraceRecordingType, which
// sets the recording mode of all or some of the spans in a trace.
type SetTraceRecordingTypeRequest struct {
	// TraceID identifies the trace to toggle the recording of. It must always be
	// specified.
	TraceID github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.TraceID `protobuf:"varint,1,opt,name=trace_id,json=traceId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb.TraceID" json:"trace_id"`
	// SpanID, if not zero, controls which spans in the trace get their recording
	// mode set. If zero, all spans in the trace are updated. If not zero, only
	// the respective span and its descendants get updated.
	SpanID        github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.SpanID `protobuf:"varint,2,opt,name=span_id,json=spanId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb.SpanID" json:"span_id"`
	RecordingMode tracingpb.RecordingMode                                            `protobuf:"varint,3,opt,name=recording_mode,json=recordingMode,proto3,enum=cockroach.util.tracing.tracingpb.RecordingMode" json:"recording_mode,omitempty"`
}

func (m *SetTraceRecordingTypeRequest) Reset()         { *m = SetTraceRecordingTypeRequest{} }
func (m *SetTraceRecordingTypeRequest) String() string { return proto.CompactTextString(m) }
func (*SetTraceRecordingTypeRequest) ProtoMessage()    {}
func (*SetTraceRecordingTypeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{82}
}
func (m *SetTraceRecordingTypeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetTraceRecordingTypeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SetTraceRecordingTypeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTraceRecordingTypeRequest.Merge(m, src)
}
func (m *SetTraceRecordingTypeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetTraceRecordingTypeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTraceRecordingTypeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetTraceRecordingTypeRequest proto.InternalMessageInfo

// SetTraceRecordingTypeRequest is the response for SetTraceRecordingType.
type SetTraceRecordingTypeResponse struct {
}

func (m *SetTraceRecordingTypeResponse) Reset()         { *m = SetTraceRecordingTypeResponse{} }
func (m *SetTraceRecordingTypeResponse) String() string { return proto.CompactTextString(m) }
func (*SetTraceRecordingTypeResponse) ProtoMessage()    {}
func (*SetTraceRecordingTypeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{83}
}
func (m *SetTraceRecordingTypeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetTraceRecordingTypeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SetTraceRecordingTypeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTraceRecordingTypeResponse.Merge(m, src)
}
func (m *SetTraceRecordingTypeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetTraceRecordingTypeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTraceRecordingTypeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetTraceRecordingTypeResponse proto.InternalMessageInfo

// FeatureFlags within this struct are used within back-end/front-end code to show/hide features.
type FeatureFlags struct {
	// isObservabiliyService is true when the server is an instance of the Observability Service
	IsObservabilityService bool `protobuf:"varint,1,opt,name=is_observability_service,json=isObservabilityService,proto3" json:"is_observability_service,omitempty"`
	// CanViewKVMetricDashboards is true when the logged in user is able to view KV-level metric dashboards.
	CanViewKvMetricDashboards bool `protobuf:"varint,2,opt,name=can_view_kv_metric_dashboards,json=canViewKvMetricDashboards,proto3" json:"can_view_kv_metric_dashboards,omitempty"`
	// DisableKVLevelAdvancedDebug is true when the UI should remove options to certain KV-level
	// debug operations. This is helpful in application tenant contexsts, where these requests
	// can only return errors since the tenant cannot perform the operations.
	DisableKvLevelAdvancedDebug bool `protobuf:"varint,3,opt,name=disable_kv_level_advanced_debug,json=disableKvLevelAdvancedDebug,proto3" json:"disable_kv_level_advanced_debug,omitempty"`
}

func (m *FeatureFlags) Reset()         { *m = FeatureFlags{} }
func (m *FeatureFlags) String() string { return proto.CompactTextString(m) }
func (*FeatureFlags) ProtoMessage()    {}
func (*FeatureFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2ccb6a0551fa7e, []int{84}
}
func (m *FeatureFlags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureFlags.Merge(m, src)
}
func (m *FeatureFlags) XXX_Size() int {
	return m.Size()
}
func (m *FeatureFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureFlags.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureFlags proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.server.serverpb.ZoneConfigurationLevel", ZoneConfigurationLevel_name, ZoneConfigurationLevel_value)
	proto.RegisterEnum("cockroach.server.serverpb.DecommissionPreCheckResponse_NodeReadiness", DecommissionPreCheckResponse_NodeReadiness_name, DecommissionPreCheckResponse_NodeReadiness_value)
	proto.RegisterType((*DatabasesRequest)(nil), "cockroach.server.serverpb.DatabasesRequest")
	proto.RegisterType((*DatabasesResponse)(nil), "cockroach.server.serverpb.DatabasesResponse")
	proto.RegisterType((*DatabaseDetailsRequest)(nil), "cockroach.server.serverpb.DatabaseDetailsRequest")
	proto.RegisterType((*DatabaseDetailsResponse)(nil), "cockroach.server.serverpb.DatabaseDetailsResponse")
	proto.RegisterType((*DatabaseDetailsResponse_Grant)(nil), "cockroach.server.serverpb.DatabaseDetailsResponse.Grant")
	proto.RegisterType((*DatabaseDetailsResponse_Stats)(nil), "cockroach.server.serverpb.DatabaseDetailsResponse.Stats")
	proto.RegisterType((*DatabaseDetailsResponse_Stats_MissingTable)(nil), "cockroach.server.serverpb.DatabaseDetailsResponse.Stats.MissingTable")
	proto.RegisterType((*TableDetailsRequest)(nil), "cockroach.server.serverpb.TableDetailsRequest")
	proto.RegisterType((*TableDetailsResponse)(nil), "cockroach.server.serverpb.TableDetailsResponse")
	proto.RegisterType((*TableDetailsResponse_Grant)(nil), "cockroach.server.serverpb.TableDetailsResponse.Grant")
	proto.RegisterType((*TableDetailsResponse_Column)(nil), "cockroach.server.serverpb.TableDetailsResponse.Column")
	proto.RegisterType((*TableDetailsResponse_Index)(nil), "cockroach.server.serverpb.TableDetailsResponse.Index")
	proto.RegisterType((*TableStatsRequest)(nil), "cockroach.server.serverpb.TableStatsRequest")
	proto.RegisterType((*TableStatsResponse)(nil), "cockroach.server.serverpb.TableStatsResponse")
	proto.RegisterType((*TableStatsResponse_MissingNode)(nil), "cockroach.server.serverpb.TableStatsResponse.MissingNode")
	proto.RegisterType((*NonTableStatsRequest)(nil), "cockroach.server.serverpb.NonTableStatsRequest")
	proto.RegisterType((*NonTableStatsResponse)(nil), "cockroach.server.serverpb.NonTableStatsResponse")
	proto.RegisterType((*UsersRequest)(nil), "cockroach.server.serverpb.UsersRequest")
	proto.RegisterType((*UsersResponse)(nil), "cockroach.server.serverpb.UsersResponse")
	proto.RegisterType((*UsersResponse_User)(nil), "cockroach.server.serverpb.UsersResponse.User")
	proto.RegisterType((*EventsRequest)(nil), "cockroach.server.serverpb.EventsRequest")
	proto.RegisterType((*EventsResponse)(nil), "cockroach.server.serverpb.EventsResponse")
	proto.RegisterType((*EventsResponse_Event)(nil), "cockroach.server.serverpb.EventsResponse.Event")
	proto.RegisterType((*SetUIDataRequest)(nil), "cockroach.server.serverpb.SetUIDataRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "cockroach.server.serverpb.SetUIDataRequest.KeyValuesEntry")
	proto.RegisterType((*SetUIDataResponse)(nil), "cockroach.server.serverpb.SetUIDataResponse")
	proto.RegisterType((*GetUIDataRequest)(nil), "cockroach.server.serverpb.GetUIDataRequest")
	proto.RegisterType((*GetUIDataResponse)(nil), "cockroach.server.serverpb.GetUIDataResponse")
	proto.RegisterMapType((map[string]GetUIDataResponse_Value)(nil), "cockroach.server.serverpb.GetUIDataResponse.KeyValuesEntry")
	proto.RegisterType((*GetUIDataResponse_Value)(nil), "cockroach.server.serverpb.GetUIDataResponse.Value")
	proto.RegisterType((*ClusterRequest)(nil), "cockroach.server.serverpb.ClusterRequest")
	proto.RegisterType((*ClusterResponse)(nil), "cockroach.server.serverpb.ClusterResponse")
	proto.RegisterType((*DrainRequest)(nil), "cockroach.server.serverpb.DrainRequest")
	proto.RegisterType((*DrainResponse)(nil), "cockroach.server.serverpb.DrainResponse")
	proto.RegisterType((*DecommissionPreCheckRequest)(nil), "cockroach.server.serverpb.DecommissionPreCheckRequest")
	proto.RegisterType((*DecommissionPreCheckResponse)(nil), "cockroach.server.serverpb.DecommissionPreCheckResponse")
	proto.RegisterType((*DecommissionPreCheckResponse_RangeCheckResult)(nil), "cockroach.server.serverpb.DecommissionPreCheckResponse.RangeCheckResult")
	proto.RegisterType((*DecommissionPreCheckResponse_NodeCheckResult)(nil), "cockroach.server.serverpb.DecommissionPreCheckResponse.NodeCheckResult")
	proto.RegisterType((*DecommissionStatusRequest)(nil), "cockroach.server.serverpb.DecommissionStatusRequest")
	proto.RegisterType((*DecommissionRequest)(nil), "cockroach.server.serverpb.DecommissionRequest")
	proto.RegisterType((*DecommissionStatusResponse)(nil), "cockroach.server.serverpb.DecommissionStatusResponse")
	proto.RegisterType((*DecommissionStatusResponse_Replica)(nil), "cockroach.server.serverpb.DecommissionStatusResponse.Replica")
	proto.RegisterType((*DecommissionStatusResponse_Status)(nil), "cockroach.server.serverpb.DecommissionStatusResponse.Status")
	proto.RegisterType((*SettingsRequest)(nil), "cockroach.server.serverpb.SettingsRequest")
	proto.RegisterType((*SettingsResponse)(nil), "cockroach.server.serverpb.SettingsResponse")
	proto.RegisterMapType((map[string]SettingsResponse_Value)(nil), "cockroach.server.serverpb.SettingsResponse.KeyValuesEntry")
	proto.RegisterType((*SettingsResponse_Value)(nil), "cockroach.server.serverpb.SettingsResponse.Value")
	proto.RegisterType((*HealthRequest)(nil), "cockroach.server.serverpb.HealthRequest")
	proto.RegisterType((*HealthResponse)(nil), "cockroach.server.serverpb.HealthResponse")
	proto.RegisterType((*LivenessRequest)(nil), "cockroach.server.serverpb.LivenessRequest")
	proto.RegisterType((*LivenessResponse)(nil), "cockroach.server.serverpb.LivenessResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus)(nil), "cockroach.server.serverpb.LivenessResponse.StatusesEntry")
	proto.RegisterType((*JobsRequest)(nil), "cockroach.server.serverpb.JobsRequest")
	proto.RegisterType((*JobsResponse)(nil), "cockroach.server.serverpb.JobsResponse")
	proto.RegisterType((*JobRequest)(nil), "cockroach.server.serverpb.JobRequest")
	proto.RegisterType((*JobMessage)(nil), "cockroach.server.serverpb.JobMessage")
	proto.RegisterType((*JobResponse)(nil), "cockroach.server.serverpb.JobResponse")
	proto.RegisterType((*JobResponse_ExecutionFailure)(nil), "cockroach.server.serverpb.JobResponse.ExecutionFailure")
	proto.RegisterType((*LocationsRequest)(nil), "cockroach.server.serverpb.LocationsRequest")
	proto.RegisterType((*LocationsResponse)(nil), "cockroach.server.serverpb.LocationsResponse")
	proto.RegisterType((*LocationsResponse_Location)(nil), "cockroach.server.serverpb.LocationsResponse.Location")
	proto.RegisterType((*RangeLogRequest)(nil), "cockroach.server.serverpb.RangeLogRequest")
	proto.RegisterType((*RangeLogResponse)(nil), "cockroach.server.serverpb.RangeLogResponse")
	proto.RegisterType((*RangeLogResponse_PrettyInfo)(nil), "cockroach.server.serverpb.RangeLogResponse.PrettyInfo")
	proto.RegisterType((*RangeLogResponse_Event)(nil), "cockroach.server.serverpb.RangeLogResponse.Event")
	proto.RegisterType((*QueryPlanRequest)(nil), "cockroach.server.serverpb.QueryPlanRequest")
	proto.RegisterType((*QueryPlanResponse)(nil), "cockroach.server.serverpb.QueryPlanResponse")
	proto.RegisterType((*DataDistributionRequest)(nil), "cockroach.server.serverpb.DataDistributionRequest")
	proto.RegisterType((*DataDistributionResponse)(nil), "cockroach.server.serverpb.DataDistributionResponse")
	proto.RegisterMapType((map[string]DataDistributionResponse_DatabaseInfo)(nil), "cockroach.server.serverpb.DataDistributionResponse.DatabaseInfoEntry")
	proto.RegisterMapType((map[string]DataDistributionResponse_ZoneConfig)(nil), "cockroach.server.serverpb.DataDistributionResponse.ZoneConfigsEntry")
	proto.RegisterType((*DataDistributionResponse_ZoneConfig)(nil), "cockroach.server.serverpb.DataDistributionResponse.ZoneConfig")
	proto.RegisterType((*DataDistributionResponse_TableInfo)(nil), "cockroach.server.serverpb.DataDistributionResponse.TableInfo")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64)(nil), "cockroach.server.serverpb.DataDistributionResponse.TableInfo.ReplicaCountByNodeIdEntry")
	proto.RegisterType((*DataDistributionResponse_DatabaseInfo)(nil), "cockroach.server.serverpb.DataDistributionResponse.DatabaseInfo")
	proto.RegisterMapType((map[string]DataDistributionResponse_TableInfo)(nil), "cockroach.server.serverpb.DataDistributionResponse.DatabaseInfo.TableInfoEntry")
	proto.RegisterType((*MetricMetadataRequest)(nil), "cockroach.server.serverpb.MetricMetadataRequest")
	proto.RegisterType((*MetricMetadataResponse)(nil), "cockroach.server.serverpb.MetricMetadataResponse")
	proto.RegisterMapType((map[string]metric.Metadata)(nil), "cockroach.server.serverpb.MetricMetadataResponse.MetadataEntry")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.server.serverpb.MetricMetadataResponse.RecordedNamesEntry")
	proto.RegisterType((*EnqueueRangeRequest)(nil), "cockroach.server.serverpb.EnqueueRangeRequest")
	proto.RegisterType((*EnqueueRangeResponse)(nil), "cockroach.server.serverpb.EnqueueRangeResponse")
	proto.RegisterType((*EnqueueRangeResponse_Details)(nil), "cockroach.server.serverpb.EnqueueRangeResponse.Details")
	proto.RegisterType((*ChartCatalogRequest)(nil), "cockroach.server.serverpb.ChartCatalogRequest")
	proto.RegisterType((*ChartCatalogResponse)(nil), "cockroach.server.serverpb.ChartCatalogResponse")
	proto.RegisterType((*RecoveryCollectReplicaInfoRequest)(nil), "cockroach.server.serverpb.RecoveryCollectReplicaInfoRequest")
	proto.RegisterType((*RecoveryCollectReplicaRestartNodeStream)(nil), "cockroach.server.serverpb.RecoveryCollectReplicaRestartNodeStream")
	proto.RegisterType((*RecoveryCollectReplicaInfoResponse)(nil), "cockroach.server.serverpb.RecoveryCollectReplicaInfoResponse")
	proto.RegisterType((*RecoveryCollectLocalReplicaInfoRequest)(nil), "cockroach.server.serverpb.RecoveryCollectLocalReplicaInfoRequest")
	proto.RegisterType((*RecoveryCollectLocalReplicaInfoResponse)(nil), "cockroach.server.serverpb.RecoveryCollectLocalReplicaInfoResponse")
	proto.RegisterType((*RecoveryStagePlanRequest)(nil), "cockroach.server.serverpb.RecoveryStagePlanRequest")
	proto.RegisterType((*RecoveryStagePlanResponse)(nil), "cockroach.server.serverpb.RecoveryStagePlanResponse")
	proto.RegisterType((*RecoveryNodeStatusRequest)(nil), "cockroach.server.serverpb.RecoveryNodeStatusRequest")
	proto.RegisterType((*RecoveryNodeStatusResponse)(nil), "cockroach.server.serverpb.RecoveryNodeStatusResponse")
	proto.RegisterType((*RecoveryVerifyRequest)(nil), "cockroach.server.serverpb.RecoveryVerifyRequest")
	proto.RegisterType((*RecoveryVerifyResponse)(nil), "cockroach.server.serverpb.RecoveryVerifyResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.MembershipStatus)(nil), "cockroach.server.serverpb.RecoveryVerifyResponse.DecommissionedNodeStatusesEntry")
	proto.RegisterType((*RecoveryVerifyResponse_UnavailableRanges)(nil), "cockroach.server.serverpb.RecoveryVerifyResponse.UnavailableRanges")
	proto.RegisterType((*ListTenantsRequest)(nil), "cockroach.server.serverpb.ListTenantsRequest")
	proto.RegisterType((*ListTenantsResponse)(nil), "cockroach.server.serverpb.ListTenantsResponse")
	proto.RegisterType((*Tenant)(nil), "cockroach.server.serverpb.Tenant")
	proto.RegisterType((*ReadFromTenantInfoRequest)(nil), "cockroach.server.serverpb.ReadFromTenantInfoRequest")
	proto.RegisterType((*ReadFromTenantInfoResponse)(nil), "cockroach.server.serverpb.ReadFromTenantInfoResponse")
	proto.RegisterType((*ListTracingSnapshotsRequest)(nil), "cockroach.server.serverpb.ListTracingSnapshotsRequest")
	proto.RegisterType((*ListTracingSnapshotsResponse)(nil), "cockroach.server.serverpb.ListTracingSnapshotsResponse")
	proto.RegisterType((*SnapshotInfo)(nil), "cockroach.server.serverpb.SnapshotInfo")
	proto.RegisterType((*TakeTracingSnapshotRequest)(nil), "cockroach.server.serverpb.TakeTracingSnapshotRequest")
	proto.RegisterType((*TakeTracingSnapshotResponse)(nil), "cockroach.server.serverpb.TakeTracingSnapshotResponse")
	proto.RegisterType((*GetTracingSnapshotRequest)(nil), "cockroach.server.serverpb.GetTracingSnapshotRequest")
	proto.RegisterType((*GetTracingSnapshotResponse)(nil), "cockroach.server.serverpb.GetTracingSnapshotResponse")
	proto.RegisterType((*GetTraceRequest)(nil), "cockroach.server.serverpb.GetTraceRequest")
	proto.RegisterType((*GetTraceResponse)(nil), "cockroach.server.serverpb.GetTraceResponse")
	proto.RegisterType((*TracingSnapshot)(nil), "cockroach.server.serverpb.TracingSnapshot")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.server.serverpb.TracingSnapshot.StacksEntry")
	proto.RegisterType((*NamedOperationMetadata)(nil), "cockroach.server.serverpb.NamedOperationMetadata")
	proto.RegisterType((*TracingSpan)(nil), "cockroach.server.serverpb.TracingSpan")
	proto.RegisterType((*SpanTag)(nil), "cockroach.server.serverpb.SpanTag")
	proto.RegisterType((*ChildSpanTag)(nil), "cockroach.server.serverpb.ChildSpanTag")
	proto.RegisterType((*SetTraceRecordingTypeRequest)(nil), "cockroach.server.serverpb.SetTraceRecordingTypeRequest")
	proto.RegisterType((*SetTraceRecordingTypeResponse)(nil), "cockroach.server.serverpb.SetTraceRecordingTypeResponse")
	proto.RegisterType((*FeatureFlags)(nil), "cockroach.server.serverpb.FeatureFlags")
}

func init() { proto.RegisterFile("server/serverpb/admin.proto", fileDescriptor_0b2ccb6a0551fa7e) }

var fileDescriptor_0b2ccb6a0551fa7e = []byte{
	// 7192 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7d, 0xdd, 0x6f, 0x24, 0xc7,
	0x71, 0x38, 0x67, 0x3f, 0xb8, 0xbb, 0xb5, 0x4b, 0x72, 0xd9, 0x47, 0xf2, 0xc8, 0xbd, 0xd3, 0xf1,
	0x34, 0x67, 0x49, 0xe7, 0x3b, 0x69, 0x29, 0xdd, 0x49, 0x27, 0x59, 0x3a, 0xd9, 0x22, 0xb9, 0x14,
	0x6f, 0x4f, 0xbc, 0xaf, 0x21, 0xef, 0x0c, 0x9d, 0x7f, 0xf6, 0x78, 0x76, 0xa7, 0xb9, 0x1c, 0x71,
	0x76, 0x66, 0x6f, 0x66, 0x96, 0x3a, 0x4a, 0x96, 0x7f, 0xfe, 0xfa, 0xe1, 0xe7, 0x18, 0x56, 0x20,
	0xc4, 0x79, 0x88, 0x63, 0xe4, 0x21, 0x41, 0x90, 0x18, 0xb0, 0x81, 0x24, 0x8e, 0x81, 0x00, 0x7e,
	0xc8, 0x5b, 0x00, 0x21, 0x30, 0x62, 0x07, 0x09, 0x02, 0xc3, 0x40, 0xe8, 0x84, 0x4a, 0xfc, 0x92,
	0xff, 0xc0, 0x08, 0x92, 0xa0, 0xbf, 0xe6, 0x63, 0x77, 0x38, 0xdc, 0x25, 0x25, 0x27, 0x79, 0x39,
	0x6e, 0x57, 0x57, 0x57, 0xd7, 0x54, 0x57, 0x57, 0x57, 0x57, 0x57, 0xf7, 0xc1, 0x29, 0x17, 0x3b,
	0x3b, 0xd8, 0x59, 0x60, 0x7f, 0x3a, 0x8d, 0x05, 0x4d, 0x6f, 0x1b, 0x56, 0xb5, 0xe3, 0xd8, 0x9e,
	0x8d, 0xe6, 0x9a, 0x76, 0x73, 0xdb, 0xb1, 0xb5, 0xe6, 0x56, 0x95, 0xd5, 0x57, 0x05, 0x5a, 0x65,
	0xb6, 0x69, 0x5b, 0x9b, 0x46, 0x6b, 0xe1, 0x2d, 0xdb, 0xc2, 0x9d, 0x06, 0xfd, 0xc3, 0x1a, 0x55,
	0x3e, 0xd6, 0xf5, 0x0c, 0x73, 0xc1, 0x73, 0xb4, 0xa6, 0x61, 0xb5, 0xc4, 0xdf, 0x4e, 0x43, 0xfc,
	0xe2, 0x58, 0x33, 0x6f, 0xd8, 0x0d, 0x77, 0x81, 0xfc, 0xd3, 0x69, 0xd0, 0x3f, 0x1c, 0x7e, 0xba,
	0x97, 0x1f, 0xd7, 0xd3, 0xbc, 0xae, 0xa8, 0x3d, 0xe5, 0x7a, 0xb6, 0xa3, 0xb5, 0xf0, 0x02, 0xb6,
	0x5a, 0x06, 0xed, 0xb8, 0xbd, 0xd3, 0x6c, 0xf2, 0xca, 0xea, 0xf6, 0xce, 0xc2, 0xf6, 0x0e, 0x6f,
	0x6f, 0x1a, 0x3b, 0xd8, 0xc2, 0xae, 0xeb, 0xff, 0xe8, 0x34, 0xfc, 0x9f, 0x1c, 0xff, 0xd9, 0x08,
	0xbe, 0xfd, 0xc0, 0xc1, 0x4d, 0x7b, 0x07, 0x3b, 0xbb, 0xe1, 0xdf, 0x9d, 0xc6, 0x82, 0xf8, 0xc9,
	0x5b, 0x3d, 0x1e, 0x6e, 0x25, 0x7e, 0x10, 0x34, 0xcd, 0x6a, 0x61, 0xd5, 0xb4, 0xc5, 0x07, 0x4e,
	0x52, 0x3c, 0x22, 0xd0, 0x8e, 0x21, 0xbe, 0x99, 0x8a, 0x92, 0x30, 0x8d, 0x3d, 0x4d, 0xd7, 0x3c,
	0x8d, 0xc3, 0x91, 0x80, 0x87, 0x60, 0x67, 0x3c, 0x77, 0xa1, 0xa9, 0x79, 0x9a, 0x69, 0xb7, 0x16,
	0x9a, 0x5b, 0x9a, 0xe3, 0xa9, 0xbc, 0xc4, 0xeb, 0x67, 0xa9, 0x94, 0xb7, 0xcc, 0xe6, 0x82, 0x67,
	0xb4, 0xb1, 0xeb, 0x69, 0xed, 0x4e, 0xa4, 0xa6, 0x8d, 0x3d, 0xc7, 0x68, 0xf2, 0x3f, 0xbc, 0xe6,
	0xc2, 0x01, 0x23, 0x43, 0xbe, 0xd0, 0xd1, 0xb1, 0xae, 0xba, 0x1d, 0x8d, 0x0f, 0x7d, 0x65, 0xaa,
	0x65, 0xb7, 0x6c, 0xfa, 0x73, 0x81, 0xfc, 0x12, 0xa3, 0xd3, 0xb2, 0xed, 0x96, 0x89, 0xc9, 0x37,
	0x2d, 0x68, 0x96, 0x65, 0x7b, 0x9a, 0x67, 0xd8, 0x96, 0x10, 0xe8, 0x3c, 0xaf, 0xa5, 0xa5, 0x46,
	0x77, 0xb3, 0x97, 0x35, 0x19, 0x41, 0xb9, 0xa6, 0x79, 0x5a, 0x43, 0x73, 0xb1, 0xab, 0xe0, 0x07,
	0x5d, 0xec, 0x7a, 0xf2, 0x33, 0x30, 0x19, 0x82, 0xb9, 0x1d, 0xdb, 0x72, 0x31, 0x3a, 0x0d, 0x05,
	0x5d, 0x00, 0x67, 0xa5, 0xb3, 0xe9, 0xf3, 0x05, 0x25, 0x00, 0xc8, 0xaf, 0xc3, 0x8c, 0x68, 0x52,
	0xc3, 0x9e, 0x66, 0x98, 0x82, 0x18, 0xaa, 0x40, 0x5e, 0xa0, 0xcd, 0x4a, 0x67, 0xa5, 0xf3, 0x05,
	0xc5, 0x2f, 0xa3, 0x73, 0x30, 0x66, 0x58, 0x4d, 0xb3, 0xab, 0x63, 0x95, 0xe8, 0x94, 0x3b, 0x9b,
	0x3a, 0x2b, 0x9d, 0xcf, 0x2b, 0x25, 0x0e, 0x5c, 0x27, 0x30, 0xf9, 0x87, 0x39, 0x38, 0xd9, 0x47,
	0x9b, 0x33, 0x75, 0x0f, 0x46, 0x5b, 0x8e, 0x66, 0x79, 0x8c, 0xa3, 0xe2, 0xa5, 0x17, 0xaa, 0x07,
	0x4e, 0x8f, 0xea, 0x01, 0x34, 0xaa, 0xab, 0x84, 0xc0, 0x52, 0xe6, 0xfd, 0xbd, 0xf9, 0x11, 0x85,
	0x53, 0x43, 0xf3, 0x50, 0xf4, 0xb4, 0x86, 0x89, 0x55, 0x4b, 0x6b, 0x63, 0xc2, 0x16, 0xf9, 0x5c,
	0xa0, 0xa0, 0x9b, 0x04, 0x82, 0x9e, 0x83, 0x31, 0x1d, 0xbb, 0x4d, 0xc7, 0xe8, 0x78, 0xb6, 0xa3,
	0x1a, 0xfa, 0x6c, 0xfa, 0xac, 0x74, 0x3e, 0xbd, 0x54, 0xde, 0xdf, 0x9b, 0x2f, 0xd5, 0xfc, 0x8a,
	0x7a, 0x4d, 0x29, 0x05, 0x68, 0x75, 0x1d, 0x5d, 0x87, 0x22, 0x99, 0x96, 0x2a, 0x9b, 0xa9, 0xb3,
	0x99, 0xb3, 0xd2, 0xf9, 0xe2, 0xa5, 0x73, 0x21, 0xa6, 0x59, 0x45, 0x95, 0x4d, 0xe1, 0xea, 0x7d,
	0xdb, 0xc2, 0xcb, 0x14, 0xc2, 0xf9, 0x83, 0xb7, 0x7c, 0x08, 0xfa, 0x2c, 0x4c, 0x86, 0x68, 0xa9,
	0x26, 0xde, 0xc1, 0xe6, 0x6c, 0xf6, 0xac, 0x74, 0x7e, 0xfc, 0xd2, 0x33, 0x09, 0x62, 0x08, 0x68,
	0x76, 0x1d, 0xaa, 0x2a, 0x6b, 0xa4, 0xa1, 0x32, 0x11, 0x50, 0xa6, 0x00, 0x74, 0x13, 0xb2, 0x6c,
	0x4c, 0x46, 0x29, 0x93, 0x47, 0x91, 0x2c, 0x1d, 0x3f, 0x85, 0x91, 0xa9, 0xbc, 0x04, 0x59, 0x2a,
	0x69, 0x84, 0x20, 0xd3, 0x75, 0xb1, 0xc3, 0x95, 0x81, 0xfe, 0x46, 0x67, 0x00, 0x3a, 0x8e, 0xb1,
	0x63, 0x98, 0xb8, 0x15, 0x88, 0x3b, 0x80, 0x54, 0xfe, 0x34, 0x0d, 0x59, 0x4a, 0x0d, 0x99, 0x30,
	0xde, 0x36, 0x5c, 0xd7, 0xb0, 0x5a, 0x2a, 0x1d, 0x0e, 0x31, 0xf2, 0x2b, 0x47, 0xe5, 0xaf, 0x7a,
	0x83, 0x91, 0xdb, 0x20, 0xd4, 0x94, 0xb1, 0x76, 0xa8, 0x44, 0xf5, 0x80, 0x19, 0x91, 0xa6, 0xdd,
	0xb5, 0x3c, 0xaa, 0x9e, 0x69, 0x05, 0x28, 0x68, 0x99, 0x40, 0xd0, 0xb3, 0x30, 0xa3, 0x75, 0x3a,
	0x8e, 0xfd, 0xd0, 0x68, 0x6b, 0x1e, 0x56, 0x75, 0xc3, 0xdd, 0x56, 0x1b, 0xbb, 0x1e, 0x76, 0xa9,
	0x42, 0x64, 0x94, 0xa9, 0x50, 0x6d, 0xcd, 0x70, 0xb7, 0x97, 0x48, 0x1d, 0xfa, 0x2c, 0xe4, 0x2d,
	0x5b, 0xc7, 0xaa, 0xa1, 0xbb, 0xb3, 0x99, 0xb3, 0xe9, 0xf3, 0xd9, 0xa5, 0xa5, 0xfd, 0xbd, 0xf9,
	0xdc, 0x4d, 0x5b, 0xc7, 0xf5, 0x9a, 0xfb, 0xab, 0xbd, 0xf9, 0xcb, 0x2d, 0xc3, 0xdb, 0xea, 0x36,
	0xaa, 0x4d, 0xbb, 0xbd, 0xe0, 0x7f, 0x97, 0xde, 0x08, 0x7e, 0x2f, 0x74, 0xb6, 0x5b, 0x0b, 0xdc,
	0x46, 0x55, 0x59, 0x3b, 0x25, 0x47, 0x68, 0xd6, 0x75, 0x17, 0xbd, 0x08, 0x73, 0x56, 0xb7, 0xad,
	0x1a, 0x96, 0x8e, 0x1f, 0xaa, 0xc4, 0x92, 0xb4, 0xdb, 0xd8, 0xd2, 0x99, 0x5d, 0xa0, 0x1a, 0x92,
	0x55, 0x4e, 0x5a, 0xdd, 0x76, 0x9d, 0xd4, 0x2b, 0xd1, 0xea, 0xca, 0x2a, 0x94, 0xc2, 0x02, 0x21,
	0xa3, 0x45, 0xe6, 0x80, 0x18, 0x2d, 0xf2, 0x9b, 0x4c, 0x5b, 0xec, 0x38, 0xb6, 0xa3, 0xb6, 0xb1,
	0xeb, 0x6a, 0x2d, 0x4c, 0xe5, 0x52, 0x50, 0x4a, 0x14, 0x78, 0x83, 0xc1, 0xe4, 0x55, 0x38, 0x41,
	0x29, 0x0c, 0x61, 0x0e, 0xa6, 0x20, 0x4b, 0xc7, 0x94, 0xd3, 0x63, 0x05, 0xf9, 0xef, 0x01, 0xa6,
	0xa2, 0x94, 0xf8, 0xe4, 0x5f, 0xef, 0x99, 0xfc, 0xcf, 0x25, 0xa8, 0x40, 0x1c, 0x81, 0xd8, 0x99,
	0x7f, 0x0f, 0x72, 0x4d, 0xdb, 0xec, 0xb6, 0x2d, 0xa6, 0x86, 0xc5, 0x4b, 0x57, 0x86, 0xa5, 0xba,
	0x4c, 0x9b, 0x73, 0xb2, 0x82, 0x18, 0xba, 0x0b, 0x39, 0x3a, 0x1e, 0x54, 0x33, 0x8e, 0xc4, 0x2d,
	0x1d, 0x2e, 0x41, 0x96, 0xd3, 0xea, 0x55, 0xd0, 0x4c, 0x9c, 0x82, 0x36, 0x1d, 0x4c, 0x74, 0x93,
	0x19, 0x34, 0x32, 0x19, 0x71, 0x1b, 0x5b, 0x1e, 0x55, 0x84, 0x82, 0x32, 0xc5, 0x6a, 0x69, 0x8f,
	0xeb, 0xa2, 0xae, 0xd7, 0x4e, 0x8d, 0x7e, 0xe8, 0x76, 0x2a, 0xf7, 0xa1, 0xd9, 0xa9, 0x3e, 0x4b,
	0x9c, 0x1f, 0xc8, 0x12, 0xbf, 0x00, 0xdc, 0x5d, 0xea, 0x3a, 0x58, 0xa5, 0xfc, 0x05, 0x92, 0x29,
	0x50, 0xc9, 0xcc, 0xf8, 0xf5, 0x84, 0x95, 0x40, 0x36, 0xeb, 0x30, 0x4d, 0x2d, 0x9a, 0x6a, 0x6a,
	0xae, 0xa7, 0x32, 0xf1, 0xe9, 0xaa, 0xe6, 0xcd, 0x02, 0x95, 0x52, 0xa5, 0xca, 0x96, 0xdc, 0xaa,
	0x58, 0x72, 0xab, 0x1b, 0x62, 0xc9, 0x5d, 0xca, 0xbc, 0xf7, 0x8b, 0x79, 0x49, 0x41, 0xb4, 0xf9,
	0x9a, 0xe6, 0x7a, 0xcb, 0xac, 0xf1, 0xa2, 0x47, 0xa6, 0xec, 0x96, 0xe6, 0x1e, 0x30, 0x65, 0x8b,
	0x74, 0x55, 0x3c, 0xb9, 0xa5, 0xb9, 0x71, 0x53, 0x16, 0x9d, 0x87, 0x32, 0x99, 0x42, 0xaa, 0x67,
	0x7b, 0x9a, 0xc9, 0xad, 0x4f, 0x89, 0x2a, 0xc2, 0x38, 0x81, 0x6f, 0x10, 0x30, 0xb3, 0x3b, 0x8f,
	0xc3, 0x04, 0xc5, 0x24, 0x5e, 0x17, 0x47, 0x1c, 0xa3, 0x88, 0x63, 0x04, 0xbc, 0x66, 0xec, 0x60,
	0x86, 0xf7, 0x34, 0x4c, 0x05, 0x78, 0x1d, 0xec, 0x34, 0xb1, 0xe5, 0x91, 0x79, 0x3e, 0x7e, 0x56,
	0x3a, 0x9f, 0x52, 0x90, 0x40, 0xbe, 0xed, 0xd7, 0x1c, 0xcf, 0xba, 0xff, 0xa5, 0x04, 0xa3, 0x6c,
	0xd6, 0xc4, 0x9a, 0x1b, 0x04, 0x19, 0x6f, 0xb7, 0x23, 0xac, 0x02, 0xfd, 0x4d, 0xcc, 0x88, 0xd5,
	0x35, 0x4d, 0x6a, 0x2d, 0xd2, 0x54, 0x3c, 0x7e, 0x99, 0x98, 0x27, 0x1d, 0x6f, 0x6a, 0x5d, 0xd3,
	0x53, 0x77, 0x34, 0xb3, 0x8b, 0xe9, 0xac, 0x28, 0x90, 0xf1, 0xa7, 0xc0, 0x7b, 0x04, 0x86, 0x2e,
	0xc3, 0x74, 0x0b, 0x5b, 0x98, 0xa9, 0x96, 0x8a, 0x1f, 0x76, 0x1c, 0xec, 0xba, 0x86, 0x6d, 0x89,
	0x69, 0x11, 0x54, 0xae, 0xf8, 0x75, 0x68, 0x06, 0x46, 0xb7, 0x0c, 0x5d, 0xc7, 0x16, 0x9d, 0x11,
	0x79, 0x85, 0x97, 0x2a, 0x7f, 0x26, 0x41, 0x96, 0x0e, 0x4d, 0x2c, 0xff, 0x33, 0x30, 0xda, 0xb5,
	0x8c, 0x07, 0x5d, 0xcc, 0xdd, 0x1b, 0x5e, 0x42, 0x65, 0x48, 0xbb, 0xf8, 0x01, 0xf3, 0x1c, 0x14,
	0xf2, 0x93, 0x60, 0x32, 0x7b, 0xc1, 0x59, 0xe6, 0x25, 0xea, 0x7b, 0x19, 0x0e, 0x6e, 0x7a, 0x01,
	0x83, 0x01, 0x00, 0xcd, 0x42, 0x8e, 0xf8, 0xe0, 0x86, 0xd5, 0xe2, 0x6c, 0x89, 0x22, 0x91, 0x92,
	0xd1, 0xee, 0x98, 0x46, 0xd3, 0xf0, 0xe8, 0x8c, 0xcb, 0x2b, 0x7e, 0x59, 0x5e, 0x81, 0x49, 0x7f,
	0xd2, 0x1f, 0xc3, 0x3a, 0xbf, 0x97, 0x01, 0x14, 0xa6, 0xc3, 0x6d, 0x73, 0x8f, 0x5d, 0x92, 0xfa,
	0xec, 0xd2, 0x39, 0x18, 0x73, 0x30, 0x61, 0x45, 0x8b, 0xac, 0xad, 0x25, 0x0e, 0x64, 0x48, 0x8f,
	0x00, 0xd0, 0x75, 0x92, 0x61, 0x30, 0x41, 0x15, 0x08, 0x84, 0x55, 0x2f, 0x0a, 0x17, 0x85, 0xf9,
	0x51, 0x8f, 0x85, 0xad, 0x09, 0xdb, 0x94, 0x54, 0xc5, 0xa6, 0xa4, 0x7a, 0xe3, 0xde, 0xf2, 0x32,
	0x65, 0x91, 0x5b, 0x28, 0xd6, 0x32, 0x61, 0xfd, 0x1e, 0x4d, 0x58, 0xbf, 0x75, 0x10, 0x7e, 0x82,
	0x4a, 0xb8, 0x21, 0x8b, 0x2a, 0x31, 0xe9, 0x9f, 0x38, 0xcc, 0xa4, 0x47, 0x64, 0x24, 0x1c, 0x0f,
	0xb2, 0x7a, 0x73, 0xa6, 0x4a, 0xed, 0x00, 0x14, 0xf5, 0x12, 0x72, 0x1f, 0xba, 0x97, 0x50, 0xf9,
	0x34, 0x14, 0x43, 0x1c, 0xa0, 0x73, 0x90, 0xe3, 0xbd, 0xb1, 0x91, 0x5f, 0x82, 0xfd, 0xbd, 0xf9,
	0x51, 0xde, 0x68, 0x94, 0x35, 0x1a, 0x6c, 0xe5, 0x9f, 0x81, 0xa9, 0x9b, 0xb6, 0xd5, 0xa7, 0x5c,
	0xf2, 0x4f, 0x24, 0x98, 0xee, 0xa9, 0xe0, 0xda, 0xf2, 0x3a, 0x4c, 0x92, 0x7d, 0x89, 0xea, 0x62,
	0xc7, 0xc0, 0x2e, 0xdf, 0x0b, 0x48, 0x74, 0x50, 0x9f, 0x1a, 0x4a, 0xa6, 0xca, 0x04, 0xa1, 0xb3,
	0x4e, 0xc9, 0x30, 0x7f, 0xf1, 0x33, 0x80, 0x0c, 0xcb, 0xc3, 0x8e, 0xa5, 0x99, 0x6a, 0xd7, 0x0d,
	0xef, 0x33, 0x86, 0xa6, 0x5d, 0x16, 0x84, 0xee, 0xba, 0x7c, 0x6b, 0x32, 0x0e, 0xa5, 0xbb, 0x2e,
	0x76, 0xfc, 0x2f, 0xfc, 0x22, 0x8c, 0xf1, 0x32, 0xff, 0xb0, 0x3a, 0x64, 0x89, 0x05, 0x14, 0x1e,
	0x4a, 0x52, 0x87, 0x91, 0x86, 0xb4, 0x24, 0x34, 0x95, 0x52, 0xa8, 0xc8, 0x90, 0x21, 0x40, 0x32,
	0x45, 0x09, 0x20, 0x64, 0x65, 0xfc, 0xb2, 0x6c, 0xc2, 0xd8, 0xca, 0x0e, 0xb6, 0x82, 0xf9, 0x2c,
	0x4c, 0xa7, 0x14, 0x32, 0x9d, 0x53, 0x90, 0x35, 0x8d, 0xb6, 0xc1, 0xe6, 0x53, 0x56, 0x61, 0x05,
	0x74, 0x11, 0x26, 0xbb, 0x96, 0x83, 0x75, 0xad, 0x49, 0x56, 0x33, 0x4c, 0xa9, 0xd0, 0x79, 0x95,
	0x57, 0xca, 0x41, 0x05, 0xa3, 0x7e, 0x3d, 0x93, 0x4f, 0x95, 0xd3, 0xf2, 0x5f, 0xa5, 0x60, 0x5c,
	0x74, 0xc7, 0xbf, 0xf7, 0x06, 0x8c, 0xf2, 0xa6, 0xec, 0x83, 0x17, 0x12, 0x3e, 0x38, 0xda, 0x94,
	0x15, 0x85, 0x33, 0xc6, 0x88, 0x54, 0x3e, 0x90, 0x20, 0x4b, 0xe1, 0x68, 0x09, 0x0a, 0xfe, 0xce,
	0x95, 0x6b, 0x46, 0xd2, 0x42, 0x9b, 0x27, 0x64, 0xe8, 0x62, 0x1b, 0x34, 0x23, 0xd6, 0x84, 0xd2,
	0x55, 0x43, 0xab, 0x49, 0x81, 0x42, 0x36, 0x88, 0x5c, 0x2e, 0x01, 0x31, 0x3e, 0xb6, 0xe3, 0x91,
	0x69, 0x6d, 0xe8, 0xcc, 0x97, 0x5a, 0x9a, 0xd8, 0xdf, 0x9b, 0x2f, 0x2a, 0x02, 0x5e, 0xaf, 0x29,
	0x45, 0x1f, 0xa9, 0xae, 0x13, 0xf9, 0x1a, 0xd6, 0xa6, 0xcd, 0x6d, 0x32, 0xfd, 0x8d, 0x3e, 0x0e,
	0x05, 0x66, 0xe0, 0x09, 0x11, 0x62, 0x45, 0x4a, 0x4b, 0xa5, 0xfd, 0xbd, 0xf9, 0xfc, 0x5d, 0x0a,
	0xac, 0xd7, 0x94, 0x3c, 0xab, 0xae, 0xeb, 0xd7, 0x33, 0xf9, 0x74, 0x39, 0x23, 0x7f, 0x4f, 0x82,
	0xf2, 0x3a, 0xf6, 0xee, 0xd6, 0xc9, 0x3e, 0x45, 0x8c, 0xdc, 0xeb, 0x00, 0xdb, 0x78, 0x97, 0x2d,
	0x60, 0x42, 0x9a, 0x2f, 0x26, 0x48, 0xb3, 0x97, 0x40, 0xf5, 0x35, 0xbc, 0x4b, 0x57, 0x3a, 0x77,
	0xc5, 0xf2, 0x9c, 0x5d, 0xa5, 0xb0, 0x2d, 0xca, 0x95, 0xab, 0x30, 0x1e, 0xad, 0x24, 0x2b, 0xd1,
	0x36, 0xde, 0xe5, 0x5a, 0x42, 0x7e, 0x12, 0x25, 0x61, 0x6b, 0x27, 0x11, 0x53, 0x49, 0x61, 0x85,
	0x17, 0x53, 0x2f, 0x48, 0xf2, 0x09, 0x98, 0x0c, 0xf5, 0xc5, 0x06, 0x4f, 0x7e, 0x1c, 0xca, 0xab,
	0xbd, 0x5f, 0x80, 0x20, 0xb3, 0x8d, 0x77, 0x45, 0xac, 0x80, 0xfe, 0x96, 0x7f, 0x92, 0x82, 0xc9,
	0xd5, 0xde, 0xd6, 0xe8, 0xf3, 0x31, 0xdf, 0xfa, 0x52, 0xc2, 0xb7, 0xf6, 0x51, 0xe8, 0xf9, 0x58,
	0xae, 0x45, 0xa1, 0x4f, 0xde, 0x84, 0x2c, 0x5b, 0xf6, 0xfd, 0xef, 0x92, 0x42, 0xdf, 0x85, 0x56,
	0xa1, 0x44, 0x9d, 0xb9, 0x6e, 0x47, 0x27, 0xfe, 0x18, 0x37, 0x0f, 0x83, 0x29, 0x58, 0x91, 0xb4,
	0xbc, 0xcb, 0x1a, 0x56, 0x3a, 0x03, 0x88, 0xf6, 0x5a, 0x58, 0xb4, 0xc5, 0x4b, 0x97, 0x86, 0xfa,
	0x50, 0x4a, 0x3a, 0x3c, 0x1c, 0x65, 0x18, 0x5f, 0x36, 0xbb, 0xae, 0x87, 0x1d, 0x61, 0x84, 0xbe,
	0x23, 0xc1, 0x84, 0x0f, 0xe2, 0x12, 0x7e, 0x12, 0xa0, 0xc9, 0x40, 0x81, 0x7d, 0x1f, 0xdb, 0xdf,
	0x9b, 0x2f, 0x70, 0xc4, 0x7a, 0x4d, 0x29, 0x70, 0x84, 0xba, 0x4e, 0x6c, 0x41, 0x30, 0x13, 0xb0,
	0x45, 0x2c, 0xa1, 0xce, 0x7d, 0x97, 0xb2, 0x5f, 0xb1, 0xc2, 0xe0, 0xe8, 0x29, 0x40, 0x98, 0xd8,
	0xc5, 0x8e, 0x63, 0xb8, 0xd8, 0xc7, 0x66, 0x3e, 0xd9, 0x64, 0x50, 0xc3, 0xd1, 0xe5, 0xaf, 0x49,
	0x50, 0xaa, 0x39, 0x9a, 0x61, 0x85, 0x5c, 0x0e, 0x77, 0xab, 0xeb, 0xe9, 0xf6, 0x9b, 0x96, 0xf0,
	0xe4, 0x44, 0x19, 0xcd, 0x41, 0x5e, 0xb7, 0x55, 0x9d, 0xa0, 0x73, 0x5b, 0x94, 0xd3, 0x6d, 0xda,
	0x1a, 0x9d, 0x0c, 0x96, 0x2b, 0x36, 0xf9, 0xc4, 0x12, 0x35, 0x0b, 0xb9, 0x1d, 0xec, 0x34, 0x6c,
	0x17, 0x0b, 0x6f, 0x88, 0x17, 0xaf, 0x67, 0xf2, 0x52, 0x39, 0xc5, 0x6d, 0xd7, 0x0f, 0x24, 0x18,
	0xe3, 0x6c, 0x04, 0x1e, 0x8b, 0xe1, 0xb2, 0xbe, 0x88, 0x27, 0xc5, 0x3e, 0x17, 0x0c, 0xb7, 0xc6,
	0x21, 0xc4, 0x45, 0xa7, 0xb5, 0xaa, 0x83, 0xdb, 0x0c, 0x44, 0xdc, 0x75, 0xa3, 0xa9, 0x79, 0xb6,
	0xc3, 0x77, 0xfb, 0x27, 0x75, 0x46, 0x92, 0xd7, 0xd7, 0x45, 0x35, 0xfa, 0x24, 0x9c, 0xea, 0x6d,
	0x2b, 0x76, 0x23, 0xc4, 0xa5, 0x63, 0xde, 0xde, 0x5c, 0xb4, 0x75, 0x2d, 0x40, 0x60, 0xac, 0xcb,
	0xff, 0x2e, 0xc1, 0xa9, 0x1a, 0x75, 0xfe, 0x0d, 0xea, 0x8f, 0xde, 0x76, 0xf0, 0xf2, 0x16, 0x6e,
	0x6e, 0x0b, 0x51, 0x86, 0x1d, 0x06, 0xe9, 0xc3, 0x0f, 0x2b, 0x3c, 0x09, 0xc8, 0xea, 0xb6, 0x55,
	0xe1, 0xb6, 0x31, 0x4d, 0xa0, 0x82, 0xca, 0x2a, 0x65, 0xab, 0xdb, 0x56, 0x58, 0x05, 0x33, 0x96,
	0xe8, 0xe3, 0x50, 0x76, 0x3d, 0xc7, 0x68, 0x7a, 0xaa, 0x83, 0x35, 0xdd, 0xb0, 0xb0, 0xeb, 0xf2,
	0xf1, 0x9d, 0x60, 0x70, 0x45, 0x80, 0xd1, 0x63, 0x30, 0xde, 0xb4, 0x4d, 0x13, 0x37, 0x3d, 0xd5,
	0x73, 0xb4, 0x26, 0x16, 0x0b, 0xcf, 0x18, 0x87, 0x6e, 0x50, 0xa0, 0xfc, 0xcb, 0x51, 0x38, 0x1d,
	0xff, 0xf9, 0x7c, 0x08, 0x1d, 0x18, 0x6b, 0x12, 0x00, 0xd6, 0xb9, 0x5b, 0xc6, 0x4c, 0xc9, 0x6a,
	0x52, 0x68, 0x28, 0x81, 0x1e, 0x15, 0x80, 0x80, 0x74, 0x4d, 0xb1, 0x38, 0x95, 0x78, 0x1f, 0xd4,
	0x49, 0xab, 0xfc, 0x42, 0x82, 0xb2, 0x42, 0xdd, 0xda, 0x00, 0x11, 0x7d, 0x0e, 0xf2, 0xcc, 0xfb,
	0xe5, 0x93, 0x2d, 0xbb, 0xb4, 0x4c, 0x06, 0x82, 0xe2, 0xd5, 0x6b, 0xbf, 0xda, 0x9b, 0x7f, 0x76,
	0xa8, 0x81, 0xe0, 0xed, 0x94, 0x1c, 0x25, 0x5a, 0xd7, 0xc9, 0x3e, 0x41, 0x63, 0x9b, 0x01, 0xb6,
	0x8a, 0xf1, 0x12, 0x7a, 0xd9, 0x5f, 0x7e, 0x59, 0x8c, 0xe1, 0xb1, 0x24, 0x07, 0x87, 0x08, 0x95,
	0x2e, 0xae, 0x62, 0xb9, 0x25, 0xc6, 0x91, 0x3a, 0x72, 0x5c, 0x1f, 0x59, 0xa1, 0xf2, 0x6e, 0x1a,
	0x26, 0x7a, 0x24, 0x81, 0xee, 0x47, 0x9d, 0xc5, 0xec, 0xd2, 0x62, 0xe0, 0x2c, 0x1e, 0x55, 0xcf,
	0xc4, 0x04, 0xfe, 0x02, 0xcc, 0xe8, 0xa1, 0x51, 0x09, 0xa9, 0x4f, 0x8a, 0x06, 0x0d, 0x56, 0x8e,
	0x33, 0x9c, 0xbe, 0xd2, 0x29, 0xd3, 0xe1, 0x4e, 0x02, 0x5d, 0xec, 0xdb, 0x97, 0x64, 0x62, 0xf6,
	0x25, 0x5d, 0x18, 0x17, 0x8a, 0x46, 0x87, 0x44, 0x6c, 0x00, 0xae, 0x1d, 0x95, 0xb5, 0x5e, 0x0d,
	0xe2, 0xaa, 0x26, 0xd4, 0x99, 0x56, 0xbb, 0xdc, 0x5d, 0xf8, 0x3c, 0x8c, 0x45, 0xbe, 0x04, 0x15,
	0x21, 0x77, 0xf7, 0xe6, 0x6b, 0x37, 0x6f, 0x7d, 0xfa, 0x66, 0x79, 0x04, 0x15, 0x20, 0xab, 0xac,
	0x2c, 0xd6, 0x5e, 0x2f, 0x4b, 0xa8, 0x02, 0x33, 0x8b, 0x6b, 0xb4, 0xa0, 0xd6, 0x56, 0x96, 0x6f,
	0xdd, 0xb8, 0x51, 0x5f, 0x5f, 0xaf, 0xdf, 0xba, 0xb9, 0x52, 0x2b, 0xa7, 0xd0, 0x34, 0x4c, 0x2e,
	0xae, 0xad, 0xdd, 0x5a, 0x5e, 0xdc, 0xa8, 0xdf, 0xba, 0xa9, 0xae, 0x28, 0xca, 0x2d, 0x65, 0xbd,
	0x9c, 0xae, 0x64, 0xbe, 0xfb, 0x87, 0x67, 0x46, 0xe4, 0xef, 0x4a, 0x30, 0x17, 0x66, 0x77, 0x9d,
	0x9e, 0xf7, 0xfc, 0x4f, 0xb4, 0x32, 0xf2, 0x37, 0x53, 0x70, 0xa2, 0x16, 0x19, 0xc8, 0x5f, 0x0b,
	0x93, 0x5b, 0x30, 0xe9, 0x69, 0x4e, 0x0b, 0x7b, 0x6a, 0x1b, 0xb7, 0x1b, 0xd8, 0x71, 0xb7, 0x8c,
	0x0e, 0x57, 0xcf, 0xb0, 0xe3, 0xb2, 0xbd, 0x53, 0x15, 0xc7, 0x51, 0x55, 0xff, 0xa4, 0x2b, 0x38,
	0xfd, 0xaa, 0xde, 0xf0, 0x1b, 0x73, 0x11, 0x97, 0x19, 0xd5, 0x00, 0x7e, 0x80, 0x38, 0xd2, 0x07,
	0x88, 0xe3, 0x1f, 0xb2, 0x50, 0x89, 0x1b, 0x39, 0x6e, 0x20, 0xef, 0xc3, 0x28, 0x3b, 0xbb, 0xe3,
	0xb1, 0xcd, 0xab, 0x03, 0xea, 0x6b, 0x94, 0x4c, 0x95, 0x15, 0x85, 0xaf, 0xce, 0x28, 0x56, 0xfe,
	0x56, 0x82, 0x1c, 0x67, 0x06, 0x6d, 0x02, 0x08, 0x86, 0x7d, 0x0b, 0xb1, 0x4a, 0xdc, 0x0d, 0x8e,
	0x40, 0x8d, 0xc4, 0x95, 0xe1, 0x6c, 0xa0, 0x68, 0xa9, 0x14, 0x38, 0xe9, 0xba, 0x1e, 0xb1, 0xb3,
	0xa9, 0x0f, 0xdf, 0xce, 0x56, 0xfe, 0x7f, 0x1a, 0x46, 0xd9, 0xc7, 0x7e, 0xa4, 0x16, 0xef, 0x24,
	0xe4, 0x0c, 0x97, 0x06, 0xdb, 0x44, 0x84, 0xc8, 0x70, 0xd7, 0x8c, 0x1d, 0xdc, 0x6f, 0x8c, 0xd2,
	0x31, 0xc6, 0xe8, 0x33, 0x00, 0x21, 0x25, 0xcc, 0x1c, 0x5f, 0x09, 0x43, 0xe4, 0x68, 0x40, 0x48,
	0xb8, 0x44, 0x59, 0xe6, 0x9d, 0x89, 0x32, 0x7a, 0x43, 0xb8, 0x89, 0xc4, 0x0c, 0x32, 0x8e, 0xdc,
	0xd9, 0x51, 0xaa, 0x58, 0x2f, 0x1f, 0x4d, 0xb1, 0x84, 0x32, 0x97, 0x05, 0x5d, 0x0e, 0x70, 0xe5,
	0x8b, 0x30, 0xb1, 0x8e, 0x3d, 0xe2, 0x77, 0xba, 0x09, 0xfb, 0x0b, 0xee, 0xdc, 0xfd, 0x49, 0x9a,
	0x6e, 0xa8, 0x38, 0x36, 0xd7, 0x7d, 0x75, 0xf8, 0x0d, 0x55, 0x84, 0xc0, 0xa1, 0x7b, 0x8c, 0xf7,
	0xa5, 0xd8, 0x4d, 0x46, 0x41, 0x6c, 0x32, 0xe2, 0xc2, 0x98, 0x67, 0xa1, 0x18, 0xf6, 0x03, 0xd3,
	0xb4, 0x2a, 0x0c, 0x22, 0x4b, 0x7d, 0xa7, 0xdb, 0x30, 0x8d, 0x26, 0xf7, 0x89, 0x78, 0xa9, 0x6f,
	0xcb, 0x92, 0x1d, 0x68, 0xcb, 0x22, 0xf5, 0x6d, 0x59, 0xfc, 0x88, 0xe5, 0x68, 0x10, 0xb1, 0xac,
	0xd8, 0x03, 0x6c, 0x63, 0x56, 0xa3, 0xdb, 0x98, 0x67, 0x86, 0x11, 0x65, 0xdf, 0x2e, 0xe6, 0x31,
	0x18, 0xbb, 0x86, 0x35, 0xd3, 0xdb, 0x12, 0x83, 0x3b, 0x05, 0x59, 0xb2, 0xee, 0xb3, 0x1e, 0xf3,
	0x0a, 0x2b, 0x90, 0xcd, 0x8e, 0x40, 0xe3, 0x1b, 0xcf, 0x49, 0x98, 0x58, 0xe3, 0xaa, 0x2c, 0xf6,
	0x3f, 0xff, 0x91, 0x82, 0x72, 0x00, 0xf3, 0x23, 0x4c, 0x20, 0x54, 0xde, 0x1f, 0xfd, 0xcb, 0x43,
	0x4c, 0x12, 0x41, 0x50, 0x9c, 0x6f, 0x04, 0xc4, 0xd0, 0x6f, 0x49, 0x90, 0x67, 0x36, 0x10, 0x0b,
	0xbb, 0x9a, 0x14, 0x08, 0xec, 0x65, 0x8d, 0x5b, 0x53, 0xa1, 0x56, 0x2f, 0x11, 0xfa, 0x5f, 0xf9,
	0xc5, 0xd1, 0x0c, 0x8a, 0xcf, 0x47, 0xe5, 0x2d, 0x18, 0x8b, 0xd0, 0x0d, 0x0f, 0x60, 0x96, 0x0d,
	0xe0, 0x7a, 0x78, 0x00, 0xc7, 0x23, 0x53, 0xf6, 0x30, 0x69, 0x90, 0xee, 0xc4, 0x77, 0xf0, 0x29,
	0x1c, 0x1a, 0xcc, 0x0e, 0x14, 0xaf, 0xdb, 0x0d, 0x37, 0x34, 0x94, 0x2c, 0xde, 0x24, 0x85, 0xe3,
	0x4d, 0x33, 0xa1, 0xa5, 0x88, 0xba, 0xb0, 0xac, 0x84, 0x2e, 0xf3, 0x59, 0x92, 0xa6, 0x4c, 0xcd,
	0x87, 0x05, 0xf9, 0xc0, 0xac, 0xd2, 0xac, 0x14, 0x96, 0xa1, 0x52, 0xdd, 0xd8, 0xed, 0x60, 0x36,
	0x8d, 0xe4, 0xef, 0x4b, 0x50, 0x62, 0x5d, 0xf2, 0xe1, 0x7e, 0x05, 0x32, 0x04, 0x8b, 0x0f, 0xf4,
	0xe3, 0x09, 0xc3, 0x71, 0xdd, 0x6e, 0x88, 0x56, 0x7c, 0x6c, 0x69, 0x4b, 0x74, 0x1f, 0x66, 0xb0,
	0xe6, 0x98, 0x06, 0x76, 0xc9, 0x06, 0xc6, 0xd3, 0x0c, 0x0b, 0xeb, 0xaa, 0x67, 0xb4, 0xf1, 0x50,
	0xc1, 0x81, 0x29, 0x41, 0x43, 0xe1, 0x24, 0x08, 0x92, 0x7c, 0x0e, 0x80, 0x76, 0xcb, 0xe4, 0x33,
	0x0d, 0xa3, 0x6f, 0xd8, 0x0d, 0xb1, 0xb0, 0xa4, 0x95, 0xec, 0x1b, 0x76, 0xa3, 0xae, 0xcb, 0x5f,
	0xa4, 0x48, 0x3c, 0xa6, 0x4a, 0x8d, 0x9d, 0x61, 0xe9, 0x22, 0x90, 0x47, 0x7e, 0x47, 0x63, 0x62,
	0xa9, 0xa3, 0xc5, 0xc4, 0x66, 0x21, 0x27, 0x42, 0xb9, 0xcc, 0xf8, 0x88, 0xa2, 0xfc, 0x43, 0xa0,
	0xc3, 0xe8, 0x8b, 0x74, 0x06, 0x52, 0x82, 0xc5, 0xa5, 0xd1, 0xfd, 0xbd, 0xf9, 0x54, 0xbd, 0xa6,
	0xa4, 0x0c, 0xfd, 0x88, 0x66, 0xed, 0x34, 0x14, 0x82, 0xf3, 0xb6, 0x32, 0x0b, 0xc5, 0xf9, 0x80,
	0x48, 0x8c, 0x33, 0x13, 0x8d, 0x71, 0xa2, 0x1d, 0x18, 0x8f, 0x9c, 0xf7, 0x31, 0xdf, 0x7b, 0x6c,
	0xe9, 0xd6, 0xfe, 0xde, 0xfc, 0x58, 0xf8, 0xc0, 0x8f, 0x78, 0x79, 0x2f, 0x0e, 0x34, 0x8b, 0xdc,
	0x07, 0xa6, 0x9f, 0xd8, 0x43, 0x68, 0x77, 0x1a, 0xd5, 0x7a, 0x4d, 0x19, 0x0b, 0x9f, 0x17, 0xba,
	0x21, 0x85, 0x1d, 0x8d, 0x28, 0xec, 0x8b, 0x90, 0xe3, 0x67, 0x80, 0xf4, 0x88, 0x65, 0x90, 0x03,
	0x40, 0xd1, 0x80, 0xb4, 0x75, 0x3d, 0x8d, 0x2c, 0x74, 0xf4, 0xd4, 0x72, 0xa0, 0xb6, 0xbc, 0x01,
	0xba, 0x0a, 0xf9, 0x4d, 0xc3, 0x32, 0xdc, 0x2d, 0xac, 0xd3, 0x03, 0xcb, 0x41, 0x1a, 0xfb, 0x2d,
	0x48, 0xeb, 0xb6, 0xad, 0x1b, 0x9b, 0x06, 0xd6, 0x07, 0x3e, 0xb7, 0xf4, 0x5b, 0xa0, 0xa7, 0x00,
	0x6d, 0x3a, 0x6c, 0xcf, 0xa9, 0x36, 0xed, 0x76, 0xc7, 0xc4, 0xe4, 0x13, 0x8a, 0xf4, 0x74, 0x70,
	0x52, 0xd4, 0x2c, 0x8b, 0x8a, 0x60, 0x5f, 0x59, 0x0a, 0xed, 0x2b, 0xd1, 0x1d, 0x38, 0xb1, 0x65,
	0xb4, 0xb6, 0xde, 0xd4, 0x3c, 0xec, 0xa8, 0x81, 0x22, 0x8f, 0x0d, 0x7a, 0x8a, 0xea, 0x37, 0xf6,
	0x6b, 0xd0, 0x45, 0x98, 0x0c, 0x48, 0xea, 0xb8, 0x69, 0xb4, 0x35, 0x93, 0x1e, 0x5a, 0x16, 0x94,
	0xb2, 0x5f, 0x51, 0x63, 0x70, 0xf4, 0x18, 0x8c, 0x3b, 0x5d, 0x8b, 0xc6, 0x62, 0xf8, 0xc0, 0x4e,
	0x50, 0xcc, 0x31, 0x0e, 0xe5, 0x8e, 0xdf, 0x4b, 0x90, 0xa7, 0x0b, 0xad, 0xd3, 0xb5, 0x66, 0x27,
	0x07, 0x1d, 0x24, 0xd2, 0x42, 0xe9, 0x5a, 0xa4, 0xb1, 0x85, 0x1f, 0xb2, 0xc6, 0x68, 0xd0, 0xc6,
	0xa4, 0x05, 0x69, 0x3c, 0x07, 0x79, 0xea, 0xfa, 0x77, 0x2d, 0x77, 0xf6, 0x04, 0x35, 0x0d, 0x39,
	0xe2, 0xf0, 0x77, 0x2d, 0x17, 0x6d, 0x02, 0xc2, 0x0f, 0x71, 0xb3, 0x4b, 0x47, 0x60, 0x53, 0x33,
	0xcc, 0xae, 0x83, 0xdd, 0xd9, 0x29, 0x6a, 0xed, 0x9e, 0x1f, 0xcc, 0xda, 0x55, 0x57, 0x04, 0x81,
	0x57, 0x59, 0x7b, 0x65, 0x12, 0xf7, 0x40, 0x5c, 0xf4, 0x02, 0x8c, 0x37, 0x6d, 0xdb, 0xd1, 0x0d,
	0x4b, 0xe3, 0xa7, 0xeb, 0xd3, 0xd4, 0x00, 0x4c, 0x92, 0xc9, 0xb6, 0x1c, 0xd4, 0x90, 0xe9, 0x12,
	0x42, 0xac, 0xeb, 0x68, 0x15, 0xf2, 0xdc, 0x92, 0xb8, 0xb3, 0x33, 0x87, 0x06, 0x23, 0x02, 0x4b,
	0xc7, 0x8d, 0xb0, 0xdf, 0xb8, 0xf2, 0x7d, 0x09, 0xca, 0xbd, 0xac, 0x86, 0x26, 0xa3, 0x14, 0x99,
	0x8c, 0x57, 0xe8, 0x89, 0x20, 0xdf, 0x2f, 0x0e, 0x22, 0x6c, 0x86, 0x8e, 0x2e, 0x41, 0x1a, 0x5b,
	0x2c, 0x6a, 0x39, 0x48, 0x2b, 0x82, 0x1c, 0x1f, 0x2d, 0x91, 0x11, 0x94, 0xd7, 0xec, 0x26, 0x3b,
	0x99, 0x17, 0x1e, 0xc9, 0x7f, 0x4a, 0x30, 0x19, 0x02, 0xfa, 0x2e, 0x49, 0xc1, 0x14, 0xc0, 0x01,
	0x32, 0x58, 0xfa, 0x08, 0xf8, 0x10, 0xe1, 0x8a, 0xfa, 0xd4, 0x2a, 0xbf, 0x29, 0x41, 0x5e, 0xd4,
	0xa2, 0x47, 0xa1, 0x44, 0x6a, 0x4c, 0xc3, 0xdb, 0x55, 0x03, 0x1f, 0xae, 0x28, 0x60, 0xaf, 0xe1,
	0x5d, 0x32, 0x15, 0x7c, 0x94, 0xc0, 0x27, 0x28, 0x28, 0x63, 0x02, 0xca, 0xfc, 0xda, 0x0a, 0x99,
	0x0a, 0x9e, 0xe1, 0x75, 0x75, 0xb6, 0x5a, 0x48, 0x8a, 0x5f, 0x26, 0x06, 0xdd, 0xb4, 0xad, 0x16,
	0xab, 0xcc, 0xd0, 0xca, 0x00, 0x20, 0x2f, 0xc1, 0x04, 0xdd, 0x5c, 0xad, 0xd9, 0x2d, 0xb1, 0xec,
	0xcd, 0xf5, 0xc4, 0xc8, 0xd2, 0x41, 0x78, 0xcb, 0xf7, 0x18, 0x52, 0x21, 0x8f, 0x41, 0xfe, 0xb7,
	0x34, 0x8f, 0xb4, 0x51, 0x22, 0x5c, 0x88, 0xb7, 0xfc, 0x88, 0x17, 0xf3, 0xbc, 0x92, 0xdc, 0xd0,
	0xde, 0xc6, 0xb1, 0x47, 0x4e, 0x7f, 0x2d, 0x01, 0xdc, 0x76, 0xb0, 0xe7, 0xed, 0xd6, 0xad, 0x4d,
	0x9b, 0x08, 0x8f, 0x7b, 0xd8, 0x34, 0x60, 0x2b, 0x84, 0xc7, 0x61, 0x64, 0xb9, 0xa1, 0xd3, 0x14,
	0xbf, 0xc9, 0xaa, 0x99, 0xd8, 0x72, 0x16, 0x7e, 0x93, 0x56, 0x9d, 0x83, 0x31, 0x4d, 0xd7, 0x83,
	0xed, 0x11, 0x5f, 0x09, 0x4b, 0x14, 0x28, 0x36, 0xcb, 0x4f, 0xc0, 0x84, 0x83, 0xdb, 0xf6, 0x4e,
	0x08, 0x8d, 0x69, 0xd4, 0x38, 0x07, 0x0b, 0xc4, 0x19, 0x18, 0x75, 0xb0, 0xe6, 0xfa, 0x29, 0x00,
	0xbc, 0x44, 0xd6, 0x70, 0x9d, 0xe5, 0x0a, 0xf1, 0xa5, 0x49, 0x14, 0x2b, 0x3f, 0xf0, 0xcf, 0xcf,
	0xae, 0x43, 0x96, 0x7e, 0x20, 0x3f, 0x3b, 0xab, 0x1e, 0xe0, 0xec, 0xf1, 0x63, 0xf3, 0x90, 0xb0,
	0xc2, 0x32, 0x62, 0x24, 0xd0, 0x67, 0xa1, 0xd8, 0xa1, 0x12, 0x52, 0xe9, 0xd9, 0x17, 0x9b, 0x6a,
	0x57, 0x86, 0x11, 0x7c, 0x20, 0x60, 0xe1, 0x4f, 0x77, 0x7c, 0x08, 0x8f, 0x75, 0x9f, 0x87, 0xf2,
	0x9d, 0x2e, 0x76, 0x76, 0x6f, 0x9b, 0x9a, 0x15, 0xf2, 0x24, 0x1f, 0x10, 0x98, 0xd8, 0x57, 0xd1,
	0x82, 0xdc, 0x81, 0xc9, 0x10, 0x26, 0xd7, 0x8b, 0xcf, 0xc0, 0x29, 0xdd, 0x70, 0x3d, 0xf7, 0x81,
	0xa9, 0x76, 0xb6, 0x76, 0x5d, 0xa3, 0xa9, 0x99, 0x2a, 0x45, 0x57, 0x3b, 0xa6, 0x66, 0xf1, 0x13,
	0x90, 0xd3, 0xfb, 0x7b, 0xf3, 0xb3, 0x35, 0xc3, 0xf5, 0xd6, 0xef, 0xac, 0xdd, 0xe6, 0x58, 0x01,
	0xa9, 0x59, 0x4e, 0xa0, 0xaf, 0x46, 0x9e, 0x63, 0x09, 0xa9, 0xa4, 0xa5, 0x63, 0x34, 0xa8, 0x61,
	0x12, 0x53, 0xfd, 0x3d, 0x80, 0xd9, 0xfe, 0x3a, 0xce, 0x54, 0x07, 0xc6, 0x44, 0x36, 0x05, 0x13,
	0xdd, 0x60, 0xa9, 0x8b, 0x71, 0xb4, 0xfc, 0x9c, 0x46, 0x22, 0xb2, 0xf0, 0x86, 0xb4, 0xa4, 0x87,
	0x2a, 0x50, 0x1b, 0x4a, 0xa1, 0xdc, 0x2b, 0x11, 0x16, 0xae, 0x1d, 0xa5, 0xc3, 0x20, 0x1f, 0x2b,
	0xb2, 0x01, 0x2e, 0x06, 0xf9, 0x58, 0x6e, 0xe5, 0x3b, 0x12, 0x40, 0x80, 0x47, 0x14, 0x96, 0xc5,
	0xb3, 0x84, 0x95, 0x66, 0x25, 0xb4, 0x08, 0xa3, 0x3c, 0xb1, 0x2c, 0x35, 0x6c, 0x62, 0x19, 0x6f,
	0x48, 0x0f, 0xb4, 0x58, 0x3e, 0x99, 0xfb, 0xc0, 0x64, 0xf3, 0x85, 0x1f, 0x68, 0x51, 0xe8, 0xfa,
	0x9d, 0x35, 0xa5, 0xc0, 0x10, 0xd6, 0x1f, 0x98, 0x2c, 0x70, 0x5a, 0xf9, 0x65, 0x0a, 0x0a, 0xf4,
	0x58, 0x9f, 0x8a, 0xe6, 0x7d, 0x09, 0x66, 0x23, 0xc1, 0x15, 0xb5, 0xb1, 0xab, 0x06, 0x21, 0x1e,
	0x22, 0xa7, 0x4f, 0x1f, 0x45, 0x4e, 0x7e, 0x0f, 0x22, 0x9a, 0x41, 0xa3, 0x34, 0x4b, 0xbb, 0x74,
	0x8b, 0xa6, 0x33, 0xd1, 0x3d, 0x7f, 0xd4, 0x0d, 0xde, 0x94, 0x13, 0x43, 0x13, 0x7d, 0x0a, 0x40,
	0x77, 0xec, 0x4e, 0x87, 0xa5, 0xa1, 0x0d, 0xba, 0x88, 0x15, 0x78, 0x9b, 0x45, 0xaf, 0xb2, 0x0a,
	0x73, 0x07, 0x32, 0x1b, 0xb3, 0x73, 0x8c, 0x1c, 0x0e, 0xa7, 0x43, 0x5b, 0x3f, 0x16, 0x7f, 0xa9,
	0x7c, 0x39, 0x05, 0xa5, 0xb0, 0x7e, 0x22, 0x0f, 0x58, 0xee, 0x74, 0x58, 0xeb, 0x6f, 0x1d, 0x57,
	0xeb, 0x03, 0x49, 0x47, 0x02, 0x32, 0x9e, 0x80, 0x56, 0xde, 0x86, 0xf1, 0x28, 0x4a, 0x4c, 0x14,
	0x63, 0x3d, 0x1a, 0xc5, 0x78, 0xf9, 0x58, 0x23, 0x1e, 0x92, 0x44, 0xe5, 0xcb, 0x52, 0x90, 0x44,
	0x9f, 0xc4, 0xc0, 0xbd, 0x28, 0x03, 0xaf, 0x1c, 0x57, 0x2a, 0x61, 0x1e, 0xbe, 0x08, 0xe5, 0xde,
	0x59, 0x1b, 0xc3, 0xc1, 0x46, 0x94, 0x83, 0x4f, 0x1e, 0xcf, 0x38, 0xf4, 0x69, 0x83, 0x7c, 0x12,
	0xa6, 0x6f, 0xd0, 0x2b, 0x0f, 0x37, 0xf8, 0x15, 0x0b, 0x61, 0x2b, 0xdf, 0x4d, 0xc3, 0x4c, 0x6f,
	0x0d, 0xb7, 0x94, 0x1a, 0xf1, 0x1e, 0x19, 0x8c, 0xab, 0xcb, 0xa7, 0x12, 0xd8, 0x8a, 0x27, 0x52,
	0x15, 0x80, 0xb0, 0x7a, 0xf8, 0x64, 0x89, 0x31, 0x16, 0x97, 0x2c, 0x6e, 0xfa, 0x49, 0xfe, 0xc9,
	0xb6, 0xf1, 0x80, 0x7e, 0x94, 0x30, 0x99, 0x70, 0x67, 0xd1, 0x0e, 0x2a, 0xff, 0x07, 0xc6, 0x22,
	0x2c, 0xc5, 0x8c, 0xc5, 0x73, 0xd1, 0xb1, 0x08, 0x87, 0x3f, 0xba, 0x9e, 0x61, 0x56, 0xf9, 0xdd,
	0x11, 0x9f, 0x85, 0xd0, 0x60, 0xbf, 0x02, 0xa8, 0x9f, 0x91, 0xc3, 0x32, 0x3b, 0x0a, 0xe1, 0xb8,
	0xcd, 0xb7, 0x52, 0x70, 0x62, 0xc5, 0x7a, 0xd0, 0xc5, 0x5d, 0x4c, 0x57, 0x6c, 0xb1, 0xec, 0x7e,
	0x94, 0xa1, 0x6f, 0xb6, 0xa4, 0x07, 0xdc, 0xd0, 0x42, 0x24, 0xae, 0x9f, 0xfe, 0x08, 0xce, 0x4f,
	0x2f, 0xc0, 0xa4, 0xbb, 0x6d, 0x74, 0x54, 0x77, 0xcb, 0xee, 0x9a, 0xba, 0xca, 0x38, 0xc8, 0xf0,
	0xc3, 0xe9, 0x6d, 0xa3, 0xb3, 0x4e, 0xe1, 0x77, 0x08, 0x58, 0xfe, 0xa3, 0x14, 0x4c, 0x45, 0xa5,
	0xc2, 0x75, 0xf4, 0x4e, 0xe0, 0x76, 0x49, 0x87, 0x6e, 0xbc, 0xe2, 0x28, 0x54, 0x45, 0x86, 0xb7,
	0xef, 0xaf, 0xfd, 0x48, 0x82, 0x1c, 0x07, 0x7e, 0xa4, 0x52, 0x7f, 0xb9, 0xc7, 0x6b, 0x3e, 0xea,
	0x39, 0x71, 0x3a, 0xbc, 0xf3, 0x99, 0x86, 0x13, 0xcb, 0x5b, 0x9a, 0xe3, 0x2d, 0xb3, 0x48, 0x8a,
	0x98, 0xe5, 0xf7, 0x61, 0x2a, 0x0a, 0xe6, 0xe2, 0x5b, 0x82, 0x1c, 0x8f, 0xb9, 0x70, 0xf1, 0xc9,
	0x21, 0x26, 0x3c, 0xb7, 0x2a, 0xee, 0x56, 0xd1, 0xc6, 0xeb, 0x2c, 0xd5, 0xd5, 0x4f, 0xaa, 0x67,
	0x75, 0xf2, 0x1a, 0x3c, 0xaa, 0xf0, 0xab, 0x60, 0xcb, 0x2c, 0x55, 0x40, 0x1c, 0x13, 0x11, 0x4b,
	0xc8, 0xd5, 0xf7, 0x09, 0x98, 0x68, 0x6b, 0x0f, 0x89, 0x0b, 0xd4, 0xec, 0x3a, 0x0e, 0xb6, 0x9a,
	0x62, 0x2d, 0x1b, 0x6f, 0x6b, 0x0f, 0x97, 0x03, 0xa8, 0xfc, 0xff, 0x24, 0x78, 0x22, 0x9e, 0x9c,
	0x82, 0xe9, 0x36, 0x91, 0x48, 0x71, 0xdd, 0x73, 0xb0, 0xd6, 0xfe, 0x28, 0x47, 0x47, 0xfe, 0x51,
	0x1a, 0xe4, 0xa4, 0xcf, 0xf2, 0xb7, 0x3e, 0x65, 0x36, 0x49, 0x82, 0x38, 0x15, 0xf7, 0xee, 0xc3,
	0x92, 0x8c, 0xcc, 0x81, 0x20, 0x3c, 0x76, 0x6d, 0x44, 0x99, 0x70, 0xa2, 0x20, 0xa4, 0x41, 0xc9,
	0x3f, 0xb5, 0x0b, 0x1c, 0xfb, 0xab, 0x07, 0xc5, 0x85, 0x83, 0x1b, 0x79, 0xd5, 0xc8, 0xed, 0xbc,
	0x6a, 0x88, 0xd9, 0x6b, 0x23, 0x34, 0x5f, 0x4e, 0x14, 0xd1, 0x43, 0x98, 0xa6, 0x62, 0x73, 0xa9,
	0x14, 0x55, 0x07, 0x8b, 0xf0, 0x17, 0x73, 0x5a, 0x96, 0x92, 0x36, 0x11, 0x83, 0x8d, 0xcc, 0xb5,
	0x11, 0xe5, 0x84, 0xe5, 0x97, 0x14, 0xd1, 0x01, 0x31, 0x29, 0xfe, 0x8a, 0x92, 0xe9, 0x5b, 0x6a,
	0x07, 0xfb, 0x30, 0x9e, 0x2c, 0x25, 0xac, 0xef, 0xb5, 0xd0, 0x72, 0xb2, 0x34, 0xca, 0x32, 0x01,
	0xe5, 0xf3, 0xf0, 0x78, 0x0f, 0xa7, 0x64, 0x23, 0x6e, 0xf6, 0xeb, 0xa5, 0xfc, 0x8d, 0x7e, 0x75,
	0xeb, 0x47, 0xf5, 0x0f, 0xaf, 0xa2, 0x43, 0x23, 0x1d, 0x7f, 0x68, 0x22, 0x03, 0x23, 0xff, 0x4e,
	0x0a, 0x66, 0x05, 0x33, 0xeb, 0x9e, 0xd6, 0xc2, 0xe1, 0x7d, 0xd7, 0x3d, 0xc8, 0xf8, 0xbb, 0xa6,
	0xe8, 0x20, 0x0d, 0xd5, 0x2b, 0x3b, 0x71, 0xa2, 0x84, 0x29, 0x3d, 0x74, 0x0a, 0x0a, 0x9a, 0x69,
	0xf2, 0x5c, 0x1d, 0x76, 0xf2, 0x99, 0xd7, 0x4c, 0x93, 0x65, 0x3f, 0x3f, 0x02, 0xb0, 0x69, 0x3b,
	0x4d, 0xcc, 0x36, 0x6c, 0x2c, 0x73, 0xa8, 0x40, 0x21, 0x84, 0x02, 0xfa, 0x14, 0x9c, 0x66, 0xd5,
	0x34, 0x44, 0xa1, 0xfa, 0x39, 0xbe, 0x3b, 0xd8, 0x71, 0x45, 0x4a, 0x55, 0x5e, 0x99, 0xa3, 0x38,
	0x54, 0xac, 0x75, 0x8e, 0x71, 0x8f, 0x21, 0xc4, 0x99, 0x85, 0x6c, 0xac, 0x59, 0xb8, 0x4c, 0x9c,
	0xe3, 0x3e, 0xc9, 0xf8, 0x51, 0xf1, 0x51, 0x6a, 0xfd, 0xc4, 0x31, 0x24, 0x2f, 0xc9, 0xa7, 0x82,
	0x46, 0x4c, 0x37, 0x43, 0x19, 0x14, 0xf2, 0xff, 0x85, 0x4a, 0x5c, 0xa5, 0xef, 0xfb, 0x84, 0x63,
	0x5b, 0xc5, 0x4b, 0xcb, 0x43, 0xcb, 0x9b, 0xa5, 0x87, 0xf8, 0x2c, 0xf7, 0x9d, 0xd5, 0xcb, 0x7b,
	0x29, 0x98, 0x16, 0x08, 0xf7, 0xb0, 0x63, 0x6c, 0xee, 0x8a, 0xa1, 0xd6, 0x20, 0x47, 0xe4, 0x2d,
	0xec, 0x5a, 0x69, 0xe9, 0xda, 0xcf, 0x07, 0xb5, 0x66, 0xf4, 0x26, 0x6b, 0xb7, 0x6b, 0xe8, 0xd5,
	0xbb, 0x77, 0xeb, 0xb5, 0xfd, 0xbd, 0xf9, 0xb1, 0xdb, 0xd8, 0xd2, 0x0d, 0xab, 0x45, 0x04, 0x46,
	0xcc, 0x1b, 0x21, 0x5c, 0xd7, 0xd1, 0xd7, 0x25, 0x38, 0x19, 0xce, 0xbd, 0xe1, 0xd9, 0x5a, 0x34,
	0x94, 0x9f, 0xa2, 0xa9, 0x1a, 0xb7, 0xf7, 0xf7, 0xe6, 0xa7, 0x6b, 0x11, 0x94, 0x63, 0x26, 0x6e,
	0x4c, 0xeb, 0xfd, 0xd4, 0x74, 0x17, 0x55, 0xe1, 0x04, 0xd1, 0x81, 0xe0, 0x14, 0x9b, 0x25, 0xf3,
	0xb0, 0xec, 0x8a, 0xc9, 0xb6, 0xf6, 0x50, 0x11, 0xe7, 0xd0, 0xb4, 0x22, 0x4e, 0x67, 0x32, 0xb1,
	0x3a, 0xf3, 0xaf, 0x59, 0x98, 0xe9, 0x15, 0x30, 0x1f, 0x5e, 0x1c, 0x3a, 0x2d, 0x64, 0x0b, 0xdf,
	0x87, 0x38, 0xc0, 0x3e, 0x69, 0xf4, 0x10, 0x50, 0xd7, 0xd2, 0x76, 0x34, 0x83, 0xde, 0x89, 0x11,
	0x5f, 0x96, 0xea, 0xd3, 0xa8, 0x83, 0xcc, 0x6c, 0x94, 0xeb, 0xea, 0xdd, 0x80, 0x16, 0x93, 0x05,
	0xef, 0x70, 0xb2, 0xdb, 0x5b, 0x81, 0x7e, 0x2c, 0xc1, 0xe9, 0xb8, 0xf1, 0xf5, 0xbf, 0x9a, 0x05,
	0x21, 0xee, 0x0c, 0xcf, 0x44, 0xbf, 0x4a, 0x44, 0xcf, 0x4e, 0x8f, 0xbc, 0xad, 0xae, 0xe8, 0x07,
	0x52, 0xae, 0xbc, 0x2b, 0xc1, 0x64, 0xdf, 0xd7, 0xa3, 0x06, 0x8c, 0x72, 0x91, 0x4a, 0x7d, 0xdb,
	0x86, 0x01, 0x8d, 0x22, 0x73, 0x05, 0xe3, 0x66, 0x29, 0xa3, 0x1c, 0xb8, 0x59, 0xa9, 0x70, 0x3a,
	0xde, 0x37, 0x24, 0x98, 0x3f, 0x44, 0x10, 0x31, 0x5b, 0xf6, 0x3b, 0xd1, 0xc3, 0xde, 0x63, 0xe5,
	0x87, 0x84, 0xb6, 0x0c, 0x53, 0x80, 0xd6, 0x0c, 0xd7, 0xdb, 0xc0, 0x96, 0x16, 0xdc, 0x3a, 0x90,
	0x15, 0x38, 0x11, 0x81, 0x72, 0xcd, 0x7f, 0x09, 0x72, 0x1e, 0x03, 0x71, 0xa1, 0x3d, 0x9a, 0xe4,
	0x76, 0x52, 0x4c, 0x45, 0xb4, 0x90, 0xbf, 0x2d, 0xc1, 0x28, 0x83, 0xa1, 0x17, 0xa0, 0xc0, 0xa0,
	0xc2, 0x4a, 0x15, 0x2f, 0x9d, 0x8a, 0xf1, 0x78, 0x18, 0x76, 0xbd, 0xa6, 0xe4, 0x19, 0x76, 0x5d,
	0xa7, 0xd7, 0xba, 0x59, 0x4b, 0x7a, 0xb4, 0xc8, 0xe4, 0x0a, 0x0c, 0x44, 0x36, 0x4d, 0x68, 0x0e,
	0xf2, 0xee, 0x03, 0x53, 0xd5, 0x74, 0x5d, 0x38, 0xb7, 0x39, 0xf7, 0x81, 0xb9, 0xa8, 0xeb, 0x0e,
	0x8d, 0x57, 0x77, 0x9a, 0xac, 0x8a, 0xc5, 0x67, 0x73, 0x4e, 0xa7, 0x49, 0xaa, 0xe4, 0x16, 0x31,
	0xf6, 0x9a, 0xfe, 0xaa, 0x63, 0xb7, 0x79, 0xa7, 0x21, 0xf7, 0xf3, 0xfa, 0x70, 0xdc, 0x2e, 0x95,
	0x89, 0x0e, 0xec, 0xef, 0xcd, 0xe7, 0xfb, 0xf9, 0x97, 0x7f, 0x57, 0x22, 0x2b, 0x47, 0x7f, 0x4f,
	0x5c, 0xc0, 0x9f, 0x84, 0x82, 0x83, 0x35, 0x5d, 0xdd, 0x74, 0xec, 0xf6, 0x20, 0x5d, 0x71, 0x9b,
	0xe1, 0x70, 0x8a, 0xe8, 0x2a, 0xe4, 0x68, 0x7b, 0x4d, 0x9c, 0x9f, 0x3c, 0xd2, 0xbb, 0xff, 0xdc,
	0x32, 0x9b, 0xe1, 0x38, 0x12, 0x57, 0x57, 0xac, 0xe9, 0x8b, 0x9e, 0xfc, 0x08, 0x9c, 0xa2, 0xa3,
	0xce, 0xde, 0x30, 0x58, 0xb7, 0xb4, 0x8e, 0xbb, 0x65, 0x07, 0x4a, 0x81, 0xe1, 0x74, 0x7c, 0x35,
	0x67, 0x7e, 0x05, 0x0a, 0xae, 0x00, 0x72, 0xfd, 0x78, 0x22, 0x29, 0xa7, 0x84, 0xe3, 0x52, 0x01,
	0x04, 0x2d, 0xe5, 0xaf, 0x48, 0x50, 0x0a, 0xd7, 0xa1, 0x05, 0x28, 0x8a, 0x5a, 0xff, 0xa8, 0x61,
	0x69, 0x7c, 0x7f, 0x6f, 0x1e, 0x7c, 0xb4, 0x9a, 0x02, 0x02, 0xa5, 0xae, 0xa3, 0x45, 0x28, 0x36,
	0xb5, 0x8e, 0xd7, 0x75, 0x70, 0x48, 0x12, 0x87, 0x87, 0xd3, 0x40, 0x34, 0x5a, 0xf4, 0xe4, 0xd3,
	0x50, 0xd9, 0xd0, 0xb6, 0x71, 0xcf, 0xb7, 0x0a, 0x49, 0x34, 0xe0, 0x54, 0x6c, 0x2d, 0x17, 0xc4,
	0x32, 0xe4, 0x05, 0x37, 0x7c, 0x10, 0x07, 0x96, 0x83, 0xdf, 0x50, 0xbe, 0x0a, 0x73, 0xab, 0xd8,
	0x8b, 0x67, 0x80, 0x4c, 0x83, 0x3e, 0x91, 0x84, 0x45, 0x20, 0xeb, 0x50, 0x89, 0x6b, 0xcd, 0x19,
	0x7c, 0xb5, 0x8f, 0xc1, 0x0b, 0x87, 0xec, 0x1f, 0xc3, 0x54, 0x02, 0x1e, 0xdf, 0x4d, 0xc1, 0x04,
	0xef, 0xc6, 0x8f, 0x35, 0x0c, 0x3d, 0x5a, 0x0f, 0x20, 0x4f, 0x73, 0xc6, 0x45, 0x0a, 0x60, 0x66,
	0xe9, 0x1e, 0xd1, 0xca, 0x9f, 0xef, 0xcd, 0x2f, 0x0f, 0xee, 0xb5, 0xf4, 0xbd, 0xbf, 0xc1, 0x76,
	0xbd, 0xd4, 0x8b, 0xc9, 0xf1, 0x9f, 0x4a, 0x8e, 0xf6, 0x53, 0xd7, 0xd1, 0x3d, 0x18, 0x67, 0x81,
	0x1d, 0xfa, 0x08, 0x41, 0x90, 0xac, 0xb2, 0xd0, 0x3b, 0x5b, 0xc4, 0xf3, 0x2a, 0x01, 0x59, 0x45,
	0xb4, 0xbb, 0x41, 0x56, 0xf0, 0x31, 0x9f, 0xcc, 0xc6, 0x6e, 0x07, 0xcb, 0xdf, 0x4c, 0xd1, 0x5b,
	0x34, 0x5c, 0x1e, 0x5c, 0xd8, 0xff, 0x1b, 0x04, 0xf2, 0x28, 0x94, 0x5c, 0xcf, 0x30, 0x4d, 0x15,
	0x3f, 0x34, 0x5c, 0x4f, 0xa4, 0xf9, 0x17, 0x29, 0x6c, 0x85, 0x82, 0xd0, 0x33, 0x30, 0xe5, 0x62,
	0xc7, 0xd0, 0x4c, 0xe3, 0x2d, 0x7a, 0xce, 0xc5, 0xbf, 0x9b, 0x5b, 0xd2, 0x13, 0x41, 0x9d, 0x2f,
	0x21, 0xf9, 0x6f, 0x52, 0x30, 0xd1, 0xa3, 0x3c, 0xff, 0x1d, 0x93, 0x19, 0x5d, 0x85, 0xac, 0xdb,
	0xd1, 0x2c, 0xe1, 0xb7, 0x3c, 0x3e, 0x80, 0xae, 0x77, 0x34, 0x4b, 0x61, 0x8d, 0xd0, 0x4d, 0xea,
	0xcd, 0x37, 0xb7, 0xd9, 0x43, 0x0f, 0x87, 0x3c, 0x27, 0x10, 0xfd, 0xda, 0xea, 0x3a, 0x6d, 0xc8,
	0xee, 0x6f, 0x71, 0x2a, 0x95, 0x4f, 0x40, 0x31, 0x04, 0x1e, 0x2a, 0xbe, 0xf7, 0x55, 0x09, 0x66,
	0xc8, 0x2a, 0xa7, 0xdf, 0xea, 0xf0, 0xab, 0xcd, 0x62, 0x27, 0x1b, 0x7b, 0x6d, 0xf9, 0x6e, 0x68,
	0xc7, 0xcc, 0xe4, 0x76, 0xf9, 0x70, 0x05, 0xef, 0x23, 0xdd, 0x1b, 0x77, 0x95, 0x7f, 0x9c, 0x81,
	0x62, 0x48, 0x4e, 0xe8, 0x34, 0x14, 0x6c, 0xd1, 0x88, 0xf7, 0x1f, 0x00, 0xd0, 0xe3, 0x7d, 0xda,
	0x5c, 0x8c, 0x55, 0xc1, 0x73, 0x90, 0x23, 0xf2, 0x16, 0x01, 0xc3, 0x0c, 0xbb, 0xbd, 0x4a, 0x3a,
	0x20, 0x3b, 0x0f, 0x52, 0x55, 0xd7, 0xd1, 0x15, 0x18, 0xef, 0x68, 0x0e, 0xb6, 0x3c, 0x55, 0xe0,
	0x66, 0x28, 0x2e, 0x7d, 0x2b, 0xe0, 0x36, 0xad, 0xe1, 0x2d, 0x4a, 0x9d, 0xa0, 0xa4, 0xa3, 0x17,
	0x45, 0x56, 0x41, 0x76, 0x88, 0x24, 0x2b, 0x3f, 0xb3, 0xa0, 0xd4, 0xb2, 0x1d, 0xbb, 0xeb, 0x19,
	0x96, 0x7f, 0x21, 0x30, 0xc3, 0x6e, 0x15, 0xae, 0x0a, 0x78, 0xbd, 0xa6, 0x14, 0x7d, 0xa4, 0xba,
	0x8e, 0xea, 0x30, 0xde, 0x71, 0xec, 0x26, 0x76, 0x5d, 0xac, 0xab, 0x9e, 0xd6, 0x62, 0xd7, 0x7f,
	0xa3, 0x71, 0x9d, 0xbe, 0x75, 0xa0, 0xa3, 0x59, 0x1b, 0x5a, 0x4b, 0x19, 0xf3, 0x5b, 0x6e, 0x68,
	0x2d, 0x17, 0xcd, 0x42, 0x8e, 0x6d, 0x4a, 0x3c, 0x9a, 0x61, 0x94, 0x57, 0x44, 0x11, 0x61, 0x98,
	0xe1, 0x3f, 0x83, 0xe9, 0xa8, 0xb6, 0x6d, 0x1d, 0xd3, 0x6c, 0xa2, 0x23, 0x58, 0xb3, 0x29, 0x4e,
	0x2e, 0x02, 0x45, 0x9f, 0x83, 0xc9, 0xe6, 0x96, 0x61, 0xea, 0x0e, 0xb6, 0x54, 0x5f, 0x9d, 0xe0,
	0xd0, 0xb3, 0xfa, 0x78, 0x3d, 0x55, 0xca, 0x82, 0x96, 0x80, 0xc8, 0xff, 0x98, 0x82, 0x1c, 0xff,
	0xf6, 0x98, 0xc9, 0x50, 0x86, 0xf4, 0x8e, 0x66, 0xf2, 0xa9, 0x40, 0x7e, 0x52, 0x81, 0x68, 0xe1,
	0xb4, 0x34, 0x51, 0x24, 0x73, 0xc0, 0x34, 0xac, 0x6d, 0x6e, 0x92, 0xe8, 0xef, 0xd0, 0x85, 0xff,
	0x6c, 0xf8, 0xc2, 0x3f, 0x51, 0xda, 0x2d, 0xa3, 0xb5, 0x65, 0x1a, 0xad, 0x2d, 0x8f, 0x5f, 0x33,
	0x0b, 0x00, 0xa4, 0x0f, 0xc3, 0xda, 0xc2, 0x8e, 0x7f, 0xeb, 0x5e, 0x14, 0x49, 0x3b, 0xfe, 0x93,
	0xa7, 0x7c, 0xe5, 0x95, 0x00, 0x40, 0xec, 0x68, 0xc7, 0xb1, 0x3b, 0x5a, 0x4b, 0xf3, 0xb0, 0xda,
	0xed, 0xd0, 0x81, 0xc8, 0x2b, 0x45, 0x1f, 0x76, 0xb7, 0x83, 0x2e, 0xc0, 0x64, 0xd3, 0xee, 0x18,
	0x98, 0x39, 0x79, 0x2a, 0x15, 0x07, 0x4d, 0xe0, 0xca, 0x2b, 0x13, 0xac, 0x82, 0x78, 0x72, 0xcb,
	0x04, 0x4c, 0x1c, 0x09, 0x21, 0xae, 0xd9, 0xe2, 0xa1, 0x0e, 0x15, 0x6d, 0x23, 0xb4, 0xc8, 0x6f,
	0x28, 0x5f, 0x82, 0x52, 0xb8, 0x66, 0x10, 0x19, 0xcb, 0x3f, 0x4b, 0xc1, 0xe9, 0x75, 0x7f, 0x21,
	0x0b, 0x2d, 0x71, 0x62, 0x95, 0x0f, 0xaf, 0x51, 0xd2, 0xaf, 0x67, 0x8d, 0x6a, 0x07, 0x06, 0x82,
	0xd9, 0x91, 0x0d, 0xde, 0xe3, 0xd2, 0x71, 0x7a, 0x64, 0xe6, 0x22, 0xc6, 0xd4, 0x44, 0x7c, 0x04,
	0x3a, 0xab, 0x8e, 0xed, 0x23, 0x90, 0xa2, 0x3c, 0x0f, 0x8f, 0x1c, 0x20, 0x59, 0x9e, 0x10, 0xfd,
	0x53, 0x09, 0x4a, 0xaf, 0x62, 0x8d, 0x2c, 0x5e, 0xaf, 0x9a, 0xc4, 0x02, 0xbc, 0x00, 0xb3, 0x86,
	0xab, 0xda, 0x0d, 0x32, 0xd0, 0x5a, 0xc3, 0xa0, 0x39, 0x3e, 0xe4, 0xb7, 0xd1, 0xc4, 0x3c, 0xb9,
	0x7a, 0xc6, 0x70, 0x6f, 0x85, 0xab, 0xd7, 0x59, 0x2d, 0x7a, 0x05, 0x1e, 0x69, 0x6a, 0x96, 0xba,
	0x63, 0xe0, 0x37, 0xd5, 0xed, 0x1d, 0x95, 0x9d, 0x3d, 0xa9, 0xba, 0xe6, 0x6e, 0x35, 0x6c, 0xcd,
	0xd1, 0x45, 0xc8, 0x6e, 0xae, 0xa9, 0x59, 0xf7, 0x0c, 0xfc, 0xe6, 0x6b, 0x3b, 0xec, 0x7c, 0xac,
	0xe6, 0x23, 0xa0, 0x1a, 0xcc, 0xeb, 0x86, 0x4b, 0x03, 0x10, 0xdb, 0x3b, 0xec, 0xe5, 0x17, 0x55,
	0xd3, 0x77, 0x34, 0xab, 0x49, 0xf3, 0x69, 0x1a, 0xdd, 0x16, 0xf7, 0x15, 0x4e, 0x71, 0xb4, 0xd7,
	0x76, 0xe8, 0xa3, 0x2e, 0x8b, 0x1c, 0xa7, 0x46, 0x50, 0x2e, 0xbc, 0x06, 0x33, 0xf1, 0x8f, 0xc1,
	0x44, 0x6f, 0x3e, 0x15, 0x21, 0xb7, 0xbc, 0x76, 0x77, 0x7d, 0x63, 0x45, 0x29, 0x4b, 0xa8, 0x04,
	0xf9, 0xda, 0xe2, 0xc6, 0xe2, 0xd2, 0xe2, 0xfa, 0x4a, 0x39, 0x85, 0x0a, 0x90, 0xdd, 0x58, 0x5c,
	0x5a, 0x5b, 0x29, 0xa7, 0x2f, 0x7d, 0xfb, 0x22, 0x64, 0x17, 0xf5, 0xb6, 0x61, 0x21, 0x0f, 0xb2,
	0xf4, 0xce, 0x3d, 0x7a, 0xe2, 0xf0, 0x5b, 0xf9, 0x54, 0x6d, 0x2b, 0xe7, 0x07, 0xbd, 0xbe, 0x2f,
	0xcf, 0x7e, 0xe5, 0xef, 0xfe, 0xe5, 0x5b, 0x29, 0x84, 0xca, 0x0b, 0x2a, 0x7d, 0xbc, 0x6f, 0x61,
	0xe7, 0x99, 0x05, 0x7a, 0x8d, 0x1f, 0x7d, 0x4d, 0x82, 0x82, 0xff, 0xb8, 0x1a, 0xba, 0x38, 0xc0,
	0xab, 0x55, 0x7e, 0xf7, 0x4f, 0x0e, 0x86, 0xcc, 0x59, 0x38, 0x4d, 0x59, 0x98, 0x41, 0x53, 0x21,
	0x16, 0xfc, 0xf7, 0xda, 0xd0, 0xef, 0x4b, 0x30, 0xd1, 0xf3, 0x2c, 0x16, 0x7a, 0x66, 0x98, 0x27,
	0xb4, 0x18, 0x4b, 0x97, 0x86, 0x7f, 0x75, 0x4b, 0x7e, 0x82, 0x32, 0xf6, 0x28, 0x9a, 0x8f, 0x63,
	0x6c, 0xe1, 0x6d, 0xf1, 0xf3, 0x1d, 0xf4, 0xc7, 0x12, 0x94, 0xc2, 0x2f, 0x21, 0xa1, 0xea, 0xc0,
	0x4f, 0x26, 0x31, 0xee, 0x16, 0x86, 0x7c, 0x62, 0x49, 0xbe, 0x42, 0x59, 0x7b, 0x1a, 0x55, 0x0f,
	0x61, 0x6d, 0x81, 0x3d, 0x3d, 0xb6, 0xf0, 0x36, 0xfd, 0x4b, 0x39, 0x85, 0xe0, 0xc1, 0x08, 0xf4,
	0xe4, 0x80, 0xef, 0x4a, 0x30, 0x2e, 0x87, 0x7b, 0x85, 0x42, 0xbe, 0x4a, 0x79, 0xbc, 0x82, 0x9e,
	0x1d, 0x8e, 0xc7, 0x05, 0xf6, 0xde, 0xc9, 0x6f, 0x4b, 0x30, 0x16, 0x79, 0x83, 0x03, 0x25, 0x09,
	0x29, 0xee, 0x19, 0x8f, 0xca, 0xd3, 0x83, 0x37, 0xe0, 0x2c, 0x9f, 0xa5, 0x2c, 0x57, 0xd0, 0x6c,
	0x88, 0x65, 0xcb, 0xb6, 0x18, 0x83, 0x94, 0x89, 0x87, 0x30, 0xca, 0x9e, 0x83, 0x40, 0xe7, 0x07,
	0x78, 0x31, 0x82, 0xf1, 0xf1, 0xf1, 0x81, 0xdf, 0x96, 0x90, 0xe7, 0x28, 0x03, 0x27, 0xd0, 0x64,
	0x88, 0x01, 0x7e, 0x96, 0x49, 0xe6, 0xa3, 0xff, 0x9e, 0x41, 0xe2, 0x7c, 0xec, 0x7d, 0x61, 0x21,
	0x71, 0x3e, 0xf6, 0x3f, 0x91, 0xc0, 0xe7, 0xa3, 0x1c, 0xe6, 0xa1, 0x6b, 0x90, 0xe1, 0x7a, 0x51,
	0xba, 0x80, 0xbe, 0x2c, 0x41, 0x61, 0x75, 0x20, 0x36, 0x56, 0x87, 0x61, 0xa3, 0xef, 0x01, 0x81,
	0x58, 0x51, 0x30, 0x36, 0xd0, 0x17, 0x20, 0xc7, 0x4f, 0xb8, 0x50, 0x92, 0x6c, 0xa3, 0xcf, 0x0d,
	0x54, 0x2e, 0x0c, 0x82, 0xca, 0x3b, 0xaf, 0xd0, 0xce, 0xa7, 0x10, 0x0a, 0x75, 0xce, 0x9f, 0x1d,
	0x40, 0x5f, 0x92, 0x20, 0x2f, 0x2e, 0x0a, 0xa1, 0x0b, 0x03, 0xdd, 0x26, 0x62, 0x0c, 0x5c, 0x1c,
	0xe2, 0xe6, 0x91, 0x7c, 0x8a, 0x72, 0x30, 0x8d, 0x4e, 0x84, 0x38, 0x70, 0x45, 0xaf, 0x5f, 0x95,
	0x60, 0x94, 0xdd, 0x2f, 0x4a, 0x54, 0xc3, 0xc8, 0x4d, 0xa5, 0x44, 0x35, 0xec, 0xb9, 0xac, 0xf4,
	0x31, 0xda, 0xf9, 0x99, 0x88, 0xec, 0xb7, 0x28, 0xca, 0xfd, 0x02, 0xca, 0xf1, 0x9f, 0x54, 0x10,
	0xe2, 0x72, 0x4d, 0xa2, 0x20, 0x7a, 0x2e, 0x3e, 0x25, 0x0a, 0xa2, 0xf7, 0xd6, 0x51, 0xac, 0x20,
	0x44, 0xd0, 0x17, 0x75, 0x20, 0x73, 0xdd, 0x6e, 0xb8, 0xe8, 0x90, 0x8b, 0x33, 0x7e, 0xcf, 0x4f,
	0x1c, 0x8a, 0xc7, 0x7b, 0x3d, 0x49, 0x7b, 0x9d, 0x44, 0x13, 0xa1, 0x5e, 0xe9, 0x75, 0x9b, 0x1d,
	0x48, 0x5f, 0xb7, 0x1b, 0xe8, 0xb1, 0xc3, 0x72, 0xd7, 0x59, 0x7f, 0x03, 0x5e, 0xe8, 0x89, 0x35,
	0x3c, 0xf4, 0x91, 0xdb, 0xb7, 0xd9, 0x8d, 0x9b, 0x77, 0xe8, 0xf4, 0xf7, 0x33, 0xab, 0x13, 0xe7,
	0x5d, 0x6f, 0x56, 0x77, 0xe2, 0xbc, 0xeb, 0x4b, 0xd6, 0x8e, 0x5d, 0x8e, 0xfd, 0x84, 0x6d, 0xca,
	0x86, 0x9f, 0x5f, 0x9a, 0xc8, 0x46, 0x6f, 0x52, 0x6c, 0x22, 0x1b, 0x7d, 0x79, 0xb1, 0xb1, 0x6c,
	0xd0, 0xbc, 0x58, 0x7a, 0x20, 0xfb, 0x39, 0xc8, 0xb2, 0xd7, 0x35, 0x92, 0x06, 0x34, 0xfc, 0x7a,
	0x47, 0xa2, 0x4b, 0x14, 0x79, 0x5f, 0x43, 0x1e, 0x79, 0x5a, 0x42, 0xbf, 0x21, 0xc1, 0x54, 0xdc,
	0x3d, 0x78, 0x74, 0x65, 0xe8, 0x8b, 0xf3, 0xac, 0xfb, 0xe7, 0x8f, 0x78, 0xe1, 0x5e, 0x1e, 0x41,
	0x6f, 0x42, 0x29, 0x8c, 0x91, 0xe8, 0x5c, 0xc4, 0xdc, 0x30, 0xaf, 0x3c, 0x77, 0xa4, 0x2b, 0xae,
	0xf2, 0x08, 0xb1, 0x32, 0xa8, 0x1f, 0x01, 0x3d, 0x3b, 0x24, 0xbd, 0x63, 0x72, 0xf1, 0x07, 0x12,
	0xe4, 0x45, 0x5e, 0x76, 0xa2, 0x95, 0xe9, 0xc9, 0xdb, 0x4f, 0xb4, 0x32, 0xbd, 0x89, 0xde, 0xf2,
	0xcb, 0x54, 0xdd, 0x9e, 0x8f, 0x58, 0x19, 0x7a, 0xba, 0x65, 0xda, 0xad, 0xfb, 0x67, 0xd1, 0x99,
	0x18, 0xf0, 0xc2, 0xdb, 0x22, 0xf5, 0xeb, 0x1d, 0xe2, 0xa5, 0x96, 0x7b, 0x73, 0x0e, 0xd1, 0xa5,
	0xa1, 0x12, 0x14, 0x19, 0xd3, 0x97, 0x8f, 0x90, 0xd4, 0xe8, 0x9b, 0xeb, 0xd3, 0x3d, 0x9e, 0x96,
	0xaa, 0x87, 0xd9, 0xf9, 0x8e, 0x04, 0x93, 0x8b, 0xa6, 0x19, 0xcd, 0x0d, 0x44, 0x4f, 0x0f, 0x91,
	0x46, 0xc8, 0x58, 0x7c, 0x66, 0xe8, 0xc4, 0x43, 0xf9, 0x51, 0xca, 0xe0, 0x29, 0x34, 0x17, 0x62,
	0x90, 0xed, 0xd2, 0xfc, 0x2c, 0xc7, 0xf7, 0x24, 0xb2, 0x7f, 0x0f, 0xd2, 0xaf, 0x12, 0xd5, 0x3c,
	0x26, 0x7d, 0x2b, 0xd1, 0x87, 0x8e, 0xcb, 0xeb, 0x92, 0xe7, 0x29, 0x53, 0x73, 0xe8, 0x64, 0x78,
	0x8d, 0x27, 0x88, 0x3c, 0x69, 0x8b, 0xb8, 0xa0, 0xa5, 0x70, 0x3a, 0x5c, 0x22, 0x4b, 0x31, 0xf9,
	0x88, 0x89, 0x2c, 0xc5, 0xe5, 0xd9, 0xc9, 0xe7, 0x28, 0x4b, 0x8f, 0xc8, 0xe1, 0x65, 0x00, 0x33,
	0x44, 0x76, 0x30, 0x4e, 0x3c, 0x30, 0x05, 0x8a, 0xeb, 0xd8, 0xd2, 0x5f, 0xbb, 0xb7, 0xa4, 0x79,
	0xcd, 0x2d, 0x34, 0x1f, 0x73, 0x70, 0x46, 0x6b, 0x04, 0x17, 0x67, 0x0f, 0x46, 0xf0, 0x27, 0xd9,
	0xf7, 0x24, 0x98, 0x8a, 0x3b, 0xf4, 0x4a, 0xb4, 0x77, 0x09, 0x87, 0x68, 0x89, 0xf6, 0x2e, 0xe9,
	0x74, 0x4d, 0x96, 0xa9, 0x08, 0x4e, 0xa3, 0x4a, 0x48, 0x04, 0x2c, 0x04, 0xe3, 0x1f, 0x9d, 0xa1,
	0xef, 0x4a, 0x70, 0x22, 0xe6, 0x60, 0x0a, 0x25, 0xbf, 0x54, 0x7b, 0xd0, 0x31, 0x57, 0xe5, 0xca,
	0xb0, 0xcd, 0xa2, 0xac, 0xca, 0x49, 0xac, 0xfe, 0xb9, 0x04, 0xa8, 0xff, 0x84, 0x2a, 0xd1, 0x86,
	0x1e, 0x78, 0x1c, 0x96, 0x68, 0x43, 0x0f, 0x3e, 0x06, 0x93, 0x9f, 0xa6, 0x7c, 0x5e, 0x40, 0xe7,
	0x0f, 0xe6, 0x73, 0xe1, 0xed, 0xd0, 0x69, 0xc5, 0x3b, 0xc4, 0xc9, 0xcf, 0x8b, 0x03, 0x9e, 0x44,
	0x9b, 0xdb, 0x73, 0x2a, 0x56, 0xb9, 0x38, 0x10, 0x6e, 0xc2, 0x46, 0x83, 0x3d, 0xab, 0x44, 0xd4,
	0xfc, 0x2f, 0x24, 0x98, 0x8e, 0x8d, 0x20, 0xa1, 0xe7, 0x93, 0xfd, 0xe8, 0x03, 0xa3, 0x79, 0x95,
	0x17, 0x86, 0x6f, 0xc8, 0x59, 0xbd, 0x48, 0x59, 0x7d, 0x4c, 0x3e, 0xdb, 0xe3, 0x8d, 0x93, 0x16,
	0x7e, 0xdc, 0xcb, 0xdb, 0xed, 0xd0, 0x09, 0xfa, 0x7b, 0x52, 0x90, 0x36, 0xd5, 0x9f, 0x16, 0x89,
	0xae, 0x0e, 0x9d, 0x3b, 0x18, 0x3a, 0xa5, 0xaf, 0xbc, 0x7c, 0xc4, 0xd6, 0x21, 0xe7, 0xe6, 0xfb,
	0x12, 0xcc, 0x1f, 0x92, 0xcf, 0x87, 0x16, 0x07, 0xef, 0xe6, 0x80, 0xb4, 0xc1, 0xca, 0xd2, 0x71,
	0x48, 0x84, 0xd8, 0xfd, 0x92, 0x04, 0x93, 0x7d, 0x79, 0x6d, 0xe8, 0xf2, 0x00, 0xd4, 0x7b, 0xf3,
	0x03, 0x2b, 0xcf, 0x0e, 0xd7, 0x28, 0xe2, 0x09, 0xf5, 0x27, 0xc2, 0xa1, 0x41, 0xc8, 0xf5, 0x25,
	0xd5, 0x25, 0xce, 0xe2, 0x83, 0xb3, 0xed, 0xa8, 0x23, 0x38, 0x1e, 0xcd, 0x37, 0x4a, 0x5c, 0xbc,
	0x63, 0xd3, 0xe6, 0x12, 0x17, 0xef, 0xf8, 0x64, 0x26, 0x79, 0x04, 0x7d, 0x5d, 0x82, 0x62, 0x28,
	0x4f, 0x06, 0x3d, 0x75, 0x98, 0x71, 0x8f, 0x64, 0xd9, 0x54, 0xaa, 0x83, 0xa2, 0x27, 0x6c, 0xbe,
	0x79, 0x76, 0x0d, 0x1f, 0x89, 0xde, 0xc4, 0x92, 0x43, 0x46, 0xe2, 0x80, 0x8c, 0x97, 0x43, 0x46,
	0xe2, 0xa0, 0xec, 0x15, 0x79, 0x64, 0xe9, 0xde, 0xfb, 0xff, 0x7c, 0x66, 0xe4, 0xfd, 0xfd, 0x33,
	0xd2, 0x4f, 0xf7, 0xcf, 0x48, 0x3f, 0xdb, 0x3f, 0x23, 0xfd, 0xd3, 0xfe, 0x19, 0xe9, 0xbd, 0x0f,
	0xce, 0x8c, 0xfc, 0xf4, 0x83, 0x33, 0x23, 0x3f, 0xfb, 0xe0, 0xcc, 0xc8, 0xfd, 0xc1, 0xf2, 0xfe,
	0x7b, 0xfe, 0xbf, 0x92, 0xc6, 0x28, 0x3d, 0xa8, 0xbb, 0xfc, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x3f, 0xe4, 0x50, 0xc0, 0x59, 0x65, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdminClient interface {
	// URL: /_admin/v1/users
	Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// URL: /_admin/v1/databases
	Databases(ctx context.Context, in *DatabasesRequest, opts ...grpc.CallOption) (*DatabasesResponse, error)
	// Example URL: /_admin/v1/databases/system
	DatabaseDetails(ctx context.Context, in *DatabaseDetailsRequest, opts ...grpc.CallOption) (*DatabaseDetailsResponse, error)
	// Example URL: /_admin/v1/databases/system/tables/ui
	TableDetails(ctx context.Context, in *TableDetailsRequest, opts ...grpc.CallOption) (*TableDetailsResponse, error)
	// Example URL: /_admin/v1/databases/system/tables/ui/stats
	TableStats(ctx context.Context, in *TableStatsRequest, opts ...grpc.CallOption) (*TableStatsResponse, error)
	// Example URL: /_admin/v1/nontablestats
	NonTableStats(ctx context.Context, in *NonTableStatsRequest, opts ...grpc.CallOption) (*NonTableStatsResponse, error)
	// Example URLs:
	// Example URLs:
	// - /_admin/v1/events
	// - /_admin/v1/events?limit=100
	// - /_admin/v1/events?type=create_table
	// - /_admin/v1/events?type=create_table&limit=100
	Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (*EventsResponse, error)
	// This requires a POST. Because of the libraries we're using, the POST body
	// must be in the following format:
	//
	// {"key_values":
	//   { "key1": "base64_encoded_value1"},
	//   ...
	//   { "keyN": "base64_encoded_valueN"},
	// }
	//
	// Note that all keys are quoted strings and that all values are base64-
	// encoded.
	//
	// Together, SetUIData and GetUIData provide access to a "cookie jar" for the
	// admin UI. The structure of the underlying data is meant to be opaque to the
	// server.
	SetUIData(ctx context.Context, in *SetUIDataRequest, opts ...grpc.CallOption) (*SetUIDataResponse, error)
	// Example URLs:
	// - /_admin/v1/uidata?keys=MYKEY
	// - /_admin/v1/uidata?keys=MYKEY1&keys=MYKEY2
	//
	// Yes, it's a little odd that the query parameter is named "keys" instead of
	// "key". I would've preferred that the URL parameter be named "key". However,
	// it's clearer for the protobuf field to be named "keys," which makes the URL
	// parameter "keys" as well.
	GetUIData(ctx context.Context, in *GetUIDataRequest, opts ...grpc.CallOption) (*GetUIDataResponse, error)
	// Cluster returns metadata for the cluster.
	Cluster(ctx context.Context, in *ClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error)
	// Settings returns the cluster-wide settings for the cluster.
	Settings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*SettingsResponse, error)
	// Health returns liveness for the node target of the request.
	// API: PUBLIC
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// Liveness returns the liveness state of all nodes on the cluster.
	Liveness(ctx context.Context, in *LivenessRequest, opts ...grpc.CallOption) (*LivenessResponse, error)
	// Jobs returns the job records for all jobs of the given status and type.
	Jobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsResponse, error)
	// Job returns the job record for the job of the given job_id.
	Job(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (*JobResponse, error)
	// Locations returns the locality location records.
	Locations(ctx context.Context, in *LocationsRequest, opts ...grpc.CallOption) (*LocationsResponse, error)
	// QueryPlan returns the query plans for a SQL string.
	QueryPlan(ctx context.Context, in *QueryPlanRequest, opts ...grpc.CallOption) (*QueryPlanResponse, error)
	// Drain puts the node into the specified drain mode(s) and optionally
	// instructs the process to terminate.
	// We do not expose this via HTTP unless we have a way to authenticate
	// + authorize streaming RPC connections. See #42567.
	Drain(ctx context.Context, in *DrainRequest, opts ...grpc.CallOption) (Admin_DrainClient, error)
	// DecommissionPreCheck requests that the server execute preliminary checks
	// to evaluate the possibility of successfully decommissioning a given node.
	DecommissionPreCheck(ctx context.Context, in *DecommissionPreCheckRequest, opts ...grpc.CallOption) (*DecommissionPreCheckResponse, error)
	// Decommission puts the node(s) into the specified decommissioning state.
	// If this ever becomes exposed via HTTP, ensure that it performs
	// authorization. See #42567.
	Decommission(ctx context.Context, in *DecommissionRequest, opts ...grpc.CallOption) (*DecommissionStatusResponse, error)
	// DecommissionStatus retrieves the decommissioning status of the specified nodes.
	// If this ever becomes exposed via HTTP, ensure that it performs
	// authorization. See #42567.
	DecommissionStatus(ctx context.Context, in *DecommissionStatusRequest, opts ...grpc.CallOption) (*DecommissionStatusResponse, error)
	// URL: /_admin/v1/rangelog
	// URL: /_admin/v1/rangelog?limit=100
	// URL: /_admin/v1/rangelog/1
	// URL: /_admin/v1/rangelog/1?limit=100
	RangeLog(ctx context.Context, in *RangeLogRequest, opts ...grpc.CallOption) (*RangeLogResponse, error)
	DataDistribution(ctx context.Context, in *DataDistributionRequest, opts ...grpc.CallOption) (*DataDistributionResponse, error)
	// URL: /_admin/v1/metricmetadata
	AllMetricMetadata(ctx context.Context, in *MetricMetadataRequest, opts ...grpc.CallOption) (*MetricMetadataResponse, error)
	// URL: /_admin/v1/chartcatalog
	ChartCatalog(ctx context.Context, in *ChartCatalogRequest, opts ...grpc.CallOption) (*ChartCatalogResponse, error)
	// EnqueueRange runs the specified range through the specified queue on the
	// range's leaseholder store, returning the detailed trace and error
	// information from doing so. Parameters must be provided in the body of the
	// POST request.
	// For example:
	//
	// {
	//   "queue": "raftlog",
	//   "rangeId": 10
	// }
	EnqueueRange(ctx context.Context, in *EnqueueRangeRequest, opts ...grpc.CallOption) (*EnqueueRangeResponse, error)
	// SendKVBatch proxies the given BatchRequest into KV, returning the
	// response. It is used by the CLI `debug send-kv-batch` command.
	SendKVBatch(ctx context.Context, in *kvpb.BatchRequest, opts ...grpc.CallOption) (*kvpb.BatchResponse, error)
	// ListTracingSnapshots retrieves the list of snapshots of the Active Spans
	// Registry that the node currently has in memory. A new snapshot can be
	// captured with TakeTracingSnapshots.
	ListTracingSnapshots(ctx context.Context, in *ListTracingSnapshotsRequest, opts ...grpc.CallOption) (*ListTracingSnapshotsResponse, error)
	// TakeTracingSnapshot captures a new snapshot of the Active Spans Registry.
	// The new snapshot is returned, and also made available through
	// ListTracingSnapshots.
	TakeTracingSnapshot(ctx context.Context, in *TakeTracingSnapshotRequest, opts ...grpc.CallOption) (*TakeTracingSnapshotResponse, error)
	// GetTracingSnapshot returns a snapshot of the tracing spans in the active
	// spans registry previously generated through TakeTracingSnapshots.
	GetTracingSnapshot(ctx context.Context, in *GetTracingSnapshotRequest, opts ...grpc.CallOption) (*GetTracingSnapshotResponse, error)
	// GetTrace returns the trace with a specified ID. Depending on the request,
	// the trace is returned either from a snapshot that was previously taken, or
	// directly from the active spans registry.
	GetTrace(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (*GetTraceResponse, error)
	// SetTraceRecordingType sets the recording mode of all or some of the spans
	// in a trace.
	SetTraceRecordingType(ctx context.Context, in *SetTraceRecordingTypeRequest, opts ...grpc.CallOption) (*SetTraceRecordingTypeResponse, error)
	// RecoveryCollectReplicaInfo retrieves information about:
	// 1. range descriptors contained in cluster meta ranges if meta ranges
	//    are readable;
	// 2. replica information from all live nodes that have connection to
	//    the target node.
	RecoveryCollectReplicaInfo(ctx context.Context, in *RecoveryCollectReplicaInfoRequest, opts ...grpc.CallOption) (Admin_RecoveryCollectReplicaInfoClient, error)
	// RecoveryCollectLocalReplicaInfo retrieve information about all local
	// replicas in all stores on the node.
	RecoveryCollectLocalReplicaInfo(ctx context.Context, in *RecoveryCollectLocalReplicaInfoRequest, opts ...grpc.CallOption) (Admin_RecoveryCollectLocalReplicaInfoClient, error)
	// RecoveryStagePlan stages recovery plan on target or all nodes in cluster
	// depending on request content and marks nodes deleted in the plan as
	// decommissioned in each node's local node tombstone storage.
	RecoveryStagePlan(ctx context.Context, in *RecoveryStagePlanRequest, opts ...grpc.CallOption) (*RecoveryStagePlanResponse, error)
	// RecoveryNodeStatus retrieves loss of quorum recovery status of a single
	// node.
	RecoveryNodeStatus(ctx context.Context, in *RecoveryNodeStatusRequest, opts ...grpc.CallOption) (*RecoveryNodeStatusResponse, error)
	// RecoveryVerify verifies that recovery plan is applied on all necessary
	// nodes, ranges are available and nodes removed in plan are marked as
	// decommissioned.
	RecoveryVerify(ctx context.Context, in *RecoveryVerifyRequest, opts ...grpc.CallOption) (*RecoveryVerifyResponse, error)
	// ListTenants returns a list of active tenants in the cluster.
	ListTenants(ctx context.Context, in *ListTenantsRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error)
	// ReadFromTenantInfo returns the tenant from which the requesting tenant
	// should read, if any.
	ReadFromTenantInfo(ctx context.Context, in *ReadFromTenantInfoRequest, opts ...grpc.CallOption) (*ReadFromTenantInfoResponse, error)
}

type adminClient struct {
	cc *grpc.ClientConn
}

func NewAdminClient(cc *grpc.ClientConn) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Users", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Databases(ctx context.Context, in *DatabasesRequest, opts ...grpc.CallOption) (*DatabasesResponse, error) {
	out := new(DatabasesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Databases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) DatabaseDetails(ctx context.Context, in *DatabaseDetailsRequest, opts ...grpc.CallOption) (*DatabaseDetailsResponse, error) {
	out := new(DatabaseDetailsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/DatabaseDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) TableDetails(ctx context.Context, in *TableDetailsRequest, opts ...grpc.CallOption) (*TableDetailsResponse, error) {
	out := new(TableDetailsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/TableDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) TableStats(ctx context.Context, in *TableStatsRequest, opts ...grpc.CallOption) (*TableStatsResponse, error) {
	out := new(TableStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/TableStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) NonTableStats(ctx context.Context, in *NonTableStatsRequest, opts ...grpc.CallOption) (*NonTableStatsResponse, error) {
	out := new(NonTableStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/NonTableStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (*EventsResponse, error) {
	out := new(EventsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Events", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) SetUIData(ctx context.Context, in *SetUIDataRequest, opts ...grpc.CallOption) (*SetUIDataResponse, error) {
	out := new(SetUIDataResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/SetUIData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetUIData(ctx context.Context, in *GetUIDataRequest, opts ...grpc.CallOption) (*GetUIDataResponse, error) {
	out := new(GetUIDataResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/GetUIData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Cluster(ctx context.Context, in *ClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error) {
	out := new(ClusterResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Cluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Settings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Settings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Health", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Liveness(ctx context.Context, in *LivenessRequest, opts ...grpc.CallOption) (*LivenessResponse, error) {
	out := new(LivenessResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Liveness", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Jobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsResponse, error) {
	out := new(JobsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Jobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Job(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (*JobResponse, error) {
	out := new(JobResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Job", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Locations(ctx context.Context, in *LocationsRequest, opts ...grpc.CallOption) (*LocationsResponse, error) {
	out := new(LocationsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Locations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) QueryPlan(ctx context.Context, in *QueryPlanRequest, opts ...grpc.CallOption) (*QueryPlanResponse, error) {
	out := new(QueryPlanResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/QueryPlan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Drain(ctx context.Context, in *DrainRequest, opts ...grpc.CallOption) (Admin_DrainClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Admin_serviceDesc.Streams[0], "/cockroach.server.serverpb.Admin/Drain", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminDrainClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Admin_DrainClient interface {
	Recv() (*DrainResponse, error)
	grpc.ClientStream
}

type adminDrainClient struct {
	grpc.ClientStream
}

func (x *adminDrainClient) Recv() (*DrainResponse, error) {
	m := new(DrainResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *adminClient) DecommissionPreCheck(ctx context.Context, in *DecommissionPreCheckRequest, opts ...grpc.CallOption) (*DecommissionPreCheckResponse, error) {
	out := new(DecommissionPreCheckResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/DecommissionPreCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Decommission(ctx context.Context, in *DecommissionRequest, opts ...grpc.CallOption) (*DecommissionStatusResponse, error) {
	out := new(DecommissionStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/Decommission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) DecommissionStatus(ctx context.Context, in *DecommissionStatusRequest, opts ...grpc.CallOption) (*DecommissionStatusResponse, error) {
	out := new(DecommissionStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/DecommissionStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RangeLog(ctx context.Context, in *RangeLogRequest, opts ...grpc.CallOption) (*RangeLogResponse, error) {
	out := new(RangeLogResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/RangeLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) DataDistribution(ctx context.Context, in *DataDistributionRequest, opts ...grpc.CallOption) (*DataDistributionResponse, error) {
	out := new(DataDistributionResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/DataDistribution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) AllMetricMetadata(ctx context.Context, in *MetricMetadataRequest, opts ...grpc.CallOption) (*MetricMetadataResponse, error) {
	out := new(MetricMetadataResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/AllMetricMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ChartCatalog(ctx context.Context, in *ChartCatalogRequest, opts ...grpc.CallOption) (*ChartCatalogResponse, error) {
	out := new(ChartCatalogResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/ChartCatalog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) EnqueueRange(ctx context.Context, in *EnqueueRangeRequest, opts ...grpc.CallOption) (*EnqueueRangeResponse, error) {
	out := new(EnqueueRangeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/EnqueueRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) SendKVBatch(ctx context.Context, in *kvpb.BatchRequest, opts ...grpc.CallOption) (*kvpb.BatchResponse, error) {
	out := new(kvpb.BatchResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/SendKVBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ListTracingSnapshots(ctx context.Context, in *ListTracingSnapshotsRequest, opts ...grpc.CallOption) (*ListTracingSnapshotsResponse, error) {
	out := new(ListTracingSnapshotsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/ListTracingSnapshots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) TakeTracingSnapshot(ctx context.Context, in *TakeTracingSnapshotRequest, opts ...grpc.CallOption) (*TakeTracingSnapshotResponse, error) {
	out := new(TakeTracingSnapshotResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/TakeTracingSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetTracingSnapshot(ctx context.Context, in *GetTracingSnapshotRequest, opts ...grpc.CallOption) (*GetTracingSnapshotResponse, error) {
	out := new(GetTracingSnapshotResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/GetTracingSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetTrace(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (*GetTraceResponse, error) {
	out := new(GetTraceResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/GetTrace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) SetTraceRecordingType(ctx context.Context, in *SetTraceRecordingTypeRequest, opts ...grpc.CallOption) (*SetTraceRecordingTypeResponse, error) {
	out := new(SetTraceRecordingTypeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/SetTraceRecordingType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RecoveryCollectReplicaInfo(ctx context.Context, in *RecoveryCollectReplicaInfoRequest, opts ...grpc.CallOption) (Admin_RecoveryCollectReplicaInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Admin_serviceDesc.Streams[1], "/cockroach.server.serverpb.Admin/RecoveryCollectReplicaInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminRecoveryCollectReplicaInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Admin_RecoveryCollectReplicaInfoClient interface {
	Recv() (*RecoveryCollectReplicaInfoResponse, error)
	grpc.ClientStream
}

type adminRecoveryCollectReplicaInfoClient struct {
	grpc.ClientStream
}

func (x *adminRecoveryCollectReplicaInfoClient) Recv() (*RecoveryCollectReplicaInfoResponse, error) {
	m := new(RecoveryCollectReplicaInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *adminClient) RecoveryCollectLocalReplicaInfo(ctx context.Context, in *RecoveryCollectLocalReplicaInfoRequest, opts ...grpc.CallOption) (Admin_RecoveryCollectLocalReplicaInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Admin_serviceDesc.Streams[2], "/cockroach.server.serverpb.Admin/RecoveryCollectLocalReplicaInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminRecoveryCollectLocalReplicaInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Admin_RecoveryCollectLocalReplicaInfoClient interface {
	Recv() (*RecoveryCollectLocalReplicaInfoResponse, error)
	grpc.ClientStream
}

type adminRecoveryCollectLocalReplicaInfoClient struct {
	grpc.ClientStream
}

func (x *adminRecoveryCollectLocalReplicaInfoClient) Recv() (*RecoveryCollectLocalReplicaInfoResponse, error) {
	m := new(RecoveryCollectLocalReplicaInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *adminClient) RecoveryStagePlan(ctx context.Context, in *RecoveryStagePlanRequest, opts ...grpc.CallOption) (*RecoveryStagePlanResponse, error) {
	out := new(RecoveryStagePlanResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/RecoveryStagePlan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RecoveryNodeStatus(ctx context.Context, in *RecoveryNodeStatusRequest, opts ...grpc.CallOption) (*RecoveryNodeStatusResponse, error) {
	out := new(RecoveryNodeStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/RecoveryNodeStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RecoveryVerify(ctx context.Context, in *RecoveryVerifyRequest, opts ...grpc.CallOption) (*RecoveryVerifyResponse, error) {
	out := new(RecoveryVerifyResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/RecoveryVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ListTenants(ctx context.Context, in *ListTenantsRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error) {
	out := new(ListTenantsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/ListTenants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ReadFromTenantInfo(ctx context.Context, in *ReadFromTenantInfoRequest, opts ...grpc.CallOption) (*ReadFromTenantInfoResponse, error) {
	out := new(ReadFromTenantInfoResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Admin/ReadFromTenantInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
type AdminServer interface {
	// URL: /_admin/v1/users
	Users(context.Context, *UsersRequest) (*UsersResponse, error)
	// URL: /_admin/v1/databases
	Databases(context.Context, *DatabasesRequest) (*DatabasesResponse, error)
	// Example URL: /_admin/v1/databases/system
	DatabaseDetails(context.Context, *DatabaseDetailsRequest) (*DatabaseDetailsResponse, error)
	// Example URL: /_admin/v1/databases/system/tables/ui
	TableDetails(context.Context, *TableDetailsRequest) (*TableDetailsResponse, error)
	// Example URL: /_admin/v1/databases/system/tables/ui/stats
	TableStats(context.Context, *TableStatsRequest) (*TableStatsResponse, error)
	// Example URL: /_admin/v1/nontablestats
	NonTableStats(context.Context, *NonTableStatsRequest) (*NonTableStatsResponse, error)
	// Example URLs:
	// Example URLs:
	// - /_admin/v1/events
	// - /_admin/v1/events?limit=100
	// - /_admin/v1/events?type=create_table
	// - /_admin/v1/events?type=create_table&limit=100
	Events(context.Context, *EventsRequest) (*EventsResponse, error)
	// This requires a POST. Because of the libraries we're using, the POST body
	// must be in the following format:
	//
	// {"key_values":
	//   { "key1": "base64_encoded_value1"},
	//   ...
	//   { "keyN": "base64_encoded_valueN"},
	// }
	//
	// Note that all keys are quoted strings and that all values are base64-
	// encoded.
	//
	// Together, SetUIData and GetUIData provide access to a "cookie jar" for the
	// admin UI. The structure of the underlying data is meant to be opaque to the
	// server.
	SetUIData(context.Context, *SetUIDataRequest) (*SetUIDataResponse, error)
	// Example URLs:
	// - /_admin/v1/uidata?keys=MYKEY
	// - /_admin/v1/uidata?keys=MYKEY1&keys=MYKEY2
	//
	// Yes, it's a little odd that the query parameter is named "keys" instead of
	// "key". I would've preferred that the URL parameter be named "key". However,
	// it's clearer for the protobuf field to be named "keys," which makes the URL
	// parameter "keys" as well.
	GetUIData(context.Context, *GetUIDataRequest) (*GetUIDataResponse, error)
	// Cluster returns metadata for the cluster.
	Cluster(context.Context, *ClusterRequest) (*ClusterResponse, error)
	// Settings returns the cluster-wide settings for the cluster.
	Settings(context.Context, *SettingsRequest) (*SettingsResponse, error)
	// Health returns liveness for the node target of the request.
	// API: PUBLIC
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	// Liveness returns the liveness state of all nodes on the cluster.
	Liveness(context.Context, *LivenessRequest) (*LivenessResponse, error)
	// Jobs returns the job records for all jobs of the given status and type.
	Jobs(context.Context, *JobsRequest) (*JobsResponse, error)
	// Job returns the job record for the job of the given job_id.
	Job(context.Context, *JobRequest) (*JobResponse, error)
	// Locations returns the locality location records.
	Locations(context.Context, *LocationsRequest) (*LocationsResponse, error)
	// QueryPlan returns the query plans for a SQL string.
	QueryPlan(context.Context, *QueryPlanRequest) (*QueryPlanResponse, error)
	// Drain puts the node into the specified drain mode(s) and optionally
	// instructs the process to terminate.
	// We do not expose this via HTTP unless we have a way to authenticate
	// + authorize streaming RPC connections. See #42567.
	Drain(*DrainRequest, Admin_DrainServer) error
	// DecommissionPreCheck requests that the server execute preliminary checks
	// to evaluate the possibility of successfully decommissioning a given node.
	DecommissionPreCheck(context.Context, *DecommissionPreCheckRequest) (*DecommissionPreCheckResponse, error)
	// Decommission puts the node(s) into the specified decommissioning state.
	// If this ever becomes exposed via HTTP, ensure that it performs
	// authorization. See #42567.
	Decommission(context.Context, *DecommissionRequest) (*DecommissionStatusResponse, error)
	// DecommissionStatus retrieves the decommissioning status of the specified nodes.
	// If this ever becomes exposed via HTTP, ensure that it performs
	// authorization. See #42567.
	DecommissionStatus(context.Context, *DecommissionStatusRequest) (*DecommissionStatusResponse, error)
	// URL: /_admin/v1/rangelog
	// URL: /_admin/v1/rangelog?limit=100
	// URL: /_admin/v1/rangelog/1
	// URL: /_admin/v1/rangelog/1?limit=100
	RangeLog(context.Context, *RangeLogRequest) (*RangeLogResponse, error)
	DataDistribution(context.Context, *DataDistributionRequest) (*DataDistributionResponse, error)
	// URL: /_admin/v1/metricmetadata
	AllMetricMetadata(context.Context, *MetricMetadataRequest) (*MetricMetadataResponse, error)
	// URL: /_admin/v1/chartcatalog
	ChartCatalog(context.Context, *ChartCatalogRequest) (*ChartCatalogResponse, error)
	// EnqueueRange runs the specified range through the specified queue on the
	// range's leaseholder store, returning the detailed trace and error
	// information from doing so. Parameters must be provided in the body of the
	// POST request.
	// For example:
	//
	// {
	//   "queue": "raftlog",
	//   "rangeId": 10
	// }
	EnqueueRange(context.Context, *EnqueueRangeRequest) (*EnqueueRangeResponse, error)
	// SendKVBatch proxies the given BatchRequest into KV, returning the
	// response. It is used by the CLI `debug send-kv-batch` command.
	SendKVBatch(context.Context, *kvpb.BatchRequest) (*kvpb.BatchResponse, error)
	// ListTracingSnapshots retrieves the list of snapshots of the Active Spans
	// Registry that the node currently has in memory. A new snapshot can be
	// captured with TakeTracingSnapshots.
	ListTracingSnapshots(context.Context, *ListTracingSnapshotsRequest) (*ListTracingSnapshotsResponse, error)
	// TakeTracingSnapshot captures a new snapshot of the Active Spans Registry.
	// The new snapshot is returned, and also made available through
	// ListTracingSnapshots.
	TakeTracingSnapshot(context.Context, *TakeTracingSnapshotRequest) (*TakeTracingSnapshotResponse, error)
	// GetTracingSnapshot returns a snapshot of the tracing spans in the active
	// spans registry previously generated through TakeTracingSnapshots.
	GetTracingSnapshot(context.Context, *GetTracingSnapshotRequest) (*GetTracingSnapshotResponse, error)
	// GetTrace returns the trace with a specified ID. Depending on the request,
	// the trace is returned either from a snapshot that was previously taken, or
	// directly from the active spans registry.
	GetTrace(context.Context, *GetTraceRequest) (*GetTraceResponse, error)
	// SetTraceRecordingType sets the recording mode of all or some of the spans
	// in a trace.
	SetTraceRecordingType(context.Context, *SetTraceRecordingTypeRequest) (*SetTraceRecordingTypeResponse, error)
	// RecoveryCollectReplicaInfo retrieves information about:
	// 1. range descriptors contained in cluster meta ranges if meta ranges
	//    are readable;
	// 2. replica information from all live nodes that have connection to
	//    the target node.
	RecoveryCollectReplicaInfo(*RecoveryCollectReplicaInfoRequest, Admin_RecoveryCollectReplicaInfoServer) error
	// RecoveryCollectLocalReplicaInfo retrieve information about all local
	// replicas in all stores on the node.
	RecoveryCollectLocalReplicaInfo(*RecoveryCollectLocalReplicaInfoRequest, Admin_RecoveryCollectLocalReplicaInfoServer) error
	// RecoveryStagePlan stages recovery plan on target or all nodes in cluster
	// depending on request content and marks nodes deleted in the plan as
	// decommissioned in each node's local node tombstone storage.
	RecoveryStagePlan(context.Context, *RecoveryStagePlanRequest) (*RecoveryStagePlanResponse, error)
	// RecoveryNodeStatus retrieves loss of quorum recovery status of a single
	// node.
	RecoveryNodeStatus(context.Context, *RecoveryNodeStatusRequest) (*RecoveryNodeStatusResponse, error)
	// RecoveryVerify verifies that recovery plan is applied on all necessary
	// nodes, ranges are available and nodes removed in plan are marked as
	// decommissioned.
	RecoveryVerify(context.Context, *RecoveryVerifyRequest) (*RecoveryVerifyResponse, error)
	// ListTenants returns a list of active tenants in the cluster.
	ListTenants(context.Context, *ListTenantsRequest) (*ListTenantsResponse, error)
	// ReadFromTenantInfo returns the tenant from which the requesting tenant
	// should read, if any.
	ReadFromTenantInfo(context.Context, *ReadFromTenantInfoRequest) (*ReadFromTenantInfoResponse, error)
}

// UnimplementedAdminServer can be embedded to have forward compatible implementations.
type UnimplementedAdminServer struct {
}

func (*UnimplementedAdminServer) Users(ctx context.Context, req *UsersRequest) (*UsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Users not implemented")
}
func (*UnimplementedAdminServer) Databases(ctx context.Context, req *DatabasesRequest) (*DatabasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Databases not implemented")
}
func (*UnimplementedAdminServer) DatabaseDetails(ctx context.Context, req *DatabaseDetailsRequest) (*DatabaseDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseDetails not implemented")
}
func (*UnimplementedAdminServer) TableDetails(ctx context.Context, req *TableDetailsRequest) (*TableDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableDetails not implemented")
}
func (*UnimplementedAdminServer) TableStats(ctx context.Context, req *TableStatsRequest) (*TableStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableStats not implemented")
}
func (*UnimplementedAdminServer) NonTableStats(ctx context.Context, req *NonTableStatsRequest) (*NonTableStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NonTableStats not implemented")
}
func (*UnimplementedAdminServer) Events(ctx context.Context, req *EventsRequest) (*EventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (*UnimplementedAdminServer) SetUIData(ctx context.Context, req *SetUIDataRequest) (*SetUIDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUIData not implemented")
}
func (*UnimplementedAdminServer) GetUIData(ctx context.Context, req *GetUIDataRequest) (*GetUIDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUIData not implemented")
}
func (*UnimplementedAdminServer) Cluster(ctx context.Context, req *ClusterRequest) (*ClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cluster not implemented")
}
func (*UnimplementedAdminServer) Settings(ctx context.Context, req *SettingsRequest) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Settings not implemented")
}
func (*UnimplementedAdminServer) Health(ctx context.Context, req *HealthRequest) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (*UnimplementedAdminServer) Liveness(ctx context.Context, req *LivenessRequest) (*LivenessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Liveness not implemented")
}
func (*UnimplementedAdminServer) Jobs(ctx context.Context, req *JobsRequest) (*JobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Jobs not implemented")
}
func (*UnimplementedAdminServer) Job(ctx context.Context, req *JobRequest) (*JobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Job not implemented")
}
func (*UnimplementedAdminServer) Locations(ctx context.Context, req *LocationsRequest) (*LocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Locations not implemented")
}
func (*UnimplementedAdminServer) QueryPlan(ctx context.Context, req *QueryPlanRequest) (*QueryPlanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPlan not implemented")
}
func (*UnimplementedAdminServer) Drain(req *DrainRequest, srv Admin_DrainServer) error {
	return status.Errorf(codes.Unimplemented, "method Drain not implemented")
}
func (*UnimplementedAdminServer) DecommissionPreCheck(ctx context.Context, req *DecommissionPreCheckRequest) (*DecommissionPreCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecommissionPreCheck not implemented")
}
func (*UnimplementedAdminServer) Decommission(ctx context.Context, req *DecommissionRequest) (*DecommissionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decommission not implemented")
}
func (*UnimplementedAdminServer) DecommissionStatus(ctx context.Context, req *DecommissionStatusRequest) (*DecommissionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecommissionStatus not implemented")
}
func (*UnimplementedAdminServer) RangeLog(ctx context.Context, req *RangeLogRequest) (*RangeLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeLog not implemented")
}
func (*UnimplementedAdminServer) DataDistribution(ctx context.Context, req *DataDistributionRequest) (*DataDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDistribution not implemented")
}
func (*UnimplementedAdminServer) AllMetricMetadata(ctx context.Context, req *MetricMetadataRequest) (*MetricMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllMetricMetadata not implemented")
}
func (*UnimplementedAdminServer) ChartCatalog(ctx context.Context, req *ChartCatalogRequest) (*ChartCatalogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChartCatalog not implemented")
}
func (*UnimplementedAdminServer) EnqueueRange(ctx context.Context, req *EnqueueRangeRequest) (*EnqueueRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueRange not implemented")
}
func (*UnimplementedAdminServer) SendKVBatch(ctx context.Context, req *kvpb.BatchRequest) (*kvpb.BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendKVBatch not implemented")
}
func (*UnimplementedAdminServer) ListTracingSnapshots(ctx context.Context, req *ListTracingSnapshotsRequest) (*ListTracingSnapshotsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTracingSnapshots not implemented")
}
func (*UnimplementedAdminServer) TakeTracingSnapshot(ctx context.Context, req *TakeTracingSnapshotRequest) (*TakeTracingSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeTracingSnapshot not implemented")
}
func (*UnimplementedAdminServer) GetTracingSnapshot(ctx context.Context, req *GetTracingSnapshotRequest) (*GetTracingSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTracingSnapshot not implemented")
}
func (*UnimplementedAdminServer) GetTrace(ctx context.Context, req *GetTraceRequest) (*GetTraceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrace not implemented")
}
func (*UnimplementedAdminServer) SetTraceRecordingType(ctx context.Context, req *SetTraceRecordingTypeRequest) (*SetTraceRecordingTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTraceRecordingType not implemented")
}
func (*UnimplementedAdminServer) RecoveryCollectReplicaInfo(req *RecoveryCollectReplicaInfoRequest, srv Admin_RecoveryCollectReplicaInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoveryCollectReplicaInfo not implemented")
}
func (*UnimplementedAdminServer) RecoveryCollectLocalReplicaInfo(req *RecoveryCollectLocalReplicaInfoRequest, srv Admin_RecoveryCollectLocalReplicaInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoveryCollectLocalReplicaInfo not implemented")
}
func (*UnimplementedAdminServer) RecoveryStagePlan(ctx context.Context, req *RecoveryStagePlanRequest) (*RecoveryStagePlanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoveryStagePlan not implemented")
}
func (*UnimplementedAdminServer) RecoveryNodeStatus(ctx context.Context, req *RecoveryNodeStatusRequest) (*RecoveryNodeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoveryNodeStatus not implemented")
}
func (*UnimplementedAdminServer) RecoveryVerify(ctx context.Context, req *RecoveryVerifyRequest) (*RecoveryVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoveryVerify not implemented")
}
func (*UnimplementedAdminServer) ListTenants(ctx context.Context, req *ListTenantsRequest) (*ListTenantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTenants not implemented")
}
func (*UnimplementedAdminServer) ReadFromTenantInfo(ctx context.Context, req *ReadFromTenantInfoRequest) (*ReadFromTenantInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFromTenantInfo not implemented")
}

func RegisterAdminServer(s *grpc.Server, srv AdminServer) {
	s.RegisterService(&_Admin_serviceDesc, srv)
}

func _Admin_Users_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Users(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Users",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Users(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Databases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Databases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Databases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Databases(ctx, req.(*DatabasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_DatabaseDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).DatabaseDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/DatabaseDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).DatabaseDetails(ctx, req.(*DatabaseDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_TableDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).TableDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/TableDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).TableDetails(ctx, req.(*TableDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_TableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).TableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/TableStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).TableStats(ctx, req.(*TableStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_NonTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonTableStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).NonTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/NonTableStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).NonTableStats(ctx, req.(*NonTableStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Events_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Events(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Events",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Events(ctx, req.(*EventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_SetUIData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUIDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).SetUIData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/SetUIData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).SetUIData(ctx, req.(*SetUIDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetUIData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUIDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetUIData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/GetUIData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetUIData(ctx, req.(*GetUIDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Cluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Cluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Cluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Cluster(ctx, req.(*ClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Settings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Settings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Settings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Settings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Liveness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LivenessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Liveness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Liveness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Liveness(ctx, req.(*LivenessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Jobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Jobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Jobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Jobs(ctx, req.(*JobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Job_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Job(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Job",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Job(ctx, req.(*JobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Locations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Locations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Locations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Locations(ctx, req.(*LocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_QueryPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).QueryPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/QueryPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).QueryPlan(ctx, req.(*QueryPlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Drain_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DrainRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).Drain(m, &adminDrainServer{stream})
}

type Admin_DrainServer interface {
	Send(*DrainResponse) error
	grpc.ServerStream
}

type adminDrainServer struct {
	grpc.ServerStream
}

func (x *adminDrainServer) Send(m *DrainResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_DecommissionPreCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecommissionPreCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).DecommissionPreCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/DecommissionPreCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).DecommissionPreCheck(ctx, req.(*DecommissionPreCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Decommission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecommissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Decommission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/Decommission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Decommission(ctx, req.(*DecommissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_DecommissionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecommissionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).DecommissionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/DecommissionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).DecommissionStatus(ctx, req.(*DecommissionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RangeLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RangeLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/RangeLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RangeLog(ctx, req.(*RangeLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_DataDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).DataDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/DataDistribution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).DataDistribution(ctx, req.(*DataDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_AllMetricMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).AllMetricMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/AllMetricMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).AllMetricMetadata(ctx, req.(*MetricMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ChartCatalog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChartCatalogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ChartCatalog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/ChartCatalog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ChartCatalog(ctx, req.(*ChartCatalogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_EnqueueRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).EnqueueRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/EnqueueRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).EnqueueRange(ctx, req.(*EnqueueRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_SendKVBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvpb.BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).SendKVBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/SendKVBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).SendKVBatch(ctx, req.(*kvpb.BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ListTracingSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTracingSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ListTracingSnapshots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/ListTracingSnapshots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ListTracingSnapshots(ctx, req.(*ListTracingSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_TakeTracingSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeTracingSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).TakeTracingSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/TakeTracingSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).TakeTracingSnapshot(ctx, req.(*TakeTracingSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetTracingSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTracingSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetTracingSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/GetTracingSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetTracingSnapshot(ctx, req.(*GetTracingSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/GetTrace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetTrace(ctx, req.(*GetTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_SetTraceRecordingType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTraceRecordingTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).SetTraceRecordingType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/SetTraceRecordingType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).SetTraceRecordingType(ctx, req.(*SetTraceRecordingTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RecoveryCollectReplicaInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoveryCollectReplicaInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).RecoveryCollectReplicaInfo(m, &adminRecoveryCollectReplicaInfoServer{stream})
}

type Admin_RecoveryCollectReplicaInfoServer interface {
	Send(*RecoveryCollectReplicaInfoResponse) error
	grpc.ServerStream
}

type adminRecoveryCollectReplicaInfoServer struct {
	grpc.ServerStream
}

func (x *adminRecoveryCollectReplicaInfoServer) Send(m *RecoveryCollectReplicaInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_RecoveryCollectLocalReplicaInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoveryCollectLocalReplicaInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).RecoveryCollectLocalReplicaInfo(m, &adminRecoveryCollectLocalReplicaInfoServer{stream})
}

type Admin_RecoveryCollectLocalReplicaInfoServer interface {
	Send(*RecoveryCollectLocalReplicaInfoResponse) error
	grpc.ServerStream
}

type adminRecoveryCollectLocalReplicaInfoServer struct {
	grpc.ServerStream
}

func (x *adminRecoveryCollectLocalReplicaInfoServer) Send(m *RecoveryCollectLocalReplicaInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_RecoveryStagePlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoveryStagePlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RecoveryStagePlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/RecoveryStagePlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RecoveryStagePlan(ctx, req.(*RecoveryStagePlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RecoveryNodeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoveryNodeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RecoveryNodeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/RecoveryNodeStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RecoveryNodeStatus(ctx, req.(*RecoveryNodeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RecoveryVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoveryVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RecoveryVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/RecoveryVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RecoveryVerify(ctx, req.(*RecoveryVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ListTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTenantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ListTenants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/ListTenants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ListTenants(ctx, req.(*ListTenantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ReadFromTenantInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFromTenantInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ReadFromTenantInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Admin/ReadFromTenantInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ReadFromTenantInfo(ctx, req.(*ReadFromTenantInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Admin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.server.serverpb.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Users",
			Handler:    _Admin_Users_Handler,
		},
		{
			MethodName: "Databases",
			Handler:    _Admin_Databases_Handler,
		},
		{
			MethodName: "DatabaseDetails",
			Handler:    _Admin_DatabaseDetails_Handler,
		},
		{
			MethodName: "TableDetails",
			Handler:    _Admin_TableDetails_Handler,
		},
		{
			MethodName: "TableStats",
			Handler:    _Admin_TableStats_Handler,
		},
		{
			MethodName: "NonTableStats",
			Handler:    _Admin_NonTableStats_Handler,
		},
		{
			MethodName: "Events",
			Handler:    _Admin_Events_Handler,
		},
		{
			MethodName: "SetUIData",
			Handler:    _Admin_SetUIData_Handler,
		},
		{
			MethodName: "GetUIData",
			Handler:    _Admin_GetUIData_Handler,
		},
		{
			MethodName: "Cluster",
			Handler:    _Admin_Cluster_Handler,
		},
		{
			MethodName: "Settings",
			Handler:    _Admin_Settings_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _Admin_Health_Handler,
		},
		{
			MethodName: "Liveness",
			Handler:    _Admin_Liveness_Handler,
		},
		{
			MethodName: "Jobs",
			Handler:    _Admin_Jobs_Handler,
		},
		{
			MethodName: "Job",
			Handler:    _Admin_Job_Handler,
		},
		{
			MethodName: "Locations",
			Handler:    _Admin_Locations_Handler,
		},
		{
			MethodName: "QueryPlan",
			Handler:    _Admin_QueryPlan_Handler,
		},
		{
			MethodName: "DecommissionPreCheck",
			Handler:    _Admin_DecommissionPreCheck_Handler,
		},
		{
			MethodName: "Decommission",
			Handler:    _Admin_Decommission_Handler,
		},
		{
			MethodName: "DecommissionStatus",
			Handler:    _Admin_DecommissionStatus_Handler,
		},
		{
			MethodName: "RangeLog",
			Handler:    _Admin_RangeLog_Handler,
		},
		{
			MethodName: "DataDistribution",
			Handler:    _Admin_DataDistribution_Handler,
		},
		{
			MethodName: "AllMetricMetadata",
			Handler:    _Admin_AllMetricMetadata_Handler,
		},
		{
			MethodName: "ChartCatalog",
			Handler:    _Admin_ChartCatalog_Handler,
		},
		{
			MethodName: "EnqueueRange",
			Handler:    _Admin_EnqueueRange_Handler,
		},
		{
			MethodName: "SendKVBatch",
			Handler:    _Admin_SendKVBatch_Handler,
		},
		{
			MethodName: "ListTracingSnapshots",
			Handler:    _Admin_ListTracingSnapshots_Handler,
		},
		{
			MethodName: "TakeTracingSnapshot",
			Handler:    _Admin_TakeTracingSnapshot_Handler,
		},
		{
			MethodName: "GetTracingSnapshot",
			Handler:    _Admin_GetTracingSnapshot_Handler,
		},
		{
			MethodName: "GetTrace",
			Handler:    _Admin_GetTrace_Handler,
		},
		{
			MethodName: "SetTraceRecordingType",
			Handler:    _Admin_SetTraceRecordingType_Handler,
		},
		{
			MethodName: "RecoveryStagePlan",
			Handler:    _Admin_RecoveryStagePlan_Handler,
		},
		{
			MethodName: "RecoveryNodeStatus",
			Handler:    _Admin_RecoveryNodeStatus_Handler,
		},
		{
			MethodName: "RecoveryVerify",
			Handler:    _Admin_RecoveryVerify_Handler,
		},
		{
			MethodName: "ListTenants",
			Handler:    _Admin_ListTenants_Handler,
		},
		{
			MethodName: "ReadFromTenantInfo",
			Handler:    _Admin_ReadFromTenantInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Drain",
			Handler:       _Admin_Drain_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoveryCollectReplicaInfo",
			Handler:       _Admin_RecoveryCollectReplicaInfo_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoveryCollectLocalReplicaInfo",
			Handler:       _Admin_RecoveryCollectLocalReplicaInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server/serverpb/admin.proto",
}

func (m *DatabasesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabasesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabasesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DatabasesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabasesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabasesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Databases) > 0 {
		for iNdEx := len(m.Databases) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Databases[iNdEx])
			copy(dAtA[i:], m.Databases[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Databases[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeStats {
		i--
		if m.IncludeStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ZoneConfigLevel != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ZoneConfigLevel))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.ZoneConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.DescriptorID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TableNames) > 0 {
		for iNdEx := len(m.TableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TableNames[iNdEx])
			copy(dAtA[i:], m.TableNames[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.TableNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Grants) > 0 {
		for iNdEx := len(m.Grants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Grants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseDetailsResponse_Grant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseDetailsResponse_Grant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseDetailsResponse_Grant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Privileges) > 0 {
		for iNdEx := len(m.Privileges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Privileges[iNdEx])
			copy(dAtA[i:], m.Privileges[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Privileges[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseDetailsResponse_Stats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseDetailsResponse_Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseDetailsResponse_Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumIndexRecommendations != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NumIndexRecommendations))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NodeIDs) > 0 {
		l := 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.NodeIDs) {
			dest := dAtA[i : i+len(m.NodeIDs)]
			for k, num := range m.NodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j3 := i
			for _, num1 := range m.NodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j3++
				}
				dAtA[j3] = uint8(num)
				j3++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	if m.ApproximateDiskBytes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ApproximateDiskBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.RangeCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MissingTables) > 0 {
		for iNdEx := len(m.MissingTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MissingTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseDetailsResponse_Stats_MissingTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseDetailsResponse_Stats_MissingTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseDetailsResponse_Stats_MissingTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataLivePercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DataLivePercentage))))
		i--
		dAtA[i] = 0x75
	}
	if m.DataLiveBytes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DataLiveBytes))
		i--
		dAtA[i] = 0x68
	}
	if m.DataTotalBytes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DataTotalBytes))
		i--
		dAtA[i] = 0x60
	}
	if m.HasIndexRecommendations {
		i--
		if m.HasIndexRecommendations {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.StatsLastCreatedAt != nil {
		n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StatsLastCreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StatsLastCreatedAt):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintAdmin(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ConfigureZoneStatement) > 0 {
		i -= len(m.ConfigureZoneStatement)
		copy(dAtA[i:], m.ConfigureZoneStatement)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ConfigureZoneStatement)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DescriptorID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x40
	}
	if m.ZoneConfigLevel != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ZoneConfigLevel))
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.ZoneConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.CreateTableStatement) > 0 {
		i -= len(m.CreateTableStatement)
		copy(dAtA[i:], m.CreateTableStatement)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.CreateTableStatement)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RangeCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Indexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Grants) > 0 {
		for iNdEx := len(m.Grants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Grants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableDetailsResponse_Grant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDetailsResponse_Grant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDetailsResponse_Grant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Privileges) > 0 {
		for iNdEx := len(m.Privileges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Privileges[iNdEx])
			copy(dAtA[i:], m.Privileges[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Privileges[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDetailsResponse_Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDetailsResponse_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDetailsResponse_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.GenerationExpression) > 0 {
		i -= len(m.GenerationExpression)
		copy(dAtA[i:], m.GenerationExpression)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.GenerationExpression)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDetailsResponse_Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDetailsResponse_Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDetailsResponse_Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Implicit {
		i--
		if m.Implicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Storing {
		i--
		if m.Storing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Direction) > 0 {
		i -= len(m.Direction)
		copy(dAtA[i:], m.Direction)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Direction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Column) > 0 {
		i -= len(m.Column)
		copy(dAtA[i:], m.Column)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Column)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeIDs) > 0 {
		l := 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.NodeIDs) {
			dest := dAtA[i : i+len(m.NodeIDs)]
			for k, num := range m.NodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j6 := i
			for _, num1 := range m.NodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j6] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j6++
				}
				dAtA[j6] = uint8(num)
				j6++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ApproximateDiskBytes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ApproximateDiskBytes))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MissingNodes) > 0 {
		for iNdEx := len(m.MissingNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MissingNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.NodeCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ReplicaCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicaCount))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableStatsResponse_MissingNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatsResponse_MissingNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatsResponse_MissingNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NonTableStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonTableStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NonTableStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NonTableStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonTableStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NonTableStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InternalUseStats != nil {
		{
			size, err := m.InternalUseStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimeSeriesStats != nil {
		{
			size, err := m.TimeSeriesStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UsersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UsersResponse_User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsersResponse_User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsersResponse_User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnredactedEvents {
		i--
		if m.UnredactedEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventsResponse_Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsResponse_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsResponse_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UniqueID) > 0 {
		i -= len(m.UniqueID)
		copy(dAtA[i:], m.UniqueID)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.UniqueID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReportingID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReportingID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EventType) > 0 {
		i -= len(m.EventType)
		copy(dAtA[i:], m.EventType)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.EventType)))
		i--
		dAtA[i] = 0x12
	}
	n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintAdmin(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SetUIDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUIDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetUIDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		keysForKeyValues := make([]string, 0, len(m.KeyValues))
		for k := range m.KeyValues {
			keysForKeyValues = append(keysForKeyValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKeyValues)
		for iNdEx := len(keysForKeyValues) - 1; iNdEx >= 0; iNdEx-- {
			v := m.KeyValues[string(keysForKeyValues[iNdEx])]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintAdmin(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForKeyValues[iNdEx])
			copy(dAtA[i:], keysForKeyValues[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForKeyValues[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetUIDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUIDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetUIDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetUIDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUIDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUIDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetUIDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUIDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUIDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		keysForKeyValues := make([]string, 0, len(m.KeyValues))
		for k := range m.KeyValues {
			keysForKeyValues = append(keysForKeyValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKeyValues)
		for iNdEx := len(keysForKeyValues) - 1; iNdEx >= 0; iNdEx-- {
			v := m.KeyValues[string(keysForKeyValues[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForKeyValues[iNdEx])
			copy(dAtA[i:], keysForKeyValues[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForKeyValues[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetUIDataResponse_Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUIDataResponse_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUIDataResponse_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdated, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdated):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintAdmin(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x12
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnterpriseEnabled {
		i--
		if m.EnterpriseEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ReportingEnabled {
		i--
		if m.ReportingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DrainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DrainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Verbose {
		i--
		if m.Verbose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DoDrain {
		i--
		if m.DoDrain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Shutdown {
		i--
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *DrainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DrainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DrainRemainingDescription) > 0 {
		i -= len(m.DrainRemainingDescription)
		copy(dAtA[i:], m.DrainRemainingDescription)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.DrainRemainingDescription)))
		i--
		dAtA[i] = 0x22
	}
	if m.DrainRemainingIndicator != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DrainRemainingIndicator))
		i--
		dAtA[i] = 0x18
	}
	if m.IsDraining {
		i--
		if m.IsDraining {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionPreCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionPreCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionPreCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollectTraces {
		i--
		if m.CollectTraces {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.StrictReadiness {
		i--
		if m.StrictReadiness {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NumReplicaReport != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NumReplicaReport))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeIDs) > 0 {
		l := 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.NodeIDs) {
			dest := dAtA[i : i+len(m.NodeIDs)]
			for k, num := range m.NodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j13 := i
			for _, num1 := range m.NodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j13] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j13++
				}
				dAtA[j13] = uint8(num)
				j13++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionPreCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionPreCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionPreCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CheckedNodes) > 0 {
		for iNdEx := len(m.CheckedNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CheckedNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionPreCheckResponse_RangeCheckResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionPreCheckResponse_RangeCheckResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionPreCheckResponse_RangeCheckResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionPreCheckResponse_NodeCheckResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionPreCheckResponse_NodeCheckResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionPreCheckResponse_NodeCheckResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CheckedRanges) > 0 {
		for iNdEx := len(m.CheckedRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CheckedRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ReplicaCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicaCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DecommissionReadiness != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DecommissionReadiness))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumReplicaReport != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NumReplicaReport))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeIDs) > 0 {
		l := 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.NodeIDs) {
			dest := dAtA[i : i+len(m.NodeIDs)]
			for k, num := range m.NodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j14 := i
			for _, num1 := range m.NodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j14] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j14++
				}
				dAtA[j14] = uint8(num)
				j14++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumReplicaReport != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NumReplicaReport))
		i--
		dAtA[i] = 0x18
	}
	if m.TargetMembership != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TargetMembership))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeIDs) > 0 {
		l := 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.NodeIDs) {
			dest := dAtA[i : i+len(m.NodeIDs)]
			for k, num := range m.NodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j15 := i
			for _, num1 := range m.NodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j15] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j15++
				}
				dAtA[j15] = uint8(num)
				j15++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		for iNdEx := len(m.Status) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Status[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionStatusResponse_Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionStatusResponse_Replica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionStatusResponse_Replica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DecommissionStatusResponse_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecommissionStatusResponse_Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecommissionStatusResponse_Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReportedReplicas) > 0 {
		for iNdEx := len(m.ReportedReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportedReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Draining {
		i--
		if m.Draining {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Membership != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Membership))
		i--
		dAtA[i] = 0x20
	}
	if m.ReplicaCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicaCount))
		i--
		dAtA[i] = 0x18
	}
	if m.IsLive {
		i--
		if m.IsLive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SettingsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SettingsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SettingsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SettingsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SettingsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SettingsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		keysForKeyValues := make([]string, 0, len(m.KeyValues))
		for k := range m.KeyValues {
			keysForKeyValues = append(keysForKeyValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKeyValues)
		for iNdEx := len(keysForKeyValues) - 1; iNdEx >= 0; iNdEx-- {
			v := m.KeyValues[string(keysForKeyValues[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForKeyValues[iNdEx])
			copy(dAtA[i:], keysForKeyValues[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForKeyValues[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SettingsResponse_Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SettingsResponse_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SettingsResponse_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastUpdated != nil {
		n17, err17 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastUpdated, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastUpdated):])
		if err17 != nil {
			return 0, err17
		}
		i -= n17
		i = encodeVarintAdmin(dAtA, i, uint64(n17))
		i--
		dAtA[i] = 0x2a
	}
	if m.Public {
		i--
		if m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HealthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ready {
		i--
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HealthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LivenessRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LivenessRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LivenessRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LivenessResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LivenessResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LivenessResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Statuses) > 0 {
		keysForStatuses := make([]int32, 0, len(m.Statuses))
		for k := range m.Statuses {
			keysForStatuses = append(keysForStatuses, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForStatuses)
		for iNdEx := len(keysForStatuses) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Statuses[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForStatuses[iNdEx])]
			baseI := i
			i = encodeVarintAdmin(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintAdmin(dAtA, i, uint64(keysForStatuses[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Livenesses) > 0 {
		for iNdEx := len(m.Livenesses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Livenesses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if m.Limit != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n18, err18 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.EarliestRetainedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.EarliestRetainedTime):])
	if err18 != nil {
		return 0, err18
	}
	i -= n18
	i = encodeVarintAdmin(dAtA, i, uint64(n18))
	i--
	dAtA[i] = 0x12
	if len(m.Jobs) > 0 {
		for iNdEx := len(m.Jobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JobId != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	n19, err19 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintAdmin(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0x12
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.CoordinatorID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CoordinatorID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ExecutionFailures) > 0 {
		for iNdEx := len(m.ExecutionFailures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecutionFailures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.NumRuns != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NumRuns))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NextRun != nil {
		n20, err20 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.NextRun, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.NextRun):])
		if err20 != nil {
			return 0, err20
		}
		i -= n20
		i = encodeVarintAdmin(dAtA, i, uint64(n20))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.LastRun != nil {
		n21, err21 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastRun, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastRun):])
		if err21 != nil {
			return 0, err21
		}
		i -= n21
		i = encodeVarintAdmin(dAtA, i, uint64(n21))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Statement) > 0 {
		i -= len(m.Statement)
		copy(dAtA[i:], m.Statement)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Statement)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.RunningStatus) > 0 {
		i -= len(m.RunningStatus)
		copy(dAtA[i:], m.RunningStatus)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RunningStatus)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.HighwaterDecimal) > 0 {
		i -= len(m.HighwaterDecimal)
		copy(dAtA[i:], m.HighwaterDecimal)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.HighwaterDecimal)))
		i--
		dAtA[i] = 0x72
	}
	if m.HighwaterTimestamp != nil {
		n22, err22 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.HighwaterTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.HighwaterTimestamp):])
		if err22 != nil {
			return 0, err22
		}
		i -= n22
		i = encodeVarintAdmin(dAtA, i, uint64(n22))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x62
	}
	if m.FractionCompleted != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FractionCompleted))))
		i--
		dAtA[i] = 0x5d
	}
	if m.Modified != nil {
		n23, err23 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Modified, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Modified):])
		if err23 != nil {
			return 0, err23
		}
		i -= n23
		i = encodeVarintAdmin(dAtA, i, uint64(n23))
		i--
		dAtA[i] = 0x52
	}
	if m.Finished != nil {
		n24, err24 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Finished, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Finished):])
		if err24 != nil {
			return 0, err24
		}
		i -= n24
		i = encodeVarintAdmin(dAtA, i, uint64(n24))
		i--
		dAtA[i] = 0x4a
	}
	if m.Started != nil {
		n25, err25 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Started, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Started):])
		if err25 != nil {
			return 0, err25
		}
		i -= n25
		i = encodeVarintAdmin(dAtA, i, uint64(n25))
		i--
		dAtA[i] = 0x42
	}
	if m.Created != nil {
		n26, err26 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created):])
		if err26 != nil {
			return 0, err26
		}
		i -= n26
		i = encodeVarintAdmin(dAtA, i, uint64(n26))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DescriptorIDs) > 0 {
		l := 0
		for _, e := range m.DescriptorIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.DescriptorIDs) {
			dest := dAtA[i : i+len(m.DescriptorIDs)]
			for k, num := range m.DescriptorIDs {
				dest[k] = uint8(num)
			}
		} else {
			j27 := i
			for _, num := range m.DescriptorIDs {
				for num >= 1<<7 {
					dAtA[j27] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j27++
				}
				dAtA[j27] = uint8(num)
				j27++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobResponse_ExecutionFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobResponse_ExecutionFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobResponse_ExecutionFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.End != nil {
		n28, err28 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.End, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.End):])
		if err28 != nil {
			return 0, err28
		}
		i -= n28
		i = encodeVarintAdmin(dAtA, i, uint64(n28))
		i--
		dAtA[i] = 0x1a
	}
	if m.Start != nil {
		n29, err29 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Start):])
		if err29 != nil {
			return 0, err29
		}
		i -= n29
		i = encodeVarintAdmin(dAtA, i, uint64(n29))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LocationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Locations) > 0 {
		for iNdEx := len(m.Locations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocationsResponse_Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationsResponse_Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationsResponse_Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x21
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.LocalityValue) > 0 {
		i -= len(m.LocalityValue)
		copy(dAtA[i:], m.LocalityValue)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.LocalityValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LocalityKey) > 0 {
		i -= len(m.LocalityKey)
		copy(dAtA[i:], m.LocalityKey)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.LocalityKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeId != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *RangeLogResponse_PrettyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLogResponse_PrettyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLogResponse_PrettyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RemovedReplica) > 0 {
		i -= len(m.RemovedReplica)
		copy(dAtA[i:], m.RemovedReplica)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RemovedReplica)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AddedReplica) > 0 {
		i -= len(m.AddedReplica)
		copy(dAtA[i:], m.AddedReplica)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.AddedReplica)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewDesc) > 0 {
		i -= len(m.NewDesc)
		copy(dAtA[i:], m.NewDesc)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.NewDesc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UpdatedDesc) > 0 {
		i -= len(m.UpdatedDesc)
		copy(dAtA[i:], m.UpdatedDesc)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.UpdatedDesc)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeLogResponse_Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLogResponse_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLogResponse_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrettyInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryPlanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPlanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPlanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPlanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPlanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPlanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DistSQLPhysicalQueryPlan) > 0 {
		i -= len(m.DistSQLPhysicalQueryPlan)
		copy(dAtA[i:], m.DistSQLPhysicalQueryPlan)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.DistSQLPhysicalQueryPlan)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataDistributionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDistributionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDistributionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DataDistributionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDistributionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDistributionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ZoneConfigs) > 0 {
		keysForZoneConfigs := make([]string, 0, len(m.ZoneConfigs))
		for k := range m.ZoneConfigs {
			keysForZoneConfigs = append(keysForZoneConfigs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForZoneConfigs)
		for iNdEx := len(keysForZoneConfigs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ZoneConfigs[string(keysForZoneConfigs[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForZoneConfigs[iNdEx])
			copy(dAtA[i:], keysForZoneConfigs[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForZoneConfigs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DatabaseInfo) > 0 {
		keysForDatabaseInfo := make([]string, 0, len(m.DatabaseInfo))
		for k := range m.DatabaseInfo {
			keysForDatabaseInfo = append(keysForDatabaseInfo, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDatabaseInfo)
		for iNdEx := len(keysForDatabaseInfo) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DatabaseInfo[string(keysForDatabaseInfo[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForDatabaseInfo[iNdEx])
			copy(dAtA[i:], keysForDatabaseInfo[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForDatabaseInfo[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataDistributionResponse_ZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDistributionResponse_ZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDistributionResponse_ZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfigSQL) > 0 {
		i -= len(m.ConfigSQL)
		copy(dAtA[i:], m.ConfigSQL)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ConfigSQL)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataDistributionResponse_TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDistributionResponse_TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDistributionResponse_TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DroppedAt != nil {
		n35, err35 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.DroppedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.DroppedAt):])
		if err35 != nil {
			return 0, err35
		}
		i -= n35
		i = encodeVarintAdmin(dAtA, i, uint64(n35))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReplicaCountByNodeId) > 0 {
		keysForReplicaCountByNodeId := make([]int32, 0, len(m.ReplicaCountByNodeId))
		for k := range m.ReplicaCountByNodeId {
			keysForReplicaCountByNodeId = append(keysForReplicaCountByNodeId, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForReplicaCountByNodeId)
		for iNdEx := len(keysForReplicaCountByNodeId) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ReplicaCountByNodeId[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForReplicaCountByNodeId[iNdEx])]
			baseI := i
			i = encodeVarintAdmin(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintAdmin(dAtA, i, uint64(keysForReplicaCountByNodeId[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataDistributionResponse_DatabaseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDistributionResponse_DatabaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDistributionResponse_DatabaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TableInfo) > 0 {
		keysForTableInfo := make([]string, 0, len(m.TableInfo))
		for k := range m.TableInfo {
			keysForTableInfo = append(keysForTableInfo, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTableInfo)
		for iNdEx := len(keysForTableInfo) - 1; iNdEx >= 0; iNdEx-- {
			v := m.TableInfo[string(keysForTableInfo[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForTableInfo[iNdEx])
			copy(dAtA[i:], keysForTableInfo[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForTableInfo[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MetricMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecordedNames) > 0 {
		keysForRecordedNames := make([]string, 0, len(m.RecordedNames))
		for k := range m.RecordedNames {
			keysForRecordedNames = append(keysForRecordedNames, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForRecordedNames)
		for iNdEx := len(keysForRecordedNames) - 1; iNdEx >= 0; iNdEx-- {
			v := m.RecordedNames[string(keysForRecordedNames[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdmin(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForRecordedNames[iNdEx])
			copy(dAtA[i:], keysForRecordedNames[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForRecordedNames[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Metadata) > 0 {
		keysForMetadata := make([]string, 0, len(m.Metadata))
		for k := range m.Metadata {
			keysForMetadata = append(keysForMetadata, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
		for iNdEx := len(keysForMetadata) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Metadata[string(keysForMetadata[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForMetadata[iNdEx])
			copy(dAtA[i:], keysForMetadata[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForMetadata[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EnqueueRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnqueueRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnqueueRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipShouldQueue {
		i--
		if m.SkipShouldQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RangeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnqueueRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnqueueRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnqueueRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Details[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EnqueueRangeResponse_Details) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnqueueRangeResponse_Details) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnqueueRangeResponse_Details) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChartCatalogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartCatalogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartCatalogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ChartCatalogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartCatalogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartCatalogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Catalog) > 0 {
		for iNdEx := len(m.Catalog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Catalog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCollectReplicaInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCollectReplicaInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxConcurrency != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxConcurrency))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCollectReplicaRestartNodeStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCollectReplicaRestartNodeStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaRestartNodeStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCollectReplicaInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCollectReplicaInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size := m.Info.Size()
			i -= size
			if _, err := m.Info.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCollectReplicaInfoResponse_RangeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaInfoResponse_RangeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeDescriptor != nil {
		{
			size, err := m.RangeDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RecoveryCollectReplicaInfoResponse_ReplicaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaInfoResponse_ReplicaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReplicaInfo != nil {
		{
			size, err := m.ReplicaInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RecoveryCollectReplicaInfoResponse_NodeStreamRestarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaInfoResponse_NodeStreamRestarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeStreamRestarted != nil {
		{
			size, err := m.NodeStreamRestarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RecoveryCollectReplicaInfoResponse_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectReplicaInfoResponse_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RecoveryCollectLocalReplicaInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCollectLocalReplicaInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectLocalReplicaInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RecoveryCollectLocalReplicaInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCollectLocalReplicaInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCollectLocalReplicaInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplicaInfo != nil {
		{
			size, err := m.ReplicaInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryStagePlanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryStagePlanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryStagePlanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxConcurrency != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxConcurrency))
		i--
		dAtA[i] = 0x28
	}
	if m.ForceLocalInternalVersion {
		i--
		if m.ForceLocalInternalVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ForcePlan {
		i--
		if m.ForcePlan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllNodes {
		i--
		if m.AllNodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryStagePlanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryStagePlanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryStagePlanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryNodeStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryNodeStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryNodeStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RecoveryNodeStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryNodeStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryNodeStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoveryVerifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryVerifyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryVerifyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxConcurrency != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxConcurrency))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxReportedRanges != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxReportedRanges))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DecommissionedNodeIDs) > 0 {
		l := 0
		for _, e := range m.DecommissionedNodeIDs {
			l += sovAdmin(uint64(e))
		}
		i -= l
		if l == len(m.DecommissionedNodeIDs) {
			dest := dAtA[i : i+len(m.DecommissionedNodeIDs)]
			for k, num := range m.DecommissionedNodeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j45 := i
			for _, num1 := range m.DecommissionedNodeIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j45] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j45++
				}
				dAtA[j45] = uint8(num)
				j45++
			}
		}
		i = encodeVarintAdmin(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.PendingPlanID != nil {
		{
			size := m.PendingPlanID.Size()
			i -= size
			if _, err := m.PendingPlanID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryVerifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryVerifyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryVerifyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DecommissionedNodeStatuses) > 0 {
		keysForDecommissionedNodeStatuses := make([]int32, 0, len(m.DecommissionedNodeStatuses))
		for k := range m.DecommissionedNodeStatuses {
			keysForDecommissionedNodeStatuses = append(keysForDecommissionedNodeStatuses, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForDecommissionedNodeStatuses)
		for iNdEx := len(keysForDecommissionedNodeStatuses) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DecommissionedNodeStatuses[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForDecommissionedNodeStatuses[iNdEx])]
			baseI := i
			i = encodeVarintAdmin(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintAdmin(dAtA, i, uint64(keysForDecommissionedNodeStatuses[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.UnavailableRanges.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Statuses) > 0 {
		for iNdEx := len(m.Statuses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Statuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryVerifyResponse_UnavailableRanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryVerifyResponse_UnavailableRanges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryVerifyResponse_UnavailableRanges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListTenantsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTenantsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTenantsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListTenantsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTenantsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTenantsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for iNdEx := len(m.Tenants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tenants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tenant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tenant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tenant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RpcAddr) > 0 {
		i -= len(m.RpcAddr)
		copy(dAtA[i:], m.RpcAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RpcAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SqlAddr) > 0 {
		i -= len(m.SqlAddr)
		copy(dAtA[i:], m.SqlAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SqlAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TenantName) > 0 {
		i -= len(m.TenantName)
		copy(dAtA[i:], m.TenantName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.TenantName)))
		i--
		dAtA[i] = 0x12
	}
	if m.TenantId != nil {
		{
			size, err := m.TenantId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadFromTenantInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFromTenantInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadFromTenantInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReadFromTenantInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFromTenantInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadFromTenantInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ReadAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReadFrom.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListTracingSnapshotsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTracingSnapshotsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTracingSnapshotsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListTracingSnapshotsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTracingSnapshotsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTracingSnapshotsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Snapshots) > 0 {
		for iNdEx := len(m.Snapshots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Snapshots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CapturedAt != nil {
		n51, err51 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CapturedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CapturedAt):])
		if err51 != nil {
			return 0, err51
		}
		i -= n51
		i = encodeVarintAdmin(dAtA, i, uint64(n51))
		i--
		dAtA[i] = 0x12
	}
	if m.SnapshotID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SnapshotID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TakeTracingSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TakeTracingSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TakeTracingSnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TakeTracingSnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TakeTracingSnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TakeTracingSnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTracingSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTracingSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTracingSnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnapshotId != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SnapshotId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTracingSnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTracingSnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTracingSnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTraceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTraceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTraceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecordingType != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RecordingType))
		i--
		dAtA[i] = 0x18
	}
	if m.TraceID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TraceID))
		i--
		dAtA[i] = 0x10
	}
	if m.SnapshotID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SnapshotID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTraceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTraceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTraceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SerializedRecording) > 0 {
		i -= len(m.SerializedRecording)
		copy(dAtA[i:], m.SerializedRecording)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SerializedRecording)))
		i--
		dAtA[i] = 0x22
	}
	if m.StillExists {
		i--
		if m.StillExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TraceID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TraceID))
		i--
		dAtA[i] = 0x10
	}
	if m.SnapshotID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SnapshotID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TracingSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracingSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stacks) > 0 {
		keysForStacks := make([]string, 0, len(m.Stacks))
		for k := range m.Stacks {
			keysForStacks = append(keysForStacks, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForStacks)
		for iNdEx := len(keysForStacks) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Stacks[string(keysForStacks[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdmin(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForStacks[iNdEx])
			copy(dAtA[i:], keysForStacks[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(keysForStacks[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CapturedAt != nil {
		n54, err54 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CapturedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CapturedAt):])
		if err54 != nil {
			return 0, err54
		}
		i -= n54
		i = encodeVarintAdmin(dAtA, i, uint64(n54))
		i--
		dAtA[i] = 0x12
	}
	if m.SnapshotID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SnapshotID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NamedOperationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedOperationMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamedOperationMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracingSpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingSpan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracingSpan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChildrenMetadata) > 0 {
		for iNdEx := len(m.ChildrenMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChildrenMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CurrentRecordingMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CurrentRecordingMode))
		i--
		dAtA[i] = 0x48
	}
	if m.Current {
		i--
		if m.Current {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.ProcessedTags) > 0 {
		for iNdEx := len(m.ProcessedTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProcessedTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.GoroutineID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.GoroutineID))
		i--
		dAtA[i] = 0x30
	}
	n56, err56 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Start):])
	if err56 != nil {
		return 0, err56
	}
	i -= n56
	i = encodeVarintAdmin(dAtA, i, uint64(n56))
	i--
	dAtA[i] = 0x2a
	if m.ParentSpanID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ParentSpanID))
		i--
		dAtA[i] = 0x20
	}
	if m.SpanID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SpanID))
		i--
		dAtA[i] = 0x18
	}
	if m.TraceID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TraceID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.CopiedFromChild {
		i--
		if m.CopiedFromChild {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.PropagateUp {
		i--
		if m.PropagateUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Inherited {
		i--
		if m.Inherited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Inherit {
		i--
		if m.Inherit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Highlight {
		i--
		if m.Highlight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Caption) > 0 {
		i -= len(m.Caption)
		copy(dAtA[i:], m.Caption)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Caption)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChildSpanTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChildSpanTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChildSpanTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetTraceRecordingTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTraceRecordingTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetTraceRecordingTypeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecordingMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RecordingMode))
		i--
		dAtA[i] = 0x18
	}
	if m.SpanID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SpanID))
		i--
		dAtA[i] = 0x10
	}
	if m.TraceID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TraceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetTraceRecordingTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTraceRecordingTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetTraceRecordingTypeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FeatureFlags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureFlags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureFlags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisableKvLevelAdvancedDebug {
		i--
		if m.DisableKvLevelAdvancedDebug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CanViewKvMetricDashboards {
		i--
		if m.CanViewKvMetricDashboards {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsObservabilityService {
		i--
		if m.IsObservabilityService {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAdmin(dAtA []byte, offset int, v uint64) int {
	offset -= sovAdmin(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DatabasesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DatabasesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Databases) > 0 {
		for _, s := range m.Databases {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DatabaseDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.IncludeStats {
		n += 2
	}
	return n
}

func (m *DatabaseDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for _, e := range m.Grants {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.TableNames) > 0 {
		for _, s := range m.TableNames {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.DescriptorID != 0 {
		n += 1 + sovAdmin(uint64(m.DescriptorID))
	}
	l = m.ZoneConfig.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if m.ZoneConfigLevel != 0 {
		n += 1 + sovAdmin(uint64(m.ZoneConfigLevel))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DatabaseDetailsResponse_Grant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Privileges) > 0 {
		for _, s := range m.Privileges {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DatabaseDetailsResponse_Stats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MissingTables) > 0 {
		for _, e := range m.MissingTables {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.RangeCount != 0 {
		n += 1 + sovAdmin(uint64(m.RangeCount))
	}
	if m.ApproximateDiskBytes != 0 {
		n += 1 + sovAdmin(uint64(m.ApproximateDiskBytes))
	}
	if len(m.NodeIDs) > 0 {
		l = 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if m.NumIndexRecommendations != 0 {
		n += 1 + sovAdmin(uint64(m.NumIndexRecommendations))
	}
	return n
}

func (m *DatabaseDetailsResponse_Stats_MissingTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TableDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TableDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for _, e := range m.Grants {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.RangeCount != 0 {
		n += 1 + sovAdmin(uint64(m.RangeCount))
	}
	l = len(m.CreateTableStatement)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = m.ZoneConfig.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if m.ZoneConfigLevel != 0 {
		n += 1 + sovAdmin(uint64(m.ZoneConfigLevel))
	}
	if m.DescriptorID != 0 {
		n += 1 + sovAdmin(uint64(m.DescriptorID))
	}
	l = len(m.ConfigureZoneStatement)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.StatsLastCreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StatsLastCreatedAt)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.HasIndexRecommendations {
		n += 2
	}
	if m.DataTotalBytes != 0 {
		n += 1 + sovAdmin(uint64(m.DataTotalBytes))
	}
	if m.DataLiveBytes != 0 {
		n += 1 + sovAdmin(uint64(m.DataLiveBytes))
	}
	if m.DataLivePercentage != 0 {
		n += 5
	}
	return n
}

func (m *TableDetailsResponse_Grant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Privileges) > 0 {
		for _, s := range m.Privileges {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *TableDetailsResponse_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Nullable {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.GenerationExpression)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	return n
}

func (m *TableDetailsResponse_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Unique {
		n += 2
	}
	if m.Seq != 0 {
		n += 1 + sovAdmin(uint64(m.Seq))
	}
	l = len(m.Column)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Storing {
		n += 2
	}
	if m.Implicit {
		n += 2
	}
	return n
}

func (m *TableStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TableStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeCount != 0 {
		n += 1 + sovAdmin(uint64(m.RangeCount))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicaCount))
	}
	if m.NodeCount != 0 {
		n += 1 + sovAdmin(uint64(m.NodeCount))
	}
	l = m.Stats.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if len(m.MissingNodes) > 0 {
		for _, e := range m.MissingNodes {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.ApproximateDiskBytes != 0 {
		n += 1 + sovAdmin(uint64(m.ApproximateDiskBytes))
	}
	if len(m.NodeIDs) > 0 {
		l = 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	return n
}

func (m *TableStatsResponse_MissingNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *NonTableStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NonTableStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeSeriesStats != nil {
		l = m.TimeSeriesStats.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.InternalUseStats != nil {
		l = m.InternalUseStats.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *UsersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UsersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *UsersResponse_User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *EventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovAdmin(uint64(m.Limit))
	}
	if m.UnredactedEvents {
		n += 2
	}
	return n
}

func (m *EventsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *EventsResponse_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovAdmin(uint64(l))
	l = len(m.EventType)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.ReportingID != 0 {
		n += 1 + sovAdmin(uint64(m.ReportingID))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.UniqueID)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *SetUIDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		for k, v := range m.KeyValues {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovAdmin(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SetUIDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetUIDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *GetUIDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		for k, v := range m.KeyValues {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetUIDataResponse_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdated)
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *ClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.ReportingEnabled {
		n += 2
	}
	if m.EnterpriseEnabled {
		n += 2
	}
	return n
}

func (m *DrainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	if m.DoDrain {
		n += 2
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Verbose {
		n += 2
	}
	return n
}

func (m *DrainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsDraining {
		n += 2
	}
	if m.DrainRemainingIndicator != 0 {
		n += 1 + sovAdmin(uint64(m.DrainRemainingIndicator))
	}
	l = len(m.DrainRemainingDescription)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DecommissionPreCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeIDs) > 0 {
		l = 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if m.NumReplicaReport != 0 {
		n += 1 + sovAdmin(uint64(m.NumReplicaReport))
	}
	if m.StrictReadiness {
		n += 2
	}
	if m.CollectTraces {
		n += 2
	}
	return n
}

func (m *DecommissionPreCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CheckedNodes) > 0 {
		for _, e := range m.CheckedNodes {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DecommissionPreCheckResponse_RangeCheckResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovAdmin(uint64(m.RangeID))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DecommissionPreCheckResponse_NodeCheckResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	if m.DecommissionReadiness != 0 {
		n += 1 + sovAdmin(uint64(m.DecommissionReadiness))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicaCount))
	}
	if len(m.CheckedRanges) > 0 {
		for _, e := range m.CheckedRanges {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DecommissionStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeIDs) > 0 {
		l = 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if m.NumReplicaReport != 0 {
		n += 1 + sovAdmin(uint64(m.NumReplicaReport))
	}
	return n
}

func (m *DecommissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeIDs) > 0 {
		l = 0
		for _, e := range m.NodeIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if m.TargetMembership != 0 {
		n += 1 + sovAdmin(uint64(m.TargetMembership))
	}
	if m.NumReplicaReport != 0 {
		n += 1 + sovAdmin(uint64(m.NumReplicaReport))
	}
	return n
}

func (m *DecommissionStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DecommissionStatusResponse_Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicaID))
	}
	if m.RangeID != 0 {
		n += 1 + sovAdmin(uint64(m.RangeID))
	}
	return n
}

func (m *DecommissionStatusResponse_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	if m.IsLive {
		n += 2
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicaCount))
	}
	if m.Membership != 0 {
		n += 1 + sovAdmin(uint64(m.Membership))
	}
	if m.Draining {
		n += 2
	}
	if len(m.ReportedReplicas) > 0 {
		for _, e := range m.ReportedReplicas {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *SettingsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *SettingsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		for k, v := range m.KeyValues {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SettingsResponse_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Public {
		n += 2
	}
	if m.LastUpdated != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastUpdated)
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *HealthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ready {
		n += 2
	}
	return n
}

func (m *HealthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LivenessRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LivenessResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Livenesses) > 0 {
		for _, e := range m.Livenesses {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Statuses) > 0 {
		for k, v := range m.Statuses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAdmin(uint64(k)) + 1 + sovAdmin(uint64(v))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovAdmin(uint64(m.Limit))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAdmin(uint64(m.Type))
	}
	return n
}

func (m *JobsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.EarliestRetainedTime)
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *JobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != 0 {
		n += 1 + sovAdmin(uint64(m.JobId))
	}
	return n
}

func (m *JobMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovAdmin(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *JobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAdmin(uint64(m.ID))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.DescriptorIDs) > 0 {
		l = 0
		for _, e := range m.DescriptorIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Created != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Started != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Started)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Finished != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Finished)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Modified != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Modified)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.FractionCompleted != 0 {
		n += 5
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.HighwaterTimestamp != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.HighwaterTimestamp)
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.HighwaterDecimal)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.RunningStatus)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Statement)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.LastRun != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastRun)
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.NextRun != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.NextRun)
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.NumRuns != 0 {
		n += 2 + sovAdmin(uint64(m.NumRuns))
	}
	if len(m.ExecutionFailures) > 0 {
		for _, e := range m.ExecutionFailures {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if m.CoordinatorID != 0 {
		n += 2 + sovAdmin(uint64(m.CoordinatorID))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *JobResponse_ExecutionFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Start != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Start)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.End != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.End)
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *LocationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LocationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *LocationsResponse_Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalityKey)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.LocalityValue)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.Longitude != 0 {
		n += 9
	}
	return n
}

func (m *RangeLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovAdmin(uint64(m.RangeId))
	}
	if m.Limit != 0 {
		n += 1 + sovAdmin(uint64(m.Limit))
	}
	return n
}

func (m *RangeLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *RangeLogResponse_PrettyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UpdatedDesc)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.NewDesc)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.AddedReplica)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.RemovedReplica)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *RangeLogResponse_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Event.Size()
	n += 1 + l + sovAdmin(uint64(l))
	l = m.PrettyInfo.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *QueryPlanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *QueryPlanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DistSQLPhysicalQueryPlan)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DataDistributionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DataDistributionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DatabaseInfo) > 0 {
		for k, v := range m.DatabaseInfo {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	if len(m.ZoneConfigs) > 0 {
		for k, v := range m.ZoneConfigs {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DataDistributionResponse_ZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovAdmin(uint64(l))
	l = len(m.ConfigSQL)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DataDistributionResponse_TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReplicaCountByNodeId) > 0 {
		for k, v := range m.ReplicaCountByNodeId {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAdmin(uint64(k)) + 1 + sovAdmin(uint64(v))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	if m.DroppedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.DroppedAt)
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DataDistributionResponse_DatabaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableInfo) > 0 {
		for k, v := range m.TableInfo {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MetricMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MetricMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	if len(m.RecordedNames) > 0 {
		for k, v := range m.RecordedNames {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + len(v) + sovAdmin(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EnqueueRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.RangeID != 0 {
		n += 1 + sovAdmin(uint64(m.RangeID))
	}
	if m.SkipShouldQueue {
		n += 2
	}
	return n
}

func (m *EnqueueRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *EnqueueRangeResponse_Details) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ChartCatalogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ChartCatalogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Catalog) > 0 {
		for _, e := range m.Catalog {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *RecoveryCollectReplicaInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxConcurrency != 0 {
		n += 1 + sovAdmin(uint64(m.MaxConcurrency))
	}
	return n
}

func (m *RecoveryCollectReplicaRestartNodeStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	return n
}

func (m *RecoveryCollectReplicaInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		n += m.Info.Size()
	}
	return n
}

func (m *RecoveryCollectReplicaInfoResponse_RangeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeDescriptor != nil {
		l = m.RangeDescriptor.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}
func (m *RecoveryCollectReplicaInfoResponse_ReplicaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaInfo != nil {
		l = m.ReplicaInfo.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}
func (m *RecoveryCollectReplicaInfoResponse_NodeStreamRestarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeStreamRestarted != nil {
		l = m.NodeStreamRestarted.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}
func (m *RecoveryCollectReplicaInfoResponse_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}
func (m *RecoveryCollectLocalReplicaInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RecoveryCollectLocalReplicaInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaInfo != nil {
		l = m.ReplicaInfo.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *RecoveryStagePlanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		l = m.Plan.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.AllNodes {
		n += 2
	}
	if m.ForcePlan {
		n += 2
	}
	if m.ForceLocalInternalVersion {
		n += 2
	}
	if m.MaxConcurrency != 0 {
		n += 1 + sovAdmin(uint64(m.MaxConcurrency))
	}
	return n
}

func (m *RecoveryStagePlanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *RecoveryNodeStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RecoveryNodeStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Status.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *RecoveryVerifyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PendingPlanID != nil {
		l = m.PendingPlanID.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.DecommissionedNodeIDs) > 0 {
		l = 0
		for _, e := range m.DecommissionedNodeIDs {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if m.MaxReportedRanges != 0 {
		n += 1 + sovAdmin(uint64(m.MaxReportedRanges))
	}
	if m.MaxConcurrency != 0 {
		n += 1 + sovAdmin(uint64(m.MaxConcurrency))
	}
	return n
}

func (m *RecoveryVerifyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = m.UnavailableRanges.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if len(m.DecommissionedNodeStatuses) > 0 {
		for k, v := range m.DecommissionedNodeStatuses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAdmin(uint64(k)) + 1 + sovAdmin(uint64(v))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RecoveryVerifyResponse_UnavailableRanges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListTenantsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListTenantsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for _, e := range m.Tenants {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *Tenant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantId != nil {
		l = m.TenantId.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.TenantName)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.SqlAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.RpcAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ReadFromTenantInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TenantID.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *ReadFromTenantInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReadFrom.Size()
	n += 1 + l + sovAdmin(uint64(l))
	l = m.ReadAt.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *ListTracingSnapshotsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListTracingSnapshotsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Snapshots) > 0 {
		for _, e := range m.Snapshots {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *SnapshotInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotID != 0 {
		n += 1 + sovAdmin(uint64(m.SnapshotID))
	}
	if m.CapturedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CapturedAt)
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TakeTracingSnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TakeTracingSnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *GetTracingSnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotId != 0 {
		n += 1 + sovAdmin(uint64(m.SnapshotId))
	}
	return n
}

func (m *GetTracingSnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *GetTraceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotID != 0 {
		n += 1 + sovAdmin(uint64(m.SnapshotID))
	}
	if m.TraceID != 0 {
		n += 1 + sovAdmin(uint64(m.TraceID))
	}
	if m.RecordingType != 0 {
		n += 1 + sovAdmin(uint64(m.RecordingType))
	}
	return n
}

func (m *GetTraceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotID != 0 {
		n += 1 + sovAdmin(uint64(m.SnapshotID))
	}
	if m.TraceID != 0 {
		n += 1 + sovAdmin(uint64(m.TraceID))
	}
	if m.StillExists {
		n += 2
	}
	l = len(m.SerializedRecording)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TracingSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotID != 0 {
		n += 1 + sovAdmin(uint64(m.SnapshotID))
	}
	if m.CapturedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CapturedAt)
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Stacks) > 0 {
		for k, v := range m.Stacks {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + len(v) + sovAdmin(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NamedOperationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *TracingSpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.TraceID != 0 {
		n += 1 + sovAdmin(uint64(m.TraceID))
	}
	if m.SpanID != 0 {
		n += 1 + sovAdmin(uint64(m.SpanID))
	}
	if m.ParentSpanID != 0 {
		n += 1 + sovAdmin(uint64(m.ParentSpanID))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovAdmin(uint64(l))
	if m.GoroutineID != 0 {
		n += 1 + sovAdmin(uint64(m.GoroutineID))
	}
	if len(m.ProcessedTags) > 0 {
		for _, e := range m.ProcessedTags {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.Current {
		n += 2
	}
	if m.CurrentRecordingMode != 0 {
		n += 1 + sovAdmin(uint64(m.CurrentRecordingMode))
	}
	if len(m.ChildrenMetadata) > 0 {
		for _, e := range m.ChildrenMetadata {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *SpanTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if m.Highlight {
		n += 2
	}
	if m.Inherit {
		n += 2
	}
	if m.Inherited {
		n += 2
	}
	if m.PropagateUp {
		n += 2
	}
	if m.CopiedFromChild {
		n += 2
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *ChildSpanTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *SetTraceRecordingTypeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TraceID != 0 {
		n += 1 + sovAdmin(uint64(m.TraceID))
	}
	if m.SpanID != 0 {
		n += 1 + sovAdmin(uint64(m.SpanID))
	}
	if m.RecordingMode != 0 {
		n += 1 + sovAdmin(uint64(m.RecordingMode))
	}
	return n
}

func (m *SetTraceRecordingTypeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FeatureFlags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsObservabilityService {
		n += 2
	}
	if m.CanViewKvMetricDashboards {
		n += 2
	}
	if m.DisableKvLevelAdvancedDebug {
		n += 2
	}
	return n
}

func sovAdmin(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozAdmin(x uint64) (n int) {
	return sovAdmin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DatabasesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabasesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabasesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabasesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabasesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabasesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Databases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Databases = append(m.Databases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeStats = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grants = append(m.Grants, DatabaseDetailsResponse_Grant{})
			if err := m.Grants[len(m.Grants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableNames = append(m.TableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ZoneConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfigLevel", wireType)
			}
			m.ZoneConfigLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZoneConfigLevel |= ZoneConfigurationLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DatabaseDetailsResponse_Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsResponse_Grant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Privileges = append(m.Privileges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsResponse_Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingTables = append(m.MissingTables, &DatabaseDetailsResponse_Stats_MissingTable{})
			if err := m.MissingTables[len(m.MissingTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateDiskBytes", wireType)
			}
			m.ApproximateDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateDiskBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeIDs = append(m.NodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.NodeIDs == nil {
						m.NodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.NodeIDs = slices.Grow(m.NodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeIDs = append(m.NodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIDs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIndexRecommendations", wireType)
			}
			m.NumIndexRecommendations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumIndexRecommendations |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsResponse_Stats_MissingTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MissingTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MissingTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grants = append(m.Grants, TableDetailsResponse_Grant{})
			if err := m.Grants[len(m.Grants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, TableDetailsResponse_Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, TableDetailsResponse_Index{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTableStatement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTableStatement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ZoneConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfigLevel", wireType)
			}
			m.ZoneConfigLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZoneConfigLevel |= ZoneConfigurationLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigureZoneStatement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigureZoneStatement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsLastCreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsLastCreatedAt == nil {
				m.StatsLastCreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StatsLastCreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasIndexRecommendations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasIndexRecommendations = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotalBytes", wireType)
			}
			m.DataTotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotalBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLiveBytes", wireType)
			}
			m.DataLiveBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLiveBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLivePercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DataLivePercentage = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse_Grant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Privileges = append(m.Privileges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse_Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerationExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenerationExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse_Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Storing = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implicit = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingNodes = append(m.MissingNodes, TableStatsResponse_MissingNode{})
			if err := m.MissingNodes[len(m.MissingNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateDiskBytes", wireType)
			}
			m.ApproximateDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateDiskBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeIDs = append(m.NodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.NodeIDs == nil {
						m.NodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.NodeIDs = slices.Grow(m.NodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeIDs = append(m.NodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatsResponse_MissingNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MissingNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MissingNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonTableStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonTableStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonTableStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonTableStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonTableStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonTableStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSeriesStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeSeriesStats == nil {
				m.TimeSeriesStats = &TableStatsResponse{}
			}
			if err := m.TimeSeriesStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalUseStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalUseStats == nil {
				m.InternalUseStats = &TableStatsResponse{}
			}
			if err := m.InternalUseStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, UsersResponse_User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersResponse_User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnredactedEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnredactedEvents = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, EventsResponse_Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse_Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportingID", wireType)
			}
			m.ReportingID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportingID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueID = append(m.UniqueID[:0], dAtA[iNdEx:postIndex]...)
			if m.UniqueID == nil {
				m.UniqueID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUIDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUIDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUIDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyValues == nil {
				m.KeyValues = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthAdmin
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KeyValues[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUIDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUIDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUIDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUIDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUIDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUIDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUIDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyValues == nil {
				m.KeyValues = make(map[string]GetUIDataResponse_Value)
			}
			var mapkey string
			mapvalue := &GetUIDataResponse_Value{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GetUIDataResponse_Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KeyValues[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataResponse_Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportingEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnterpriseEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoDrain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoDrain = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verbose = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDraining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDraining = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainRemainingIndicator", wireType)
			}
			m.DrainRemainingIndicator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrainRemainingIndicator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainRemainingDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrainRemainingDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionPreCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecommissionPreCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecommissionPreCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeIDs = append(m.NodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.NodeIDs == nil {
						m.NodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.NodeIDs = slices.Grow(m.NodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeIDs = append(m.NodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicaReport", wireType)
			}
			m.NumReplicaReport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicaReport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictReadiness", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrictReadiness = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectTraces", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectTraces = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionPreCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecommissionPreCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecommissionPreCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckedNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckedNodes = append(m.CheckedNodes, DecommissionPreCheckResponse_NodeCheckResult{})
			if err := m.CheckedNodes[len(m.CheckedNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionPreCheckResponse_RangeCheckResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeCheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeCheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &TraceEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionPreCheckResponse_NodeCheckResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecommissionReadiness", wireType)
			}
			m.DecommissionReadiness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecommissionReadiness |= DecommissionPreCheckResponse_NodeReadiness(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckedRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckedRanges = append(m.CheckedRanges, DecommissionPreCheckResponse_RangeCheckResult{})
			if err := m.CheckedRanges[len(m.CheckedRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecommissionStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecommissionStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeIDs = append(m.NodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.NodeIDs == nil {
						m.NodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.NodeIDs = slices.Grow(m.NodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeIDs = append(m.NodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicaReport", wireType)
			}
			m.NumReplicaReport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicaReport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecommissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecommissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeIDs = append(m.NodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.NodeIDs == nil {
						m.NodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.NodeIDs = slices.Grow(m.NodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeIDs = append(m.NodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetMembership", wireType)
			}
			m.TargetMembership = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetMembership |= livenesspb.MembershipStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicaReport", wireType)
			}
			m.NumReplicaReport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicaReport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecommissionStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecommissionStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, DecommissionStatusResponse_Status{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionStatusResponse_Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecommissionStatusResponse_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			m.Membership = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Membership |= livenesspb.MembershipStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Draining = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportedReplicas = append(m.ReportedReplicas, &DecommissionStatusResponse_Replica{})
			if err := m.ReportedReplicas[len(m.ReportedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SettingsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SettingsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SettingsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SettingsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SettingsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SettingsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyValues == nil {
				m.KeyValues = make(map[string]SettingsResponse_Value)
			}
			var mapkey string
			mapvalue := &SettingsResponse_Value{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SettingsResponse_Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KeyValues[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SettingsResponse_Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastUpdated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LivenessRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LivenessRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LivenessRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LivenessResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LivenessResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LivenessResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Livenesses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Livenesses = append(m.Livenesses, livenesspb.Liveness{})
			if err := m.Livenesses[len(m.Livenesses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statuses == nil {
				m.Statuses = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus)
			}
			var mapkey int32
			var mapvalue livenesspb.NodeLivenessStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= livenesspb.NodeLivenessStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Statuses[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= jobspb.Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, JobResponse{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestRetainedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.EarliestRetainedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DescriptorIDs = append(m.DescriptorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.DescriptorIDs == nil {
						m.DescriptorIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID, 0, elementCount)
					} else {
						m.DescriptorIDs = slices.Grow(m.DescriptorIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DescriptorIDs = append(m.DescriptorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorIDs", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Started, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Finished, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modified == nil {
				m.Modified = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Modified, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FractionCompleted", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.FractionCompleted = float32(math.Float32frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighwaterTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighwaterTimestamp == nil {
				m.HighwaterTimestamp = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.HighwaterTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighwaterDecimal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighwaterDecimal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRun == nil {
				m.LastRun = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastRun, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextRun == nil {
				m.NextRun = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.NextRun, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRuns", wireType)
			}
			m.NumRuns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRuns |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionFailures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionFailures = append(m.ExecutionFailures, &JobResponse_ExecutionFailure{})
			if err := m.ExecutionFailures[len(m.ExecutionFailures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorID", wireType)
			}
			m.CoordinatorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, JobMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobResponse_ExecutionFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.End, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, LocationsResponse_Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationsResponse_Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, RangeLogResponse_Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLogResponse_PrettyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrettyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrettyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedReplica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddedReplica = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedReplica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemovedReplica = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLogResponse_Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrettyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrettyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPlanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPlanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPlanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPlanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPlanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPlanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQLPhysicalQueryPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistSQLPhysicalQueryPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDistributionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDistributionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDistributionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDistributionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDistributionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDistributionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseInfo == nil {
				m.DatabaseInfo = make(map[string]DataDistributionResponse_DatabaseInfo)
			}
			var mapkey string
			mapvalue := &DataDistributionResponse_DatabaseInfo{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DataDistributionResponse_DatabaseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DatabaseInfo[mapkey] = *mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZoneConfigs == nil {
				m.ZoneConfigs = make(map[string]DataDistributionResponse_ZoneConfig)
			}
			var mapkey string
			mapvalue := &DataDistributionResponse_ZoneConfig{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DataDistributionResponse_ZoneConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ZoneConfigs[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDistributionResponse_ZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSQL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigSQL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDistributionResponse_TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCountByNodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplicaCountByNodeId == nil {
				m.ReplicaCountByNodeId = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReplicaCountByNodeId[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DroppedAt == nil {
				m.DroppedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.DroppedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDistributionResponse_DatabaseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = make(map[string]DataDistributionResponse_TableInfo)
			}
			var mapkey string
			mapvalue := &DataDistributionResponse_TableInfo{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DataDistributionResponse_TableInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableInfo[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]metric.Metadata)
			}
			var mapkey string
			mapvalue := &metric.Metadata{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &metric.Metadata{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = *mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordedNames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecordedNames == nil {
				m.RecordedNames = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RecordedNames[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnqueueRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnqueueRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnqueueRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipShouldQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipShouldQueue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnqueueRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnqueueRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnqueueRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &EnqueueRangeResponse_Details{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnqueueRangeResponse_Details) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &TraceEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartCatalogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartCatalogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartCatalogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartCatalogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartCatalogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartCatalogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Catalog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Catalog = append(m.Catalog, catalog.ChartSection{})
			if err := m.Catalog[len(m.Catalog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCollectReplicaInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCollectReplicaInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCollectReplicaInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrency", wireType)
			}
			m.MaxConcurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCollectReplicaRestartNodeStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCollectReplicaRestartNodeStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCollectReplicaRestartNodeStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCollectReplicaInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCollectReplicaInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCollectReplicaInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RecoveryCollectReplicaInfoResponse_RangeDescriptor
				field roachpb.RangeDescriptor
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RangeDescriptor = &alloc.field
			m.Info = &alloc.value
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RecoveryCollectReplicaInfoResponse_ReplicaInfo
				field loqrecoverypb.ReplicaInfo
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ReplicaInfo = &alloc.field
			m.Info = &alloc.value
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStreamRestarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RecoveryCollectReplicaInfoResponse_NodeStreamRestarted
				field RecoveryCollectReplicaRestartNodeStream
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.NodeStreamRestarted = &alloc.field
			m.Info = &alloc.value
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value RecoveryCollectReplicaInfoResponse_Metadata
				field loqrecoverypb.ClusterMetadata
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Metadata = &alloc.field
			m.Info = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCollectLocalReplicaInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCollectLocalReplicaInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCollectLocalReplicaInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCollectLocalReplicaInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCollectLocalReplicaInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCollectLocalReplicaInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplicaInfo == nil {
				m.ReplicaInfo = &loqrecoverypb.ReplicaInfo{}
			}
			if err := m.ReplicaInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryStagePlanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryStagePlanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryStagePlanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &loqrecoverypb.ReplicaUpdatePlan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllNodes = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePlan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePlan = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceLocalInternalVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceLocalInternalVersion = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrency", wireType)
			}
			m.MaxConcurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryStagePlanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryStagePlanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryStagePlanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryNodeStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryNodeStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryNodeStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryNodeStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryNodeStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryNodeStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryVerifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryVerifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryVerifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPlanID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.PendingPlanID = &v
			if err := m.PendingPlanID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DecommissionedNodeIDs = append(m.DecommissionedNodeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.DecommissionedNodeIDs == nil {
						m.DecommissionedNodeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
					} else {
						m.DecommissionedNodeIDs = slices.Grow(m.DecommissionedNodeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DecommissionedNodeIDs = append(m.DecommissionedNodeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DecommissionedNodeIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReportedRanges", wireType)
			}
			m.MaxReportedRanges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReportedRanges |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrency", wireType)
			}
			m.MaxConcurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryVerifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryVerifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryVerifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, loqrecoverypb.NodeRecoveryStatus{})
			if err := m.Statuses[len(m.Statuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnavailableRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnavailableRanges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecommissionedNodeStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecommissionedNodeStatuses == nil {
				m.DecommissionedNodeStatuses = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.MembershipStatus)
			}
			var mapkey int32
			var mapvalue livenesspb.MembershipStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= livenesspb.MembershipStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DecommissionedNodeStatuses[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryVerifyResponse_UnavailableRanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnavailableRanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnavailableRanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, loqrecoverypb.RangeRecoveryStatus{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTenantsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTenantsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTenantsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTenantsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTenantsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTenantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenants = append(m.Tenants, &Tenant{})
			if err := m.Tenants[len(m.Tenants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tenant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tenant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tenant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantId == nil {
				m.TenantId = &roachpb.TenantID{}
			}
			if err := m.TenantId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFromTenantInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFromTenantInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFromTenantInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFromTenantInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFromTenantInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFromTenantInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTracingSnapshotsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTracingSnapshotsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTracingSnapshotsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTracingSnapshotsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTracingSnapshotsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTracingSnapshotsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshots = append(m.Snapshots, &SnapshotInfo{})
			if err := m.Snapshots[len(m.Snapshots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			m.SnapshotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapturedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CapturedAt == nil {
				m.CapturedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CapturedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TakeTracingSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TakeTracingSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TakeTracingSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TakeTracingSnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TakeTracingSnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TakeTracingSnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &SnapshotInfo{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTracingSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTracingSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTracingSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotId", wireType)
			}
			m.SnapshotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTracingSnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTracingSnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTracingSnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &TracingSnapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTraceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTraceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTraceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			m.SnapshotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			m.TraceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceID |= github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.TraceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordingType", wireType)
			}
			m.RecordingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordingType |= tracingpb.RecordingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTraceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTraceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTraceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			m.SnapshotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			m.TraceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceID |= github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.TraceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StillExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StillExists = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedRecording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedRecording = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			m.SnapshotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapturedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CapturedAt == nil {
				m.CapturedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CapturedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &TracingSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stacks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stacks == nil {
				m.Stacks = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Stacks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedOperationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedOperationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedOperationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingSpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			m.TraceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			m.SpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSpanID", wireType)
			}
			m.ParentSpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentSpanID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoroutineID", wireType)
			}
			m.GoroutineID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoroutineID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessedTags = append(m.ProcessedTags, &SpanTag{})
			if err := m.ProcessedTags[len(m.ProcessedTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Current = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRecordingMode", wireType)
			}
			m.CurrentRecordingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentRecordingMode |= tracingpb.RecordingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildrenMetadata = append(m.ChildrenMetadata, &NamedOperationMetadata{})
			if err := m.ChildrenMetadata[len(m.ChildrenMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Highlight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Highlight = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inherit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inherit = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inherited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inherited = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagateUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropagateUp = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopiedFromChild", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopiedFromChild = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &ChildSpanTag{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChildSpanTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChildSpanTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChildSpanTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTraceRecordingTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTraceRecordingTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTraceRecordingTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			m.TraceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceID |= github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.TraceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			m.SpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanID |= github_com_cockroachdb_cockroach_pkg_util_tracing_tracingpb.SpanID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordingMode", wireType)
			}
			m.RecordingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordingMode |= tracingpb.RecordingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTraceRecordingTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTraceRecordingTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTraceRecordingTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureFlags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureFlags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureFlags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsObservabilityService", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsObservabilityService = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanViewKvMetricDashboards", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanViewKvMetricDashboards = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableKvLevelAdvancedDebug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableKvLevelAdvancedDebug = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdmin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdmin
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAdmin
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAdmin
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAdmin        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdmin          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAdmin = fmt.Errorf("proto: unexpected end of group")
)

