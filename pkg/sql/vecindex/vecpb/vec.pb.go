// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/vecindex/vecpb/vec.proto

package vecpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RotAlgorithm specifies the algorithm used to randomly rotate the original
// vectors inserted into the index.
type RotAlgorithm int32

const (
	// RotMatrix specifies that vectors will be randomly rotated by multiplying
	// them by a full random orthogonal matrix (e.g., generated via QR
	// decomposition of a random Gaussian matrix). This provides a true
	// Haar-random rotation, which fully preserves all pairwise distances and
	// angles.
	// NOTE: This algorithm is retained for backwards-compatibility and will not
	// be used for new indexes due to its high computational cost, especially in
	// high dimensions.
	RotMatrix RotAlgorithm = 0
	// RotNone specifies that vectors will not be randomly rotated. This is
	// appropriate when the input vectors are already sufficiently mixed. For
	// example, OpenAI embeddings are often already well-mixed, so additional
	// random rotation provides little benefit and can be skipped to save
	// computation.
	RotNone RotAlgorithm = 1
	// RotGivens specifies that vectors will be randomly rotated by applying a
	// sequence of Givens rotations. Each Givens rotation mixes a pair of vector
	// coordinates using a random angle, and applying O(N log N) such rotations
	// (where N is the number of dimensions) is sufficient to approximate a
	// Haar-random orthogonal transformation. This approach is much more
	// computationally efficient than applying a full random orthogonal matrix,
	// while still providing strong mixing and preserving all pairwise distances
	// and angles between vectors.
	RotGivens RotAlgorithm = 2
)

var RotAlgorithm_name = map[int32]string{
	0: "RotMatrix",
	1: "RotNone",
	2: "RotGivens",
}

var RotAlgorithm_value = map[string]int32{
	"RotMatrix": 0,
	"RotNone":   1,
	"RotGivens": 2,
}

func (x RotAlgorithm) String() string {
	return proto.EnumName(RotAlgorithm_name, int32(x))
}

func (RotAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b5dcf377592245f2, []int{0}
}

// DistanceMetric defines the function that's used to compute similarity between
// vectors.
type DistanceMetric int32

const (
	// L2SquaredDistance specifies squared Euclidean distance between two vectors,
	// defined as the square of the L2 norm of their difference:
	//  ||vec1 - vec2||²
	//
	// This is equivalent to the dot product of the difference with itself:
	//  (vec1 - vec2) · (vec1 - vec2)
	L2SquaredDistance DistanceMetric = 0
	// InnerProductDistance specifies inner product distance between two vectors,
	// defined as the negative value of the dot product between them:
	//  -(vec1 · vec2)
	//
	// Negating the distance ensures that the smaller the distance, the more
	// similar are the vectors, aligning this metric with L2Squared and Cosine.
	InnerProductDistance DistanceMetric = 1
	// CosineDistance specifies the cosine distance between two vectors, defined
	// as one minus their cosine similarity:
	//  1 - cos(vec1, vec2)
	//
	// Cosine similarity is computed as the dot product of the vectors divided
	// by the product of their norms (magnitudes):
	//  cos(vec1, vec2) = (vec1 · vec2) / (||vec1|| * ||vec2||)
	//
	// However, when using Cosine distance, we always pre-normalize vectors, so
	// that they are always unit vectors. This means the product of their norms
	// is one. Therefore, cosine distance becomes simply:
	//  1 - (vec1 · vec2)
	CosineDistance DistanceMetric = 2
)

var DistanceMetric_name = map[int32]string{
	0: "L2SquaredDistance",
	1: "InnerProductDistance",
	2: "CosineDistance",
}

var DistanceMetric_value = map[string]int32{
	"L2SquaredDistance":    0,
	"InnerProductDistance": 1,
	"CosineDistance":       2,
}

func (x DistanceMetric) String() string {
	return proto.EnumName(DistanceMetric_name, int32(x))
}

func (DistanceMetric) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b5dcf377592245f2, []int{1}
}

// Config encapsulates the information needed to search and maintain a vector
// index. This includes the dimensions of the vectors and the random seed,
// neither of which should change after the index is created.
type Config struct {
	// Dims is the width of vectors in the index (i.e. number of dimensions).
	Dims int32 `protobuf:"varint,1,opt,name=dims,proto3" json:"dims,omitempty"`
	// Seed initializes the pseudo-random generator used to randomly perturb
	// vectors, in order to mitigate the impact of skewed input data
	// distributions. This seed stays constant for the lifetime of the index.
	Seed int64 `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
	// BuildBeamSize specifies the default breadth of searches used when inserting
	// into, deleting from, or updating the index. This is typically quite a bit
	// smaller than the beam sizes used during read-only search, since it's not
	// critical for vectors to be in exactly the nearest partition - close enough
	// is good enough.
	BuildBeamSize int32 `protobuf:"varint,3,opt,name=build_beam_size,json=buildBeamSize,proto3" json:"build_beam_size,omitempty"`
	// MinPartitionSize is the lowest number of vectors that a partition can have
	// without being merged away.
	MinPartitionSize int32 `protobuf:"varint,4,opt,name=min_partition_size,json=minPartitionSize,proto3" json:"min_partition_size,omitempty"`
	// MaxPartitionSize is the highest number of vectors that a partition can have
	// without being split.
	MaxPartitionSize int32 `protobuf:"varint,5,opt,name=max_partition_size,json=maxPartitionSize,proto3" json:"max_partition_size,omitempty"`
	// IsDeterministic means that background fixup operations on the index are
	// deterministic, as explained in the DeterministicFixupsSetting comment. This
	// is set to true when the DeterministicFixupsSetting is true at index
	// creation time.
	IsDeterministic bool `protobuf:"varint,6,opt,name=is_deterministic,json=isDeterministic,proto3" json:"is_deterministic,omitempty"`
	// RotAlgorithm specifies the type of random orthogonal transformation to
	// apply to vectors before indexing and search. It must be one of the
	// cspann.RotAlgorithm enum values.
	RotAlgorithm RotAlgorithm `protobuf:"varint,7,opt,name=rot_algorithm,json=rotAlgorithm,proto3,enum=cockroach.sql.vecindex.vecpb.RotAlgorithm" json:"rot_algorithm,omitempty"`
	// DistanceMetric specifies how similarity is computed for vectors in the
	// index, e.g. Euclidean (L2Squared), InnerProduct, or Cosine.
	DistanceMetric DistanceMetric `protobuf:"varint,8,opt,name=distance_metric,json=distanceMetric,proto3,enum=cockroach.sql.vecindex.vecpb.DistanceMetric" json:"distance_metric,omitempty"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5dcf377592245f2, []int{0}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.vecindex.vecpb.RotAlgorithm", RotAlgorithm_name, RotAlgorithm_value)
	proto.RegisterEnum("cockroach.sql.vecindex.vecpb.DistanceMetric", DistanceMetric_name, DistanceMetric_value)
	proto.RegisterType((*Config)(nil), "cockroach.sql.vecindex.vecpb.Config")
}

func init() { proto.RegisterFile("sql/vecindex/vecpb/vec.proto", fileDescriptor_b5dcf377592245f2) }

var fileDescriptor_b5dcf377592245f2 = []byte{
	// 467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0xc1, 0x6a, 0x13, 0x41,
	0x1c, 0xc6, 0x77, 0x9a, 0x34, 0xad, 0x63, 0x93, 0xac, 0x43, 0x85, 0xa5, 0x94, 0x35, 0x78, 0x90,
	0x18, 0xca, 0x2e, 0xd4, 0x83, 0xe0, 0x45, 0x6c, 0x0b, 0x22, 0x58, 0x2d, 0x5b, 0x3c, 0xa8, 0x87,
	0x65, 0x76, 0x66, 0xdc, 0xfc, 0x69, 0x66, 0x26, 0x99, 0x99, 0x94, 0xd0, 0x27, 0xf0, 0x22, 0xf8,
	0x08, 0x82, 0x2f, 0xd3, 0x63, 0x8f, 0x3d, 0x6a, 0x72, 0xf1, 0x31, 0x24, 0xd3, 0x24, 0x26, 0x16,
	0x7a, 0x19, 0xbe, 0xf9, 0xbe, 0xdf, 0xf7, 0x1f, 0x18, 0xfe, 0x78, 0xd7, 0x0e, 0x7a, 0xe9, 0xb9,
	0x60, 0xa0, 0xb8, 0x18, 0x4d, 0x45, 0xbf, 0x98, 0x9e, 0x49, 0xdf, 0x68, 0xa7, 0xc9, 0x2e, 0xd3,
	0xec, 0xcc, 0x68, 0xca, 0xba, 0x89, 0x1d, 0xf4, 0x92, 0x39, 0x97, 0x78, 0x6e, 0x67, 0xbb, 0xd4,
	0xa5, 0xf6, 0x60, 0x3a, 0x55, 0x37, 0x9d, 0xc7, 0xdf, 0x2a, 0xb8, 0x76, 0xa8, 0xd5, 0x17, 0x28,
	0x09, 0xc1, 0x55, 0x0e, 0xd2, 0x46, 0xa8, 0x85, 0xda, 0xeb, 0x99, 0xd7, 0x53, 0xcf, 0x0a, 0xc1,
	0xa3, 0xb5, 0x16, 0x6a, 0x57, 0x32, 0xaf, 0xc9, 0x13, 0xdc, 0x2c, 0x86, 0xd0, 0xe3, 0x79, 0x21,
	0xa8, 0xcc, 0x2d, 0x5c, 0x88, 0xa8, 0xe2, 0x2b, 0x75, 0x6f, 0x1f, 0x08, 0x2a, 0x4f, 0xe1, 0x42,
	0x90, 0x3d, 0x4c, 0x24, 0xa8, 0xbc, 0x4f, 0x8d, 0x03, 0x07, 0x5a, 0xdd, 0xa0, 0x55, 0x8f, 0x86,
	0x12, 0xd4, 0xc9, 0x3c, 0x58, 0xd0, 0x74, 0xf4, 0x3f, 0xbd, 0x3e, 0xa3, 0xe9, 0x68, 0x95, 0x7e,
	0x8a, 0x43, 0xb0, 0x39, 0x17, 0x4e, 0x18, 0x09, 0x0a, 0xac, 0x03, 0x16, 0xd5, 0x5a, 0xa8, 0xbd,
	0x99, 0x35, 0xc1, 0x1e, 0x2d, 0xdb, 0xe4, 0x3d, 0xae, 0x1b, 0xed, 0x72, 0xda, 0x2b, 0xb5, 0x01,
	0xd7, 0x95, 0xd1, 0x46, 0x0b, 0xb5, 0x1b, 0xfb, 0x9d, 0xe4, 0xae, 0xdf, 0x4a, 0x32, 0xed, 0x5e,
	0xcd, 0x1b, 0xd9, 0x96, 0x59, 0xba, 0x91, 0x0f, 0xb8, 0xc9, 0xc1, 0x3a, 0xaa, 0x98, 0xc8, 0xa5,
	0x70, 0x06, 0x58, 0xb4, 0xe9, 0x47, 0xee, 0xdd, 0x3d, 0xf2, 0x68, 0x56, 0x3a, 0xf6, 0x9d, 0xac,
	0xc1, 0x57, 0xee, 0x2f, 0xaa, 0x7f, 0x7e, 0x3c, 0x42, 0x9d, 0x97, 0x78, 0x6b, 0xf9, 0x69, 0x52,
	0xc7, 0xf7, 0x32, 0xed, 0x8e, 0xa9, 0x33, 0x30, 0x0a, 0x03, 0x72, 0x1f, 0x6f, 0x64, 0xda, 0xbd,
	0xd3, 0x4a, 0x84, 0x68, 0x96, 0xbd, 0x86, 0x73, 0xa1, 0x6c, 0xb8, 0xb6, 0x53, 0xfd, 0xfa, 0x33,
	0x0e, 0x3a, 0x9f, 0x71, 0x63, 0xf5, 0x21, 0xf2, 0x10, 0x3f, 0x78, 0xbb, 0x7f, 0x3a, 0x18, 0x52,
	0x23, 0xf8, 0x3c, 0x0a, 0x03, 0x12, 0xe1, 0xed, 0x37, 0x4a, 0x09, 0x73, 0x62, 0x34, 0x1f, 0x32,
	0xb7, 0x48, 0x10, 0x21, 0xb8, 0x71, 0xa8, 0x2d, 0x28, 0xb1, 0xf0, 0x66, 0xc3, 0x0f, 0x3e, 0x5e,
	0xfe, 0x8e, 0x83, 0xcb, 0x71, 0x8c, 0xae, 0xc6, 0x31, 0xba, 0x1e, 0xc7, 0xe8, 0xd7, 0x38, 0x46,
	0xdf, 0x27, 0x71, 0x70, 0x35, 0x89, 0x83, 0xeb, 0x49, 0x1c, 0x7c, 0x7a, 0x5e, 0x82, 0xeb, 0x0e,
	0x8b, 0x84, 0x69, 0x99, 0x2e, 0x7e, 0x83, 0x17, 0xff, 0x74, 0xda, 0x3f, 0x2b, 0xd3, 0xdb, 0x6b,
	0x5c, 0xd4, 0xfc, 0x3e, 0x3e, 0xfb, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x31, 0x78, 0xa1, 0x20, 0xe3,
	0x02, 0x00, 0x00,
}

func (this *Config) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Config)
	if !ok {
		that2, ok := that.(Config)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dims != that1.Dims {
		return false
	}
	if this.Seed != that1.Seed {
		return false
	}
	if this.BuildBeamSize != that1.BuildBeamSize {
		return false
	}
	if this.MinPartitionSize != that1.MinPartitionSize {
		return false
	}
	if this.MaxPartitionSize != that1.MaxPartitionSize {
		return false
	}
	if this.IsDeterministic != that1.IsDeterministic {
		return false
	}
	if this.RotAlgorithm != that1.RotAlgorithm {
		return false
	}
	if this.DistanceMetric != that1.DistanceMetric {
		return false
	}
	return true
}
func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DistanceMetric != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.DistanceMetric))
		i--
		dAtA[i] = 0x40
	}
	if m.RotAlgorithm != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.RotAlgorithm))
		i--
		dAtA[i] = 0x38
	}
	if m.IsDeterministic {
		i--
		if m.IsDeterministic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MaxPartitionSize != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.MaxPartitionSize))
		i--
		dAtA[i] = 0x28
	}
	if m.MinPartitionSize != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.MinPartitionSize))
		i--
		dAtA[i] = 0x20
	}
	if m.BuildBeamSize != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.BuildBeamSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Seed != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x10
	}
	if m.Dims != 0 {
		i = encodeVarintVec(dAtA, i, uint64(m.Dims))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintVec(dAtA []byte, offset int, v uint64) int {
	offset -= sovVec(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dims != 0 {
		n += 1 + sovVec(uint64(m.Dims))
	}
	if m.Seed != 0 {
		n += 1 + sovVec(uint64(m.Seed))
	}
	if m.BuildBeamSize != 0 {
		n += 1 + sovVec(uint64(m.BuildBeamSize))
	}
	if m.MinPartitionSize != 0 {
		n += 1 + sovVec(uint64(m.MinPartitionSize))
	}
	if m.MaxPartitionSize != 0 {
		n += 1 + sovVec(uint64(m.MaxPartitionSize))
	}
	if m.IsDeterministic {
		n += 2
	}
	if m.RotAlgorithm != 0 {
		n += 1 + sovVec(uint64(m.RotAlgorithm))
	}
	if m.DistanceMetric != 0 {
		n += 1 + sovVec(uint64(m.DistanceMetric))
	}
	return n
}

func sovVec(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozVec(x uint64) (n int) {
	return sovVec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dims", wireType)
			}
			m.Dims = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dims |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildBeamSize", wireType)
			}
			m.BuildBeamSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildBeamSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPartitionSize", wireType)
			}
			m.MinPartitionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPartitionSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPartitionSize", wireType)
			}
			m.MaxPartitionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPartitionSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeterministic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeterministic = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RotAlgorithm", wireType)
			}
			m.RotAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RotAlgorithm |= RotAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistanceMetric", wireType)
			}
			m.DistanceMetric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistanceMetric |= DistanceMetric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVec
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVec
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVec
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVec        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVec          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVec = fmt.Errorf("proto: unexpected end of group")
)

