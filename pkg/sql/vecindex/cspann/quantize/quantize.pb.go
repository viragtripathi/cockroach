// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/vecindex/cspann/quantize/quantize.proto

package quantize

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	vecpb "github.com/cockroachdb/cockroach/pkg/sql/vecindex/vecpb"
	vector "github.com/cockroachdb/cockroach/pkg/util/vector"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RaBitQCodeSet is a set of RaBitQ quantization codes. Each code represents a
// quantized vector.
type RaBitQCodeSet struct {
	// Count is the number of codes in the set.
	Count int `protobuf:"varint,1,opt,name=count,proto3,casttype=int" json:"count,omitempty"`
	// Width is the number of uint64 values that store a single code.
	Width int `protobuf:"varint,2,opt,name=width,proto3,casttype=int" json:"width,omitempty"`
	// Data is a uint64 slice that stores all the codes in the set. Codes are
	// stored contiguously in row-wise order.
	Data []uint64 `protobuf:"varint,3,rep,packed,name=data,proto3" json:"data,omitempty"`
}

func (m *RaBitQCodeSet) Reset()         { *m = RaBitQCodeSet{} }
func (m *RaBitQCodeSet) String() string { return proto.CompactTextString(m) }
func (*RaBitQCodeSet) ProtoMessage()    {}
func (*RaBitQCodeSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9038a658a9c2c06b, []int{0}
}
func (m *RaBitQCodeSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaBitQCodeSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaBitQCodeSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaBitQCodeSet.Merge(m, src)
}
func (m *RaBitQCodeSet) XXX_Size() int {
	return m.Size()
}
func (m *RaBitQCodeSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RaBitQCodeSet.DiscardUnknown(m)
}

var xxx_messageInfo_RaBitQCodeSet proto.InternalMessageInfo

// RaBitQuantizedVectorSet encodes a set of RaBitQ quantized vectors. This
// includes enough information to estimate the distance from the original
// full-size vectors to a user-provided query vector.
type RaBitQuantizedVectorSet struct {
	// Metric specifies the metric used to compute similarity between vectors in
	// the set.
	Metric vecpb.DistanceMetric `protobuf:"varint,1,opt,name=metric,proto3,enum=cockroach.sql.vecindex.vecpb.DistanceMetric" json:"metric,omitempty"`
	// Centroid is the average of vectors in the set, representing its "center of
	// mass". Note that the centroid is computed when a vector set is created and
	// is not updated when vectors are added or removed.
	// NOTE: This is always the mean centroid, regardless of the distance metric.
	// The caller is responsible for converting this to a spherical centroid when
	// that's needed.
	// NOTE: The centroid should be treated as immutable.
	Centroid []float32 `protobuf:"fixed32,2,rep,packed,name=centroid,proto3" json:"centroid,omitempty"`
	// Codes is a set of RaBitQ quantization codes, with one code per quantized
	// vector in the set.
	Codes RaBitQCodeSet `protobuf:"bytes,3,opt,name=codes,proto3" json:"codes"`
	// CodeCounts records the count of "1" bits in each of the quantization codes.
	CodeCounts []uint32 `protobuf:"varint,4,rep,packed,name=code_counts,json=codeCounts,proto3" json:"code_counts,omitempty"`
	// CentroidDistances is a slice of the exact Euclidean distances (non-squared)
	// of the original full-size vectors from the centroid.
	CentroidDistances []float32 `protobuf:"fixed32,5,rep,packed,name=centroid_distances,json=centroidDistances,proto3" json:"centroid_distances,omitempty"`
	// QuantizedDotProducts is a slice of the exact inner products between the
	// original full-size vectors and their corresponding quantized vectors.
	// NOTE: These values have been inverted (1/inner_product) to avoid expensive
	// division during distance estimation.
	QuantizedDotProducts []float32 `protobuf:"fixed32,6,rep,packed,name=quantized_dot_products,json=quantizedDotProducts,proto3" json:"quantized_dot_products,omitempty"`
	// CentroidDotProducts is a slice of the exact inner products between the
	// original full-size vectors and the centroid.
	// NOTE: This is always nil when using the L2Squared distance metric.
	CentroidDotProducts []float32 `protobuf:"fixed32,7,rep,packed,name=centroid_dot_products,json=centroidDotProducts,proto3" json:"centroid_dot_products,omitempty"`
	// CentroidNorm is the L2 norm of the mean centroid.
	// NOTE: This is always nil when using the L2Squared distance metric.
	CentroidNorm float32 `protobuf:"fixed32,8,opt,name=centroid_norm,json=centroidNorm,proto3" json:"centroid_norm,omitempty"`
}

func (m *RaBitQuantizedVectorSet) Reset()         { *m = RaBitQuantizedVectorSet{} }
func (m *RaBitQuantizedVectorSet) String() string { return proto.CompactTextString(m) }
func (*RaBitQuantizedVectorSet) ProtoMessage()    {}
func (*RaBitQuantizedVectorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9038a658a9c2c06b, []int{1}
}
func (m *RaBitQuantizedVectorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaBitQuantizedVectorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaBitQuantizedVectorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaBitQuantizedVectorSet.Merge(m, src)
}
func (m *RaBitQuantizedVectorSet) XXX_Size() int {
	return m.Size()
}
func (m *RaBitQuantizedVectorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RaBitQuantizedVectorSet.DiscardUnknown(m)
}

var xxx_messageInfo_RaBitQuantizedVectorSet proto.InternalMessageInfo

// UnQuantizedVectorSet trivially implements the QuantizedVectorSet interface,
// storing the original full-size vectors without quantization. This is used in
// testing and for the root partition, which is never quantized.
type UnQuantizedVectorSet struct {
	// Vectors is the set of original full-size vectors.
	Vectors vector.Set `protobuf:"bytes,1,opt,name=vectors,proto3" json:"vectors"`
}

func (m *UnQuantizedVectorSet) Reset()         { *m = UnQuantizedVectorSet{} }
func (m *UnQuantizedVectorSet) String() string { return proto.CompactTextString(m) }
func (*UnQuantizedVectorSet) ProtoMessage()    {}
func (*UnQuantizedVectorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9038a658a9c2c06b, []int{2}
}
func (m *UnQuantizedVectorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnQuantizedVectorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UnQuantizedVectorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnQuantizedVectorSet.Merge(m, src)
}
func (m *UnQuantizedVectorSet) XXX_Size() int {
	return m.Size()
}
func (m *UnQuantizedVectorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_UnQuantizedVectorSet.DiscardUnknown(m)
}

var xxx_messageInfo_UnQuantizedVectorSet proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RaBitQCodeSet)(nil), "cockroach.sql.vecindex.quantize.RaBitQCodeSet")
	proto.RegisterType((*RaBitQuantizedVectorSet)(nil), "cockroach.sql.vecindex.quantize.RaBitQuantizedVectorSet")
	proto.RegisterType((*UnQuantizedVectorSet)(nil), "cockroach.sql.vecindex.quantize.UnQuantizedVectorSet")
}

func init() {
	proto.RegisterFile("sql/vecindex/cspann/quantize/quantize.proto", fileDescriptor_9038a658a9c2c06b)
}

var fileDescriptor_9038a658a9c2c06b = []byte{
	// 502 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xcb, 0x8e, 0xd3, 0x30,
	0x14, 0x4d, 0x9a, 0xcc, 0x74, 0xe4, 0x52, 0x24, 0x4c, 0x01, 0xab, 0x82, 0x24, 0x1a, 0x36, 0x91,
	0x00, 0x47, 0x2a, 0xac, 0x66, 0x47, 0xa7, 0x2b, 0x24, 0x10, 0x04, 0x81, 0x10, 0x9b, 0x2a, 0xb5,
	0xad, 0xd4, 0x9a, 0xa9, 0x9d, 0xc6, 0xce, 0x80, 0xf8, 0x0a, 0x3e, 0x81, 0x0f, 0xe0, 0x43, 0xba,
	0x9c, 0xe5, 0xac, 0x46, 0xd0, 0x6e, 0xf8, 0x06, 0x56, 0x28, 0xce, 0xa3, 0x1d, 0xc4, 0x63, 0xd3,
	0xde, 0x9c, 0x93, 0x73, 0x8f, 0xef, 0xf1, 0x0d, 0x78, 0xa0, 0x96, 0xa7, 0xd1, 0x19, 0x23, 0x5c,
	0x50, 0xf6, 0x31, 0x22, 0x2a, 0x4b, 0x84, 0x88, 0x96, 0x45, 0x22, 0x34, 0xff, 0xc4, 0xda, 0x02,
	0x67, 0xb9, 0xd4, 0x12, 0xfa, 0x44, 0x92, 0x93, 0x5c, 0x26, 0x64, 0x8e, 0xd5, 0xf2, 0x14, 0x37,
	0x32, 0xdc, 0xbc, 0x36, 0xbc, 0x7b, 0xa5, 0xdb, 0x19, 0x23, 0xd9, 0xac, 0xfc, 0xad, 0xe4, 0x43,
	0x54, 0x68, 0x6e, 0x68, 0x2d, 0xf3, 0xfa, 0xaf, 0x66, 0x06, 0xa9, 0x4c, 0xa5, 0x29, 0xa3, 0xb2,
	0xaa, 0xd0, 0xc3, 0x14, 0xf4, 0xe3, 0x64, 0xcc, 0xf5, 0xab, 0x63, 0x49, 0xd9, 0x6b, 0xa6, 0xe1,
	0x3d, 0xb0, 0x47, 0x64, 0x21, 0x34, 0xb2, 0x03, 0x3b, 0x74, 0xc6, 0xdd, 0x9f, 0x97, 0xbe, 0xc3,
	0x85, 0x8e, 0x2b, 0xb4, 0xa4, 0x3f, 0x70, 0xaa, 0xe7, 0xa8, 0xf3, 0x1b, 0x6d, 0x50, 0x08, 0x81,
	0x4b, 0x13, 0x9d, 0x20, 0x27, 0x70, 0x42, 0x37, 0x36, 0xf5, 0x91, 0xfb, 0xe3, 0x8b, 0x6f, 0x1f,
	0x7e, 0x75, 0xc0, 0x9d, 0xca, 0xa9, 0x1e, 0x84, 0xbe, 0x35, 0xa7, 0x2b, 0x3d, 0x27, 0x60, 0x7f,
	0xc1, 0x74, 0xce, 0x89, 0x31, 0xbd, 0x3e, 0x7a, 0x88, 0xff, 0x12, 0x82, 0x99, 0x16, 0x4f, 0xb8,
	0xd2, 0x89, 0x20, 0xec, 0xb9, 0xd1, 0xc4, 0xb5, 0x16, 0x0e, 0xc1, 0x01, 0x61, 0x42, 0xe7, 0x92,
	0x53, 0xd4, 0x09, 0x9c, 0xb0, 0x13, 0xb7, 0xcf, 0xf0, 0x59, 0x39, 0x15, 0x65, 0x0a, 0x39, 0x81,
	0x1d, 0xf6, 0x46, 0x18, 0xff, 0x27, 0x65, 0x7c, 0x25, 0x94, 0xb1, 0xbb, 0xba, 0xf4, 0xad, 0xb8,
	0x6a, 0x01, 0x7d, 0xd0, 0x2b, 0x8b, 0xa9, 0x09, 0x44, 0x21, 0x37, 0x70, 0xc2, 0x7e, 0x0c, 0x4a,
	0xe8, 0xd8, 0x20, 0xf0, 0x11, 0x80, 0x8d, 0xf1, 0x94, 0xd6, 0x67, 0x55, 0x68, 0xcf, 0x1c, 0xe9,
	0x46, 0xc3, 0x34, 0x43, 0x28, 0xf8, 0x04, 0xdc, 0x6e, 0x6c, 0xe9, 0x94, 0x4a, 0x3d, 0xcd, 0x72,
	0x49, 0x0b, 0xa2, 0x15, 0xda, 0x37, 0x92, 0x41, 0xcb, 0x4e, 0xa4, 0x7e, 0x59, 0x73, 0x70, 0x04,
	0x6e, 0x6d, 0x4d, 0x76, 0x45, 0x5d, 0x23, 0xba, 0xd9, 0xfa, 0xec, 0x68, 0xee, 0x83, 0x7e, 0xab,
	0x11, 0x32, 0x5f, 0xa0, 0x83, 0xc0, 0x0e, 0x3b, 0xf1, 0xb5, 0x06, 0x7c, 0x21, 0xf3, 0x45, 0x7d,
	0x5d, 0xef, 0xc0, 0xe0, 0x8d, 0xf8, 0xc3, 0x55, 0x1d, 0x81, 0x6e, 0xb5, 0x55, 0xca, 0xdc, 0x55,
	0x6f, 0x34, 0xdc, 0x89, 0xb2, 0xdc, 0x3d, 0x5c, 0x2f, 0xdd, 0x36, 0xb6, 0x46, 0x50, 0x75, 0x1e,
	0x93, 0xd5, 0x77, 0xcf, 0x5a, 0xad, 0x3d, 0xfb, 0x7c, 0xed, 0xd9, 0x17, 0x6b, 0xcf, 0xfe, 0xb6,
	0xf6, 0xec, 0xcf, 0x1b, 0xcf, 0x3a, 0xdf, 0x78, 0xd6, 0xc5, 0xc6, 0xb3, 0xde, 0x3f, 0x4d, 0xb9,
	0x9e, 0x17, 0x33, 0x4c, 0xe4, 0x22, 0x6a, 0x9b, 0xd3, 0xd9, 0xb6, 0x8e, 0xb2, 0x93, 0x34, 0xfa,
	0xd7, 0x47, 0x35, 0xdb, 0x37, 0xdb, 0xfd, 0xf8, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe8, 0xf4,
	0x3f, 0xec, 0x7b, 0x03, 0x00, 0x00,
}

func (this *RaBitQCodeSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RaBitQCodeSet)
	if !ok {
		that2, ok := that.(RaBitQCodeSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if this.Data[i] != that1.Data[i] {
			return false
		}
	}
	return true
}
func (this *RaBitQuantizedVectorSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RaBitQuantizedVectorSet)
	if !ok {
		that2, ok := that.(RaBitQuantizedVectorSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Metric != that1.Metric {
		return false
	}
	if len(this.Centroid) != len(that1.Centroid) {
		return false
	}
	for i := range this.Centroid {
		if this.Centroid[i] != that1.Centroid[i] {
			return false
		}
	}
	if !this.Codes.Equal(&that1.Codes) {
		return false
	}
	if len(this.CodeCounts) != len(that1.CodeCounts) {
		return false
	}
	for i := range this.CodeCounts {
		if this.CodeCounts[i] != that1.CodeCounts[i] {
			return false
		}
	}
	if len(this.CentroidDistances) != len(that1.CentroidDistances) {
		return false
	}
	for i := range this.CentroidDistances {
		if this.CentroidDistances[i] != that1.CentroidDistances[i] {
			return false
		}
	}
	if len(this.QuantizedDotProducts) != len(that1.QuantizedDotProducts) {
		return false
	}
	for i := range this.QuantizedDotProducts {
		if this.QuantizedDotProducts[i] != that1.QuantizedDotProducts[i] {
			return false
		}
	}
	if len(this.CentroidDotProducts) != len(that1.CentroidDotProducts) {
		return false
	}
	for i := range this.CentroidDotProducts {
		if this.CentroidDotProducts[i] != that1.CentroidDotProducts[i] {
			return false
		}
	}
	if this.CentroidNorm != that1.CentroidNorm {
		return false
	}
	return true
}
func (this *UnQuantizedVectorSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnQuantizedVectorSet)
	if !ok {
		that2, ok := that.(UnQuantizedVectorSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vectors.Equal(&that1.Vectors) {
		return false
	}
	return true
}
func (m *RaBitQCodeSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaBitQCodeSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaBitQCodeSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		l := 0
		for _, e := range m.Data {
			l += sovQuantize(uint64(e))
		}
		i -= l
		if l == len(m.Data) {
			dest := dAtA[i : i+len(m.Data)]
			for k, num := range m.Data {
				dest[k] = uint8(num)
			}
		} else {
			j1 := i
			for _, num := range m.Data {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
		}
		i = encodeVarintQuantize(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Width != 0 {
		i = encodeVarintQuantize(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x10
	}
	if m.Count != 0 {
		i = encodeVarintQuantize(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaBitQuantizedVectorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaBitQuantizedVectorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaBitQuantizedVectorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CentroidNorm != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CentroidNorm))))
		i--
		dAtA[i] = 0x45
	}
	if len(m.CentroidDotProducts) > 0 {
		for iNdEx := len(m.CentroidDotProducts) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.CentroidDotProducts[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
		}
		i = encodeVarintQuantize(dAtA, i, uint64(len(m.CentroidDotProducts)*4))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.QuantizedDotProducts) > 0 {
		for iNdEx := len(m.QuantizedDotProducts) - 1; iNdEx >= 0; iNdEx-- {
			f3 := math.Float32bits(float32(m.QuantizedDotProducts[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f3))
		}
		i = encodeVarintQuantize(dAtA, i, uint64(len(m.QuantizedDotProducts)*4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CentroidDistances) > 0 {
		for iNdEx := len(m.CentroidDistances) - 1; iNdEx >= 0; iNdEx-- {
			f4 := math.Float32bits(float32(m.CentroidDistances[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f4))
		}
		i = encodeVarintQuantize(dAtA, i, uint64(len(m.CentroidDistances)*4))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CodeCounts) > 0 {
		l := 0
		for _, e := range m.CodeCounts {
			l += sovQuantize(uint64(e))
		}
		i -= l
		if l == len(m.CodeCounts) {
			dest := dAtA[i : i+len(m.CodeCounts)]
			for k, num := range m.CodeCounts {
				dest[k] = uint8(num)
			}
		} else {
			j5 := i
			for _, num := range m.CodeCounts {
				for num >= 1<<7 {
					dAtA[j5] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j5++
				}
				dAtA[j5] = uint8(num)
				j5++
			}
		}
		i = encodeVarintQuantize(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Codes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuantize(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Centroid) > 0 {
		for iNdEx := len(m.Centroid) - 1; iNdEx >= 0; iNdEx-- {
			f7 := math.Float32bits(float32(m.Centroid[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f7))
		}
		i = encodeVarintQuantize(dAtA, i, uint64(len(m.Centroid)*4))
		i--
		dAtA[i] = 0x12
	}
	if m.Metric != 0 {
		i = encodeVarintQuantize(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnQuantizedVectorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnQuantizedVectorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnQuantizedVectorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuantize(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintQuantize(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuantize(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RaBitQCodeSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovQuantize(uint64(m.Count))
	}
	if m.Width != 0 {
		n += 1 + sovQuantize(uint64(m.Width))
	}
	if len(m.Data) > 0 {
		l = 0
		for _, e := range m.Data {
			l += sovQuantize(uint64(e))
		}
		n += 1 + sovQuantize(uint64(l)) + l
	}
	return n
}

func (m *RaBitQuantizedVectorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metric != 0 {
		n += 1 + sovQuantize(uint64(m.Metric))
	}
	if len(m.Centroid) > 0 {
		n += 1 + sovQuantize(uint64(len(m.Centroid)*4)) + len(m.Centroid)*4
	}
	l = m.Codes.Size()
	n += 1 + l + sovQuantize(uint64(l))
	if len(m.CodeCounts) > 0 {
		l = 0
		for _, e := range m.CodeCounts {
			l += sovQuantize(uint64(e))
		}
		n += 1 + sovQuantize(uint64(l)) + l
	}
	if len(m.CentroidDistances) > 0 {
		n += 1 + sovQuantize(uint64(len(m.CentroidDistances)*4)) + len(m.CentroidDistances)*4
	}
	if len(m.QuantizedDotProducts) > 0 {
		n += 1 + sovQuantize(uint64(len(m.QuantizedDotProducts)*4)) + len(m.QuantizedDotProducts)*4
	}
	if len(m.CentroidDotProducts) > 0 {
		n += 1 + sovQuantize(uint64(len(m.CentroidDotProducts)*4)) + len(m.CentroidDotProducts)*4
	}
	if m.CentroidNorm != 0 {
		n += 5
	}
	return n
}

func (m *UnQuantizedVectorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Vectors.Size()
	n += 1 + l + sovQuantize(uint64(l))
	return n
}

func sovQuantize(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozQuantize(x uint64) (n int) {
	return sovQuantize(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RaBitQCodeSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuantize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaBitQCodeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaBitQCodeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Data = append(m.Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuantize
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuantize
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.Data == nil {
						m.Data = make([]uint64, 0, elementCount)
					} else {
						m.Data = slices.Grow(m.Data, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuantize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Data = append(m.Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuantize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuantize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaBitQuantizedVectorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuantize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaBitQuantizedVectorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaBitQuantizedVectorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= vecpb.DistanceMetric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Centroid = append(m.Centroid, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuantize
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuantize
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 {
					if m.Centroid == nil {
						m.Centroid = make([]float32, 0, elementCount)
					} else {
						m.Centroid = slices.Grow(m.Centroid, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Centroid = append(m.Centroid, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Centroid", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuantize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuantize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Codes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CodeCounts = append(m.CodeCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuantize
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuantize
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.CodeCounts == nil {
						m.CodeCounts = make([]uint32, 0, elementCount)
					} else {
						m.CodeCounts = slices.Grow(m.CodeCounts, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuantize
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CodeCounts = append(m.CodeCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeCounts", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.CentroidDistances = append(m.CentroidDistances, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuantize
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuantize
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 {
					if m.CentroidDistances == nil {
						m.CentroidDistances = make([]float32, 0, elementCount)
					} else {
						m.CentroidDistances = slices.Grow(m.CentroidDistances, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.CentroidDistances = append(m.CentroidDistances, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CentroidDistances", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.QuantizedDotProducts = append(m.QuantizedDotProducts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuantize
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuantize
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 {
					if m.QuantizedDotProducts == nil {
						m.QuantizedDotProducts = make([]float32, 0, elementCount)
					} else {
						m.QuantizedDotProducts = slices.Grow(m.QuantizedDotProducts, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.QuantizedDotProducts = append(m.QuantizedDotProducts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizedDotProducts", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.CentroidDotProducts = append(m.CentroidDotProducts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuantize
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuantize
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuantize
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 {
					if m.CentroidDotProducts == nil {
						m.CentroidDotProducts = make([]float32, 0, elementCount)
					} else {
						m.CentroidDotProducts = slices.Grow(m.CentroidDotProducts, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.CentroidDotProducts = append(m.CentroidDotProducts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CentroidDotProducts", wireType)
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CentroidNorm", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CentroidNorm = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipQuantize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuantize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnQuantizedVectorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuantize
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnQuantizedVectorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnQuantizedVectorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuantize
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuantize
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuantize(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuantize
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuantize(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuantize
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuantize
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuantize
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuantize
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuantize
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuantize        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuantize          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuantize = fmt.Errorf("proto: unexpected end of group")
)

