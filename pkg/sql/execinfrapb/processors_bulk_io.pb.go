// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_bulk_io.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_base "github.com/cockroachdb/cockroach/pkg/base"
	cloudpb "github.com/cockroachdb/cockroach/pkg/cloud/cloudpb"
	github_com_cockroachdb_cockroach_pkg_jobs_jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_security_username "github.com/cockroachdb/cockroach/pkg/security/username"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ElidePrefix int32

const (
	ElidePrefix_None           ElidePrefix = 0
	ElidePrefix_Tenant         ElidePrefix = 1
	ElidePrefix_TenantAndTable ElidePrefix = 2
)

var ElidePrefix_name = map[int32]string{
	0: "None",
	1: "Tenant",
	2: "TenantAndTable",
}

var ElidePrefix_value = map[string]int32{
	"None":           0,
	"Tenant":         1,
	"TenantAndTable": 2,
}

func (x ElidePrefix) Enum() *ElidePrefix {
	p := new(ElidePrefix)
	*p = x
	return p
}

func (x ElidePrefix) String() string {
	return proto.EnumName(ElidePrefix_name, int32(x))
}

func (x *ElidePrefix) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ElidePrefix_value, data, "ElidePrefix")
	if err != nil {
		return err
	}
	*x = ElidePrefix(value)
	return nil
}

func (ElidePrefix) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0}
}

type BackfillerSpec_Type int32

const (
	BackfillerSpec_Invalid BackfillerSpec_Type = 0
	BackfillerSpec_Column  BackfillerSpec_Type = 1
	BackfillerSpec_Index   BackfillerSpec_Type = 2
)

var BackfillerSpec_Type_name = map[int32]string{
	0: "Invalid",
	1: "Column",
	2: "Index",
}

var BackfillerSpec_Type_value = map[string]int32{
	"Invalid": 0,
	"Column":  1,
	"Index":   2,
}

func (x BackfillerSpec_Type) Enum() *BackfillerSpec_Type {
	p := new(BackfillerSpec_Type)
	*p = x
	return p
}

func (x BackfillerSpec_Type) String() string {
	return proto.EnumName(BackfillerSpec_Type_name, int32(x))
}

func (x *BackfillerSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BackfillerSpec_Type_value, data, "BackfillerSpec_Type")
	if err != nil {
		return err
	}
	*x = BackfillerSpec_Type(value)
	return nil
}

func (BackfillerSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0, 0}
}

// BackfillerSpec is the specification for a "schema change backfiller".
// The created backfill processor runs a backfill for the first mutations in
// the table descriptor mutation list with the same mutation id and type.
// A backfiller processor performs KV operations to retrieve rows for a
// table and backfills the new indexes/columns contained in the table
// descriptor. It checkpoints its progress by updating the table
// descriptor in the database, and doesn't emit any rows nor support
// any post-processing.
type BackfillerSpec struct {
	Type  BackfillerSpec_Type    `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.BackfillerSpec_Type" json:"type"`
	Table descpb.TableDescriptor `protobuf:"bytes,2,opt,name=table" json:"table"`
	Spans []roachpb.Span         `protobuf:"bytes,10,rep,name=spans" json:"spans"`
	// Run the backfill for approximately this duration.
	// The backfill will always process at least one backfill chunk.
	Duration time.Duration `protobuf:"varint,4,opt,name=duration,casttype=time.Duration" json:"duration"`
	// The backfill involves a complete table scan in chunks,
	// where each chunk is a transactional read of a set of rows
	// along with a backfill for the rows. This is the maximum number
	// of entries backfilled per chunk.
	ChunkSize int64 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// The column backfiller will run an update batch immediately
	// once its estimated byte size reaches UpdateChunkSizeThresholdBytes, if nonzero.
	UpdateChunkSizeThresholdBytes uint64 `protobuf:"varint,14,opt,name=update_chunk_size_threshold_bytes,json=updateChunkSizeThresholdBytes" json:"update_chunk_size_threshold_bytes"`
	// WriteAsOf is the time that the backfill entries should be written.
	WriteAsOf hlc.Timestamp `protobuf:"bytes,7,opt,name=writeAsOf" json:"writeAsOf"`
	// The timestamp to perform index backfill historical scans at.
	// This is only used by the column backfiller.
	ReadAsOf hlc.Timestamp `protobuf:"bytes,9,opt,name=readAsOf" json:"readAsOf"`
	// IndexesToBackfill is the set of indexes to backfill. This is populated only
	// starting in 21.1, prior to that the implied index set are those containing
	// the mutation ID of the first mutation on the table descriptor.
	IndexesToBackfill []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,8,rep,name=indexes_to_backfill,json=indexesToBackfill,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"indexes_to_backfill,omitempty"`
	InitialSplits     int32                                                             `protobuf:"varint,11,opt,name=initial_splits,json=initialSplits" json:"initial_splits"`
	// WriteAtBatchTimestamp will write the SST MVCC timestamps at the batch
	// timestamp, even if the request gets pushed server-side. This ensures the
	// writes comply with the timestamp cache and closed timestamp. See also
	// AddSSTableRequest.SSTTimestampToRequestTimestamp.
	WriteAtBatchTimestamp bool `protobuf:"varint,12,opt,name=write_at_batch_timestamp,json=writeAtBatchTimestamp" json:"write_at_batch_timestamp"`
	// SourceIndexID is the source index that will be used for this backfill. If
	// the value of 0 is specified then the primary index will be used implicitly.
	SourceIndexID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,16,opt,name=source_index_id,json=sourceIndexId,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"source_index_id"`
}

func (m *BackfillerSpec) Reset()         { *m = BackfillerSpec{} }
func (m *BackfillerSpec) String() string { return proto.CompactTextString(m) }
func (*BackfillerSpec) ProtoMessage()    {}
func (*BackfillerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0}
}
func (m *BackfillerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackfillerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillerSpec.Merge(m, src)
}
func (m *BackfillerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackfillerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillerSpec proto.InternalMessageInfo

// JobProgress identifies the job to report progress on. This reporting
// happens outside this package.
type JobProgress struct {
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,1,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
	// contribution is the percent of work of the total this processor will
	// process.
	Contribution float32 `protobuf:"fixed32,2,opt,name=contribution" json:"contribution"`
	// slot is the index into the job details for this processor's completion.
	Slot int32 `protobuf:"varint,3,opt,name=slot" json:"slot"`
}

func (m *JobProgress) Reset()         { *m = JobProgress{} }
func (m *JobProgress) String() string { return proto.CompactTextString(m) }
func (*JobProgress) ProtoMessage()    {}
func (*JobProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{1}
}
func (m *JobProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobProgress.Merge(m, src)
}
func (m *JobProgress) XXX_Size() int {
	return m.Size()
}
func (m *JobProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_JobProgress.DiscardUnknown(m)
}

var xxx_messageInfo_JobProgress proto.InternalMessageInfo

type ReadImportDataSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID  int64                `protobuf:"varint,19,opt,name=job_id,json=jobId" json:"job_id"`
	Format roachpb.IOFileFormat `protobuf:"bytes,8,opt,name=format" json:"format"`
	// sample_size is the rate at which to output rows, based on an input row's size.
	SampleSize int32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// tables supports input formats that can read multiple tables. If it is
	// non-empty, the keys specify the names of tables for which the processor
	// should read and emit data (ignoring data for any other tables that is
	// present in the input).
	//
	// TODO(dt): If a key has a nil value, the schema for that table should be
	// determined from the input on-the-fly (e.g. by parsing a CREATE TABLE in a
	// dump file) and the processor should emit a key/value for the generated
	// TableDescriptor with the corresponding descriptor ID key. If tables is
	// empty (and table_desc above is not specified), the processor should read
	// all tables in the input, determining their schemas on the fly.
	Tables map[string]*ReadImportDataSpec_ImportTable `protobuf:"bytes,9,rep,name=tables" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// uri is a cloud.ExternalStorage URI pointing to the CSV files to be
	// read. The map key must be unique across the entire IMPORT job.
	Uri map[int32]string `protobuf:"bytes,7,rep,name=uri" json:"uri,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// resume_pos specifies a map from an input ID to an offset in that
	// input from which the processing should continue.
	// The meaning of offset is specific to each processor.
	ResumePos              map[int32]int64 `protobuf:"bytes,14,rep,name=resume_pos,json=resumePos" json:"resume_pos,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Progress               JobProgress     `protobuf:"bytes,6,opt,name=progress" json:"progress"`
	SkipMissingForeignKeys bool            `protobuf:"varint,10,opt,name=skip_missing_foreign_keys,json=skipMissingForeignKeys" json:"skip_missing_foreign_keys"`
	// walltimeNanos is the MVCC time at which the created KVs will be written.
	WalltimeNanos int64 `protobuf:"varint,11,opt,name=walltimeNanos" json:"walltimeNanos"`
	// If set, specifies reader parallelism; 0 implies "use default".
	ReaderParallelism int32 `protobuf:"varint,13,opt,name=readerParallelism" json:"readerParallelism"`
	// User who initiated the import. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,15,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	Types     []*descpb.TypeDescriptor                                                `protobuf:"bytes,16,rep,name=types" json:"types,omitempty"`
	// If the database being imported into is a multi-region database, then this
	// field stores the databases' primary region.
	DatabasePrimaryRegion github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName `protobuf:"bytes,17,opt,name=database_primary_region,json=databasePrimaryRegion,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.RegionName" json:"database_primary_region"`
	InitialSplits         int32                                                             `protobuf:"varint,18,opt,name=initial_splits,json=initialSplits" json:"initial_splits"`
}

func (m *ReadImportDataSpec) Reset()         { *m = ReadImportDataSpec{} }
func (m *ReadImportDataSpec) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec) ProtoMessage()    {}
func (*ReadImportDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{2}
}
func (m *ReadImportDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadImportDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec.Merge(m, src)
}
func (m *ReadImportDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec proto.InternalMessageInfo

type ReadImportDataSpec_ImportTable struct {
	Desc *descpb.TableDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	// targetCols is used to store the target columns for each existing table
	// being imported into. These are the columns for which the processor should
	// read and emit data (ignoring data for any other tables or columns outside
	// of the targetCols, that is present in the input).
	TargetCols []string `protobuf:"bytes,2,rep,name=targetCols" json:"targetCols,omitempty"`
}

func (m *ReadImportDataSpec_ImportTable) Reset()         { *m = ReadImportDataSpec_ImportTable{} }
func (m *ReadImportDataSpec_ImportTable) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec_ImportTable) ProtoMessage()    {}
func (*ReadImportDataSpec_ImportTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{2, 0}
}
func (m *ReadImportDataSpec_ImportTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadImportDataSpec_ImportTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.Merge(m, src)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec_ImportTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec_ImportTable proto.InternalMessageInfo

type IngestStoppedSpec struct {
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,1,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
}

func (m *IngestStoppedSpec) Reset()         { *m = IngestStoppedSpec{} }
func (m *IngestStoppedSpec) String() string { return proto.CompactTextString(m) }
func (*IngestStoppedSpec) ProtoMessage()    {}
func (*IngestStoppedSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{3}
}
func (m *IngestStoppedSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestStoppedSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IngestStoppedSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestStoppedSpec.Merge(m, src)
}
func (m *IngestStoppedSpec) XXX_Size() int {
	return m.Size()
}
func (m *IngestStoppedSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestStoppedSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IngestStoppedSpec proto.InternalMessageInfo

// StreamIngestionPartitionSpec contains information about a partition and how
// to connect to it.
type StreamIngestionPartitionSpec struct {
	PartitionID       string                                                  `protobuf:"bytes,1,opt,name=partition_id,json=partitionId" json:"partition_id"`
	SubscriptionToken string                                                  `protobuf:"bytes,2,opt,name=subscription_token,json=subscriptionToken" json:"subscription_token"`
	PartitionConnUri  string                                                  `protobuf:"bytes,3,opt,name=partition_conn_uri,json=partitionConnUri" json:"partition_conn_uri"`
	Spans             []roachpb.Span                                          `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	SrcInstanceID     github_com_cockroachdb_cockroach_pkg_base.SQLInstanceID `protobuf:"varint,5,opt,name=src_instance_id,json=srcInstanceId,casttype=github.com/cockroachdb/cockroach/pkg/base.SQLInstanceID" json:"src_instance_id"`
	DestInstanceID    github_com_cockroachdb_cockroach_pkg_base.SQLInstanceID `protobuf:"varint,6,opt,name=dest_instance_id,json=destInstanceId,casttype=github.com/cockroachdb/cockroach/pkg/base.SQLInstanceID" json:"dest_instance_id"`
}

func (m *StreamIngestionPartitionSpec) Reset()         { *m = StreamIngestionPartitionSpec{} }
func (m *StreamIngestionPartitionSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionPartitionSpec) ProtoMessage()    {}
func (*StreamIngestionPartitionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{4}
}
func (m *StreamIngestionPartitionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionPartitionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionPartitionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionPartitionSpec.Merge(m, src)
}
func (m *StreamIngestionPartitionSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionPartitionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionPartitionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionPartitionSpec proto.InternalMessageInfo

// StreamIngestionPartitionSpecs contains all the partition specs that are part
// of the DistSQL plan.
type StreamIngestionPartitionSpecs struct {
	Specs []*StreamIngestionPartitionSpec `protobuf:"bytes,3,rep,name=specs" json:"specs,omitempty"`
}

func (m *StreamIngestionPartitionSpecs) Reset()         { *m = StreamIngestionPartitionSpecs{} }
func (m *StreamIngestionPartitionSpecs) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionPartitionSpecs) ProtoMessage()    {}
func (*StreamIngestionPartitionSpecs) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{5}
}
func (m *StreamIngestionPartitionSpecs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionPartitionSpecs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionPartitionSpecs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionPartitionSpecs.Merge(m, src)
}
func (m *StreamIngestionPartitionSpecs) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionPartitionSpecs) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionPartitionSpecs.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionPartitionSpecs proto.InternalMessageInfo

// FrontierEntries is a snapshot of a span frontier.
type FrontierEntries struct {
	ResolvedSpans []jobspb.ResolvedSpan `protobuf:"bytes,1,rep,name=resolved_spans,json=resolvedSpans" json:"resolved_spans"`
}

func (m *FrontierEntries) Reset()         { *m = FrontierEntries{} }
func (m *FrontierEntries) String() string { return proto.CompactTextString(m) }
func (*FrontierEntries) ProtoMessage()    {}
func (*FrontierEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{6}
}
func (m *FrontierEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrontierEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FrontierEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrontierEntries.Merge(m, src)
}
func (m *FrontierEntries) XXX_Size() int {
	return m.Size()
}
func (m *FrontierEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_FrontierEntries.DiscardUnknown(m)
}

var xxx_messageInfo_FrontierEntries proto.InternalMessageInfo

type StreamIngestionDataSpec struct {
	// StreamID is the ID of the stream (which is shared across the producer and consumer).
	StreamID uint64 `protobuf:"varint,5,opt,name=stream_id,json=streamId" json:"stream_id"`
	// PartitionSpecs maps partition IDs to their specifications.
	PartitionSpecs map[string]StreamIngestionPartitionSpec `protobuf:"bytes,6,rep,name=partition_specs,json=partitionSpecs" json:"partition_specs" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// PreviousReplicatedTimestamp specifies the timestamp from which spans will
	// start ingesting data in the replication job. This timestamp is empty unless
	// the replication job resumes after a progress checkpoint has been recorded.
	// While it is empty we use the InitialScanTimestamp described below.
	PreviousReplicatedTimestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=previous_replicated_timestamp,json=previousReplicatedTimestamp" json:"previous_replicated_timestamp"`
	// InitialScanTimestamp is the timestamp at which the partition will run the
	// initial rangefeed scan before replicating further changes to the target
	// spans. This timestamp is always non-empty, but a partition will only run an
	// initial scan if no progress has been recorded prior to the current
	// resumption of the replication job. Otherwise, all spans will start
	// ingesting data from the PreviousReplicatedTimestamp described above.
	InitialScanTimestamp hlc.Timestamp `protobuf:"bytes,11,opt,name=initial_scan_timestamp,json=initialScanTimestamp" json:"initial_scan_timestamp"`
	// JobID is the job ID of the stream ingestion job.
	JobID int64 `protobuf:"varint,4,opt,name=job_id,json=jobId" json:"job_id"`
	// The processor will rekey the tenant's keyspace to a new tenant based on 'tenant_rekey'.
	TenantRekey TenantRekey `protobuf:"bytes,9,opt,name=tenant_rekey,json=tenantRekey" json:"tenant_rekey"`
	// Checkpoint stores a set of resolved spans denoting completed progress.
	Checkpoint jobspb.StreamIngestionCheckpoint `protobuf:"bytes,10,opt,name=checkpoint" json:"checkpoint"`
}

func (m *StreamIngestionDataSpec) Reset()         { *m = StreamIngestionDataSpec{} }
func (m *StreamIngestionDataSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionDataSpec) ProtoMessage()    {}
func (*StreamIngestionDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{7}
}
func (m *StreamIngestionDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionDataSpec.Merge(m, src)
}
func (m *StreamIngestionDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionDataSpec proto.InternalMessageInfo

type StreamIngestionFrontierSpec struct {
	// ReplicatedTimeAtStart is set by the ingestion job when initializing the frontier
	// processor. It is used as sanity check by the frontier processor to ensure
	// that it does not receive updates at a timestamp lower than this field. This
	// consequently prevents the job progress from regressing during ingestion.
	ReplicatedTimeAtStart hlc.Timestamp `protobuf:"bytes,1,opt,name=replicated_time_at_start,json=replicatedTimeAtStart" json:"replicated_time_at_start"`
	// TrackedSpans is the entire span set being watched. The spans do not really
	// represent KV spans but uniquely identify the partitions in the ingestion
	// stream. Once all the partitions in the ingestion stream have been resolved
	// at a certain timestamp, then it's safe to resolve the ingestion at that
	// timestamp.
	TrackedSpans []roachpb.Span `protobuf:"bytes,2,rep,name=tracked_spans,json=trackedSpans" json:"tracked_spans"`
	// JobID is the job ID of the stream ingestion job.
	JobID int64 `protobuf:"varint,3,opt,name=job_id,json=jobId" json:"job_id"`
	// StreamID is the ID of the stream.
	StreamID uint64 `protobuf:"varint,4,opt,name=stream_id,json=streamId" json:"stream_id"`
	// Checkpoint stores a set of resolved spans denoting completed progress
	Checkpoint jobspb.StreamIngestionCheckpoint `protobuf:"bytes,7,opt,name=checkpoint" json:"checkpoint"`
	// ConnectionUris are the URIs that can be connected to to interact with the
	// source job
	ConnectionUris []string `protobuf:"bytes,8,rep,name=connection_uris,json=connectionUris" json:"connection_uris,omitempty"`
	// PartitionSpecs contains the topology of the physical replication stream.
	PartitionSpecs StreamIngestionPartitionSpecs `protobuf:"bytes,9,opt,name=partition_specs,json=partitionSpecs" json:"partition_specs"`
}

func (m *StreamIngestionFrontierSpec) Reset()         { *m = StreamIngestionFrontierSpec{} }
func (m *StreamIngestionFrontierSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionFrontierSpec) ProtoMessage()    {}
func (*StreamIngestionFrontierSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{8}
}
func (m *StreamIngestionFrontierSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionFrontierSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionFrontierSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionFrontierSpec.Merge(m, src)
}
func (m *StreamIngestionFrontierSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionFrontierSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionFrontierSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionFrontierSpec proto.InternalMessageInfo

type BackupDataSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID            int64                       `protobuf:"varint,11,opt,name=job_id,json=jobId" json:"job_id"`
	Spans            []roachpb.Span              `protobuf:"bytes,1,rep,name=spans" json:"spans"`
	IntroducedSpans  []roachpb.Span              `protobuf:"bytes,2,rep,name=introduced_spans,json=introducedSpans" json:"introduced_spans"`
	DefaultURI       string                      `protobuf:"bytes,3,opt,name=default_uri,json=defaultUri" json:"default_uri"`
	URIsByLocalityKV map[string]string           `protobuf:"bytes,4,rep,name=uris_by_locality_kv,json=urisByLocalityKv" json:"uris_by_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	MVCCFilter       kvpb.MVCCFilter             `protobuf:"varint,5,opt,name=mvcc_filter,json=mvccFilter,enum=cockroach.roachpb.MVCCFilter" json:"mvcc_filter"`
	Encryption       *kvpb.FileEncryptionOptions `protobuf:"bytes,6,opt,name=encryption" json:"encryption,omitempty"`
	BackupStartTime  hlc.Timestamp               `protobuf:"bytes,7,opt,name=backup_start_time,json=backupStartTime" json:"backup_start_time"`
	BackupEndTime    hlc.Timestamp               `protobuf:"bytes,8,opt,name=backup_end_time,json=backupEndTime" json:"backup_end_time"`
	// PKIDs is used to convert result from an ExportRequest into row count
	// information passed back to track progress in the backup job.
	PKIDs map[uint64]bool `protobuf:"bytes,9,rep,name=pk_ids,json=pkIds" json:"pk_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// User who initiated the backup. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto   github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,10,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	ElidePrefix ElidePrefix                                                             `protobuf:"varint,12,opt,name=elide_prefix,json=elidePrefix,enum=cockroach.sql.distsqlrun.ElidePrefix" json:"elide_prefix"`
	// IncludeMVCCValueHeader indicates whether the backup should be
	// created with MVCCValueHeaders in the exported data. This should
	// only be set on backups starting on cluster version 24.1 or
	// greater.
	IncludeMVCCValueHeader bool `protobuf:"varint,13,opt,name=include_mvcc_value_header,json=includeMvccValueHeader" json:"include_mvcc_value_header"`
}

func (m *BackupDataSpec) Reset()         { *m = BackupDataSpec{} }
func (m *BackupDataSpec) String() string { return proto.CompactTextString(m) }
func (*BackupDataSpec) ProtoMessage()    {}
func (*BackupDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{9}
}
func (m *BackupDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackupDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDataSpec.Merge(m, src)
}
func (m *BackupDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackupDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDataSpec proto.InternalMessageInfo

type RestoreFileSpec struct {
	Dir                     cloudpb.ExternalStorage `protobuf:"bytes,1,opt,name=dir" json:"dir"`
	Path                    string                  `protobuf:"bytes,2,opt,name=path" json:"path"`
	BackupFileEntrySpan     roachpb.Span            `protobuf:"bytes,5,opt,name=backup_file_entry_span,json=backupFileEntrySpan" json:"backup_file_entry_span"`
	BackupFileEntryCounts   roachpb.RowCount        `protobuf:"bytes,6,opt,name=backup_file_entry_counts,json=backupFileEntryCounts" json:"backup_file_entry_counts"`
	BackingFileSize         uint64                  `protobuf:"varint,7,opt,name=backing_file_size,json=backingFileSize" json:"backing_file_size"`
	ApproximatePhysicalSize uint64                  `protobuf:"varint,8,opt,name=approximate_physical_size,json=approximatePhysicalSize" json:"approximate_physical_size"`
	Layer                   int32                   `protobuf:"varint,9,opt,name=layer" json:"layer"`
	HasRangeKeys            bool                    `protobuf:"varint,10,opt,name=has_range_keys,json=hasRangeKeys" json:"has_range_keys"`
}

func (m *RestoreFileSpec) Reset()         { *m = RestoreFileSpec{} }
func (m *RestoreFileSpec) String() string { return proto.CompactTextString(m) }
func (*RestoreFileSpec) ProtoMessage()    {}
func (*RestoreFileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{10}
}
func (m *RestoreFileSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreFileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreFileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreFileSpec.Merge(m, src)
}
func (m *RestoreFileSpec) XXX_Size() int {
	return m.Size()
}
func (m *RestoreFileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreFileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreFileSpec proto.InternalMessageInfo

type TableRekey struct {
	// OldID is the previous ID of `new_desc`.
	OldID uint32 `protobuf:"varint,1,opt,name=old_id,json=oldId" json:"old_id"`
	// NewDesc is an encoded Descriptor message.
	NewDesc []byte `protobuf:"bytes,2,opt,name=new_desc,json=newDesc" json:"new_desc,omitempty"`
}

func (m *TableRekey) Reset()         { *m = TableRekey{} }
func (m *TableRekey) String() string { return proto.CompactTextString(m) }
func (*TableRekey) ProtoMessage()    {}
func (*TableRekey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{11}
}
func (m *TableRekey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableRekey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableRekey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableRekey.Merge(m, src)
}
func (m *TableRekey) XXX_Size() int {
	return m.Size()
}
func (m *TableRekey) XXX_DiscardUnknown() {
	xxx_messageInfo_TableRekey.DiscardUnknown(m)
}

var xxx_messageInfo_TableRekey proto.InternalMessageInfo

type TenantRekey struct {
	// OldID is a previous tenant ID.
	OldID roachpb.TenantID `protobuf:"bytes,1,opt,name=old_id,json=oldId" json:"old_id"`
	// NewID is the ID with which to replace OldID.
	NewID roachpb.TenantID `protobuf:"bytes,2,opt,name=new_id,json=newId" json:"new_id"`
}

func (m *TenantRekey) Reset()         { *m = TenantRekey{} }
func (m *TenantRekey) String() string { return proto.CompactTextString(m) }
func (*TenantRekey) ProtoMessage()    {}
func (*TenantRekey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{12}
}
func (m *TenantRekey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantRekey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantRekey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantRekey.Merge(m, src)
}
func (m *TenantRekey) XXX_Size() int {
	return m.Size()
}
func (m *TenantRekey) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantRekey.DiscardUnknown(m)
}

var xxx_messageInfo_TenantRekey proto.InternalMessageInfo

// RestoreDataEntry will be specified at planning time to the SplitAndScatter
// processors, then those processors will stream these, encoded as bytes in rows
// to the RestoreDataProcessors.
// This field has a subset of the importEntry struct defined in restore.
type RestoreSpanEntry struct {
	Span         roachpb.Span      `protobuf:"bytes,1,opt,name=span" json:"span"`
	Files        []RestoreFileSpec `protobuf:"bytes,2,rep,name=files" json:"files"`
	ProgressIdx  int64             `protobuf:"varint,3,opt,name=progressIdx" json:"progressIdx"`
	ElidedPrefix ElidePrefix       `protobuf:"varint,4,opt,name=elided_prefix,json=elidedPrefix,enum=cockroach.sql.distsqlrun.ElidePrefix" json:"elided_prefix"`
}

func (m *RestoreSpanEntry) Reset()         { *m = RestoreSpanEntry{} }
func (m *RestoreSpanEntry) String() string { return proto.CompactTextString(m) }
func (*RestoreSpanEntry) ProtoMessage()    {}
func (*RestoreSpanEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{13}
}
func (m *RestoreSpanEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreSpanEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreSpanEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreSpanEntry.Merge(m, src)
}
func (m *RestoreSpanEntry) XXX_Size() int {
	return m.Size()
}
func (m *RestoreSpanEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreSpanEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreSpanEntry proto.InternalMessageInfo

type RestoreDataSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID        int64                       `protobuf:"varint,6,opt,name=job_id,json=jobId" json:"job_id"`
	RestoreTime  hlc.Timestamp               `protobuf:"bytes,1,opt,name=restore_time,json=restoreTime" json:"restore_time"`
	Encryption   *kvpb.FileEncryptionOptions `protobuf:"bytes,2,opt,name=encryption" json:"encryption,omitempty"`
	TableRekeys  []TableRekey                `protobuf:"bytes,3,rep,name=table_rekeys,json=tableRekeys" json:"table_rekeys"`
	TenantRekeys []TenantRekey               `protobuf:"bytes,5,rep,name=tenant_rekeys,json=tenantRekeys" json:"tenant_rekeys"`
	// PKIDs is used to convert result from an ExportRequest into row count
	// information passed back to track progress in the backup job.
	PKIDs        map[uint64]bool `protobuf:"bytes,4,rep,name=pk_ids,json=pkIds" json:"pk_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	ValidateOnly bool            `protobuf:"varint,8,opt,name=validate_only,json=validateOnly" json:"validate_only"`
	// ResumeClusterVersion is the cluster version when the restore job resumed.
	ResumeClusterVersion roachpb.Version `protobuf:"bytes,10,opt,name=resume_cluster_version,json=resumeClusterVersion" json:"resume_cluster_version"`
}

func (m *RestoreDataSpec) Reset()         { *m = RestoreDataSpec{} }
func (m *RestoreDataSpec) String() string { return proto.CompactTextString(m) }
func (*RestoreDataSpec) ProtoMessage()    {}
func (*RestoreDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{14}
}
func (m *RestoreDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDataSpec.Merge(m, src)
}
func (m *RestoreDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDataSpec proto.InternalMessageInfo

// BulkRowWriterSpec is the specification for a processor that consumes rows and
// writes them to a target table using AddSSTable. It outputs a BulkOpSummary.
type BulkRowWriterSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
}

func (m *BulkRowWriterSpec) Reset()         { *m = BulkRowWriterSpec{} }
func (m *BulkRowWriterSpec) String() string { return proto.CompactTextString(m) }
func (*BulkRowWriterSpec) ProtoMessage()    {}
func (*BulkRowWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{15}
}
func (m *BulkRowWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkRowWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BulkRowWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkRowWriterSpec.Merge(m, src)
}
func (m *BulkRowWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *BulkRowWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkRowWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BulkRowWriterSpec proto.InternalMessageInfo

type IndexBackfillMergerSpec struct {
	Table            descpb.TableDescriptor                                            `protobuf:"bytes,1,opt,name=table" json:"table"`
	TemporaryIndexes []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,2,rep,name=temporary_indexes,json=temporaryIndexes,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"temporary_indexes,omitempty"`
	AddedIndexes     []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,3,rep,name=added_indexes,json=addedIndexes,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"added_indexes,omitempty"`
	Spans            []roachpb.Span                                                    `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	SpanIdx          []int32                                                           `protobuf:"varint,5,rep,name=span_idx,json=spanIdx" json:"span_idx,omitempty"`
	MergeTimestamp   hlc.Timestamp                                                     `protobuf:"bytes,8,opt,name=mergeTimestamp" json:"mergeTimestamp"`
}

func (m *IndexBackfillMergerSpec) Reset()         { *m = IndexBackfillMergerSpec{} }
func (m *IndexBackfillMergerSpec) String() string { return proto.CompactTextString(m) }
func (*IndexBackfillMergerSpec) ProtoMessage()    {}
func (*IndexBackfillMergerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{16}
}
func (m *IndexBackfillMergerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexBackfillMergerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexBackfillMergerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexBackfillMergerSpec.Merge(m, src)
}
func (m *IndexBackfillMergerSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexBackfillMergerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexBackfillMergerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexBackfillMergerSpec proto.InternalMessageInfo

type GenerativeSplitAndScatterSpec struct {
	TableRekeys  []TableRekey  `protobuf:"bytes,1,rep,name=table_rekeys,json=tableRekeys" json:"table_rekeys"`
	TenantRekeys []TenantRekey `protobuf:"bytes,2,rep,name=tenant_rekeys,json=tenantRekeys" json:"tenant_rekeys"`
	ValidateOnly bool          `protobuf:"varint,3,opt,name=validate_only,json=validateOnly" json:"validate_only"`
	// URIs is the URIs of the backup manifests.
	URIs       []string                        `protobuf:"bytes,4,rep,name=uris" json:"uris,omitempty"`
	Encryption *jobspb.BackupEncryptionOptions `protobuf:"bytes,5,opt,name=encryption" json:"encryption,omitempty"`
	// EndTime is the time of the restore.
	EndTime hlc.Timestamp `protobuf:"bytes,9,opt,name=endTime" json:"endTime"`
	// Spans is the required spans in the restore.
	Spans              []roachpb.Span                             `protobuf:"bytes,10,rep,name=spans" json:"spans"`
	BackupLocalityInfo []jobspb.RestoreDetails_BackupLocalityInfo `protobuf:"bytes,11,rep,name=backup_locality_info,json=backupLocalityInfo" json:"backup_locality_info"`
	// User who initiated the restore.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,13,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	// ChunkSize is the number of import spans per chunk.
	ChunkSize int64 `protobuf:"varint,14,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// TargetSize is the target size for each import span.
	TargetSize int64 `protobuf:"varint,15,opt,name=target_size,json=targetSize" json:"target_size"`
	// NumEntries is the total number of import spans in this restore.
	NumEntries int64 `protobuf:"varint,16,opt,name=num_entries,json=numEntries" json:"num_entries"`
	// NumNodes is the number of nodes available for dist restore.
	NumNodes          int64                                  `protobuf:"varint,17,opt,name=num_nodes,json=numNodes" json:"num_nodes"`
	JobID             int64                                  `protobuf:"varint,18,opt,name=job_id,json=jobId" json:"job_id"`
	CheckpointedSpans []jobspb.RestoreProgress_FrontierEntry `protobuf:"bytes,21,rep,name=checkpointed_spans,json=checkpointedSpans" json:"checkpointed_spans"`
	// ExclusiveFileSpanComparison is true if the backup can safely use
	// exclusive file span comparison.
	ExclusiveFileSpanComparison bool `protobuf:"varint,22,opt,name=exclusive_file_span_comparison,json=exclusiveFileSpanComparison" json:"exclusive_file_span_comparison"`
	// MaxFileCount is the max number of files in an extending restore span entry.
	MaxFileCount int64 `protobuf:"varint,23,opt,name=max_file_count,json=maxFileCount" json:"max_file_count"`
	// SQLInstanceIDs is a slice of SQL instance IDs available for dist restore.
	SQLInstanceIDs []int32 `protobuf:"varint,24,rep,name=sql_instance_ids,json=sqlInstanceIds" json:"sql_instance_ids,omitempty"`
}

func (m *GenerativeSplitAndScatterSpec) Reset()         { *m = GenerativeSplitAndScatterSpec{} }
func (m *GenerativeSplitAndScatterSpec) String() string { return proto.CompactTextString(m) }
func (*GenerativeSplitAndScatterSpec) ProtoMessage()    {}
func (*GenerativeSplitAndScatterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{17}
}
func (m *GenerativeSplitAndScatterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerativeSplitAndScatterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GenerativeSplitAndScatterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerativeSplitAndScatterSpec.Merge(m, src)
}
func (m *GenerativeSplitAndScatterSpec) XXX_Size() int {
	return m.Size()
}
func (m *GenerativeSplitAndScatterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerativeSplitAndScatterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GenerativeSplitAndScatterSpec proto.InternalMessageInfo

type CloudStorageTestSpec struct {
	Location string                      `protobuf:"bytes,1,opt,name=location" json:"location"`
	Params   CloudStorageTestSpec_Params `protobuf:"bytes,2,opt,name=params" json:"params"`
}

func (m *CloudStorageTestSpec) Reset()         { *m = CloudStorageTestSpec{} }
func (m *CloudStorageTestSpec) String() string { return proto.CompactTextString(m) }
func (*CloudStorageTestSpec) ProtoMessage()    {}
func (*CloudStorageTestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{18}
}
func (m *CloudStorageTestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudStorageTestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudStorageTestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudStorageTestSpec.Merge(m, src)
}
func (m *CloudStorageTestSpec) XXX_Size() int {
	return m.Size()
}
func (m *CloudStorageTestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudStorageTestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CloudStorageTestSpec proto.InternalMessageInfo

type CloudStorageTestSpec_Params struct {
	// TransferSize determines the size of the file that is written and then
	// read back in its entirety in each iteration of the test.
	TransferSize int64 `protobuf:"varint,1,opt,name=transfer_size,json=transferSize" json:"transfer_size"`
	// MinDuration causes the test to be run repeatedly until the duration has
	// elapsed.
	MinDuration time.Duration `protobuf:"varint,2,opt,name=min_duration,json=minDuration,casttype=time.Duration" json:"min_duration"`
	// Concurrency causes multiple tests to be run in parallel.
	Concurrency int64 `protobuf:"varint,3,opt,name=concurrency" json:"concurrency"`
}

func (m *CloudStorageTestSpec_Params) Reset()         { *m = CloudStorageTestSpec_Params{} }
func (m *CloudStorageTestSpec_Params) String() string { return proto.CompactTextString(m) }
func (*CloudStorageTestSpec_Params) ProtoMessage()    {}
func (*CloudStorageTestSpec_Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{18, 0}
}
func (m *CloudStorageTestSpec_Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudStorageTestSpec_Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudStorageTestSpec_Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudStorageTestSpec_Params.Merge(m, src)
}
func (m *CloudStorageTestSpec_Params) XXX_Size() int {
	return m.Size()
}
func (m *CloudStorageTestSpec_Params) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudStorageTestSpec_Params.DiscardUnknown(m)
}

var xxx_messageInfo_CloudStorageTestSpec_Params proto.InternalMessageInfo

type TableReplicationMetadata struct {
	SourceDescriptor              descpb.TableDescriptor `protobuf:"bytes,1,opt,name=source_descriptor,json=sourceDescriptor" json:"source_descriptor"`
	DestinationParentDatabaseName string                 `protobuf:"bytes,2,opt,name=destination_parent_database_name,json=destinationParentDatabaseName" json:"destination_parent_database_name"`
	DestinationParentSchemaName   string                 `protobuf:"bytes,3,opt,name=destination_parent_schema_name,json=destinationParentSchemaName" json:"destination_parent_schema_name"`
	DestinationTableName          string                 `protobuf:"bytes,4,opt,name=destination_table_name,json=destinationTableName" json:"destination_table_name"`
	// DestinationFunctionOID, if non-zero, is the OID of the
	// user-defined function that should be used for the table.
	DestinationFunctionOID uint32 `protobuf:"varint,5,opt,name=destination_function_oid,json=destinationFunctionOid" json:"destination_function_oid"`
}

func (m *TableReplicationMetadata) Reset()         { *m = TableReplicationMetadata{} }
func (m *TableReplicationMetadata) String() string { return proto.CompactTextString(m) }
func (*TableReplicationMetadata) ProtoMessage()    {}
func (*TableReplicationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{19}
}
func (m *TableReplicationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableReplicationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableReplicationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableReplicationMetadata.Merge(m, src)
}
func (m *TableReplicationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TableReplicationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TableReplicationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TableReplicationMetadata proto.InternalMessageInfo

type LogicalReplicationWriterSpec struct {
	// JobID of the job that ran the replicationWriterProcessor.
	JobID int64 `protobuf:"varint,1,opt,name=job_id,json=jobId" json:"job_id"`
	// StreamID is the ID of the stream (which is shared across the producer and consumer).
	StreamID uint64 `protobuf:"varint,2,opt,name=stream_id,json=streamId" json:"stream_id"`
	// PartitionSpec is the source partition this processor will create a
	// subscription for.
	PartitionSpec StreamIngestionPartitionSpec `protobuf:"bytes,3,opt,name=partition_spec,json=partitionSpec" json:"partition_spec"`
	// PreviousReplicatedTimestamp specifies the timestamp from which spans will
	// start ingesting data in the replication job. This timestamp is empty unless
	// the replication job resumes after a progress checkpoint has been recorded.
	// While it is empty we use the InitialScanTimestamp described below.
	PreviousReplicatedTimestamp hlc.Timestamp `protobuf:"bytes,4,opt,name=previous_replicated_timestamp,json=previousReplicatedTimestamp" json:"previous_replicated_timestamp"`
	// InitialScanTimestamp is the timestamp at which the partition will run the
	// initial rangefeed scan before replicating further changes to the target
	// spans. This timestamp is always non-empty, but a partition will only run an
	// initial scan if no progress has been recorded prior to the current
	// resumption of the replication job. Otherwise, all spans will start
	// ingesting data from the PreviousReplicatedTimestamp described above.
	InitialScanTimestamp hlc.Timestamp `protobuf:"bytes,5,opt,name=initial_scan_timestamp,json=initialScanTimestamp" json:"initial_scan_timestamp"`
	// PartitionConnUri locate the stream so that a stream client can be
	// initialized.
	PartitionConnUri string `protobuf:"bytes,6,opt,name=partition_conn_uri,json=partitionConnUri" json:"partition_conn_uri"`
	// Checkpoint stores a set of resolved spans denoting completed progress.
	Checkpoint jobspb.StreamIngestionCheckpoint `protobuf:"bytes,7,opt,name=checkpoint" json:"checkpoint"`
	// TableMetadataByDestID is a map from destination table IDs to metadata
	// containing source table descriptors and fully qualified destination table
	// names.
	TableMetadataByDestID map[int32]TableReplicationMetadata `protobuf:"bytes,8,rep,name=table_metadata_by_dest_id,json=tableMetadataByDestId" json:"table_metadata_by_dest_id" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Discard is an option on whether to filter some events.
	Discard         jobspb.LogicalReplicationDetails_Discard   `protobuf:"varint,12,opt,name=discard,enum=cockroach.sql.jobs.jobspb.LogicalReplicationDetails_Discard" json:"discard"`
	Mode            jobspb.LogicalReplicationDetails_ApplyMode `protobuf:"varint,10,opt,name=mode,enum=cockroach.sql.jobs.jobspb.LogicalReplicationDetails_ApplyMode" json:"mode"`
	MetricsLabel    string                                     `protobuf:"bytes,11,opt,name=metrics_label,json=metricsLabel" json:"metrics_label"`
	TypeDescriptors []*descpb.TypeDescriptor                   `protobuf:"bytes,13,rep,name=type_descriptors,json=typeDescriptors" json:"type_descriptors,omitempty"`
	WriterType      string                                     `protobuf:"bytes,14,opt,name=writer_type,json=writerType" json:"writer_type"`
}

func (m *LogicalReplicationWriterSpec) Reset()         { *m = LogicalReplicationWriterSpec{} }
func (m *LogicalReplicationWriterSpec) String() string { return proto.CompactTextString(m) }
func (*LogicalReplicationWriterSpec) ProtoMessage()    {}
func (*LogicalReplicationWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{20}
}
func (m *LogicalReplicationWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalReplicationWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogicalReplicationWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalReplicationWriterSpec.Merge(m, src)
}
func (m *LogicalReplicationWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *LogicalReplicationWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalReplicationWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalReplicationWriterSpec proto.InternalMessageInfo

type LogicalReplicationOfflineScanSpec struct {
	// JobID of the job that ran the replicationWriterProcessor.
	JobID int64 `protobuf:"varint,1,opt,name=job_id,json=jobId" json:"job_id"`
	// StreamID is the ID of the stream (which is shared across the producer and consumer).
	StreamID uint64 `protobuf:"varint,2,opt,name=stream_id,json=streamId" json:"stream_id"`
	// PartitionSpec is the source partition this processor will create a
	// subscription for.
	PartitionSpec StreamIngestionPartitionSpec `protobuf:"bytes,3,opt,name=partition_spec,json=partitionSpec" json:"partition_spec"`
	// InitialScanTimestamp is the timestamp at which the partition will run the
	// initial rangefeed scan before replicating further changes to the target
	// spans. This timestamp is always non-empty, but a partition will only run an
	// initial scan if no progress has been recorded prior to the current
	// resumption of the replication job. Otherwise, all spans will start
	// ingesting data from the PreviousReplicatedTimestamp described above.
	InitialScanTimestamp hlc.Timestamp `protobuf:"bytes,4,opt,name=initial_scan_timestamp,json=initialScanTimestamp" json:"initial_scan_timestamp"`
	// StreamAddress locate the stream so that a stream client can be initialized.
	StreamAddress string `protobuf:"bytes,5,opt,name=stream_address,json=streamAddress" json:"stream_address"`
	// Checkpoint stores a set of resolved spans denoting completed progress.
	Checkpoint   jobspb.StreamIngestionCheckpoint `protobuf:"bytes,6,opt,name=checkpoint" json:"checkpoint"`
	Rekey        []TableRekey                     `protobuf:"bytes,7,rep,name=rekey" json:"rekey"`
	MetricsLabel string                           `protobuf:"bytes,8,opt,name=metrics_label,json=metricsLabel" json:"metrics_label"`
}

func (m *LogicalReplicationOfflineScanSpec) Reset()         { *m = LogicalReplicationOfflineScanSpec{} }
func (m *LogicalReplicationOfflineScanSpec) String() string { return proto.CompactTextString(m) }
func (*LogicalReplicationOfflineScanSpec) ProtoMessage()    {}
func (*LogicalReplicationOfflineScanSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{21}
}
func (m *LogicalReplicationOfflineScanSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalReplicationOfflineScanSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogicalReplicationOfflineScanSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalReplicationOfflineScanSpec.Merge(m, src)
}
func (m *LogicalReplicationOfflineScanSpec) XXX_Size() int {
	return m.Size()
}
func (m *LogicalReplicationOfflineScanSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalReplicationOfflineScanSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalReplicationOfflineScanSpec proto.InternalMessageInfo

type CompactBackupsSpec struct {
	JobID       int64                            `protobuf:"varint,1,opt,name=job_id,json=jobId" json:"job_id"`
	DefaultURI  string                           `protobuf:"bytes,2,opt,name=default_uri,json=defaultUri" json:"default_uri"`
	Destination jobspb.BackupDetails_Destination `protobuf:"bytes,3,opt,name=destination" json:"destination"`
	Encryption  *jobspb.BackupEncryptionOptions  `protobuf:"bytes,4,opt,name=encryption" json:"encryption,omitempty"`
	StartTime   hlc.Timestamp                    `protobuf:"bytes,5,opt,name=startTime" json:"startTime"`
	EndTime     hlc.Timestamp                    `protobuf:"bytes,6,opt,name=endTime" json:"endTime"`
	ElideMode   ElidePrefix                      `protobuf:"varint,7,opt,name=elide_mode,json=elideMode,enum=cockroach.sql.distsqlrun.ElidePrefix" json:"elide_mode"`
	// spans represents the entire set of spans to be compacted. We send all of the
	// spans to all processors because each processor needs to be able to call
	// generateAndSendImportSpans to then cross check the generated spans against
	// the assigned spans. We are uncertain if generateAndSendImportSpans will work
	// if it is only provided the assigned spans, so to be safe we send the entire
	// set of spans.
	Spans []roachpb.Span `protobuf:"bytes,8,rep,name=spans" json:"spans"`
	// assigned_spans represents the spans assigned to this particular processor
	// to compact.
	AssignedSpans []roachpb.Span                                                          `protobuf:"bytes,9,rep,name=assigned_spans,json=assignedSpans" json:"assigned_spans"`
	UserProto     github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,10,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	// Since compaction processors each have to run generateAndSendImportSpans,
	// both target_size and max_files are sent through to the spec to ensure
	// consistent values are used in the event those cluster settings are changed
	// before the processors can load them.
	TargetSize int64 `protobuf:"varint,11,opt,name=target_size,json=targetSize" json:"target_size"`
	MaxFiles   int64 `protobuf:"varint,12,opt,name=max_files,json=maxFiles" json:"max_files"`
}

func (m *CompactBackupsSpec) Reset()         { *m = CompactBackupsSpec{} }
func (m *CompactBackupsSpec) String() string { return proto.CompactTextString(m) }
func (*CompactBackupsSpec) ProtoMessage()    {}
func (*CompactBackupsSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{22}
}
func (m *CompactBackupsSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBackupsSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompactBackupsSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBackupsSpec.Merge(m, src)
}
func (m *CompactBackupsSpec) XXX_Size() int {
	return m.Size()
}
func (m *CompactBackupsSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBackupsSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBackupsSpec proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.distsqlrun.ElidePrefix", ElidePrefix_name, ElidePrefix_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.BackfillerSpec_Type", BackfillerSpec_Type_name, BackfillerSpec_Type_value)
	proto.RegisterType((*BackfillerSpec)(nil), "cockroach.sql.distsqlrun.BackfillerSpec")
	proto.RegisterType((*JobProgress)(nil), "cockroach.sql.distsqlrun.JobProgress")
	proto.RegisterType((*ReadImportDataSpec)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec")
	proto.RegisterMapType((map[int32]int64)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ResumePosEntry")
	proto.RegisterMapType((map[string]*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.TablesEntry")
	proto.RegisterMapType((map[int32]string)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.UriEntry")
	proto.RegisterType((*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ImportTable")
	proto.RegisterType((*IngestStoppedSpec)(nil), "cockroach.sql.distsqlrun.IngestStoppedSpec")
	proto.RegisterType((*StreamIngestionPartitionSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionPartitionSpec")
	proto.RegisterType((*StreamIngestionPartitionSpecs)(nil), "cockroach.sql.distsqlrun.StreamIngestionPartitionSpecs")
	proto.RegisterType((*FrontierEntries)(nil), "cockroach.sql.distsqlrun.FrontierEntries")
	proto.RegisterType((*StreamIngestionDataSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionDataSpec")
	proto.RegisterMapType((map[string]StreamIngestionPartitionSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionDataSpec.PartitionSpecsEntry")
	proto.RegisterType((*StreamIngestionFrontierSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionFrontierSpec")
	proto.RegisterType((*BackupDataSpec)(nil), "cockroach.sql.distsqlrun.BackupDataSpec")
	proto.RegisterMapType((map[uint64]bool)(nil), "cockroach.sql.distsqlrun.BackupDataSpec.PkIdsEntry")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.distsqlrun.BackupDataSpec.UrisByLocalityKvEntry")
	proto.RegisterType((*RestoreFileSpec)(nil), "cockroach.sql.distsqlrun.RestoreFileSpec")
	proto.RegisterType((*TableRekey)(nil), "cockroach.sql.distsqlrun.TableRekey")
	proto.RegisterType((*TenantRekey)(nil), "cockroach.sql.distsqlrun.TenantRekey")
	proto.RegisterType((*RestoreSpanEntry)(nil), "cockroach.sql.distsqlrun.RestoreSpanEntry")
	proto.RegisterType((*RestoreDataSpec)(nil), "cockroach.sql.distsqlrun.RestoreDataSpec")
	proto.RegisterMapType((map[uint64]bool)(nil), "cockroach.sql.distsqlrun.RestoreDataSpec.PkIdsEntry")
	proto.RegisterType((*BulkRowWriterSpec)(nil), "cockroach.sql.distsqlrun.BulkRowWriterSpec")
	proto.RegisterType((*IndexBackfillMergerSpec)(nil), "cockroach.sql.distsqlrun.IndexBackfillMergerSpec")
	proto.RegisterType((*GenerativeSplitAndScatterSpec)(nil), "cockroach.sql.distsqlrun.GenerativeSplitAndScatterSpec")
	proto.RegisterType((*CloudStorageTestSpec)(nil), "cockroach.sql.distsqlrun.CloudStorageTestSpec")
	proto.RegisterType((*CloudStorageTestSpec_Params)(nil), "cockroach.sql.distsqlrun.CloudStorageTestSpec.Params")
	proto.RegisterType((*TableReplicationMetadata)(nil), "cockroach.sql.distsqlrun.TableReplicationMetadata")
	proto.RegisterType((*LogicalReplicationWriterSpec)(nil), "cockroach.sql.distsqlrun.LogicalReplicationWriterSpec")
	proto.RegisterMapType((map[int32]TableReplicationMetadata)(nil), "cockroach.sql.distsqlrun.LogicalReplicationWriterSpec.TableMetadataByDestIdEntry")
	proto.RegisterType((*LogicalReplicationOfflineScanSpec)(nil), "cockroach.sql.distsqlrun.LogicalReplicationOfflineScanSpec")
	proto.RegisterType((*CompactBackupsSpec)(nil), "cockroach.sql.distsqlrun.CompactBackupsSpec")
}

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_bulk_io.proto", fileDescriptor_6d46d06b67eadaca)
}

var fileDescriptor_6d46d06b67eadaca = []byte{
	// 3923 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5b, 0xcd, 0x73, 0x1b, 0x47,
	0x76, 0x17, 0x88, 0x01, 0x08, 0x3c, 0x10, 0x20, 0xd8, 0x92, 0xa8, 0x11, 0x65, 0x51, 0x34, 0x56,
	0xde, 0xe5, 0x7a, 0xcb, 0x60, 0x56, 0x76, 0x6c, 0xd7, 0xae, 0x1d, 0x9b, 0x20, 0x25, 0x19, 0xd4,
	0x17, 0x3d, 0x94, 0xb4, 0xb6, 0xcb, 0xc9, 0x54, 0x63, 0xa6, 0x09, 0xb6, 0x39, 0x98, 0x19, 0x75,
	0x37, 0x28, 0xc2, 0xc9, 0x21, 0xa9, 0x54, 0xe5, 0x92, 0x4a, 0x55, 0xaa, 0x52, 0x39, 0xa6, 0x2a,
	0x87, 0xec, 0x21, 0x39, 0xa4, 0x2a, 0xc7, 0xfc, 0x07, 0x3e, 0xee, 0x29, 0xb5, 0x27, 0x55, 0x22,
	0xd7, 0x5e, 0x92, 0xff, 0x60, 0x4f, 0xa9, 0xfe, 0x98, 0xc1, 0x80, 0x04, 0x21, 0x40, 0x96, 0x52,
	0x95, 0x0b, 0x35, 0xe8, 0xf7, 0xde, 0xaf, 0x7b, 0xba, 0xdf, 0x77, 0x8f, 0x60, 0x9d, 0x3f, 0x09,
	0x36, 0xc8, 0x31, 0xf1, 0x68, 0xb8, 0xcf, 0x70, 0xdc, 0xd9, 0x88, 0x59, 0xe4, 0x11, 0xce, 0x23,
	0xc6, 0xdd, 0x4e, 0x3f, 0x38, 0x74, 0x69, 0xd4, 0x8c, 0x59, 0x24, 0x22, 0x64, 0x7b, 0x91, 0x77,
	0xc8, 0x22, 0xec, 0x1d, 0x34, 0xf9, 0x93, 0xa0, 0xe9, 0x53, 0x2e, 0xf8, 0x93, 0x80, 0xf5, 0xc3,
	0x95, 0xe5, 0x6f, 0xa2, 0x0e, 0xdf, 0x90, 0x7f, 0xe2, 0x8e, 0xfa, 0x47, 0x4b, 0xac, 0xd8, 0x8a,
	0x3b, 0xee, 0x6c, 0xd0, 0xe8, 0x9d, 0xfd, 0x88, 0xf5, 0xb0, 0x48, 0x28, 0x3f, 0x92, 0xb3, 0x7a,
	0x58, 0xe0, 0x20, 0xea, 0x6e, 0xf8, 0x84, 0x7b, 0x71, 0x67, 0x83, 0x0b, 0xd6, 0xf7, 0x44, 0x9f,
	0x11, 0xdf, 0x30, 0x2d, 0x27, 0xe2, 0x3d, 0x22, 0xb0, 0x8f, 0x05, 0x4e, 0x60, 0xfb, 0x82, 0x06,
	0x1b, 0x07, 0x81, 0xb7, 0x21, 0x68, 0x8f, 0x70, 0x81, 0x7b, 0xb1, 0xa1, 0x5c, 0xe8, 0x46, 0xdd,
	0x48, 0x3d, 0x6e, 0xc8, 0x27, 0x33, 0x8a, 0x12, 0x9c, 0x0c, 0xc6, 0xd2, 0xe1, 0xd1, 0xc6, 0xe1,
	0x51, 0xdc, 0xd9, 0xc0, 0x31, 0x35, 0x43, 0xd7, 0xbd, 0x20, 0xea, 0xfb, 0x1b, 0xea, 0x6f, 0xdc,
	0xd9, 0x20, 0xc7, 0x82, 0xb0, 0x10, 0x07, 0x2e, 0x17, 0x11, 0xc3, 0x5d, 0xa2, 0xb9, 0x1a, 0xff,
	0x38, 0x0f, 0xb5, 0x16, 0xf6, 0x0e, 0xf7, 0x69, 0x10, 0x10, 0xb6, 0x17, 0x13, 0x0f, 0xdd, 0x06,
	0x4b, 0x0c, 0x62, 0x62, 0xe7, 0xd6, 0x72, 0xeb, 0xb5, 0x1b, 0xef, 0x34, 0xcf, 0xda, 0xa7, 0xe6,
	0xa8, 0x5c, 0xf3, 0xe1, 0x20, 0x26, 0x2d, 0xeb, 0xbb, 0x67, 0xd7, 0xce, 0x39, 0x0a, 0x00, 0xb5,
	0xa0, 0x20, 0x70, 0x27, 0x20, 0xf6, 0xdc, 0x5a, 0x6e, 0xbd, 0x72, 0xe3, 0xc7, 0x27, 0x90, 0xf8,
	0x93, 0xa0, 0x83, 0x39, 0x69, 0x3e, 0x94, 0x3c, 0xdb, 0x84, 0x7b, 0x8c, 0xc6, 0x22, 0x62, 0x06,
	0x42, 0x8b, 0xa2, 0x77, 0xa1, 0xc0, 0x63, 0x1c, 0x72, 0x1b, 0xd6, 0xf2, 0xeb, 0x95, 0x1b, 0x97,
	0x32, 0x18, 0x66, 0x1b, 0x9a, 0x7b, 0x31, 0x0e, 0x13, 0x21, 0xc5, 0x8b, 0x7e, 0x0e, 0x25, 0xbf,
	0xcf, 0xb0, 0xa0, 0x51, 0x68, 0x5b, 0x6b, 0xb9, 0xf5, 0x7c, 0xeb, 0xa2, 0x24, 0xff, 0xfe, 0xd9,
	0xb5, 0xaa, 0xdc, 0xe2, 0xe6, 0xb6, 0x21, 0x3a, 0x29, 0x1b, 0xfa, 0x11, 0x80, 0x77, 0xd0, 0x0f,
	0x0f, 0x5d, 0x4e, 0xbf, 0x25, 0x76, 0x41, 0x09, 0x69, 0xcc, 0xb2, 0x1a, 0xdf, 0xa3, 0xdf, 0x12,
	0x74, 0x1f, 0xde, 0xec, 0xc7, 0x3e, 0x16, 0xc4, 0x1d, 0xf2, 0xba, 0xe2, 0x80, 0x11, 0x7e, 0x10,
	0x05, 0xbe, 0xdb, 0x19, 0x08, 0xc2, 0xed, 0xda, 0x5a, 0x6e, 0xdd, 0x32, 0xb2, 0x57, 0x35, 0xfb,
	0x56, 0x82, 0xf0, 0x30, 0xe1, 0x6d, 0x49, 0x56, 0xb4, 0x09, 0xe5, 0xa7, 0x8c, 0x0a, 0xb2, 0xc9,
	0x1f, 0xec, 0xdb, 0xf3, 0x6a, 0x93, 0xae, 0x66, 0x5e, 0x50, 0xea, 0x45, 0xf3, 0x20, 0xf0, 0x9a,
	0x0f, 0x13, 0xbd, 0x48, 0x96, 0x94, 0x4a, 0xa1, 0x4f, 0xa0, 0xc4, 0x08, 0xf6, 0x15, 0x42, 0x79,
	0x7a, 0x84, 0x54, 0x08, 0x71, 0x38, 0x4f, 0x43, 0x9f, 0x1c, 0x13, 0xee, 0x8a, 0xc8, 0xed, 0x98,
	0x23, 0xb5, 0x4b, 0x6b, 0xf9, 0xf5, 0x6a, 0x6b, 0xeb, 0xf7, 0xcf, 0xae, 0x7d, 0xd2, 0xa5, 0xe2,
	0xa0, 0xdf, 0x69, 0x7a, 0x51, 0x6f, 0x23, 0x45, 0xf6, 0x3b, 0xc3, 0xe7, 0x8d, 0xf8, 0xb0, 0xbb,
	0x71, 0xda, 0x00, 0x9a, 0x6d, 0x09, 0xdb, 0xde, 0x76, 0x96, 0x0c, 0xfe, 0xc3, 0x28, 0x51, 0x18,
	0xf4, 0x33, 0xa8, 0xd1, 0x90, 0x0a, 0x2a, 0xd5, 0x31, 0x0e, 0xa8, 0xe0, 0x76, 0x65, 0x2d, 0xb7,
	0x5e, 0x30, 0x8b, 0xab, 0x1a, 0xda, 0x9e, 0x22, 0xa1, 0x8f, 0xc1, 0x56, 0xef, 0xeb, 0x62, 0xe1,
	0x76, 0xb0, 0xf0, 0x0e, 0xdc, 0xd4, 0x4e, 0xec, 0x85, 0xb5, 0xdc, 0x7a, 0xc9, 0x88, 0x5d, 0xd4,
	0xbb, 0x22, 0x5a, 0x92, 0x27, 0x7d, 0x61, 0xf4, 0xe7, 0x39, 0x58, 0xe4, 0x51, 0x9f, 0x79, 0xc4,
	0x55, 0x0b, 0x71, 0xa9, 0x6f, 0xd7, 0xd7, 0x72, 0xeb, 0xd5, 0xd6, 0x17, 0x52, 0xec, 0xf9, 0xb3,
	0x6b, 0xd5, 0x3d, 0x45, 0x36, 0xeb, 0x7d, 0x15, 0xaf, 0x5c, 0xe5, 0x19, 0x44, 0xbf, 0xf1, 0x36,
	0x58, 0xd2, 0x38, 0x50, 0x05, 0xe6, 0xdb, 0xe1, 0x11, 0x0e, 0xa8, 0x5f, 0x3f, 0x87, 0x00, 0x8a,
	0x5b, 0x51, 0xd0, 0xef, 0x85, 0xf5, 0x1c, 0x2a, 0x43, 0x41, 0xf1, 0xd6, 0xe7, 0x76, 0xac, 0x52,
	0xb5, 0x5e, 0xdb, 0xb1, 0x4a, 0xf9, 0xba, 0xb5, 0x63, 0x95, 0x8a, 0xf5, 0xf9, 0xc6, 0xbf, 0xe5,
	0xa0, 0xb2, 0x13, 0x75, 0x76, 0x59, 0xd4, 0x65, 0x84, 0x73, 0xf4, 0x27, 0x50, 0xfc, 0x26, 0xea,
	0xc8, 0xd7, 0xc8, 0x29, 0x35, 0xbd, 0x6d, 0x5e, 0xa3, 0xb0, 0x13, 0x75, 0xd4, 0xf2, 0xdf, 0x9f,
	0x6a, 0xf9, 0x19, 0x27, 0xd7, 0x54, 0x92, 0x4e, 0xe1, 0x9b, 0xa8, 0xd3, 0xf6, 0xd1, 0x3a, 0x2c,
	0x78, 0x51, 0x28, 0x18, 0xed, 0xf4, 0x95, 0x05, 0x49, 0xeb, 0x9d, 0x33, 0x7b, 0x3c, 0x42, 0x41,
	0x36, 0x58, 0x3c, 0x88, 0x84, 0x9d, 0xcf, 0x1c, 0x9e, 0x1a, 0x69, 0xfc, 0x0e, 0x00, 0x39, 0x04,
	0xfb, 0xed, 0x5e, 0x1c, 0x31, 0xb1, 0x8d, 0x05, 0x56, 0xae, 0xe5, 0x7a, 0xba, 0xf4, 0xf3, 0x6a,
	0xe9, 0xd5, 0x91, 0xa5, 0x27, 0x0b, 0xf8, 0x18, 0x8a, 0xda, 0xbd, 0xda, 0x25, 0xa5, 0xd1, 0xd7,
	0xc6, 0x18, 0x7d, 0xfb, 0xc1, 0x2d, 0x1a, 0x90, 0x5b, 0x8a, 0xcd, 0xcc, 0x6c, 0x84, 0xd0, 0x5b,
	0x50, 0xe1, 0xb8, 0x17, 0x07, 0x44, 0xdb, 0xf2, 0x5c, 0x66, 0x71, 0xa0, 0x09, 0xca, 0x98, 0x1f,
	0x43, 0x51, 0xb9, 0x18, 0x6e, 0x97, 0x95, 0x6b, 0xf9, 0xf0, 0x6c, 0x47, 0x77, 0xfa, 0x4d, 0xb4,
	0xd3, 0xe2, 0x37, 0x43, 0xc1, 0x06, 0x0a, 0x3b, 0xe7, 0x18, 0x34, 0x74, 0x1b, 0xf2, 0x7d, 0x46,
	0xed, 0x79, 0x05, 0xfa, 0x87, 0x33, 0x81, 0x3e, 0x62, 0x54, 0x21, 0x3a, 0x12, 0x01, 0x7d, 0x05,
	0xc0, 0x08, 0xef, 0xf7, 0x88, 0x1b, 0x47, 0xd2, 0xad, 0x48, 0xbc, 0x5f, 0xce, 0x84, 0xe7, 0x28,
	0xf1, 0xdd, 0x48, 0xaf, 0xd3, 0x29, 0xb3, 0xe4, 0x37, 0xba, 0x0d, 0xa5, 0xd8, 0xe8, 0x93, 0x5d,
	0x54, 0x9b, 0xfc, 0xd6, 0xd9, 0xc8, 0x19, 0xe5, 0x4b, 0xdc, 0x47, 0x22, 0x8c, 0x3e, 0x81, 0xcb,
	0xfc, 0x90, 0xc6, 0x6e, 0x8f, 0x72, 0x4e, 0xc3, 0xae, 0xbb, 0x1f, 0x31, 0x42, 0xbb, 0xa1, 0x7b,
	0x48, 0x06, 0xd2, 0x67, 0x0f, 0xad, 0x73, 0x59, 0xb2, 0xdd, 0xd3, 0x5c, 0xb7, 0x34, 0xd3, 0x1d,
	0x32, 0xe0, 0xe8, 0x6d, 0xa8, 0x3e, 0xc5, 0x41, 0x20, 0x4d, 0xfa, 0x3e, 0x0e, 0x23, 0xed, 0x09,
	0x12, 0xdf, 0x3b, 0x4a, 0x42, 0x37, 0x60, 0x49, 0xfa, 0x2d, 0xc2, 0x76, 0x31, 0xc3, 0x41, 0x40,
	0x02, 0xca, 0x7b, 0x76, 0x35, 0x73, 0xbe, 0xa7, 0xc9, 0x28, 0x04, 0xe8, 0x73, 0xc2, 0x5c, 0x15,
	0xee, 0xec, 0xc5, 0xb5, 0xdc, 0x7a, 0xb9, 0xf5, 0xc0, 0x44, 0x83, 0xdb, 0xd3, 0xd9, 0x39, 0xf1,
	0xfa, 0x8c, 0x8a, 0xc1, 0x86, 0xc4, 0x09, 0x71, 0x8f, 0x34, 0xf7, 0x3e, 0xbf, 0xfb, 0xc8, 0x3c,
	0xef, 0x4a, 0x58, 0xa7, 0x2c, 0x49, 0xea, 0x11, 0xfd, 0x12, 0x0a, 0x32, 0xf8, 0x71, 0xbb, 0xae,
	0x0e, 0xec, 0xad, 0xb3, 0x82, 0xde, 0x20, 0xce, 0xc4, 0x3c, 0x47, 0xcb, 0xa0, 0xbf, 0xc8, 0xc1,
	0x25, 0x19, 0xd5, 0x25, 0x8b, 0x1b, 0x33, 0xda, 0xc3, 0x6c, 0xe0, 0x32, 0xd2, 0x95, 0x66, 0xb8,
	0xa4, 0x96, 0xde, 0x36, 0x4b, 0xdf, 0x9c, 0xd9, 0x45, 0x79, 0x58, 0xc4, 0x9d, 0xa6, 0xa3, 0xc0,
	0xee, 0xe3, 0x1e, 0x71, 0x2e, 0x26, 0x33, 0xed, 0xea, 0x89, 0x34, 0x69, 0x8c, 0x6f, 0x46, 0x67,
	0xfa, 0xe6, 0x95, 0x3e, 0x54, 0xb4, 0xce, 0x29, 0x7b, 0x40, 0x9f, 0x82, 0x25, 0x3d, 0xa1, 0x72,
	0x4c, 0xb3, 0x05, 0xfc, 0x9c, 0xa3, 0x24, 0xd1, 0x75, 0x00, 0x81, 0x59, 0x97, 0x88, 0xad, 0x28,
	0xe0, 0xf6, 0xdc, 0x5a, 0x7e, 0xbd, 0x6c, 0xe8, 0x99, 0xf1, 0x15, 0x0e, 0x95, 0x8c, 0x01, 0xa2,
	0x3a, 0xe4, 0x0f, 0xc9, 0x40, 0xcd, 0x5a, 0x76, 0xe4, 0x23, 0xba, 0x0f, 0x85, 0x23, 0x1c, 0xf4,
	0x93, 0xd4, 0x63, 0x36, 0xdb, 0xce, 0xbc, 0x91, 0xa3, 0x61, 0x7e, 0x31, 0xf7, 0x61, 0x6e, 0xe5,
	0x7d, 0x28, 0x25, 0x06, 0x9a, 0x9d, 0xb1, 0xa0, 0x67, 0xbc, 0x90, 0x9d, 0xb1, 0x9c, 0x95, 0xfb,
	0x08, 0x6a, 0xa3, 0x86, 0xf8, 0x22, 0xe9, 0x7c, 0x46, 0x7a, 0xc7, 0x2a, 0xe5, 0x54, 0x54, 0xd0,
	0xf1, 0xc0, 0xaa, 0x17, 0x76, 0xac, 0x52, 0xa1, 0x5e, 0xdc, 0xb1, 0x4a, 0x0b, 0xf5, 0x6a, 0x83,
	0xc3, 0x52, 0x3b, 0xec, 0x12, 0x2e, 0xf6, 0x44, 0x14, 0xc7, 0xc4, 0x57, 0x5e, 0xf6, 0x35, 0x07,
	0x88, 0xc6, 0xff, 0xe4, 0xe1, 0x8d, 0x3d, 0xc1, 0x08, 0xee, 0xe9, 0xb9, 0x69, 0x14, 0xee, 0x62,
	0x26, 0xa8, 0x7c, 0x50, 0x0b, 0x78, 0x1f, 0x16, 0xe2, 0x64, 0x20, 0x59, 0x46, 0xb9, 0x75, 0xde,
	0x2c, 0xa3, 0x92, 0x32, 0xb7, 0xb7, 0x9d, 0x4a, 0xca, 0xd8, 0xf6, 0xd1, 0xbb, 0x80, 0x78, 0xbf,
	0xa3, 0xf5, 0x42, 0x8a, 0x8a, 0xe8, 0x90, 0xe8, 0xf8, 0x53, 0x4e, 0x0c, 0x3c, 0x4b, 0x7f, 0x28,
	0xc9, 0xe8, 0x06, 0xa0, 0xe1, 0x64, 0x5e, 0x14, 0x86, 0xae, 0x74, 0xbf, 0xf9, 0x8c, 0x50, 0x3d,
	0xa5, 0x6f, 0x45, 0x61, 0xf8, 0x88, 0xd1, 0x61, 0x56, 0x69, 0xcd, 0x90, 0x55, 0x1e, 0xc3, 0x22,
	0x67, 0x9e, 0x4b, 0x43, 0x2e, 0x70, 0x28, 0xb3, 0x09, 0x5f, 0xe5, 0x89, 0x85, 0xd6, 0x6e, 0x9a,
	0x47, 0x30, 0xaf, 0x6d, 0xa8, 0x6a, 0x9f, 0x3f, 0x98, 0x6a, 0x9f, 0x95, 0x4d, 0xec, 0x7d, 0x7e,
	0x77, 0x28, 0xea, 0x54, 0x79, 0x06, 0xc9, 0x47, 0x7f, 0x0a, 0x75, 0x9f, 0x70, 0x31, 0x32, 0x75,
	0x51, 0x4d, 0xfd, 0xb9, 0x99, 0xba, 0xb6, 0x4d, 0xb8, 0x78, 0x35, 0x73, 0xd7, 0xfc, 0x2c, 0x94,
	0xdf, 0xe8, 0xc1, 0xd5, 0x49, 0x87, 0xcd, 0xd1, 0x5d, 0xb9, 0x99, 0xc4, 0xe3, 0x76, 0x5e, 0x6d,
	0xe6, 0xfb, 0x67, 0xdb, 0xda, 0x24, 0x1c, 0x47, 0x83, 0x34, 0xba, 0xb0, 0x78, 0x8b, 0x45, 0xa1,
	0xa0, 0x84, 0x49, 0x63, 0xa1, 0x84, 0xa3, 0x87, 0x50, 0x63, 0x84, 0x47, 0xc1, 0x11, 0xf1, 0x5d,
	0x7d, 0x6c, 0x39, 0x35, 0xd3, 0x4f, 0x4e, 0xcc, 0xa4, 0x4a, 0x35, 0xa3, 0xb0, 0x8e, 0x11, 0xc8,
	0x1c, 0x63, 0x95, 0x65, 0xc6, 0x78, 0xe3, 0xbf, 0x0b, 0x70, 0xe9, 0xc4, 0x82, 0xd2, 0x3c, 0xe5,
	0x1d, 0x28, 0x73, 0x45, 0x4a, 0x0e, 0xd9, 0x6a, 0xd5, 0xcd, 0x4e, 0x97, 0x8c, 0xcc, 0xb6, 0x53,
	0xd2, 0x2c, 0x6d, 0x1f, 0x09, 0x58, 0x1c, 0xaa, 0xa0, 0xde, 0x8b, 0xa2, 0x5a, 0xe1, 0xcd, 0xa9,
	0xf7, 0x22, 0x75, 0x3e, 0xa3, 0x9b, 0x3b, 0x4c, 0x30, 0xce, 0x39, 0xb5, 0x78, 0x74, 0xdf, 0xbb,
	0x70, 0x35, 0x66, 0xe4, 0x88, 0x46, 0x7d, 0xee, 0x32, 0x12, 0x07, 0xd4, 0xc3, 0x82, 0xf8, 0x99,
	0xe4, 0x78, 0x6e, 0xfa, 0x7a, 0xe0, 0x4a, 0x82, 0xe4, 0xa4, 0x40, 0xc3, 0x0c, 0xfa, 0x4b, 0x58,
	0x4e, 0x23, 0x82, 0x87, 0xc3, 0xcc, 0x0c, 0x95, 0xe9, 0x67, 0xb8, 0x90, 0x04, 0x0e, 0x0f, 0x87,
	0x43, 0xe8, 0x61, 0x42, 0x68, 0x4d, 0x48, 0x08, 0xff, 0x18, 0x16, 0x04, 0x09, 0x71, 0x28, 0x5c,
	0x46, 0xa4, 0xe3, 0x2c, 0xbf, 0x28, 0x63, 0x79, 0xa8, 0xb8, 0x1d, 0xc9, 0x3c, 0x74, 0x3b, 0x99,
	0x41, 0xa7, 0x22, 0x86, 0x3f, 0x64, 0xa2, 0xe5, 0x1d, 0x10, 0xef, 0x30, 0x8e, 0x68, 0x28, 0x54,
	0xd2, 0x52, 0xb9, 0xf1, 0xde, 0x04, 0xdd, 0x3a, 0x71, 0x74, 0x5b, 0xa9, 0x6c, 0x92, 0x65, 0x0e,
	0xd1, 0x56, 0x06, 0x70, 0x7e, 0xcc, 0x89, 0x8e, 0x89, 0x58, 0x77, 0x47, 0x23, 0xd6, 0x4b, 0x5b,
	0xd1, 0xd8, 0xc8, 0xd1, 0xf8, 0x1b, 0x0b, 0xae, 0x9c, 0x90, 0x4b, 0xac, 0x4c, 0x29, 0xfc, 0xd7,
	0x60, 0x9f, 0x50, 0x21, 0x59, 0x6d, 0x71, 0x81, 0x99, 0x30, 0xc1, 0x7c, 0xaa, 0x43, 0xbe, 0xc8,
	0x46, 0xd4, 0x67, 0x53, 0xec, 0x49, 0x04, 0xd4, 0x82, 0xaa, 0x60, 0xd8, 0x3b, 0x4c, 0xed, 0x77,
	0x6e, 0x1a, 0xb7, 0xbb, 0x60, 0x64, 0x94, 0xb9, 0x66, 0x34, 0x25, 0x3f, 0x41, 0x53, 0x46, 0x0c,
	0xd7, 0x7a, 0xa1, 0xe1, 0x8e, 0x9e, 0xfc, 0xfc, 0xab, 0x3c, 0x79, 0xf4, 0x13, 0x58, 0x94, 0xd1,
	0x88, 0x78, 0xca, 0x2b, 0xf4, 0x19, 0xe5, 0xaa, 0xa8, 0x2e, 0x3b, 0xb5, 0xe1, 0xf0, 0x23, 0x46,
	0x39, 0xda, 0x3f, 0xed, 0x3d, 0xb4, 0x82, 0x7f, 0xf0, 0x72, 0x3a, 0xc0, 0xc7, 0xfb, 0x0b, 0x5d,
	0x4d, 0xea, 0xec, 0xa1, 0xf1, 0x0f, 0x65, 0xdd, 0xf6, 0xe9, 0xc7, 0x63, 0x6a, 0xb3, 0xca, 0x84,
	0x0d, 0x4e, 0x23, 0x67, 0x6e, 0x86, 0xc8, 0xf9, 0x19, 0xd4, 0x69, 0x28, 0x58, 0xe4, 0xf7, 0xbd,
	0xd9, 0x54, 0x60, 0x71, 0x28, 0xa6, 0xb5, 0xe0, 0x5d, 0xa8, 0xf8, 0x64, 0x1f, 0xf7, 0x03, 0x91,
	0x89, 0xf2, 0xc8, 0xac, 0x14, 0xb6, 0x35, 0xe9, 0x91, 0xd3, 0x76, 0xc0, 0xb0, 0xc9, 0x68, 0xff,
	0x97, 0x39, 0x38, 0x2f, 0xf7, 0xdf, 0xed, 0x0c, 0xdc, 0x20, 0xf2, 0x70, 0x40, 0xc5, 0xc0, 0x3d,
	0x3c, 0x32, 0xc1, 0xff, 0x8f, 0x26, 0x37, 0xb8, 0x86, 0x3b, 0x24, 0xcb, 0x33, 0xde, 0x1a, 0xdc,
	0x35, 0x08, 0x77, 0x8e, 0xb4, 0x73, 0xbe, 0xf0, 0xfc, 0xd9, 0xb5, 0xfa, 0x23, 0xa7, 0x9d, 0x25,
	0x3d, 0x76, 0xea, 0xfd, 0x13, 0xcc, 0xc8, 0x81, 0x4a, 0xef, 0xc8, 0xf3, 0xdc, 0x7d, 0x1a, 0x08,
	0xc2, 0x54, 0x54, 0xa9, 0x8d, 0x58, 0x55, 0xf2, 0xfe, 0xf7, 0x1e, 0x6f, 0x6d, 0xdd, 0x52, 0x4c,
	0xc3, 0x37, 0x1b, 0x8e, 0x39, 0x20, 0x51, 0xf4, 0x33, 0xfa, 0x0c, 0x80, 0x84, 0x1e, 0x1b, 0xa8,
	0x74, 0xc8, 0x14, 0x72, 0xeb, 0x63, 0x20, 0x65, 0xad, 0x7c, 0x33, 0x65, 0x7c, 0xa0, 0xfe, 0x72,
	0x27, 0x23, 0x8b, 0x1e, 0xc0, 0x52, 0x47, 0xbd, 0xad, 0x36, 0x7a, 0xe5, 0x02, 0x66, 0x69, 0x49,
	0x2d, 0x6a, 0x69, 0x65, 0xef, 0x92, 0x86, 0xee, 0x80, 0x19, 0x72, 0x49, 0xa8, 0x3d, 0x8a, 0xa9,
	0xe6, 0xa7, 0x82, 0xab, 0x6a, 0xd9, 0x9b, 0xa1, 0xf2, 0x23, 0xe8, 0x11, 0x14, 0xe3, 0x43, 0x97,
	0xfa, 0x49, 0xad, 0xfe, 0xee, 0xd4, 0x67, 0xb6, 0x7b, 0xd8, 0xf6, 0x4d, 0x14, 0x2d, 0x4b, 0x65,
	0xde, 0xbd, 0xd3, 0xde, 0xe6, 0x4e, 0x21, 0x96, 0xc3, 0x27, 0x6a, 0x43, 0x78, 0xed, 0xb5, 0xe1,
	0x7d, 0x58, 0x20, 0x01, 0xf5, 0x65, 0x69, 0x47, 0xf6, 0xe9, 0xb1, 0xea, 0x5e, 0xd5, 0x26, 0xc5,
	0xb1, 0x9b, 0x92, 0x7b, 0x57, 0x31, 0x9b, 0x8d, 0xa9, 0x90, 0xe1, 0x10, 0xfa, 0x12, 0x2e, 0xd3,
	0xd0, 0x0b, 0xfa, 0x3e, 0x71, 0x95, 0x6a, 0x29, 0xdf, 0xef, 0x1e, 0xa8, 0x1a, 0x58, 0xd5, 0xc5,
	0xa5, 0xd6, 0xaa, 0xd1, 0xa0, 0xe5, 0xb6, 0x66, 0x94, 0x8a, 0xf4, 0x58, 0xb2, 0x7d, 0xa6, 0xb8,
	0x9c, 0x65, 0x03, 0x70, 0xef, 0xc8, 0xf3, 0x32, 0xe3, 0x2b, 0x5b, 0x70, 0x71, 0xac, 0xba, 0x8f,
	0x89, 0x5c, 0x67, 0x57, 0x3e, 0x1f, 0x02, 0x0c, 0xf7, 0x3f, 0x2b, 0x69, 0x8d, 0x91, 0x2c, 0x65,
	0x24, 0x1b, 0xbf, 0xcb, 0xc3, 0xa2, 0x43, 0xb8, 0x88, 0x18, 0x91, 0xba, 0xab, 0x1c, 0xd4, 0xa7,
	0x90, 0xf7, 0x29, 0x33, 0xe1, 0x28, 0xab, 0xe5, 0xaa, 0xc5, 0xdd, 0x34, 0x8d, 0xee, 0xe6, 0x4d,
	0xd3, 0xe8, 0xde, 0xd3, 0x7d, 0x6e, 0xb3, 0x6f, 0x52, 0x14, 0xd9, 0x60, 0xc5, 0x58, 0x1c, 0x8c,
	0x54, 0x14, 0x6a, 0x04, 0x39, 0xb0, 0x6c, 0xb4, 0x75, 0x9f, 0x06, 0xc4, 0x25, 0x72, 0xc1, 0xca,
	0x51, 0x29, 0x3b, 0x7d, 0xa1, 0x9f, 0x3a, 0xaf, 0x85, 0xb5, 0x99, 0x09, 0x36, 0x90, 0x24, 0xf4,
	0x15, 0xd8, 0xa7, 0x31, 0xbd, 0xa8, 0x1f, 0x8a, 0xa4, 0xe7, 0x72, 0x65, 0x0c, 0xaa, 0x13, 0x3d,
	0xdd, 0x92, 0x3c, 0x49, 0x44, 0x3d, 0x81, 0xac, 0x68, 0x1c, 0xfd, 0x81, 0x36, 0x57, 0xd5, 0x71,
	0xa1, 0x49, 0xa7, 0x6b, 0x3e, 0xd3, 0x79, 0x5e, 0x34, 0x64, 0xb5, 0x7b, 0xf4, 0x5b, 0x59, 0x9a,
	0x5f, 0xc6, 0x71, 0xcc, 0xa2, 0x63, 0xda, 0xc3, 0x82, 0xb8, 0xf1, 0xc1, 0x80, 0x53, 0x4f, 0x66,
	0x74, 0x52, 0xb2, 0x94, 0x91, 0xbc, 0x94, 0x61, 0xdb, 0x35, 0x5c, 0x0a, 0x61, 0x05, 0x0a, 0x01,
	0x1e, 0x10, 0xa6, 0xa2, 0x53, 0xd2, 0x0f, 0xd0, 0x43, 0xe8, 0x6d, 0xa8, 0x1d, 0x60, 0xee, 0x32,
	0x1c, 0x76, 0xc9, 0xe9, 0xde, 0xcf, 0xc2, 0x01, 0xe6, 0x8e, 0x24, 0xdd, 0x21, 0x03, 0x9e, 0xad,
	0x65, 0x1b, 0xf7, 0x00, 0x74, 0x9d, 0xad, 0x12, 0xb1, 0xeb, 0x50, 0x8c, 0x02, 0x3f, 0xa9, 0x18,
	0xab, 0xc3, 0x10, 0xf4, 0x20, 0xf0, 0x65, 0x08, 0x8a, 0x02, 0xbf, 0xed, 0xa3, 0xcb, 0x50, 0x0a,
	0xc9, 0x53, 0x57, 0x35, 0x1a, 0xe4, 0x49, 0x2e, 0x38, 0xf3, 0x21, 0x79, 0xba, 0x4d, 0xb8, 0xd7,
	0xf8, 0xbb, 0x1c, 0x64, 0xd3, 0x3c, 0xb4, 0x39, 0x02, 0x38, 0x7e, 0xc3, 0x35, 0x7f, 0x7b, 0xfb,
	0x8c, 0xd9, 0x36, 0xa1, 0x28, 0x67, 0xa3, 0xbe, 0x49, 0xcc, 0xa6, 0x83, 0xb8, 0x4f, 0x9e, 0x4a,
	0x88, 0x90, 0x3c, 0x6d, 0xfb, 0x8d, 0xbf, 0x9a, 0x83, 0xba, 0x51, 0x66, 0xa9, 0x18, 0xda, 0x1a,
	0x7e, 0x0e, 0x96, 0xd2, 0xaf, 0xdc, 0x34, 0xfa, 0xa5, 0x58, 0xd1, 0x4d, 0x28, 0xc8, 0xc3, 0x4e,
	0x62, 0xe7, 0x4f, 0x27, 0x35, 0x35, 0x46, 0x4c, 0x27, 0x39, 0x2b, 0x25, 0x8d, 0x7e, 0x0c, 0x95,
	0xa4, 0x7d, 0xd7, 0xf6, 0x8f, 0x4d, 0x3a, 0x65, 0xbc, 0x4b, 0x86, 0x80, 0x76, 0xa1, 0xaa, 0x9c,
	0x8d, 0x9f, 0xb8, 0x2b, 0x6b, 0x76, 0x77, 0xa5, 0xfd, 0x9d, 0xaf, 0xc7, 0x1a, 0x7f, 0x5d, 0x48,
	0xad, 0x7a, 0x4c, 0xda, 0x51, 0x9c, 0x90, 0x76, 0xdc, 0x82, 0x05, 0xa6, 0x05, 0x75, 0x28, 0x99,
	0x21, 0x27, 0xad, 0x18, 0x41, 0x15, 0x48, 0x46, 0x03, 0xe6, 0xdc, 0x0f, 0x08, 0x98, 0xf7, 0x60,
	0x41, 0x35, 0x7c, 0x75, 0x49, 0x92, 0x14, 0xbf, 0xd7, 0x27, 0xd4, 0x24, 0xa9, 0x9e, 0x27, 0x0b,
	0x13, 0xe9, 0x08, 0x97, 0x9b, 0x9d, 0x2d, 0x71, 0xb8, 0x5d, 0x18, 0xdb, 0x3e, 0x3c, 0xa3, 0xc6,
	0x49, 0x12, 0xe6, 0xe1, 0x10, 0x47, 0x8f, 0xd3, 0x98, 0xa9, 0xf3, 0x9c, 0xf7, 0x5e, 0xa8, 0x2e,
	0xd3, 0x05, 0xcd, 0x9f, 0x42, 0x55, 0x5d, 0x61, 0x48, 0x2f, 0x12, 0x85, 0xc1, 0x40, 0x39, 0x8f,
	0xd4, 0xd2, 0x13, 0xd2, 0x83, 0x30, 0x18, 0xa0, 0xc7, 0xb0, 0x6c, 0x3a, 0xd8, 0x5e, 0xd0, 0xe7,
	0x82, 0x30, 0xf7, 0x88, 0x30, 0x2e, 0x77, 0x5e, 0x17, 0x59, 0x2b, 0x63, 0x76, 0xfe, 0xb1, 0xe6,
	0x48, 0xaa, 0x46, 0x2d, 0xbf, 0xa5, 0xc5, 0x0d, 0xed, 0xe5, 0xe3, 0xca, 0x8e, 0x55, 0x9a, 0xaf,
	0x97, 0x76, 0xac, 0x52, 0xb9, 0x0e, 0x8d, 0x5f, 0xc1, 0x52, 0xab, 0x1f, 0x1c, 0x3a, 0xd1, 0xd3,
	0x5f, 0x31, 0x2a, 0x4c, 0x21, 0x94, 0xde, 0x59, 0xe6, 0x5e, 0xfa, 0xce, 0xb2, 0xf1, 0x1f, 0x79,
	0xb8, 0xa4, 0xae, 0x73, 0x92, 0xfb, 0xae, 0x7b, 0x84, 0x75, 0x5f, 0x1d, 0x3e, 0x8a, 0x61, 0x49,
	0x90, 0x5e, 0x1c, 0x31, 0xcc, 0x06, 0xae, 0xb9, 0x5c, 0x53, 0x3e, 0xe1, 0x15, 0x5d, 0xd8, 0xd5,
	0x53, 0xf4, 0xb6, 0x06, 0x47, 0x07, 0x50, 0xc5, 0xbe, 0xf4, 0x04, 0xc9, 0x6c, 0xf9, 0x57, 0x37,
	0xdb, 0x82, 0x42, 0x4e, 0x66, 0x7a, 0xa9, 0xce, 0xdc, 0x65, 0x28, 0xc9, 0x07, 0x97, 0xfa, 0xc7,
	0xca, 0x6e, 0x0a, 0xce, 0xbc, 0xfc, 0x2d, 0x9d, 0xd8, 0x1d, 0xa8, 0xf5, 0xe4, 0xee, 0xa7, 0x5e,
	0x61, 0x96, 0x2c, 0xf4, 0x84, 0x68, 0xe3, 0x9f, 0xcb, 0x70, 0xf5, 0x36, 0x09, 0x09, 0xc3, 0x82,
	0x1e, 0x11, 0xd5, 0x02, 0xdf, 0x0c, 0xfd, 0x3d, 0x0f, 0x8b, 0x44, 0x7d, 0x4e, 0x7a, 0x85, 0xdc,
	0x2b, 0xf6, 0x0a, 0x73, 0x3f, 0xd4, 0x2b, 0x9c, 0xb2, 0xde, 0xfc, 0x99, 0xd6, 0xfb, 0x06, 0x58,
	0xaa, 0x6a, 0xb5, 0x54, 0x13, 0xbe, 0xf4, 0xfc, 0xd9, 0x35, 0x4b, 0x96, 0x39, 0x8e, 0x1a, 0x45,
	0xce, 0x88, 0x27, 0xd5, 0x59, 0xd2, 0x8d, 0x09, 0xa5, 0x73, 0xcb, 0x24, 0xf4, 0x93, 0x7c, 0xea,
	0xc7, 0x30, 0x4f, 0x74, 0xc6, 0x3f, 0xcb, 0x5d, 0x76, 0x22, 0xf3, 0x72, 0xdf, 0x0a, 0x08, 0xb8,
	0x60, 0xb2, 0xb4, 0xb4, 0x34, 0xa4, 0xe1, 0x7e, 0x64, 0x57, 0x14, 0xc6, 0x47, 0x93, 0x5b, 0x8c,
	0xca, 0x6b, 0x12, 0x81, 0x69, 0xc0, 0xcd, 0x0b, 0x26, 0xe9, 0x72, 0x3b, 0xdc, 0x8f, 0xcc, 0x44,
	0xa8, 0x73, 0x8a, 0x72, 0xa2, 0xf2, 0xa8, 0xbe, 0xf6, 0xca, 0x63, 0xf4, 0xf3, 0x86, 0xda, 0xf8,
	0xcf, 0x1b, 0xde, 0x82, 0x8a, 0xbe, 0x63, 0xd1, 0x5c, 0x8b, 0x19, 0x2e, 0x73, 0xf9, 0x92, 0xb0,
	0x85, 0xfd, 0x9e, 0xca, 0x67, 0xa9, 0xba, 0xe7, 0xca, 0xb0, 0x85, 0xfd, 0x5e, 0xd2, 0xb5, 0x7d,
	0x13, 0xca, 0x92, 0x2d, 0x8c, 0x7c, 0xc2, 0xd5, 0xe5, 0x55, 0xc2, 0x54, 0x0a, 0xfb, 0xbd, 0xfb,
	0x72, 0x34, 0x13, 0xfb, 0xd1, 0x84, 0xd8, 0xdf, 0x03, 0x34, 0x6c, 0xab, 0xa4, 0xfd, 0x83, 0x8b,
	0x63, 0x2f, 0x6d, 0xc7, 0x9c, 0x4f, 0x72, 0x75, 0xd9, 0xcc, 0xb6, 0x95, 0x13, 0xe3, 0x58, 0xca,
	0x22, 0xeb, 0x16, 0x43, 0x1b, 0x56, 0xc9, 0xb1, 0x8c, 0x57, 0xf4, 0x88, 0x98, 0xe4, 0x5a, 0xfa,
	0x16, 0x2f, 0xea, 0xc5, 0x98, 0x51, 0x1e, 0x85, 0xf6, 0x72, 0xc6, 0x64, 0xae, 0xa4, 0xbc, 0x3a,
	0xd9, 0xc2, 0xe1, 0x56, 0xca, 0x28, 0xb3, 0xe2, 0x1e, 0x3e, 0xd6, 0x20, 0x2a, 0xf1, 0xb7, 0x2f,
	0x65, 0xf6, 0x61, 0xa1, 0x87, 0x8f, 0xa5, 0x90, 0x4a, 0xe9, 0xd1, 0x47, 0x50, 0xe7, 0x4f, 0x82,
	0x6c, 0x8b, 0x9f, 0xdb, 0xb6, 0xf4, 0x65, 0x2d, 0xf4, 0xfc, 0xd9, 0xb5, 0xda, 0x48, 0x8f, 0x9e,
	0x3b, 0x35, 0xfe, 0x24, 0x18, 0xf6, 0xe8, 0xb9, 0xbe, 0x0d, 0xda, 0xb1, 0x4a, 0x17, 0xea, 0x17,
	0x77, 0xac, 0xd2, 0xf9, 0xfa, 0x85, 0xc6, 0xaf, 0xe7, 0xe0, 0xc2, 0x96, 0x2c, 0x89, 0x4c, 0x1d,
	0xf4, 0x90, 0x70, 0xa1, 0x5c, 0xd4, 0x1a, 0x94, 0xa4, 0xa6, 0x2b, 0xb3, 0xcd, 0x65, 0x0a, 0xa1,
	0x74, 0x14, 0xed, 0x41, 0x31, 0xc6, 0x0c, 0xf7, 0xb8, 0x49, 0x90, 0x26, 0x5c, 0x62, 0x8f, 0x9b,
	0xa1, 0xb9, 0xab, 0x84, 0x93, 0x5b, 0x79, 0x0d, 0xb5, 0xf2, 0xf7, 0x39, 0x28, 0x6a, 0x82, 0xf4,
	0x41, 0x82, 0xe1, 0x90, 0xef, 0x13, 0xa6, 0x35, 0x2d, 0x97, 0xdd, 0x95, 0x84, 0xa4, 0x74, 0xed,
	0x43, 0x58, 0xe8, 0xd1, 0xd0, 0x4d, 0xbf, 0xe6, 0x99, 0x9b, 0xf4, 0x35, 0x4f, 0xa5, 0x47, 0xc3,
	0xe4, 0x87, 0xcc, 0x72, 0xbd, 0x28, 0xf4, 0xfa, 0x8c, 0x91, 0xd0, 0x1b, 0x8c, 0x66, 0xb9, 0x19,
	0x42, 0xe3, 0xd7, 0x79, 0xb0, 0x8d, 0x13, 0xd6, 0xad, 0x4b, 0x1a, 0x85, 0xf7, 0xcc, 0x07, 0x5a,
	0xe8, 0x4b, 0x58, 0x32, 0x9f, 0x8e, 0xf8, 0x69, 0x2c, 0x7e, 0xa9, 0xc8, 0x5d, 0xd7, 0x30, 0xc3,
	0x71, 0x74, 0x0f, 0xd6, 0x7c, 0xc2, 0x05, 0x0d, 0xd5, 0x8c, 0x6e, 0x8c, 0x19, 0x09, 0x85, 0x9b,
	0x5e, 0xfe, 0x4a, 0x2b, 0x1e, 0xa9, 0x53, 0xaf, 0x66, 0xb8, 0x77, 0x15, 0xf3, 0xb6, 0xe1, 0xbd,
	0x8f, 0x7b, 0x44, 0x6a, 0xed, 0x18, 0x38, 0xee, 0x1d, 0x90, 0x1e, 0xd6, 0x60, 0xd9, 0x1b, 0xb1,
	0x2b, 0xa7, 0xc0, 0xf6, 0x14, 0xa7, 0x82, 0xfa, 0x05, 0x2c, 0x67, 0xa1, 0x74, 0x3c, 0x53, 0x10,
	0x56, 0x06, 0xe2, 0x42, 0x86, 0x47, 0xbd, 0xb3, 0x92, 0xfd, 0x02, 0xec, 0xac, 0xec, 0x7e, 0x3f,
	0xd4, 0xed, 0xcf, 0xc8, 0xdc, 0xa3, 0x54, 0x87, 0x0d, 0x89, 0xed, 0x21, 0xdf, 0x2d, 0xc3, 0xf6,
	0xa0, 0xbd, 0xed, 0x64, 0xe7, 0x4e, 0xc7, 0xa9, 0xdf, 0xf8, 0xf7, 0x32, 0xbc, 0x71, 0x37, 0xea,
	0xca, 0x6a, 0x34, 0x73, 0x52, 0x99, 0xcc, 0xed, 0xfa, 0x89, 0x5b, 0xcf, 0x29, 0x1a, 0xc4, 0x73,
	0x2f, 0x6c, 0x10, 0x7b, 0x50, 0x1b, 0xed, 0xcd, 0xaa, 0x6d, 0x7c, 0xe9, 0xf6, 0x7c, 0xd2, 0xdd,
	0x1a, 0xe9, 0xcc, 0xbe, 0xf8, 0x22, 0xc7, 0x7a, 0xed, 0x17, 0x39, 0x85, 0x1f, 0x7a, 0x91, 0x33,
	0xfe, 0x16, 0xb6, 0x38, 0xf1, 0x16, 0xf6, 0x75, 0x76, 0xdf, 0xff, 0x25, 0x07, 0x97, 0xb5, 0xe6,
	0x26, 0x5f, 0x5b, 0xba, 0x9d, 0x81, 0xab, 0x6f, 0x51, 0x7d, 0xd5, 0x88, 0xaf, 0xdc, 0xf8, 0xfc,
	0xec, 0x43, 0x9c, 0xa4, 0x69, 0xda, 0xc4, 0x13, 0x1f, 0xd1, 0x1a, 0xa8, 0xab, 0x57, 0x5f, 0x47,
	0x95, 0xab, 0x46, 0x97, 0x2e, 0x8e, 0xe3, 0xd9, 0x76, 0x2e, 0x8a, 0x71, 0xa2, 0xe8, 0x6b, 0x98,
	0xf7, 0x29, 0xf7, 0x30, 0xf3, 0x4d, 0x4b, 0x70, 0x52, 0xda, 0x71, 0x7a, 0x69, 0x49, 0x06, 0xb2,
	0xad, 0x31, 0x92, 0xb4, 0xc8, 0x40, 0xa2, 0x2f, 0xc0, 0xea, 0x45, 0x3e, 0x51, 0x35, 0x57, 0xed,
	0x54, 0xbb, 0x7b, 0x3a, 0xe8, 0xcd, 0x38, 0x0e, 0x06, 0xf7, 0x22, 0x3f, 0xfd, 0xc0, 0x53, 0x22,
	0x4a, 0x47, 0xde, 0x23, 0x82, 0x51, 0x8f, 0xbb, 0x01, 0xee, 0x90, 0x40, 0xdd, 0x1c, 0x94, 0xd3,
	0xf0, 0xa6, 0x49, 0x77, 0x25, 0x05, 0xed, 0x42, 0x5d, 0x0c, 0xe2, 0xac, 0x1f, 0xe5, 0x76, 0x75,
	0x96, 0x2f, 0x64, 0x16, 0xc5, 0xc8, 0x6f, 0x2e, 0xd3, 0x10, 0xf5, 0xc1, 0x1f, 0x73, 0xd5, 0xd7,
	0xaa, 0xb5, 0xcc, 0xd4, 0xa0, 0x09, 0x12, 0x61, 0xe5, 0xcf, 0x60, 0xe5, 0xec, 0xf3, 0x1a, 0xf3,
	0x25, 0xc6, 0x67, 0xa3, 0xf7, 0x70, 0x37, 0x5e, 0x98, 0xba, 0x9f, 0x8a, 0x1a, 0xa3, 0xf5, 0xa6,
	0xac, 0x34, 0xff, 0xd5, 0x82, 0x37, 0x4f, 0xef, 0xed, 0x83, 0xfd, 0xfd, 0x80, 0x86, 0x44, 0xda,
	0xd1, 0xff, 0x73, 0x07, 0x76, 0xb6, 0x5f, 0xb1, 0x7e, 0xa8, 0x5f, 0xf9, 0x19, 0xd4, 0xcc, 0xeb,
	0x62, 0xdf, 0x57, 0x9f, 0xab, 0x15, 0x32, 0x07, 0x5d, 0xd5, 0xb4, 0x4d, 0x4d, 0x3a, 0xe1, 0x50,
	0x8a, 0xaf, 0xd4, 0xa1, 0x7c, 0x0a, 0x05, 0x7d, 0xf9, 0x3c, 0x3f, 0x73, 0x49, 0xa7, 0x05, 0x4f,
	0x5b, 0x4b, 0xe9, 0x2c, 0x6b, 0x69, 0xfc, 0x53, 0x11, 0x90, 0xca, 0x23, 0x3d, 0xa1, 0xcb, 0x0a,
	0x3e, 0x83, 0x86, 0x9c, 0xb8, 0x23, 0x9b, 0x9b, 0xea, 0x8e, 0xec, 0x6b, 0x29, 0x94, 0x06, 0x5e,
	0xa3, 0x24, 0xef, 0xbd, 0xb0, 0x9e, 0x4b, 0x5d, 0xcf, 0x50, 0x36, 0x49, 0xb2, 0x32, 0x70, 0x27,
	0x8a, 0x45, 0xeb, 0x95, 0x14, 0x8b, 0x9b, 0xd2, 0x10, 0xcc, 0x6d, 0xd3, 0x2c, 0xf1, 0x6b, 0x28,
	0x95, 0xad, 0x37, 0x8b, 0x2f, 0x51, 0x6f, 0xee, 0x00, 0xe8, 0xeb, 0x1c, 0xe5, 0x5e, 0xe7, 0x67,
	0xef, 0x8e, 0x96, 0x95, 0xb8, 0x74, 0xab, 0xc3, 0xda, 0xb5, 0x34, 0x43, 0xed, 0xba, 0x0d, 0x35,
	0xcc, 0x39, 0xed, 0x86, 0x69, 0x55, 0x54, 0x9e, 0x46, 0xba, 0x9a, 0x08, 0xe9, 0x82, 0xe7, 0xff,
	0xfa, 0x16, 0xec, 0x44, 0x99, 0x59, 0x39, 0xa3, 0xcc, 0x7c, 0x13, 0xca, 0x49, 0xf1, 0xc4, 0x55,
	0x58, 0x4c, 0xeb, 0x47, 0x53, 0x37, 0xf1, 0xb7, 0x3f, 0x80, 0x4a, 0x66, 0x53, 0x51, 0x09, 0xac,
	0xfb, 0x51, 0x48, 0xf4, 0xb7, 0xd5, 0xba, 0x11, 0x52, 0xcf, 0x21, 0x04, 0x35, 0xfd, 0xbc, 0x19,
	0xfa, 0xca, 0x34, 0xeb, 0x73, 0xad, 0xc7, 0xdf, 0xfd, 0xd7, 0xea, 0xb9, 0xef, 0x9e, 0xaf, 0xe6,
	0x7e, 0xf3, 0x7c, 0x35, 0xf7, 0xdb, 0xe7, 0xab, 0xb9, 0xff, 0x7c, 0xbe, 0x9a, 0xfb, 0xdb, 0xef,
	0x57, 0xcf, 0xfd, 0xe6, 0xfb, 0xd5, 0x73, 0xbf, 0xfd, 0x7e, 0xf5, 0xdc, 0x57, 0xef, 0x4d, 0xdd,
	0xd6, 0xca, 0xfc, 0x67, 0x93, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xb7, 0x9a, 0x6b, 0x37, 0x7e,
	0x32, 0x00, 0x00,
}

func (m *BackfillerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackfillerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SourceIndexID))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.UpdateChunkSizeThresholdBytes))
	i--
	dAtA[i] = 0x70
	i--
	if m.WriteAtBatchTimestamp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.InitialSplits))
	i--
	dAtA[i] = 0x58
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size, err := m.ReadAsOf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.IndexesToBackfill) > 0 {
		for iNdEx := len(m.IndexesToBackfill) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.IndexesToBackfill[iNdEx]))
			i--
			dAtA[i] = 0x40
		}
	}
	{
		size, err := m.WriteAsOf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Duration))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *JobProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Slot))
	i--
	dAtA[i] = 0x18
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Contribution))))
	i--
	dAtA[i] = 0x15
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ReadImportDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadImportDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.InitialSplits))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i -= len(m.DatabasePrimaryRegion)
	copy(dAtA[i:], m.DatabasePrimaryRegion)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DatabasePrimaryRegion)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x7a
	if len(m.ResumePos) > 0 {
		keysForResumePos := make([]int32, 0, len(m.ResumePos))
		for k := range m.ResumePos {
			keysForResumePos = append(keysForResumePos, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResumePos)
		for iNdEx := len(keysForResumePos) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ResumePos[int32(keysForResumePos[iNdEx])]
			baseI := i
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForResumePos[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ReaderParallelism))
	i--
	dAtA[i] = 0x68
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.WalltimeNanos))
	i--
	dAtA[i] = 0x58
	i--
	if m.SkipMissingForeignKeys {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	if len(m.Tables) > 0 {
		keysForTables := make([]string, 0, len(m.Tables))
		for k := range m.Tables {
			keysForTables = append(keysForTables, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTables)
		for iNdEx := len(keysForTables) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tables[string(keysForTables[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForTables[iNdEx])
			copy(dAtA[i:], keysForTables[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForTables[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Format.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Uri) > 0 {
		keysForUri := make([]int32, 0, len(m.Uri))
		for k := range m.Uri {
			keysForUri = append(keysForUri, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForUri)
		for iNdEx := len(keysForUri) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Uri[int32(keysForUri[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForUri[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size, err := m.Progress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SampleSize))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}

func (m *ReadImportDataSpec_ImportTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec_ImportTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadImportDataSpec_ImportTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetCols) > 0 {
		for iNdEx := len(m.TargetCols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TargetCols[iNdEx])
			copy(dAtA[i:], m.TargetCols[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.TargetCols[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngestStoppedSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestStoppedSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestStoppedSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *StreamIngestionPartitionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionPartitionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionPartitionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.DestInstanceID))
	i--
	dAtA[i] = 0x30
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SrcInstanceID))
	i--
	dAtA[i] = 0x28
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.PartitionConnUri)
	copy(dAtA[i:], m.PartitionConnUri)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.PartitionConnUri)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.SubscriptionToken)
	copy(dAtA[i:], m.SubscriptionToken)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.SubscriptionToken)))
	i--
	dAtA[i] = 0x12
	i -= len(m.PartitionID)
	copy(dAtA[i:], m.PartitionID)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.PartitionID)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StreamIngestionPartitionSpecs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionPartitionSpecs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionPartitionSpecs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Specs) > 0 {
		for iNdEx := len(m.Specs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Specs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *FrontierEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrontierEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrontierEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for iNdEx := len(m.ResolvedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResolvedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamIngestionDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InitialScanTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.TenantRekey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.PartitionSpecs) > 0 {
		keysForPartitionSpecs := make([]string, 0, len(m.PartitionSpecs))
		for k := range m.PartitionSpecs {
			keysForPartitionSpecs = append(keysForPartitionSpecs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForPartitionSpecs)
		for iNdEx := len(keysForPartitionSpecs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PartitionSpecs[string(keysForPartitionSpecs[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForPartitionSpecs[iNdEx])
			copy(dAtA[i:], keysForPartitionSpecs[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForPartitionSpecs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.PreviousReplicatedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *StreamIngestionFrontierSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionFrontierSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionFrontierSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PartitionSpecs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.ConnectionUris) > 0 {
		for iNdEx := len(m.ConnectionUris) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConnectionUris[iNdEx])
			copy(dAtA[i:], m.ConnectionUris[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.ConnectionUris[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x18
	if len(m.TrackedSpans) > 0 {
		for iNdEx := len(m.TrackedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ReplicatedTimeAtStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BackupDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IncludeMVCCValueHeader {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ElidePrefix))
	i--
	dAtA[i] = 0x60
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x58
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x52
	if len(m.PKIDs) > 0 {
		keysForPKIDs := make([]uint64, 0, len(m.PKIDs))
		for k := range m.PKIDs {
			keysForPKIDs = append(keysForPKIDs, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForPKIDs)
		for iNdEx := len(keysForPKIDs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PKIDs[uint64(keysForPKIDs[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForPKIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.BackupEndTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.BackupStartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.MVCCFilter))
	i--
	dAtA[i] = 0x28
	if len(m.URIsByLocalityKV) > 0 {
		keysForURIsByLocalityKV := make([]string, 0, len(m.URIsByLocalityKV))
		for k := range m.URIsByLocalityKV {
			keysForURIsByLocalityKV = append(keysForURIsByLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByLocalityKV)
		for iNdEx := len(keysForURIsByLocalityKV) - 1; iNdEx >= 0; iNdEx-- {
			v := m.URIsByLocalityKV[string(keysForURIsByLocalityKV[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForURIsByLocalityKV[iNdEx])
			copy(dAtA[i:], keysForURIsByLocalityKV[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForURIsByLocalityKV[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.DefaultURI)
	copy(dAtA[i:], m.DefaultURI)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DefaultURI)))
	i--
	dAtA[i] = 0x1a
	if len(m.IntroducedSpans) > 0 {
		for iNdEx := len(m.IntroducedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntroducedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RestoreFileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreFileSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreFileSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.HasRangeKeys {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Layer))
	i--
	dAtA[i] = 0x48
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ApproximatePhysicalSize))
	i--
	dAtA[i] = 0x40
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.BackingFileSize))
	i--
	dAtA[i] = 0x38
	{
		size, err := m.BackupFileEntryCounts.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.BackupFileEntrySpan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Dir.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TableRekey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableRekey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableRekey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewDesc != nil {
		i -= len(m.NewDesc)
		copy(dAtA[i:], m.NewDesc)
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.NewDesc)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.OldID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TenantRekey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantRekey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantRekey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NewID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.OldID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RestoreSpanEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreSpanEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreSpanEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ElidedPrefix))
	i--
	dAtA[i] = 0x20
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ProgressIdx))
	i--
	dAtA[i] = 0x18
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RestoreDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResumeClusterVersion.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	i--
	if m.ValidateOnly {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x30
	if len(m.TenantRekeys) > 0 {
		for iNdEx := len(m.TenantRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TenantRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PKIDs) > 0 {
		keysForPKIDs := make([]uint64, 0, len(m.PKIDs))
		for k := range m.PKIDs {
			keysForPKIDs = append(keysForPKIDs, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForPKIDs)
		for iNdEx := len(keysForPKIDs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PKIDs[uint64(keysForPKIDs[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForPKIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TableRekeys) > 0 {
		for iNdEx := len(m.TableRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RestoreTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BulkRowWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkRowWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkRowWriterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexBackfillMergerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexBackfillMergerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexBackfillMergerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MergeTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.SpanIdx) > 0 {
		for iNdEx := len(m.SpanIdx) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SpanIdx[iNdEx]))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AddedIndexes) > 0 {
		for iNdEx := len(m.AddedIndexes) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.AddedIndexes[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.TemporaryIndexes) > 0 {
		for iNdEx := len(m.TemporaryIndexes) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.TemporaryIndexes[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GenerativeSplitAndScatterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerativeSplitAndScatterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerativeSplitAndScatterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SQLInstanceIDs) > 0 {
		for iNdEx := len(m.SQLInstanceIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SQLInstanceIDs[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc0
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.MaxFileCount))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i--
	if m.ExclusiveFileSpanComparison {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	if len(m.CheckpointedSpans) > 0 {
		for iNdEx := len(m.CheckpointedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CheckpointedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.NumNodes))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.NumEntries))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.TargetSize))
	i--
	dAtA[i] = 0x78
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	i--
	dAtA[i] = 0x70
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x6a
	if len(m.BackupLocalityInfo) > 0 {
		for iNdEx := len(m.BackupLocalityInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BackupLocalityInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.URIs) > 0 {
		for iNdEx := len(m.URIs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.URIs[iNdEx])
			copy(dAtA[i:], m.URIs[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.URIs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	i--
	if m.ValidateOnly {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.TenantRekeys) > 0 {
		for iNdEx := len(m.TenantRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TenantRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TableRekeys) > 0 {
		for iNdEx := len(m.TableRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudStorageTestSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudStorageTestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudStorageTestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i -= len(m.Location)
	copy(dAtA[i:], m.Location)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Location)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CloudStorageTestSpec_Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudStorageTestSpec_Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudStorageTestSpec_Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Concurrency))
	i--
	dAtA[i] = 0x18
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.MinDuration))
	i--
	dAtA[i] = 0x10
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.TransferSize))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TableReplicationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableReplicationMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableReplicationMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.DestinationFunctionOID))
	i--
	dAtA[i] = 0x28
	i -= len(m.DestinationTableName)
	copy(dAtA[i:], m.DestinationTableName)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DestinationTableName)))
	i--
	dAtA[i] = 0x22
	i -= len(m.DestinationParentSchemaName)
	copy(dAtA[i:], m.DestinationParentSchemaName)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DestinationParentSchemaName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.DestinationParentDatabaseName)
	copy(dAtA[i:], m.DestinationParentDatabaseName)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DestinationParentDatabaseName)))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SourceDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LogicalReplicationWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalReplicationWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalReplicationWriterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.WriterType)
	copy(dAtA[i:], m.WriterType)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.WriterType)))
	i--
	dAtA[i] = 0x72
	if len(m.TypeDescriptors) > 0 {
		for iNdEx := len(m.TypeDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TypeDescriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Discard))
	i--
	dAtA[i] = 0x60
	i -= len(m.MetricsLabel)
	copy(dAtA[i:], m.MetricsLabel)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.MetricsLabel)))
	i--
	dAtA[i] = 0x5a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Mode))
	i--
	dAtA[i] = 0x50
	if len(m.TableMetadataByDestID) > 0 {
		keysForTableMetadataByDestID := make([]int32, 0, len(m.TableMetadataByDestID))
		for k := range m.TableMetadataByDestID {
			keysForTableMetadataByDestID = append(keysForTableMetadataByDestID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForTableMetadataByDestID)
		for iNdEx := len(keysForTableMetadataByDestID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.TableMetadataByDestID[int32(keysForTableMetadataByDestID[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForTableMetadataByDestID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i -= len(m.PartitionConnUri)
	copy(dAtA[i:], m.PartitionConnUri)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.PartitionConnUri)))
	i--
	dAtA[i] = 0x32
	{
		size, err := m.InitialScanTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.PreviousReplicatedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.PartitionSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LogicalReplicationOfflineScanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalReplicationOfflineScanSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalReplicationOfflineScanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.MetricsLabel)
	copy(dAtA[i:], m.MetricsLabel)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.MetricsLabel)))
	i--
	dAtA[i] = 0x42
	if len(m.Rekey) > 0 {
		for iNdEx := len(m.Rekey) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rekey[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i -= len(m.StreamAddress)
	copy(dAtA[i:], m.StreamAddress)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.StreamAddress)))
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.InitialScanTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.PartitionSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *CompactBackupsSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBackupsSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBackupsSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.MaxFiles))
	i--
	dAtA[i] = 0x60
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.TargetSize))
	i--
	dAtA[i] = 0x58
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x52
	if len(m.AssignedSpans) > 0 {
		for iNdEx := len(m.AssignedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssignedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ElideMode))
	i--
	dAtA[i] = 0x38
	{
		size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.DefaultURI)
	copy(dAtA[i:], m.DefaultURI)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DefaultURI)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintProcessorsBulkIo(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessorsBulkIo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackfillerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.Type))
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.Duration))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	l = m.WriteAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.IndexesToBackfill) > 0 {
		for _, e := range m.IndexesToBackfill {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	l = m.ReadAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.InitialSplits))
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.UpdateChunkSizeThresholdBytes))
	n += 2 + sovProcessorsBulkIo(uint64(m.SourceIndexID))
	return n
}

func (m *JobProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 5
	n += 1 + sovProcessorsBulkIo(uint64(m.Slot))
	return n
}

func (m *ReadImportDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.SampleSize))
	l = m.Progress.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Uri) > 0 {
		for k, v := range m.Uri {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProcessorsBulkIo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.WalltimeNanos))
	n += 1 + sovProcessorsBulkIo(uint64(m.ReaderParallelism))
	if len(m.ResumePos) > 0 {
		for k, v := range m.ResumePos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + sovProcessorsBulkIo(uint64(v))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 2 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.DatabasePrimaryRegion)
	n += 2 + l + sovProcessorsBulkIo(uint64(l))
	n += 2 + sovProcessorsBulkIo(uint64(m.InitialSplits))
	n += 2 + sovProcessorsBulkIo(uint64(m.JobID))
	return n
}

func (m *ReadImportDataSpec_ImportTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *IngestStoppedSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	return n
}

func (m *StreamIngestionPartitionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionID)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.SubscriptionToken)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.PartitionConnUri)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.SrcInstanceID))
	n += 1 + sovProcessorsBulkIo(uint64(m.DestInstanceID))
	return n
}

func (m *StreamIngestionPartitionSpecs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Specs) > 0 {
		for _, e := range m.Specs {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *FrontierEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, e := range m.ResolvedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *StreamIngestionDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PreviousReplicatedTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.StreamID))
	if len(m.PartitionSpecs) > 0 {
		for k, v := range m.PartitionSpecs {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + 1 + l + sovProcessorsBulkIo(uint64(l))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.TenantRekey.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Checkpoint.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.InitialScanTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *StreamIngestionFrontierSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicatedTimeAtStart.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.TrackedSpans) > 0 {
		for _, e := range m.TrackedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.StreamID))
	l = m.Checkpoint.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.ConnectionUris) > 0 {
		for _, s := range m.ConnectionUris {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = m.PartitionSpecs.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *BackupDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.IntroducedSpans) > 0 {
		for _, e := range m.IntroducedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.DefaultURI)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.URIsByLocalityKV) > 0 {
		for k, v := range m.URIsByLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.MVCCFilter))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	l = m.BackupStartTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.BackupEndTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.PKIDs) > 0 {
		for k, v := range m.PKIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.ElidePrefix))
	n += 2
	return n
}

func (m *RestoreFileSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Dir.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.Path)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.BackupFileEntrySpan.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.BackupFileEntryCounts.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.BackingFileSize))
	n += 1 + sovProcessorsBulkIo(uint64(m.ApproximatePhysicalSize))
	n += 1 + sovProcessorsBulkIo(uint64(m.Layer))
	n += 2
	return n
}

func (m *TableRekey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.OldID))
	if m.NewDesc != nil {
		l = len(m.NewDesc)
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	return n
}

func (m *TenantRekey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OldID.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.NewID.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *RestoreSpanEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.ProgressIdx))
	n += 1 + sovProcessorsBulkIo(uint64(m.ElidedPrefix))
	return n
}

func (m *RestoreDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RestoreTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TableRekeys) > 0 {
		for _, e := range m.TableRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.PKIDs) > 0 {
		for k, v := range m.PKIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	if len(m.TenantRekeys) > 0 {
		for _, e := range m.TenantRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 2
	l = m.ResumeClusterVersion.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *BulkRowWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *IndexBackfillMergerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.TemporaryIndexes) > 0 {
		for _, e := range m.TemporaryIndexes {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	if len(m.AddedIndexes) > 0 {
		for _, e := range m.AddedIndexes {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.SpanIdx) > 0 {
		for _, e := range m.SpanIdx {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	l = m.MergeTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *GenerativeSplitAndScatterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableRekeys) > 0 {
		for _, e := range m.TableRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.TenantRekeys) > 0 {
		for _, e := range m.TenantRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 2
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	l = m.EndTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.BackupLocalityInfo) > 0 {
		for _, e := range m.BackupLocalityInfo {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	n += 1 + sovProcessorsBulkIo(uint64(m.TargetSize))
	n += 2 + sovProcessorsBulkIo(uint64(m.NumEntries))
	n += 2 + sovProcessorsBulkIo(uint64(m.NumNodes))
	n += 2 + sovProcessorsBulkIo(uint64(m.JobID))
	if len(m.CheckpointedSpans) > 0 {
		for _, e := range m.CheckpointedSpans {
			l = e.Size()
			n += 2 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 3
	n += 2 + sovProcessorsBulkIo(uint64(m.MaxFileCount))
	if len(m.SQLInstanceIDs) > 0 {
		for _, e := range m.SQLInstanceIDs {
			n += 2 + sovProcessorsBulkIo(uint64(e))
		}
	}
	return n
}

func (m *CloudStorageTestSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Location)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Params.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *CloudStorageTestSpec_Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.TransferSize))
	n += 1 + sovProcessorsBulkIo(uint64(m.MinDuration))
	n += 1 + sovProcessorsBulkIo(uint64(m.Concurrency))
	return n
}

func (m *TableReplicationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SourceDescriptor.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.DestinationParentDatabaseName)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.DestinationParentSchemaName)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.DestinationTableName)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.DestinationFunctionOID))
	return n
}

func (m *LogicalReplicationWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.StreamID))
	l = m.PartitionSpec.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.PreviousReplicatedTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.InitialScanTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.PartitionConnUri)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Checkpoint.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.TableMetadataByDestID) > 0 {
		for k, v := range m.TableMetadataByDestID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + l + sovProcessorsBulkIo(uint64(l))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.Mode))
	l = len(m.MetricsLabel)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.Discard))
	if len(m.TypeDescriptors) > 0 {
		for _, e := range m.TypeDescriptors {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.WriterType)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *LogicalReplicationOfflineScanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.StreamID))
	l = m.PartitionSpec.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.InitialScanTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.StreamAddress)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Checkpoint.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Rekey) > 0 {
		for _, e := range m.Rekey {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.MetricsLabel)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *CompactBackupsSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	l = len(m.DefaultURI)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Destination.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	l = m.StartTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.ElideMode))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.AssignedSpans) > 0 {
		for _, e := range m.AssignedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.TargetSize))
	n += 1 + sovProcessorsBulkIo(uint64(m.MaxFiles))
	return n
}

func sovProcessorsBulkIo(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozProcessorsBulkIo(x uint64) (n int) {
	return sovProcessorsBulkIo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackfillerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BackfillerSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WriteAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexesToBackfill = append(m.IndexesToBackfill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.IndexesToBackfill == nil {
						m.IndexesToBackfill = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
					} else {
						m.IndexesToBackfill = slices.Grow(m.IndexesToBackfill, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexesToBackfill = append(m.IndexesToBackfill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexesToBackfill", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSplits", wireType)
			}
			m.InitialSplits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSplits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteAtBatchTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteAtBatchTimestamp = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateChunkSizeThresholdBytes", wireType)
			}
			m.UpdateChunkSizeThresholdBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateChunkSizeThresholdBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndexID", wireType)
			}
			m.SourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contribution", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Contribution = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadImportDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadImportDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uri[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[string]*ReadImportDataSpec_ImportTable)
			}
			var mapkey string
			var mapvalue *ReadImportDataSpec_ImportTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReadImportDataSpec_ImportTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMissingForeignKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMissingForeignKeys = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalltimeNanos", wireType)
			}
			m.WalltimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalltimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderParallelism", wireType)
			}
			m.ReaderParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderParallelism |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePos == nil {
				m.ResumePos = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResumePos[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &descpb.TypeDescriptor{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabasePrimaryRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabasePrimaryRegion = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSplits", wireType)
			}
			m.InitialSplits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSplits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec_ImportTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &descpb.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestStoppedSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestStoppedSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestStoppedSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionPartitionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionPartitionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionPartitionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionConnUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionConnUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcInstanceID", wireType)
			}
			m.SrcInstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcInstanceID |= github_com_cockroachdb_cockroach_pkg_base.SQLInstanceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestInstanceID", wireType)
			}
			m.DestInstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestInstanceID |= github_com_cockroachdb_cockroach_pkg_base.SQLInstanceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionPartitionSpecs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionPartitionSpecs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionPartitionSpecs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Specs = append(m.Specs, &StreamIngestionPartitionSpec{})
			if err := m.Specs[len(m.Specs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrontierEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrontierEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrontierEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedSpans = append(m.ResolvedSpans, jobspb.ResolvedSpan{})
			if err := m.ResolvedSpans[len(m.ResolvedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousReplicatedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousReplicatedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionSpecs == nil {
				m.PartitionSpecs = make(map[string]StreamIngestionPartitionSpec)
			}
			var mapkey string
			mapvalue := &StreamIngestionPartitionSpec{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StreamIngestionPartitionSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PartitionSpecs[mapkey] = *mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRekey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantRekey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialScanTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialScanTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionFrontierSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionFrontierSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionFrontierSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedTimeAtStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicatedTimeAtStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackedSpans = append(m.TrackedSpans, roachpb.Span{})
			if err := m.TrackedSpans[len(m.TrackedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionUris", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionUris = append(m.ConnectionUris, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitionSpecs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntroducedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntroducedSpans = append(m.IntroducedSpans, roachpb.Span{})
			if err := m.IntroducedSpans[len(m.IntroducedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByLocalityKV == nil {
				m.URIsByLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCFilter", wireType)
			}
			m.MVCCFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MVCCFilter |= kvpb.MVCCFilter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &kvpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PKIDs == nil {
				m.PKIDs = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PKIDs[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElidePrefix", wireType)
			}
			m.ElidePrefix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElidePrefix |= ElidePrefix(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeMVCCValueHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeMVCCValueHeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreFileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreFileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreFileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dir.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupFileEntrySpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupFileEntrySpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupFileEntryCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupFileEntryCounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingFileSize", wireType)
			}
			m.BackingFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackingFileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximatePhysicalSize", wireType)
			}
			m.ApproximatePhysicalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximatePhysicalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasRangeKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasRangeKeys = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableRekey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRekey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRekey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldID", wireType)
			}
			m.OldID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDesc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDesc = append(m.NewDesc[:0], dAtA[iNdEx:postIndex]...)
			if m.NewDesc == nil {
				m.NewDesc = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantRekey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantRekey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantRekey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OldID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreSpanEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreSpanEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreSpanEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, RestoreFileSpec{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressIdx", wireType)
			}
			m.ProgressIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProgressIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElidedPrefix", wireType)
			}
			m.ElidedPrefix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElidedPrefix |= ElidePrefix(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RestoreTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &kvpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableRekeys = append(m.TableRekeys, TableRekey{})
			if err := m.TableRekeys[len(m.TableRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PKIDs == nil {
				m.PKIDs = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PKIDs[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantRekeys = append(m.TenantRekeys, TenantRekey{})
			if err := m.TenantRekeys[len(m.TenantRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateOnly = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeClusterVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResumeClusterVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkRowWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkRowWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkRowWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexBackfillMergerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexBackfillMergerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexBackfillMergerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TemporaryIndexes = append(m.TemporaryIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.TemporaryIndexes == nil {
						m.TemporaryIndexes = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
					} else {
						m.TemporaryIndexes = slices.Grow(m.TemporaryIndexes, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TemporaryIndexes = append(m.TemporaryIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndexes", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddedIndexes = append(m.AddedIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.AddedIndexes == nil {
						m.AddedIndexes = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
					} else {
						m.AddedIndexes = slices.Grow(m.AddedIndexes, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddedIndexes = append(m.AddedIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedIndexes", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpanIdx = append(m.SpanIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.SpanIdx == nil {
						m.SpanIdx = make([]int32, 0, elementCount)
					} else {
						m.SpanIdx = slices.Grow(m.SpanIdx, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpanIdx = append(m.SpanIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanIdx", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MergeTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerativeSplitAndScatterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerativeSplitAndScatterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerativeSplitAndScatterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableRekeys = append(m.TableRekeys, TableRekey{})
			if err := m.TableRekeys[len(m.TableRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantRekeys = append(m.TenantRekeys, TenantRekey{})
			if err := m.TenantRekeys[len(m.TenantRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &jobspb.BackupEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupLocalityInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupLocalityInfo = append(m.BackupLocalityInfo, jobspb.RestoreDetails_BackupLocalityInfo{})
			if err := m.BackupLocalityInfo[len(m.BackupLocalityInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSize", wireType)
			}
			m.TargetSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEntries", wireType)
			}
			m.NumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNodes", wireType)
			}
			m.NumNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckpointedSpans = append(m.CheckpointedSpans, jobspb.RestoreProgress_FrontierEntry{})
			if err := m.CheckpointedSpans[len(m.CheckpointedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveFileSpanComparison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveFileSpanComparison = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFileCount", wireType)
			}
			m.MaxFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFileCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SQLInstanceIDs = append(m.SQLInstanceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.SQLInstanceIDs == nil {
						m.SQLInstanceIDs = make([]int32, 0, elementCount)
					} else {
						m.SQLInstanceIDs = slices.Grow(m.SQLInstanceIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SQLInstanceIDs = append(m.SQLInstanceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLInstanceIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudStorageTestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudStorageTestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudStorageTestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudStorageTestSpec_Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferSize", wireType)
			}
			m.TransferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDuration", wireType)
			}
			m.MinDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDuration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			m.Concurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Concurrency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReplicationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReplicationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReplicationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SourceDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationParentDatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationParentDatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationParentSchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationParentSchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationFunctionOID", wireType)
			}
			m.DestinationFunctionOID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationFunctionOID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalReplicationWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalReplicationWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalReplicationWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitionSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousReplicatedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousReplicatedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialScanTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialScanTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionConnUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionConnUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableMetadataByDestID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableMetadataByDestID == nil {
				m.TableMetadataByDestID = make(map[int32]TableReplicationMetadata)
			}
			var mapkey int32
			mapvalue := &TableReplicationMetadata{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TableReplicationMetadata{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableMetadataByDestID[mapkey] = *mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= jobspb.LogicalReplicationDetails_ApplyMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discard", wireType)
			}
			m.Discard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discard |= jobspb.LogicalReplicationDetails_Discard(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeDescriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeDescriptors = append(m.TypeDescriptors, &descpb.TypeDescriptor{})
			if err := m.TypeDescriptors[len(m.TypeDescriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalReplicationOfflineScanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalReplicationOfflineScanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalReplicationOfflineScanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitionSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialScanTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialScanTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rekey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rekey = append(m.Rekey, TableRekey{})
			if err := m.Rekey[len(m.Rekey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactBackupsSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBackupsSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBackupsSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &jobspb.BackupEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElideMode", wireType)
			}
			m.ElideMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElideMode |= ElidePrefix(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedSpans = append(m.AssignedSpans, roachpb.Span{})
			if err := m.AssignedSpans[len(m.AssignedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSize", wireType)
			}
			m.TargetSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFiles", wireType)
			}
			m.MaxFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFiles |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsBulkIo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsBulkIo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessorsBulkIo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessorsBulkIo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessorsBulkIo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsBulkIo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessorsBulkIo = fmt.Errorf("proto: unexpected end of group")
)

