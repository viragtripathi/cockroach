// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_changefeeds.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_jobs_jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_security_username "github.com/cockroachdb/cockroach/pkg/security/username"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ChangeAggregatorSpec is the specification for a processor that watches for
// changes in a set of spans. Each span may cross multiple ranges.
type ChangeAggregatorSpec struct {
	Watches []ChangeAggregatorSpec_Watch `protobuf:"bytes,1,rep,name=watches" json:"watches"`
	// Feed is the specification for this changefeed.
	Feed jobspb.ChangefeedDetails `protobuf:"bytes,2,opt,name=feed" json:"feed"`
	// User who initiated the changefeed. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,3,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	// JobID is the id of this changefeed in the system jobs.
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,4,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
	// select is the "select clause" for predicate changefeed.
	Select Expression `protobuf:"bytes,6,opt,name=select" json:"select"`
	// Description is the description of the changefeed. Used for structured logging.
	Description string `protobuf:"bytes,7,opt,name=description" json:"description"`
	// InitialHighWater represents a point in time where all data is known to have
	// been seen for this changefeed job. It is safe to initialize frontier spans
	// at this timestamp upon resuming.
	InitialHighWater *hlc.Timestamp `protobuf:"bytes,8,opt,name=initial_high_water,json=initialHighWater" json:"initial_high_water,omitempty"`
	// SpanLevelCheckpoint is a map from timestamps to lists of spans. These spans
	// have been resolved to the given timestamp, so it is safe to forward these
	// spans to its corresponding timestamps upon resuming.
	SpanLevelCheckpoint *jobspb.TimestampSpansMap `protobuf:"bytes,9,opt,name=span_level_checkpoint,json=spanLevelCheckpoint" json:"span_level_checkpoint,omitempty"`
	// ProgressConfig is the configuration for the changefeed's progress tracking.
	ProgressConfig *ChangefeedProgressConfig `protobuf:"bytes,10,opt,name=progress_config,json=progressConfig" json:"progress_config,omitempty"`
	// ResolvedSpans contains the resolved spans that should be restored
	// when the changefeed resumes.
	ResolvedSpans []jobspb.ResolvedSpan `protobuf:"bytes,11,rep,name=resolved_spans,json=resolvedSpans" json:"resolved_spans"`
}

func (m *ChangeAggregatorSpec) Reset()         { *m = ChangeAggregatorSpec{} }
func (m *ChangeAggregatorSpec) String() string { return proto.CompactTextString(m) }
func (*ChangeAggregatorSpec) ProtoMessage()    {}
func (*ChangeAggregatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cd2be2dc9fdf3b5, []int{0}
}
func (m *ChangeAggregatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeAggregatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangeAggregatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeAggregatorSpec.Merge(m, src)
}
func (m *ChangeAggregatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChangeAggregatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeAggregatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeAggregatorSpec proto.InternalMessageInfo

type ChangeAggregatorSpec_Watch struct {
	Span roachpb.Span `protobuf:"bytes,2,opt,name=span" json:"span"`
}

func (m *ChangeAggregatorSpec_Watch) Reset()         { *m = ChangeAggregatorSpec_Watch{} }
func (m *ChangeAggregatorSpec_Watch) String() string { return proto.CompactTextString(m) }
func (*ChangeAggregatorSpec_Watch) ProtoMessage()    {}
func (*ChangeAggregatorSpec_Watch) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cd2be2dc9fdf3b5, []int{0, 0}
}
func (m *ChangeAggregatorSpec_Watch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeAggregatorSpec_Watch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangeAggregatorSpec_Watch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeAggregatorSpec_Watch.Merge(m, src)
}
func (m *ChangeAggregatorSpec_Watch) XXX_Size() int {
	return m.Size()
}
func (m *ChangeAggregatorSpec_Watch) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeAggregatorSpec_Watch.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeAggregatorSpec_Watch proto.InternalMessageInfo

// ChangeFrontierSpec is the specification for a processor that receives
// span-level resolved timestamps, track them, and emits the changefeed-level
// resolved timestamp whenever it changes.
type ChangeFrontierSpec struct {
	// TrackedSpans is the entire span set being watched. Once all these spans
	// have been resolved at a certain timestamp, then it's safe to resolve the
	// changefeed at that timestamp.
	TrackedSpans []roachpb.Span `protobuf:"bytes,1,rep,name=tracked_spans,json=trackedSpans" json:"tracked_spans"`
	// Feed is the specification for this changefeed.
	Feed jobspb.ChangefeedDetails `protobuf:"bytes,2,opt,name=feed" json:"feed"`
	// JobID is the id of this changefeed in the system jobs.
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,3,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
	// User who initiated the changefeed. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,4,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	// Description is the description of the changefeed. Used for structured logging.
	Description string `protobuf:"bytes,5,opt,name=description" json:"description"`
	// SpanLevelCheckpoint is a map from timestamps to lists of spans that captures
	// the changefeed progress and is used to initialize the frontier on resume.
	SpanLevelCheckpoint *jobspb.TimestampSpansMap `protobuf:"bytes,6,opt,name=span_level_checkpoint,json=spanLevelCheckpoint" json:"span_level_checkpoint,omitempty"`
	// ProgressConfig is the configuration for the changefeed's progress tracking.
	ProgressConfig *ChangefeedProgressConfig `protobuf:"bytes,7,opt,name=progress_config,json=progressConfig" json:"progress_config,omitempty"`
	// ResolvedSpans contains the resolved spans that should be restored
	// when the changefeed resumes.
	ResolvedSpans []jobspb.ResolvedSpan `protobuf:"bytes,8,rep,name=resolved_spans,json=resolvedSpans" json:"resolved_spans"`
}

func (m *ChangeFrontierSpec) Reset()         { *m = ChangeFrontierSpec{} }
func (m *ChangeFrontierSpec) String() string { return proto.CompactTextString(m) }
func (*ChangeFrontierSpec) ProtoMessage()    {}
func (*ChangeFrontierSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cd2be2dc9fdf3b5, []int{1}
}
func (m *ChangeFrontierSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeFrontierSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangeFrontierSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeFrontierSpec.Merge(m, src)
}
func (m *ChangeFrontierSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChangeFrontierSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeFrontierSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeFrontierSpec proto.InternalMessageInfo

// ChangefeedProgressConfig is the configuration for the changefeed's progress tracking.
type ChangefeedProgressConfig struct {
	// PerTableTracking configures whether the changefeed should track
	// span progress on a per-table basis. If configured, any span frontiers
	// created will track spans belonging to different tables separately.
	PerTableTracking bool `protobuf:"varint,1,opt,name=per_table_tracking,json=perTableTracking" json:"per_table_tracking"`
	// PerTableProtectedTimestamps configures whether the changefeed should
	// store one protected timestamp per target table. If configured, any
	// new changefeeds created will create one record per table.
	PerTableProtectedTimestamps bool `protobuf:"varint,2,opt,name=per_table_protected_timestamps,json=perTableProtectedTimestamps" json:"per_table_protected_timestamps"`
}

func (m *ChangefeedProgressConfig) Reset()         { *m = ChangefeedProgressConfig{} }
func (m *ChangefeedProgressConfig) String() string { return proto.CompactTextString(m) }
func (*ChangefeedProgressConfig) ProtoMessage()    {}
func (*ChangefeedProgressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cd2be2dc9fdf3b5, []int{2}
}
func (m *ChangefeedProgressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedProgressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangefeedProgressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedProgressConfig.Merge(m, src)
}
func (m *ChangefeedProgressConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedProgressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedProgressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedProgressConfig proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ChangeAggregatorSpec)(nil), "cockroach.sql.distsqlrun.ChangeAggregatorSpec")
	proto.RegisterType((*ChangeAggregatorSpec_Watch)(nil), "cockroach.sql.distsqlrun.ChangeAggregatorSpec.Watch")
	proto.RegisterType((*ChangeFrontierSpec)(nil), "cockroach.sql.distsqlrun.ChangeFrontierSpec")
	proto.RegisterType((*ChangefeedProgressConfig)(nil), "cockroach.sql.distsqlrun.ChangefeedProgressConfig")
}

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_changefeeds.proto", fileDescriptor_0cd2be2dc9fdf3b5)
}

var fileDescriptor_0cd2be2dc9fdf3b5 = []byte{
	// 779 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0x6e, 0x23, 0x35,
	0x14, 0xce, 0x6c, 0x7e, 0xeb, 0xb0, 0x4b, 0x64, 0x16, 0x18, 0x05, 0x31, 0x89, 0x2a, 0x04, 0xb9,
	0x58, 0xcd, 0x88, 0x68, 0xc5, 0x35, 0xa4, 0xcb, 0x96, 0x96, 0x22, 0x4a, 0x1a, 0xa8, 0x04, 0x12,
	0x83, 0xc7, 0xe3, 0xce, 0xb8, 0x99, 0x8c, 0x5d, 0xdb, 0x69, 0xcb, 0x5b, 0x70, 0x0b, 0xef, 0xc0,
	0x7b, 0xf4, 0xb2, 0x97, 0xbd, 0x8a, 0x20, 0x7d, 0x8b, 0x5e, 0x21, 0x3b, 0x4e, 0x9a, 0x56, 0x84,
	0x56, 0x62, 0x73, 0x93, 0x9c, 0xf1, 0x39, 0xdf, 0x77, 0x8e, 0xcf, 0x7c, 0x9f, 0x06, 0xbc, 0x90,
	0x27, 0x59, 0x40, 0xce, 0x09, 0xa6, 0xf9, 0x91, 0x40, 0x3c, 0x0a, 0xb8, 0x60, 0x98, 0x48, 0xc9,
	0x84, 0x0c, 0x71, 0x8a, 0xf2, 0x84, 0x1c, 0x11, 0x12, 0x4b, 0x9f, 0x0b, 0xa6, 0x18, 0x74, 0x31,
	0xc3, 0x43, 0xc1, 0x10, 0x4e, 0x7d, 0x79, 0x92, 0xf9, 0x31, 0x95, 0x4a, 0x9e, 0x64, 0x62, 0x9c,
	0x37, 0xdf, 0x3b, 0x66, 0x91, 0x0c, 0xf4, 0x0f, 0x8f, 0xcc, 0xdf, 0x0c, 0xd1, 0x84, 0xa6, 0x9a,
	0x47, 0x41, 0x8c, 0x14, 0xb2, 0x67, 0xcd, 0xfb, 0x3d, 0x97, 0x72, 0xee, 0x58, 0xd1, 0x2c, 0x48,
	0x33, 0x1c, 0x28, 0x3a, 0x22, 0x52, 0xa1, 0x11, 0xb7, 0x99, 0xe7, 0x09, 0x4b, 0x98, 0x09, 0x03,
	0x1d, 0xcd, 0x4e, 0x37, 0xff, 0xa8, 0x82, 0xe7, 0x5b, 0x66, 0xce, 0x2f, 0x92, 0x44, 0x90, 0x04,
	0x29, 0x26, 0x0e, 0x38, 0xc1, 0x70, 0x00, 0xaa, 0x67, 0x48, 0xe1, 0x94, 0x48, 0xd7, 0x69, 0x17,
	0x3b, 0xf5, 0xee, 0x4b, 0x7f, 0xd5, 0xf0, 0xfe, 0xbf, 0x11, 0xf8, 0x87, 0x1a, 0xdd, 0x2b, 0x5d,
	0x4c, 0x5a, 0x85, 0xfe, 0x9c, 0x0a, 0xbe, 0x06, 0x25, 0xbd, 0x0f, 0xf7, 0x49, 0xdb, 0xe9, 0xd4,
	0xbb, 0x2f, 0xee, 0x51, 0x9a, 0x7b, 0xcf, 0x76, 0x60, 0x39, 0x75, 0xf1, 0x2b, 0xa2, 0x10, 0xcd,
	0xa4, 0xa5, 0x32, 0x78, 0x98, 0x03, 0x30, 0x96, 0x44, 0x84, 0xe6, 0x12, 0x6e, 0xb1, 0xed, 0x74,
	0x36, 0x7a, 0xdf, 0xea, 0xfc, 0xcd, 0xa4, 0xb5, 0x9d, 0x50, 0x95, 0x8e, 0x23, 0x1f, 0xb3, 0x51,
	0xb0, 0xe0, 0x8f, 0xa3, 0xdb, 0x38, 0xe0, 0xc3, 0x24, 0x90, 0x04, 0x8f, 0x05, 0x55, 0xbf, 0x06,
	0x9a, 0x27, 0x47, 0x23, 0xe2, 0x1f, 0x7c, 0xb7, 0xf7, 0xbd, 0x8d, 0xf7, 0x35, 0x6d, 0x7f, 0x43,
	0xa7, 0x4c, 0x08, 0x7f, 0x06, 0x95, 0x63, 0x16, 0x85, 0x34, 0x76, 0x4b, 0x6d, 0xa7, 0x53, 0xec,
	0x6d, 0xeb, 0x5e, 0xd3, 0x49, 0xab, 0xbc, 0xcb, 0xa2, 0x9d, 0x57, 0x37, 0x93, 0xd6, 0x67, 0x8f,
	0x6a, 0xba, 0xf4, 0x92, 0x7d, 0x83, 0xec, 0x97, 0x8f, 0x59, 0xb4, 0x13, 0xc3, 0x1e, 0xa8, 0x48,
	0x92, 0x11, 0xac, 0xdc, 0x8a, 0xd9, 0xcc, 0x47, 0xab, 0x97, 0xfd, 0xe5, 0x39, 0x17, 0x44, 0x4a,
	0xca, 0x72, 0xbb, 0x11, 0x8b, 0x84, 0x1f, 0x83, 0x7a, 0x4c, 0x24, 0x16, 0x94, 0x2b, 0xca, 0x72,
	0xb7, 0x6a, 0x96, 0x32, 0x2b, 0x59, 0x4e, 0xc0, 0xaf, 0x01, 0xa4, 0x39, 0x55, 0x14, 0x65, 0x61,
	0x4a, 0x93, 0x34, 0x3c, 0x43, 0x8a, 0x08, 0xb7, 0x66, 0xfa, 0x7e, 0xb8, 0xd4, 0x57, 0x2b, 0xc9,
	0x4f, 0x33, 0xec, 0x0f, 0xe6, 0x4a, 0xea, 0x37, 0x2c, 0xf0, 0x2b, 0x9a, 0xa4, 0x87, 0x1a, 0x06,
	0x7f, 0x01, 0xef, 0x4a, 0x8e, 0xf2, 0x30, 0x23, 0xa7, 0x24, 0x0b, 0x71, 0x4a, 0xf0, 0x90, 0x33,
	0x9a, 0x2b, 0x77, 0xe3, 0xc1, 0x37, 0xbc, 0xa0, 0x3d, 0xe0, 0x28, 0x97, 0xdf, 0x20, 0xde, 0x7f,
	0x47, 0x53, 0xed, 0x69, 0xa6, 0xad, 0x05, 0x11, 0xfc, 0x09, 0xbc, 0xcd, 0x05, 0x4b, 0xf4, 0x9d,
	0x43, 0xcc, 0xf2, 0x23, 0x9a, 0xb8, 0xc0, 0x70, 0x77, 0x1f, 0x12, 0xa4, 0x56, 0xca, 0xbe, 0x85,
	0x6e, 0x19, 0x64, 0xff, 0x19, 0xbf, 0xf3, 0x0c, 0x07, 0xe0, 0x99, 0x20, 0x92, 0x65, 0xa7, 0x24,
	0x0e, 0x75, 0x73, 0xe9, 0xd6, 0x8d, 0xd8, 0x3f, 0xf9, 0x8f, 0xb9, 0xfb, 0x16, 0xa0, 0xc7, 0xb6,
	0xfb, 0x7d, 0x2a, 0x96, 0xce, 0x64, 0xf3, 0x73, 0x50, 0x36, 0xea, 0x87, 0x9f, 0x82, 0x92, 0x66,
	0xb5, 0x72, 0x7f, 0x7f, 0x89, 0xd4, 0xda, 0xda, 0x5f, 0x22, 0x31, 0xa5, 0xbb, 0xa5, 0x9a, 0xd3,
	0x78, 0xb2, 0x5b, 0xaa, 0x95, 0x1b, 0x95, 0xcd, 0x3f, 0xcb, 0x00, 0xce, 0xae, 0xf2, 0x5a, 0xb0,
	0x5c, 0x51, 0x32, 0xb3, 0x66, 0x0f, 0x3c, 0x55, 0x02, 0xe1, 0xe1, 0x62, 0xe6, 0x99, 0x41, 0x1f,
	0xa0, 0x7f, 0xcb, 0x62, 0xcc, 0x88, 0x6f, 0xcc, 0x88, 0xb7, 0xc6, 0x28, 0xae, 0xc5, 0x18, 0x77,
	0x8d, 0x5e, 0x5a, 0xbb, 0xd1, 0xef, 0x99, 0xa8, 0xbc, 0xca, 0x44, 0x2b, 0x75, 0x5f, 0x59, 0xa3,
	0xee, 0xab, 0x6b, 0xd4, 0x7d, 0xed, 0xff, 0xeb, 0x7e, 0xf3, 0x77, 0x07, 0xb8, 0xab, 0x46, 0x80,
	0x5d, 0x00, 0x39, 0x11, 0xa1, 0x42, 0x51, 0x46, 0x42, 0xa3, 0x45, 0x9a, 0x27, 0xae, 0xd3, 0x76,
	0x3a, 0x35, 0xcb, 0xd6, 0xe0, 0x44, 0x0c, 0x74, 0x7a, 0x60, 0xb3, 0x70, 0x07, 0x78, 0xb7, 0x18,
	0x2d, 0x01, 0x82, 0x15, 0x89, 0xc3, 0xc5, 0xa7, 0x4d, 0x1a, 0xfd, 0xce, 0xf1, 0x1f, 0xcc, 0xf1,
	0xfb, 0xf3, 0xca, 0xc5, 0xaa, 0x65, 0xef, 0x87, 0x8b, 0xbf, 0xbd, 0xc2, 0xc5, 0xd4, 0x73, 0x2e,
	0xa7, 0x9e, 0x73, 0x35, 0xf5, 0x9c, 0xbf, 0xa6, 0x9e, 0xf3, 0xdb, 0xb5, 0x57, 0xb8, 0xbc, 0xf6,
	0x0a, 0x57, 0xd7, 0x5e, 0xe1, 0xc7, 0x97, 0x8f, 0x93, 0xd3, 0xdd, 0x6f, 0xef, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x03, 0x1a, 0xb5, 0xc1, 0x01, 0x08, 0x00, 0x00,
}

func (m *ChangeAggregatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeAggregatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeAggregatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for iNdEx := len(m.ResolvedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResolvedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ProgressConfig != nil {
		{
			size, err := m.ProgressConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SpanLevelCheckpoint != nil {
		{
			size, err := m.SpanLevelCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.InitialHighWater != nil {
		{
			size, err := m.InitialHighWater.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i -= len(m.Description)
	copy(dAtA[i:], m.Description)
	i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(len(m.Description)))
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Select.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x20
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Feed.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Watches) > 0 {
		for iNdEx := len(m.Watches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Watches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChangeAggregatorSpec_Watch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeAggregatorSpec_Watch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeAggregatorSpec_Watch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *ChangeFrontierSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeFrontierSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeFrontierSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for iNdEx := len(m.ResolvedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResolvedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ProgressConfig != nil {
		{
			size, err := m.ProgressConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SpanLevelCheckpoint != nil {
		{
			size, err := m.SpanLevelCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i -= len(m.Description)
	copy(dAtA[i:], m.Description)
	i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(len(m.Description)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x18
	{
		size, err := m.Feed.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TrackedSpans) > 0 {
		for iNdEx := len(m.TrackedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsChangefeeds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChangefeedProgressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedProgressConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangefeedProgressConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.PerTableProtectedTimestamps {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i--
	if m.PerTableTracking {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintProcessorsChangefeeds(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessorsChangefeeds(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChangeAggregatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Watches) > 0 {
		for _, e := range m.Watches {
			l = e.Size()
			n += 1 + l + sovProcessorsChangefeeds(uint64(l))
		}
	}
	l = m.Feed.Size()
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	n += 1 + sovProcessorsChangefeeds(uint64(m.JobID))
	l = m.Select.Size()
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	l = len(m.Description)
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	if m.InitialHighWater != nil {
		l = m.InitialHighWater.Size()
		n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	}
	if m.SpanLevelCheckpoint != nil {
		l = m.SpanLevelCheckpoint.Size()
		n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	}
	if m.ProgressConfig != nil {
		l = m.ProgressConfig.Size()
		n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	}
	if len(m.ResolvedSpans) > 0 {
		for _, e := range m.ResolvedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsChangefeeds(uint64(l))
		}
	}
	return n
}

func (m *ChangeAggregatorSpec_Watch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	return n
}

func (m *ChangeFrontierSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TrackedSpans) > 0 {
		for _, e := range m.TrackedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsChangefeeds(uint64(l))
		}
	}
	l = m.Feed.Size()
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	n += 1 + sovProcessorsChangefeeds(uint64(m.JobID))
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	l = len(m.Description)
	n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	if m.SpanLevelCheckpoint != nil {
		l = m.SpanLevelCheckpoint.Size()
		n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	}
	if m.ProgressConfig != nil {
		l = m.ProgressConfig.Size()
		n += 1 + l + sovProcessorsChangefeeds(uint64(l))
	}
	if len(m.ResolvedSpans) > 0 {
		for _, e := range m.ResolvedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsChangefeeds(uint64(l))
		}
	}
	return n
}

func (m *ChangefeedProgressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	return n
}

func sovProcessorsChangefeeds(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozProcessorsChangefeeds(x uint64) (n int) {
	return sovProcessorsChangefeeds(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChangeAggregatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsChangefeeds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeAggregatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeAggregatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Watches = append(m.Watches, ChangeAggregatorSpec_Watch{})
			if err := m.Watches[len(m.Watches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Feed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Select", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Select.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialHighWater", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialHighWater == nil {
				m.InitialHighWater = &hlc.Timestamp{}
			}
			if err := m.InitialHighWater.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanLevelCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanLevelCheckpoint == nil {
				m.SpanLevelCheckpoint = &jobspb.TimestampSpansMap{}
			}
			if err := m.SpanLevelCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProgressConfig == nil {
				m.ProgressConfig = &ChangefeedProgressConfig{}
			}
			if err := m.ProgressConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedSpans = append(m.ResolvedSpans, jobspb.ResolvedSpan{})
			if err := m.ResolvedSpans[len(m.ResolvedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsChangefeeds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeAggregatorSpec_Watch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsChangefeeds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Watch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Watch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsChangefeeds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeFrontierSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsChangefeeds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeFrontierSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeFrontierSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackedSpans = append(m.TrackedSpans, roachpb.Span{})
			if err := m.TrackedSpans[len(m.TrackedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Feed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanLevelCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanLevelCheckpoint == nil {
				m.SpanLevelCheckpoint = &jobspb.TimestampSpansMap{}
			}
			if err := m.SpanLevelCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProgressConfig == nil {
				m.ProgressConfig = &ChangefeedProgressConfig{}
			}
			if err := m.ProgressConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedSpans = append(m.ResolvedSpans, jobspb.ResolvedSpan{})
			if err := m.ResolvedSpans[len(m.ResolvedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsChangefeeds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedProgressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsChangefeeds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedProgressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedProgressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTableTracking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PerTableTracking = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTableProtectedTimestamps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PerTableProtectedTimestamps = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsChangefeeds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsChangefeeds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsChangefeeds(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsChangefeeds
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsChangefeeds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsChangefeeds
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessorsChangefeeds
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessorsChangefeeds
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessorsChangefeeds        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsChangefeeds          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessorsChangefeeds = fmt.Errorf("proto: unexpected end of group")
)

