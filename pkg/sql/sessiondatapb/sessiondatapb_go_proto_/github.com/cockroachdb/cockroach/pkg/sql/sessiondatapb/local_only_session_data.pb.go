// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sessiondatapb/local_only_session_data.proto

package sessiondatapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_security_username "github.com/cockroachdb/cockroach/pkg/security/username"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReplicationMode represents the replication={0,1,on,off,database} connection
// parameter in PostgreSQL.
type ReplicationMode int32

const (
	ReplicationMode_REPLICATION_MODE_DISABLED ReplicationMode = 0
	ReplicationMode_REPLICATION_MODE_ENABLED  ReplicationMode = 1
	ReplicationMode_REPLICATION_MODE_DATABASE ReplicationMode = 2
)

var ReplicationMode_name = map[int32]string{
	0: "REPLICATION_MODE_DISABLED",
	1: "REPLICATION_MODE_ENABLED",
	2: "REPLICATION_MODE_DATABASE",
}

var ReplicationMode_value = map[string]int32{
	"REPLICATION_MODE_DISABLED": 0,
	"REPLICATION_MODE_ENABLED":  1,
	"REPLICATION_MODE_DATABASE": 2,
}

func (x ReplicationMode) String() string {
	return proto.EnumName(ReplicationMode_name, int32(x))
}

func (ReplicationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{0}
}

// PlanCacheMode controls the optimizer's decision to use a custom or generic
// query plan.
type PlanCacheMode int32

const (
	// PlanCacheModeForceCustom forces the optimizer to use a custom query plan.
	PlanCacheModeForceCustom PlanCacheMode = 0
	// PlanCacheModeForceCustom forces the optimizer to use a generic query plan.
	PlanCacheModeForceGeneric PlanCacheMode = 1
	// PlanCacheModeAuto allows the optimizer to automatically choose between a
	// custom and generic query plan.
	PlanCacheModeAuto PlanCacheMode = 2
)

var PlanCacheMode_name = map[int32]string{
	0: "force_custom_plan",
	1: "force_generic_plan",
	2: "auto",
}

var PlanCacheMode_value = map[string]int32{
	"force_custom_plan":  0,
	"force_generic_plan": 1,
	"auto":               2,
}

func (PlanCacheMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{1}
}

// LocalOnlySessionData contains the serializable components of session
// parameters that only influence execution on the gateway nodes.
type LocalOnlySessionData struct {
	// SaveTablesPrefix indicates that a table should be created with the
	// given prefix for the output of each subexpression in a query. If
	// SaveTablesPrefix is empty, no tables are created.
	SaveTablesPrefix string `protobuf:"bytes,1,opt,name=save_tables_prefix,json=saveTablesPrefix,proto3" json:"save_tables_prefix,omitempty"`
	// OptimizerFKCascadesLimit is the maximum number of cascading operations that
	// are run for a single query.
	OptimizerFKCascadesLimit int64 `protobuf:"varint,2,opt,name=optimizer_fk_cascades_limit,json=optimizerFkCascadesLimit,proto3" json:"optimizer_fk_cascades_limit,omitempty"`
	// StmtTimeout is the duration a query is permitted to run before it is
	// canceled by the session. If set to 0, there is no timeout.
	StmtTimeout time.Duration `protobuf:"varint,3,opt,name=stmt_timeout,json=stmtTimeout,proto3,casttype=time.Duration" json:"stmt_timeout,omitempty"`
	// IdleInSessionTimeout is the duration a session is permitted to idle before
	// the session is canceled. If set to 0, there is no timeout.
	IdleInSessionTimeout time.Duration `protobuf:"varint,4,opt,name=idle_in_session_timeout,json=idleInSessionTimeout,proto3,casttype=time.Duration" json:"idle_in_session_timeout,omitempty"`
	// IdleInTransactionSessionTimeout is the duration a session is permitted to
	// idle in a transaction before the session is canceled.
	// If set to 0, there is no timeout.
	IdleInTransactionSessionTimeout time.Duration `protobuf:"varint,5,opt,name=idle_in_transaction_session_timeout,json=idleInTransactionSessionTimeout,proto3,casttype=time.Duration" json:"idle_in_transaction_session_timeout,omitempty"`
	// NoticeDisplaySeverity indicates the level of Severity to send notices for the given
	// session. This should ideally be of type pgnotice.DisplaySeverity, but cannot be done
	// due to a circular dependency.
	NoticeDisplaySeverity uint32 `protobuf:"varint,6,opt,name=notice_display_severity,json=noticeDisplaySeverity,proto3" json:"notice_display_severity,omitempty"`
	// ReorderJoinsLimit indicates the number of joins at which the optimizer should
	// stop attempting to reorder.
	ReorderJoinsLimit int64 `protobuf:"varint,7,opt,name=reorder_joins_limit,json=reorderJoinsLimit,proto3" json:"reorder_joins_limit,omitempty"`
	// DefaultTxnPriority indicates the default priority of newly created
	// transactions.
	// NOTE: we'd prefer to use tree.UserPriority here, but doing so would
	// introduce a package dependency cycle.
	DefaultTxnPriority int64 `protobuf:"varint,8,opt,name=default_txn_priority,json=defaultTxnPriority,proto3" json:"default_txn_priority,omitempty"`
	// DefaultTxnReadOnly indicates the default read-only status of newly
	// created transactions.
	DefaultTxnReadOnly bool `protobuf:"varint,9,opt,name=default_txn_read_only,json=defaultTxnReadOnly,proto3" json:"default_txn_read_only,omitempty"`
	// DefaultTxnUseFollowerReads indicates whether transactions should be
	// created by default using an AS OF SYSTEM TIME clause far enough in the
	// past to facilitate reads against followers. If true, transactions will
	// also default to being read-only.
	DefaultTxnUseFollowerReads bool `protobuf:"varint,10,opt,name=default_txn_use_follower_reads,json=defaultTxnUseFollowerReads,proto3" json:"default_txn_use_follower_reads,omitempty"`
	// PartiallyDistributedPlansDisabled indicates whether the partially
	// distributed plans produced by distSQLSpecExecFactory are disabled. It
	// should be set to 'true' only in tests that verify that the old and the
	// new factories return exactly the same physical plans.
	// TODO(yuzefovich): remove it when deleting old sql.execFactory.
	PartiallyDistributedPlansDisabled bool `protobuf:"varint,11,opt,name=partially_distributed_plans_disabled,json=partiallyDistributedPlansDisabled,proto3" json:"partially_distributed_plans_disabled,omitempty"`
	// OptimizerUseHistograms indicates whether we should use histograms for
	// cardinality estimation in the optimizer.
	OptimizerUseHistograms bool `protobuf:"varint,12,opt,name=optimizer_use_histograms,json=optimizerUseHistograms,proto3" json:"optimizer_use_histograms,omitempty"`
	// OptimizerUseMultiColStats indicates whether we should use multi-column
	// statistics for cardinality estimation in the optimizer.
	OptimizerUseMultiColStats bool `protobuf:"varint,13,opt,name=optimizer_use_multi_col_stats,json=optimizerUseMultiColStats,proto3" json:"optimizer_use_multi_col_stats,omitempty"`
	// LocalityOptimizedSearch indicates that the optimizer will try to plan scans
	// and lookup joins in which local nodes (i.e., nodes in the gateway region)
	// are searched for matching rows before remote nodes, in the hope that the
	// execution engine can avoid visiting remote nodes.
	LocalityOptimizedSearch bool `protobuf:"varint,14,opt,name=locality_optimized_search,json=localityOptimizedSearch,proto3" json:"locality_optimized_search,omitempty"`
	// SafeUpdates causes errors when the client
	// sends syntax that may have unwanted side effects.
	SafeUpdates bool `protobuf:"varint,15,opt,name=safe_updates,json=safeUpdates,proto3" json:"safe_updates,omitempty"`
	// PreferLookupJoinsForFKs causes foreign key operations to prefer lookup
	// joins.
	PreferLookupJoinsForFKs bool `protobuf:"varint,16,opt,name=prefer_lookup_joins_for_fks,json=preferLookupJoinsForFks,proto3" json:"prefer_lookup_joins_for_fks,omitempty"`
	// ZigzagJoinEnabled indicates whether the optimizer should try and plan a
	// zigzag join.
	ZigzagJoinEnabled bool `protobuf:"varint,17,opt,name=zigzag_join_enabled,json=zigzagJoinEnabled,proto3" json:"zigzag_join_enabled,omitempty"`
	// RequireExplicitPrimaryKeys indicates whether CREATE TABLE statements should
	// error out if no primary key is provided.
	RequireExplicitPrimaryKeys bool `protobuf:"varint,18,opt,name=require_explicit_primary_keys,json=requireExplicitPrimaryKeys,proto3" json:"require_explicit_primary_keys,omitempty"`
	// ForceSavepointRestart overrides the default SAVEPOINT behavior
	// for compatibility with certain ORMs. When this flag is set,
	// the savepoint name will no longer be compared against the magic
	// identifier `cockroach_restart` in order use a restartable
	// transaction.
	ForceSavepointRestart bool `protobuf:"varint,19,opt,name=force_savepoint_restart,json=forceSavepointRestart,proto3" json:"force_savepoint_restart,omitempty"`
	// AllowPrepareAsOptPlan must be set to allow use of
	//   PREPARE name AS OPT PLAN '...'
	AllowPrepareAsOptPlan bool `protobuf:"varint,20,opt,name=allow_prepare_as_opt_plan,json=allowPrepareAsOptPlan,proto3" json:"allow_prepare_as_opt_plan,omitempty"`
	// TempTablesEnabled indicates whether temporary tables can be created or not.
	TempTablesEnabled bool `protobuf:"varint,21,opt,name=temp_tables_enabled,json=tempTablesEnabled,proto3" json:"temp_tables_enabled,omitempty"`
	// ImplicitPartitioningEnabled indicates whether implicit column partitioning
	// can be created.
	ImplicitColumnPartitioningEnabled bool `protobuf:"varint,22,opt,name=implicit_column_partitioning_enabled,json=implicitColumnPartitioningEnabled,proto3" json:"implicit_column_partitioning_enabled,omitempty"`
	// OverrideMultiRegionZoneConfigEnabled indicates whether zone configurations can be
	// modified for multi-region databases and tables/indexes/partitions.
	OverrideMultiRegionZoneConfigEnabled bool `protobuf:"varint,24,opt,name=override_multi_region_zone_config_enabled,json=overrideMultiRegionZoneConfigEnabled,proto3" json:"override_multi_region_zone_config_enabled,omitempty"`
	// DisallowFullTableScans indicates whether queries that plan full table scans
	// should be rejected.
	DisallowFullTableScans bool `protobuf:"varint,26,opt,name=disallow_full_table_scans,json=disallowFullTableScans,proto3" json:"disallow_full_table_scans,omitempty"`
	// ImplicitSelectForUpdate is true if FOR UPDATE locking may be used during
	// the row-fetch phase of mutation statements.
	ImplicitSelectForUpdate bool `protobuf:"varint,27,opt,name=implicit_select_for_update,json=implicitSelectForUpdate,proto3" json:"implicit_select_for_update,omitempty"`
	// InsertFastPath is true if the fast path for insert (with VALUES input) may
	// be used.
	InsertFastPath bool `protobuf:"varint,28,opt,name=insert_fast_path,json=insertFastPath,proto3" json:"insert_fast_path,omitempty"`
	// AlterColumnTypeGeneralEnabled is true if ALTER TABLE ... ALTER COLUMN ...
	// TYPE x may be used for general conversions requiring online schema change/
	AlterColumnTypeGeneralEnabled bool `protobuf:"varint,29,opt,name=alter_column_type_general_enabled,json=alterColumnTypeGeneralEnabled,proto3" json:"alter_column_type_general_enabled,omitempty"`
	// SynchronousCommit is a dummy setting for the synchronous_commit var.
	SynchronousCommit bool `protobuf:"varint,30,opt,name=synchronous_commit,json=synchronousCommit,proto3" json:"synchronous_commit,omitempty"`
	// EnableSeqScan is a dummy setting for the enable_seqscan var.
	EnableSeqScan bool `protobuf:"varint,31,opt,name=enable_seq_scan,json=enableSeqScan,proto3" json:"enable_seq_scan,omitempty"`
	// EnableUniqueWithoutIndexConstraints indicates whether creating unique
	// constraints without an index is allowed.
	// TODO(rytaft): remove this once unique without index constraints are fully
	// supported.
	EnableUniqueWithoutIndexConstraints bool `protobuf:"varint,33,opt,name=enable_unique_without_index_constraints,json=enableUniqueWithoutIndexConstraints,proto3" json:"enable_unique_without_index_constraints,omitempty"`
	// StubCatalogTablesEnabled allows queries against virtual
	// tables that are not yet implemented.
	StubCatalogTablesEnabled bool `protobuf:"varint,34,opt,name=stub_catalog_tables_enabled,json=stubCatalogTablesEnabled,proto3" json:"stub_catalog_tables_enabled,omitempty"`
	// ExperimentalComputedColumnRewrites allows automatic rewriting of computed
	// column expressions in CREATE TABLE and ALTER TABLE statements. See the
	// experimentalComputedColumnRewrites cluster setting for a description of the
	// format.
	ExperimentalComputedColumnRewrites string `protobuf:"bytes,35,opt,name=experimental_computed_column_rewrites,json=experimentalComputedColumnRewrites,proto3" json:"experimental_computed_column_rewrites,omitempty"`
	// EnableStreamReplication indicates whether to allow setting up a replication
	// stream.
	EnableStreamReplication bool `protobuf:"varint,37,opt,name=enable_stream_replication,json=enableStreamReplication,proto3" json:"enable_stream_replication,omitempty"`
	// ResultsBufferSize specifies the size at which the pgwire results buffer
	// will self-flush.
	ResultsBufferSize int64 `protobuf:"varint,38,opt,name=results_buffer_size,json=resultsBufferSize,proto3" json:"results_buffer_size,omitempty"`
	// PropagateInputOrdering indicates that when planning a subquery or CTE, the
	// inner ordering should be propagated to the outer scope if the outer scope
	// is unordered. PropagateInputOrdering is currently experimental.
	PropagateInputOrdering bool `protobuf:"varint,39,opt,name=propagate_input_ordering,json=propagateInputOrdering,proto3" json:"propagate_input_ordering,omitempty"`
	// ExperimentalDistSQLPlanningMode indicates whether the experimental
	// DistSQL planning driven by the optimizer is enabled.
	ExperimentalDistSQLPlanningMode ExperimentalDistSQLPlanningMode `protobuf:"varint,40,opt,name=experimental_distsql_planning_mode,json=experimentalDistsqlPlanningMode,proto3,casttype=ExperimentalDistSQLPlanningMode" json:"experimental_distsql_planning_mode,omitempty"`
	// DistSQLMode indicates whether to run queries using the distributed
	// execution engine.
	DistSQLMode DistSQLExecMode `protobuf:"varint,41,opt,name=dist_sql_mode,json=distSqlMode,proto3,casttype=DistSQLExecMode" json:"dist_sql_mode,omitempty"`
	// SerialNormalizationMode indicates how to handle the SERIAL pseudo-type.
	SerialNormalizationMode SerialNormalizationMode `protobuf:"varint,42,opt,name=serial_normalization_mode,json=serialNormalizationMode,proto3,casttype=SerialNormalizationMode" json:"serial_normalization_mode,omitempty"`
	// NewSchemaChangerMode indicates whether to use the new schema changer.
	NewSchemaChangerMode NewSchemaChangerMode `protobuf:"varint,43,opt,name=new_schema_changer_mode,json=newSchemaChangerMode,proto3,casttype=NewSchemaChangerMode" json:"new_schema_changer_mode,omitempty"`
	// SequenceCache stores sequence values which have been cached using the
	// CACHE sequence option.
	SequenceCache SequenceCache `protobuf:"bytes,44,rep,name=sequence_cache,json=sequenceCache,proto3,casttype=SequenceCache" json:"sequence_cache,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// PlacementEnabled indicates whether PLACEMENT can be used or not.
	PlacementEnabled bool `protobuf:"varint,45,opt,name=placement_enabled,json=placementEnabled,proto3" json:"placement_enabled,omitempty"`
	// SessionUserProto is the name of the user which has performed a SET ROLE
	// command. In other words, it is the name of the user which originally
	// established the connection before SET ROLE was first performed.
	// This is only populated when SET ROLE is used, otherwise the session_user
	// is the same as the UserProto in SessionData.
	// Postgres allows the SessionUser to be changed with SET SESSION AUTHORIZATION
	// but CockroachDB doesn't allow that at the time of this writing.
	SessionUserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,46,opt,name=session_user_proto,json=sessionUserProto,proto3,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"session_user_proto,omitempty"`
	// TxnRowsWrittenLog is the threshold for the number of rows written by a SQL
	// transaction which - once exceeded - will trigger a logging event to SQL_PERF
	// (or SQL_INTERNAL_PERF for internal transactions); 0 means disabled.
	TxnRowsWrittenLog int64 `protobuf:"varint,47,opt,name=txn_rows_written_log,json=txnRowsWrittenLog,proto3" json:"txn_rows_written_log,omitempty"`
	// TxnRowsWrittenErr is the limit for the number of rows written by a SQL
	// transaction which - once exceeded - will fail the transaction (or will
	// trigger a logging event to SQL_INTERNAL_PERF for internal transactions); 0
	// means disabled.
	TxnRowsWrittenErr int64 `protobuf:"varint,48,opt,name=txn_rows_written_err,json=txnRowsWrittenErr,proto3" json:"txn_rows_written_err,omitempty"`
	// TxnRowsReadLog is the threshold for the number of rows read by a SQL
	// transaction which - once exceeded - will trigger a logging event to SQL_PERF
	// (or SQL_INTERNAL_PERF for internal transactions); 0 means disabled.
	TxnRowsReadLog int64 `protobuf:"varint,49,opt,name=txn_rows_read_log,json=txnRowsReadLog,proto3" json:"txn_rows_read_log,omitempty"`
	// TxnRowsReadErr is the limit for the number of rows read by a SQL
	// transaction which - once exceeded - will fail the transaction (or will
	// trigger a logging event to SQL_INTERNAL_PERF for internal transactions); 0
	// means disabled.
	TxnRowsReadErr int64 `protobuf:"varint,50,opt,name=txn_rows_read_err,json=txnRowsReadErr,proto3" json:"txn_rows_read_err,omitempty"`
	// AutoRehomingEnabled indicates whether or not REGIONAL BY ROW tables should
	// have a rehoming ON UPDATE clause added to them.
	AutoRehomingEnabled bool `protobuf:"varint,51,opt,name=auto_rehoming_enabled,json=autoRehomingEnabled,proto3" json:"auto_rehoming_enabled,omitempty"`
	// IsSuperuser returns whether the user is a "superuser", which is defined
	// to be a user with an admin role.
	IsSuperuser bool `protobuf:"varint,52,opt,name=is_superuser,json=isSuperuser,proto3" json:"is_superuser,omitempty"`
	// LargeFullScanRows is the estimated row count at which a full scan is
	// considered large, and worthy of logging and/or disabling depending on other
	// settings.
	LargeFullScanRows float64 `protobuf:"fixed64,53,opt,name=large_full_scan_rows,json=largeFullScanRows,proto3" json:"large_full_scan_rows,omitempty"`
	// InjectRetryErrorsEnabled causes statements inside an explicit
	// transaction to return a transaction retry error. It is intended for
	// developers to test their app's retry logic.
	//
	// Note that this session variable is **not** propagated to the internal
	// executors - use InternalExecutorOverride for that.
	InjectRetryErrorsEnabled bool `protobuf:"varint,54,opt,name=inject_retry_errors_enabled,json=injectRetryErrorsEnabled,proto3" json:"inject_retry_errors_enabled,omitempty"`
	// NullOrderedLast controls whether NULL is ordered last. We default to
	// NULLS FIRST for ascending order by default, whereas postgres defaults
	// to NULLS LAST.
	NullOrderedLast bool `protobuf:"varint,55,opt,name=null_ordered_last,json=nullOrderedLast,proto3" json:"null_ordered_last,omitempty"`
	// DisablePlanGists indicates whether we should disable automatic gists.
	DisablePlanGists bool `protobuf:"varint,56,opt,name=disable_plan_gists,json=disablePlanGists,proto3" json:"disable_plan_gists,omitempty"`
	// CustomOptions contains a map of all custom session settings.
	// These session variables have at least one period in their name.
	CustomOptions map[string]string `protobuf:"bytes,57,rep,name=custom_options,json=customOptions,proto3" json:"custom_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// IndexRecommendationsEnabled controls whether or not we display index
	// recommendations below the plan in EXPLAIN.
	IndexRecommendationsEnabled bool `protobuf:"varint,58,opt,name=index_recommendations_enabled,json=indexRecommendationsEnabled,proto3" json:"index_recommendations_enabled,omitempty"`
	// AvoidBuffering indicates that the returned data should not be
	// buffered by conn executor.  This is currently used by replication primitives
	// to ensure the data is flushed to the consumer immediately.
	//
	// Does not apply to the InternalExecutor.
	AvoidBuffering bool `protobuf:"varint,59,opt,name=avoid_buffering,json=avoidBuffering,proto3" json:"avoid_buffering,omitempty"`
	// CheckFunctionBodies indicates whether functions are validated during
	// creation.
	CheckFunctionBodies bool `protobuf:"varint,60,opt,name=check_function_bodies,json=checkFunctionBodies,proto3" json:"check_function_bodies,omitempty"`
	// CostScansWithDefaultColSize is true when the optimizer should cost scans
	// and joins using the same default number of bytes per column instead of
	// column sizes from the AvgSize table statistic.
	CostScansWithDefaultColSize bool `protobuf:"varint,61,opt,name=cost_scans_with_default_col_size,json=costScansWithDefaultColSize,proto3" json:"cost_scans_with_default_col_size,omitempty"`
	// DefaultTxnQualityOfService indicates the default QoSLevel/WorkPriority of
	// newly created transactions.
	DefaultTxnQualityOfService QoSLevel `protobuf:"varint,62,opt,name=default_txn_quality_of_service,json=defaultTxnQualityOfService,proto3,casttype=QoSLevel" json:"default_txn_quality_of_service,omitempty"`
	// OptSplitScanLimit indicates the maximum number of UNION ALL statements a
	// Scan may be split into during query optimization to avoid a sort.
	OptSplitScanLimit int32 `protobuf:"varint,63,opt,name=opt_split_scan_limit,json=optSplitScanLimit,proto3" json:"opt_split_scan_limit,omitempty"`
	// EnableSuperRegions is true when super region functionality is enabled.
	EnableSuperRegions bool `protobuf:"varint,64,opt,name=enable_super_regions,json=enableSuperRegions,proto3" json:"enable_super_regions,omitempty"`
	// OverrideAlterPrimaryRegionInSuperRegion is true when the user is allowed
	// to modify a primary region that is part of a super region.
	OverrideAlterPrimaryRegionInSuperRegion bool `protobuf:"varint,65,opt,name=override_alter_primary_region_in_super_region,json=overrideAlterPrimaryRegionInSuperRegion,proto3" json:"override_alter_primary_region_in_super_region,omitempty"`
	// EnableImplicitTransactionForBatchStatements configures the handling of
	// multiple statements in a single query. If enabled, then an implicit
	// transaction is used when multiple statements are sent in a single query.
	// Setting this to false is a divergence from the pgwire protocol, but
	// matches the behavior of CockroachDB v21.2 and earlier.
	EnableImplicitTransactionForBatchStatements bool `protobuf:"varint,66,opt,name=enable_implicit_transaction_for_batch_statements,json=enableImplicitTransactionForBatchStatements,proto3" json:"enable_implicit_transaction_for_batch_statements,omitempty"`
	// ExpectAndIgnoreNotVisibleColumnsInCopy changes behaviour for COPY t FROM ...
	// (with no column name specifiers) to expect and ignore not visible column
	// fields.
	ExpectAndIgnoreNotVisibleColumnsInCopy bool `protobuf:"varint,67,opt,name=expect_and_ignore_not_visible_columns_in_copy,json=expectAndIgnoreNotVisibleColumnsInCopy,proto3" json:"expect_and_ignore_not_visible_columns_in_copy,omitempty"`
	// MultipleModificationsOfTable allows statements containing multiple INSERT
	// ON CONFLICT, UPSERT, UPDATE, or DELETE subqueries modifying the same table,
	// at the risk of data corruption if the same row is modified multiple times.
	MultipleModificationsOfTable bool `protobuf:"varint,68,opt,name=multiple_modifications_of_table,json=multipleModificationsOfTable,proto3" json:"multiple_modifications_of_table,omitempty"`
	// ShowPrimaryKeyConstraintOnNotVisibleColumns controls whether SHOW
	// CONSTRAINTS and pg_catalog.pg_constraint will include primary key
	// constraints that only include hidden columns.
	ShowPrimaryKeyConstraintOnNotVisibleColumns bool `protobuf:"varint,69,opt,name=show_primary_key_constraint_on_not_visible_columns,json=showPrimaryKeyConstraintOnNotVisibleColumns,proto3" json:"show_primary_key_constraint_on_not_visible_columns,omitempty"`
	// TestingOptimizerRandomSeed is non-zero when we are testing the optimizer by
	// randomly perturbing costs or disabling rules. This will initialize a rng
	// seeded to the given integer. This should only be used in test scenarios and
	// is very much a non-production setting.
	TestingOptimizerRandomSeed int64 `protobuf:"varint,70,opt,name=testing_optimizer_random_seed,json=testingOptimizerRandomSeed,proto3" json:"testing_optimizer_random_seed,omitempty"`
	// UnconstrainedNonCoveringIndexScanEnabled controls whether unconstrained
	// non-covering index scan access paths are explored by the optimizer.
	UnconstrainedNonCoveringIndexScanEnabled bool `protobuf:"varint,71,opt,name=unconstrained_non_covering_index_scan_enabled,json=unconstrainedNonCoveringIndexScanEnabled,proto3" json:"unconstrained_non_covering_index_scan_enabled,omitempty"`
	// TestingOptimizerCostPerturbation is non-zero when the coster should
	// randomly perturb costs to produce a non-optimal query plan. This should
	// only be used in test scenarios and is very much a non-production setting.
	TestingOptimizerCostPerturbation float64 `protobuf:"fixed64,72,opt,name=testing_optimizer_cost_perturbation,json=testingOptimizerCostPerturbation,proto3" json:"testing_optimizer_cost_perturbation,omitempty"`
	// TestingOptimizerDisableRuleProbability is non-zero when the optimizer
	// should randomly disable every non-essential transformation rule with the
	// given probability. This should only be used in test scenarios and is very
	// much a non-production setting.
	TestingOptimizerDisableRuleProbability float64 `protobuf:"fixed64,73,opt,name=testing_optimizer_disable_rule_probability,json=testingOptimizerDisableRuleProbability,proto3" json:"testing_optimizer_disable_rule_probability,omitempty"`
	// OptimizerUseNotVisibleIndexes indicates whether the optimizer can still
	// choose to use visible indexes for query plans.
	OptimizerUseNotVisibleIndexes bool `protobuf:"varint,74,opt,name=optimizer_use_not_visible_indexes,json=optimizerUseNotVisibleIndexes,proto3" json:"optimizer_use_not_visible_indexes,omitempty"`
	// CopyFastPathEnabled controls whether the optimized copy mode is enabled.
	CopyFastPathEnabled bool `protobuf:"varint,75,opt,name=copy_fast_path_enabled,json=copyFastPathEnabled,proto3" json:"copy_fast_path_enabled,omitempty"`
	// disable_hoist_projection_in_join_limitation disables the restrictions
	// placed on projection hoisting during query planning in the optimizer.
	DisableHoistProjectionInJoinLimitation bool `protobuf:"varint,76,opt,name=disable_hoist_projection_in_join_limitation,json=disableHoistProjectionInJoinLimitation,proto3" json:"disable_hoist_projection_in_join_limitation,omitempty"`
	// CopyFromAtomicEnabled controls whether implicit txn copy from operations
	// are atomic or segmented.
	CopyFromAtomicEnabled bool `protobuf:"varint,77,opt,name=copy_from_atomic_enabled,json=copyFromAtomicEnabled,proto3" json:"copy_from_atomic_enabled,omitempty"`
	// EnforceHomeRegion, when true, causes queries which scan rows from multiple
	// regions, or which scan rows from a single home region, but initiated from
	// a gateway region which differs from that home region, to error out.
	EnforceHomeRegion bool `protobuf:"varint,78,opt,name=enforce_home_region,json=enforceHomeRegion,proto3" json:"enforce_home_region,omitempty"`
	// OptimizerUseForecasts indicates whether we should use statistics forecasts
	// for cardinality estimation in the optimizer.
	OptimizerUseForecasts bool `protobuf:"varint,79,opt,name=optimizer_use_forecasts,json=optimizerUseForecasts,proto3" json:"optimizer_use_forecasts,omitempty"`
	// VariableInequalityLookupJoinEnabled indicates whether the optimizer should
	// be allowed to consider lookup joins with inequality conditions, in
	// addition to the other restrictions on when they are planned.
	VariableInequalityLookupJoinEnabled bool `protobuf:"varint,80,opt,name=variable_inequality_lookup_join_enabled,json=variableInequalityLookupJoinEnabled,proto3" json:"variable_inequality_lookup_join_enabled,omitempty"`
	// TransactionSessionTimeout is the duration a transaction is permitted to
	// run before the transaction is canceled. If set to 0, there is no timeout.
	TransactionTimeout time.Duration `protobuf:"varint,81,opt,name=transaction_timeout,json=transactionTimeout,proto3,casttype=time.Duration" json:"transaction_timeout,omitempty"`
	// SystemIdentityProto is the original name of the client presented to pgwire
	// before it was mapped to a SQL identifier.
	SystemIdentityProto string `protobuf:"bytes,82,opt,name=system_identity_proto,json=systemIdentityProto,proto3" json:"system_identity_proto,omitempty"`
	// DescriptorValidationMode indicates whether to validate the descriptors at
	// read and write time, at read time only, or never.
	DescriptorValidationMode DescriptorValidationMode `protobuf:"varint,83,opt,name=descriptor_validation_mode,json=descriptorValidationMode,proto3,casttype=DescriptorValidationMode" json:"descriptor_validation_mode,omitempty"`
	// ExperimentalHashGroupJoinEnabled indicates whether the physical planner
	// will attempt to convert a hash join followed by a hash aggregator into a
	// single hash group-join operation. At the moment, there is no optimizer
	// support for this, so some things can be incorrect (e.g. EXPLAIN plans).
	ExperimentalHashGroupJoinEnabled bool `protobuf:"varint,84,opt,name=experimental_hash_group_join_enabled,json=experimentalHashGroupJoinEnabled,proto3" json:"experimental_hash_group_join_enabled,omitempty"`
	// AllowOrdinalColumnReferences indicates whether the deprecated ordinal
	// column reference syntax (e.g., `SELECT @1 FROM t`) is allowed.
	AllowOrdinalColumnReferences bool `protobuf:"varint,85,opt,name=allow_ordinal_column_references,json=allowOrdinalColumnReferences,proto3" json:"allow_ordinal_column_references,omitempty"`
	// OptimizerUseImprovedDisjunctionStats, when true, indicates that the
	// optimizer should use improved statistics calculations for disjunctive
	// filters.
	OptimizerUseImprovedDisjunctionStats bool `protobuf:"varint,86,opt,name=optimizer_use_improved_disjunction_stats,json=optimizerUseImprovedDisjunctionStats,proto3" json:"optimizer_use_improved_disjunction_stats,omitempty"`
	// OptimizerUseLimitOrderingForStreamingGroupBy enables the exploration rule
	// which optimizes 'SELECT ... GROUP BY ... ORDER BY ... LIMIT n' queries.
	// The rule uses the required ordering in the limit expression to inform an
	// interesting ordering to require from the input to the group-by expression.
	// This can potentially eliminate a top-k operation.
	OptimizerUseLimitOrderingForStreamingGroupBy bool `protobuf:"varint,88,opt,name=optimizer_use_limit_ordering_for_streaming_group_by,json=optimizerUseLimitOrderingForStreamingGroupBy,proto3" json:"optimizer_use_limit_ordering_for_streaming_group_by,omitempty"`
	// CopyFromRetriesEnabled controls whether retries should be internally
	// attempted for retriable errors.
	CopyFromRetriesEnabled bool `protobuf:"varint,89,opt,name=copy_from_retries_enabled,json=copyFromRetriesEnabled,proto3" json:"copy_from_retries_enabled,omitempty"`
	// DeclareCursorStatementTimeoutEnabled controls whether statement timeouts
	// apply during DECLARE CURSOR.
	DeclareCursorStatementTimeoutEnabled bool `protobuf:"varint,90,opt,name=declare_cursor_statement_timeout_enabled,json=declareCursorStatementTimeoutEnabled,proto3" json:"declare_cursor_statement_timeout_enabled,omitempty"`
	// OptimizerUseImprovedSplitDisjunctionForJoins enables the optimizer to split
	// disjunctions (OR expressions) in more cases in join conditions by building a
	// UNION of two join expressions. If this setting is true, all disjunctions in
	// inner, semi, and anti joins will be split. If false, only disjunctions
	// potentially containing an equijoin condition will be split.
	OptimizerUseImprovedSplitDisjunctionForJoins bool `protobuf:"varint,91,opt,name=optimizer_use_improved_split_disjunction_for_joins,json=optimizerUseImprovedSplitDisjunctionForJoins,proto3" json:"optimizer_use_improved_split_disjunction_for_joins,omitempty"`
	// InjectRetryErrorsOnCommitEnabled causes statements inside an explicit
	// transaction to return a transaction retry error just before transcation commit.
	// It is intended for developers to test their app's retry logic.
	InjectRetryErrorsOnCommitEnabled bool `protobuf:"varint,92,opt,name=inject_retry_errors_on_commit_enabled,json=injectRetryErrorsOnCommitEnabled,proto3" json:"inject_retry_errors_on_commit_enabled,omitempty"`
	// OptimizerAlwaysUseHistograms, when true, ensures that the optimizer
	// always uses histograms to calculate statistics if available.
	OptimizerAlwaysUseHistograms bool `protobuf:"varint,94,opt,name=optimizer_always_use_histograms,json=optimizerAlwaysUseHistograms,proto3" json:"optimizer_always_use_histograms,omitempty"`
	// EnableCreateStatsUsingExtremes, when true, allows the use of CREATE
	// STATISTICS .. USING EXTREMES.
	EnableCreateStatsUsingExtremes bool `protobuf:"varint,95,opt,name=enable_create_stats_using_extremes,json=enableCreateStatsUsingExtremes,proto3" json:"enable_create_stats_using_extremes,omitempty"`
	// AllowRoleMembershipsToChangeDuringTransaction, when true, means that
	// operations which consult the role membership cache do not retain their
	// lease on that version of the cache throughout the transaction. The
	// consequence of this is that the transaction may not experience a singular
	// view of role membership, and it may be able to commit after the revocation
	// of a role membership which the transaction relied on has successfully been
	// committed and acknowledged to the user.
	AllowRoleMembershipsToChangeDuringTransaction bool `protobuf:"varint,96,opt,name=allow_role_memberships_to_change_during_transaction,json=allowRoleMembershipsToChangeDuringTransaction,proto3" json:"allow_role_memberships_to_change_during_transaction,omitempty"`
	// PreparedStatementsCacheSize, when not equal to 0, causes the LRU prepared
	// statements in a session to be automatically deallocated when total prepared
	// statement memory usage for that session is more than the cache size.
	// Execution of these deallocated prepared statements will fail until they are
	// prepared again.
	PreparedStatementsCacheSize int64 `protobuf:"varint,97,opt,name=prepared_statements_cache_size,json=preparedStatementsCacheSize,proto3" json:"prepared_statements_cache_size,omitempty"`
	// MultipleActivePortalEnabled determines if the pgwire portal execution
	// for certain queries can be paused. If true, portals with read-only SELECT
	// query without sub/post queries can be executed in interleaving manner, but
	// with a local execution plan.
	MultipleActivePortalsEnabled bool `protobuf:"varint,100,opt,name=multiple_active_portals_enabled,json=multipleActivePortalsEnabled,proto3" json:"multiple_active_portals_enabled,omitempty"`
	// UnboundedParallelScans, when true, indicates that the TableReader DistSQL
	// processors should parallelize scans across ranges. Note that the
	// parallelization will still be disabled for queries with LIMITs, and it can
	// lead to increased likelihood of OOMs.
	UnboundedParallelScans bool `protobuf:"varint,101,opt,name=unbounded_parallel_scans,json=unboundedParallelScans,proto3" json:"unbounded_parallel_scans,omitempty"`
	// OptimizerHoistUncorrelatedEqualitySubqueries, when true, causes the
	// optimizer to hoist uncorrelated subqueries that are part of an equality
	// expression with a column reference, which can produce more efficient query
	// plans.
	OptimizerHoistUncorrelatedEqualitySubqueries bool `protobuf:"varint,102,opt,name=optimizer_hoist_uncorrelated_equality_subqueries,json=optimizerHoistUncorrelatedEqualitySubqueries,proto3" json:"optimizer_hoist_uncorrelated_equality_subqueries,omitempty"`
	// TestingOptimizerInjectPanics indicates whether random panics are injected
	// during optimization. The goal of this setting is to flush out cases where
	// panics used for error-propagation are uncaught.
	TestingOptimizerInjectPanics bool `protobuf:"varint,103,opt,name=testing_optimizer_inject_panics,json=testingOptimizerInjectPanics,proto3" json:"testing_optimizer_inject_panics,omitempty"`
	// OptimizerUseImprovedComputedColumnFiltersDerivation, when true, causes the
	// optimizer to derive filters on computed columns in more cases. Previously,
	// filters could only be derived when the expression defining the computed
	// column involved a single column and that column was equated with a single
	// constant value in a WHERE clause filter.
	OptimizerUseImprovedComputedColumnFiltersDerivation bool `protobuf:"varint,104,opt,name=optimizer_use_improved_computed_column_filters_derivation,json=optimizerUseImprovedComputedColumnFiltersDerivation,proto3" json:"optimizer_use_improved_computed_column_filters_derivation,omitempty"`
	// DefaultTxnIsolationLevel indicates the default isolation level of newly
	// created transactions.
	// NOTE: we'd prefer to use tree.IsolationLevel here, but doing so would
	// introduce a package dependency cycle.
	DefaultTxnIsolationLevel int64 `protobuf:"varint,105,opt,name=default_txn_isolation_level,json=defaultTxnIsolationLevel,proto3" json:"default_txn_isolation_level,omitempty"`
	// ReplicationMode represents the replication parameter passed in during
	// connection time.
	ReplicationMode ReplicationMode `protobuf:"varint,106,opt,name=replication_mode,json=replicationMode,proto3,enum=cockroach.sql.sessiondatapb.ReplicationMode" json:"replication_mode,omitempty"`
	// OptimizerUseImprovedJoinElimination, when true, allows the optimizer to
	// eliminate joins in more cases by remapping columns from the eliminated
	// input of the join to equivalent columns from the preserved input.
	OptimizerUseImprovedJoinElimination bool `protobuf:"varint,107,opt,name=optimizer_use_improved_join_elimination,json=optimizerUseImprovedJoinElimination,proto3" json:"optimizer_use_improved_join_elimination,omitempty"`
	// ImplicitFKLockingForSerializable is true if FOR SHARE locking may be used
	// while checking the referenced table during an insert or update to a table
	// with a foreign key under serializable isolation. (Under weaker isolation
	// levels foreign key checks of the parent table always use FOR SHARE
	// locking.)
	ImplicitFKLockingForSerializable bool `protobuf:"varint,108,opt,name=implicit_fk_locking_for_serializable,json=implicitFkLockingForSerializable,proto3" json:"implicit_fk_locking_for_serializable,omitempty"`
	// DurableLockingForSerializable is true if we should use durable locking for
	// SELECT FOR UPDATE statements, SELECT FOR SHARE statements, and constraint
	// checks under serializable isolation. (Serializable isolation does not
	// require locking for correctness, so by default we use best-effort locks for
	// better performance.) Weaker isolation levels always use durable locking.
	DurableLockingForSerializable bool `protobuf:"varint,109,opt,name=durable_locking_for_serializable,json=durableLockingForSerializable,proto3" json:"durable_locking_for_serializable,omitempty"`
	// SharedLockingForSerializable, if set to true, means SELECT FOR SHARE and
	// SELECT FOR KEY SHARE statements issued by transactions that run with
	// serializable isolation will acquire shared locks; otherwise, they'll
	// perform non-locking reads.
	//
	// Weaker isolation levels always acquire shared locks for SELECT FOR SHARE
	// and SELECT FOR KEY SHARE statements, regardless of this session setting.
	SharedLockingForSerializable bool `protobuf:"varint,112,opt,name=shared_locking_for_serializable,json=sharedLockingForSerializable,proto3" json:"shared_locking_for_serializable,omitempty"`
	// MaxRetriesForReadCommitted indicates the maximum number of
	// automatic retries to perform for statements in explicit READ COMMITTED
	// transactions that see a transaction retry error.
	MaxRetriesForReadCommitted int32 `protobuf:"varint,110,opt,name=max_retries_for_read_committed,json=maxRetriesForReadCommitted,proto3" json:"max_retries_for_read_committed,omitempty"`
	// StrictDDLAtomicity causes errors when the client attempts DDL
	// operations inside an explicit txn and CockroachDB cannot
	// guarantee the DDL to be performed atomically.
	//
	// When this is not set, a transaction may commit its DML
	// statements but fail its DDL statements, resulting
	// in error XXA00 - TransactionCommittedWithSchemaChangeFailure.
	//
	// When this is set, that particular atomicity violation should
	// not occur any more (at the expense of disabling certain
	// forms of DDL inside explicit txns).
	StrictDDLAtomicity bool `protobuf:"varint,111,opt,name=strict_ddl_atomicity,json=strictDdlAtomicity,proto3" json:"strict_ddl_atomicity,omitempty"`
	// UnsafeSettingInterlockKey needs to be set to a special string
	// before SET CLUSTER SETTING is allowed on an unsafe setting.
	UnsafeSettingInterlockKey string `protobuf:"bytes,113,opt,name=unsafe_setting_interlock_key,json=unsafeSettingInterlockKey,proto3" json:"unsafe_setting_interlock_key,omitempty"`
	// OptimizerUseLockOpForSerializable, when true, instructs the optimizer to
	// implement SELECT FOR UPDATE and SELECT FOR SHARE statements using the Lock
	// operator under serializable isolation.
	//
	// For correctness, under weaker isolation levels the optimizer always
	// implements SELECT FOR UPDATE and SELECT FOR SHARE using the Lock operator,
	// regardless of this setting.
	OptimizerUseLockOpForSerializable bool `protobuf:"varint,114,opt,name=optimizer_use_lock_op_for_serializable,json=optimizerUseLockOpForSerializable,proto3" json:"optimizer_use_lock_op_for_serializable,omitempty"`
	// OptimizerUseProvidedOrderingFix, when true, causes the optimizer to
	// reconcile provided orderings with required ordering choices. This prevents
	// internal errors due to incomplete functional dependencies, and also
	// fixes a bug that incorrectly truncated the provided ordering (see #113072).
	OptimizerUseProvidedOrderingFix bool `protobuf:"varint,115,opt,name=optimizer_use_provided_ordering_fix,json=optimizerUseProvidedOrderingFix,proto3" json:"optimizer_use_provided_ordering_fix,omitempty"`
	// DisableChangefeedReplication, when true, disables changefeed events from
	// being emitted for changes to data made in a session. This will apply only
	// to new txns created in the session.
	DisableChangefeedReplication bool `protobuf:"varint,116,opt,name=disable_changefeed_replication,json=disableChangefeedReplication,proto3" json:"disable_changefeed_replication,omitempty"`
	// CopyTxnQualityOfService indicates the default QoSLevel/WorkPriority of the
	// transactions used to evaluate COPY commands.
	CopyTxnQualityOfService QoSLevel `protobuf:"varint,117,opt,name=copy_txn_quality_of_service,json=copyTxnQualityOfService,proto3,casttype=QoSLevel" json:"copy_txn_quality_of_service,omitempty"`
	// CopyWritePipeliningEnabled indicates whether the write pipelining is
	// enabled for implicit txns used by COPY.
	CopyWritePipeliningEnabled bool `protobuf:"varint,118,opt,name=copy_write_pipelining_enabled,json=copyWritePipeliningEnabled,proto3" json:"copy_write_pipelining_enabled,omitempty"`
	// OptimizerMergeJoinsEnabled, when true, instructs the optimizer to explore
	// query plans with merge joins. When false, the optimizer does not attempt
	// to plan merge joins.
	OptimizerMergeJoinsEnabled bool `protobuf:"varint,119,opt,name=optimizer_merge_joins_enabled,json=optimizerMergeJoinsEnabled,proto3" json:"optimizer_merge_joins_enabled,omitempty"`
	// CopyNumRetriesPerBatch determines the number of times a single batch of
	// rows can be retried for non-atomic COPY.
	CopyNumRetriesPerBatch int32 `protobuf:"varint,120,opt,name=copy_num_retries_per_batch,json=copyNumRetriesPerBatch,proto3" json:"copy_num_retries_per_batch,omitempty"`
	// AutoCommitBeforeDDL will cause any DDL statement received during a
	// multi-statement transaction to make the transaction auto-commit before
	// executing the DDL statement. After the auto-commit, any other statements
	// that are in the transaction block will instead be executed in their own
	// implicit transaction.
	AutoCommitBeforeDDL bool `protobuf:"varint,121,opt,name=autocommit_before_ddl,json=autocommitBeforeDdl,proto3" json:"autocommit_before_ddl,omitempty"`
	// CloseCursorsAtCommit determines whether cursors remain open after their
	// parent transaction closes. This is useful for oracle compatibility.
	CloseCursorsAtCommit bool `protobuf:"varint,122,opt,name=close_cursors_at_commit,json=closeCursorsAtCommit,proto3" json:"close_cursors_at_commit,omitempty"`
	// PLpgSQLUseStrictInto causes PL/pgSQL "SELECT ... INTO" and "RETURNING INTO"
	// syntax to always behave as if they were specified with the STRICT option,
	// which throws a runtime error when the SQL statement doesn't return exactly
	// one row. This is useful for oracle compatibility.
	PLpgSQLUseStrictInto bool `protobuf:"varint,123,opt,name=plpgsql_use_strict_into,json=plpgsqlUseStrictInto,proto3" json:"plpgsql_use_strict_into,omitempty"`
	// OptimizerUseVirtualComputedColumnStats indicates whether we should use
	// statistics on virtual computed columns for cardinality estimation in the
	// optimizer.
	OptimizerUseVirtualComputedColumnStats bool `protobuf:"varint,124,opt,name=optimizer_use_virtual_computed_column_stats,json=optimizerUseVirtualComputedColumnStats,proto3" json:"optimizer_use_virtual_computed_column_stats,omitempty"`
	// OptimizerUseTrigramSimilarityOptimization indicates whether the optimizer
	// should generate improved plans for queries with trigram similarity filters.
	OptimizerUseTrigramSimilarityOptimization bool `protobuf:"varint,125,opt,name=optimizer_use_trigram_similarity_optimization,json=optimizerUseTrigramSimilarityOptimization,proto3" json:"optimizer_use_trigram_similarity_optimization,omitempty"`
	// OptimizerUseImprovedDistinctOnLimitHintCosting indicates whether the
	// optimizer should use an improved costing estimate for DistinctOn operators
	// with limit hints.
	OptimizerUseImprovedDistinctOnLimitHintCosting bool `protobuf:"varint,126,opt,name=optimizer_use_improved_distinct_on_limit_hint_costing,json=optimizerUseImprovedDistinctOnLimitHintCosting,proto3" json:"optimizer_use_improved_distinct_on_limit_hint_costing,omitempty"`
	// OptimizerUseImprovedTrigramSimilaritySelectivity indicates whether the
	// optimizer should use an improved selectivitiy estimate for trigram
	// similarity filters.
	OptimizerUseImprovedTrigramSimilaritySelectivity bool `protobuf:"varint,127,opt,name=optimizer_use_improved_trigram_similarity_selectivity,json=optimizerUseImprovedTrigramSimilaritySelectivity,proto3" json:"optimizer_use_improved_trigram_similarity_selectivity,omitempty"`
	// OptimizerUseImprovedZigzagJoinCosting, when true, indicates that the
	// optimizer should use improved logic in the cost model for zigzag joins.
	OptimizerUseImprovedZigzagJoinCosting bool `protobuf:"varint,128,opt,name=optimizer_use_improved_zigzag_join_costing,json=optimizerUseImprovedZigzagJoinCosting,proto3" json:"optimizer_use_improved_zigzag_join_costing,omitempty"`
	// OptimizerUseImprovedMultiColumnSelectivityEstimate, when true, indicates
	// that the optimizer should use an improved selectivity estimate for
	// multi-column predicates.
	OptimizerUseImprovedMultiColumnSelectivityEstimate bool `protobuf:"varint,129,opt,name=optimizer_use_improved_multi_column_selectivity_estimate,json=optimizerUseImprovedMultiColumnSelectivityEstimate,proto3" json:"optimizer_use_improved_multi_column_selectivity_estimate,omitempty"`
	// OptimizerProveImplicationWithVirtualComputedColumns, when true, indicates
	// that the optimizer should use virtual computed columns to prove partial
	// index implication.
	OptimizerProveImplicationWithVirtualComputedColumns bool `protobuf:"varint,130,opt,name=optimizer_prove_implication_with_virtual_computed_columns,json=optimizerProveImplicationWithVirtualComputedColumns,proto3" json:"optimizer_prove_implication_with_virtual_computed_columns,omitempty"`
	// OptimizerPushOffsetIntoIndexJoin, when true, indicates that the optimizer
	// should push offset expressions into index joins.
	OptimizerPushOffsetIntoIndexJoin bool `protobuf:"varint,132,opt,name=optimizer_push_offset_into_index_join,json=optimizerPushOffsetIntoIndexJoin,proto3" json:"optimizer_push_offset_into_index_join,omitempty"`
	// PlanCacheMode indicates the method that the optimizer should use to choose
	// between a custom and generic query plan.
	PlanCacheMode PlanCacheMode `protobuf:"varint,133,opt,name=plan_cache_mode,json=planCacheMode,proto3,enum=cockroach.sql.sessiondatapb.PlanCacheMode" json:"plan_cache_mode,omitempty"`
	// OptimizerUsePolymorphicParameterFix, when true, causes the optimizer to
	// validate a routine's polymorphic parameters during overload resolution
	// and type-checking.
	OptimizerUsePolymorphicParameterFix bool `protobuf:"varint,134,opt,name=optimizer_use_polymorphic_parameter_fix,json=optimizerUsePolymorphicParameterFix,proto3" json:"optimizer_use_polymorphic_parameter_fix,omitempty"`
	// OriginIDForLogicalDataReplication is an identifier for the cluster that
	// originally wrote the data that are being written in this session. An
	// originID of 0 (the default) identifies a local write, 1 identifies a remote
	// write of unspecified origin, and 2+ are reserved to identify remote writes
	// from specific clusters.
	OriginIDForLogicalDataReplication uint32 `protobuf:"varint,135,opt,name=origin_id_for_logical_data_replication,json=originIdForLogicalDataReplication,proto3" json:"origin_id_for_logical_data_replication,omitempty"`
	// EnableCreateStatsUsingExtremesBoolEnum, when true, allows the use of CREATE
	// STATISTICS .. USING EXTREMES on bool and enum columns.
	EnableCreateStatsUsingExtremesBoolEnum bool `protobuf:"varint,136,opt,name=enable_create_stats_using_extremes_bool_enum,json=enableCreateStatsUsingExtremesBoolEnum,proto3" json:"enable_create_stats_using_extremes_bool_enum,omitempty"`
	// OptimizerUseMergedPartialStatistics indicates whether we should use
	// statistics merged from partial and full statistics for cardinality
	// estimation in the optimizer.
	OptimizerUseMergedPartialStatistics bool `protobuf:"varint,137,opt,name=optimizer_use_merged_partial_statistics,json=optimizerUseMergedPartialStatistics,proto3" json:"optimizer_use_merged_partial_statistics,omitempty"`
	// OptimizerUseConditionalHoistFix, when true, prevents the optimizer from
	// hoisting a volatile expression that is conditionally executed by a CASE,
	// COALESCE, or IFERR expression.
	OptimizerUseConditionalHoistFix bool `protobuf:"varint,138,opt,name=optimizer_use_conditional_hoist_fix,json=optimizerUseConditionalHoistFix,proto3" json:"optimizer_use_conditional_hoist_fix,omitempty"`
	// OptimizerPushLimitIntoProjectFilteredScan, when true, indicates that the
	// optimizer should push limit expressions into projects of filtered scans.
	OptimizerPushLimitIntoProjectFilteredScan bool `protobuf:"varint,139,opt,name=optimizer_push_limit_into_project_filtered_scan,json=optimizerPushLimitIntoProjectFilteredScan,proto3" json:"optimizer_push_limit_into_project_filtered_scan,omitempty"`
	// OriginTimestampForLogicalDataReplication is the mvcc timestamp the data
	// written in this session were originally written with before being
	// replicated via Logical Data Replication.
	OriginTimestampForLogicalDataReplication hlc.Timestamp `protobuf:"bytes,140,opt,name=origin_timestamp_for_logical_data_replication,json=originTimestampForLogicalDataReplication,proto3" json:"origin_timestamp_for_logical_data_replication"`
	// BypassPCRReaderCatalogAOST disables the AOST used by all user queries on
	// the PCR reader catalog.
	BypassPCRReaderCatalogAOST bool `protobuf:"varint,141,opt,name=bypass_pcr_reader_catalog_aost,json=bypassPcrReaderCatalogAost,proto3" json:"bypass_pcr_reader_catalog_aost,omitempty"`
	// UnsafeAllowTriggersModifyingCascades, when true, allows row-level BEFORE
	// triggers to modify or filter rows that are being updated or deleted as
	// part of a cascading foreign key action. This is unsafe because it can
	// lead to constraint violations.
	UnsafeAllowTriggersModifyingCascades bool `protobuf:"varint,142,opt,name=unsafe_allow_triggers_modifying_cascades,json=unsafeAllowTriggersModifyingCascades,proto3" json:"unsafe_allow_triggers_modifying_cascades,omitempty"`
	// DisableVecUnionEagerCancellation disables the eager cancellation that is
	// performed by the vectorized engine when transitioning into the draining
	// state in some cases.
	DisableVecUnionEagerCancellation bool `protobuf:"varint,143,opt,name=disable_vec_union_eager_cancellation,json=disableVecUnionEagerCancellation,proto3" json:"disable_vec_union_eager_cancellation,omitempty"`
	// RecursionDepthLimit is the maximum depth that nested trigger-function calls
	// can reach.
	RecursionDepthLimit int64 `protobuf:"varint,144,opt,name=recursion_depth_limit,json=recursionDepthLimit,proto3" json:"recursion_depth_limit,omitempty"`
	// DistributeGroupByRowCountThreshold is the minimum number of rows estimated
	// to be processed by the GroupBy operator so that we choose to distribute the
	// plan because of this aggregator stage of DistSQL processors.
	DistributeGroupByRowCountThreshold uint64 `protobuf:"varint,145,opt,name=distribute_group_by_row_count_threshold,json=distributeGroupByRowCountThreshold,proto3" json:"distribute_group_by_row_count_threshold,omitempty"`
	// DistributeSortRowCountThreshold is the minimum number of rows estimated
	// to be processed by the Sort operator so that we choose to distribute the
	// plan because of this sorter stage of DistSQL processors.
	DistributeSortRowCountThreshold uint64 `protobuf:"varint,146,opt,name=distribute_sort_row_count_threshold,json=distributeSortRowCountThreshold,proto3" json:"distribute_sort_row_count_threshold,omitempty"`
	// DistributeScanRowCountThreshold is the minimum number of rows estimated to
	// be read by the Scan operator so that we choose to distribute the plan
	// because of this TableReader stage of DistSQL processors.
	DistributeScanRowCountThreshold uint64 `protobuf:"varint,147,opt,name=distribute_scan_row_count_threshold,json=distributeScanRowCountThreshold,proto3" json:"distribute_scan_row_count_threshold,omitempty"`
	// AlwaysDistributeFullScans determines whether full table scans always force
	// the plan to be distributed, regardless of the estimated row count.
	AlwaysDistributeFullScans bool `protobuf:"varint,148,opt,name=always_distribute_full_scans,json=alwaysDistributeFullScans,proto3" json:"always_distribute_full_scans,omitempty"`
	// DistributeJoinRowCountThreshold is the minimum number of rows estimated to
	// be processed from both inputs by the hash or merge join so that we choose
	// to distribute the plan because of this joiner stage of DistSQL processors.
	DistributeJoinRowCountThreshold uint64 `protobuf:"varint,149,opt,name=distribute_join_row_count_threshold,json=distributeJoinRowCountThreshold,proto3" json:"distribute_join_row_count_threshold,omitempty"`
	// LegacyVarcharTyping controls the legacy behavior of allowing some invalid
	// mix-typed comparisons with VARCHAR types. See #137837, #133037, and
	// #132268.
	LegacyVarcharTyping bool `protobuf:"varint,150,opt,name=legacy_varchar_typing,json=legacyVarcharTyping,proto3" json:"legacy_varchar_typing,omitempty"`
	// AvoidFullTableScansInMutations indicates whether mutation queries that plan
	// full table scans should be avoided.
	AvoidFullTableScansInMutations bool `protobuf:"varint,151,opt,name=avoid_full_table_scans_in_mutations,json=avoidFullTableScansInMutations,proto3" json:"avoid_full_table_scans_in_mutations,omitempty"`
	// CatalogDigestStalenessCheckEnabled is used to enable using the catalog
	// digest information to do fast memo checks.
	CatalogDigestStalenessCheckEnabled bool `protobuf:"varint,153,opt,name=catalog_digest_staleness_check_enabled,json=catalogDigestStalenessCheckEnabled,proto3" json:"catalog_digest_staleness_check_enabled,omitempty"`
	// OptimizerPreferBoundedCardinality instructs the optimizer to prefer query
	// plans in which every expression has a bounded cardinality over plans with
	// one or more expressions with unbounded cardinality.
	OptimizerPreferBoundedCardinality bool `protobuf:"varint,154,opt,name=optimizer_prefer_bounded_cardinality,json=optimizerPreferBoundedCardinality,proto3" json:"optimizer_prefer_bounded_cardinality,omitempty"`
	// OptimizerMinRowCount sets a lower bound on row count estimates for
	// relational expressions during query planning. A value of zero indicates no
	// lower bound. Note that if this is set to a value greater than zero, a row
	// count of zero can still be estimated for expressions with a cardinality of
	// zero, e.g., for a contradictory filter.
	OptimizerMinRowCount float64 `protobuf:"fixed64,155,opt,name=optimizer_min_row_count,json=optimizerMinRowCount,proto3" json:"optimizer_min_row_count,omitempty"`
	// BufferedWritesEnabled controls whether the buffered writes KV transaction
	// protocol is used for user queries on the current session. If this variable
	// is modified in an explicit txn, then the change will be applied only to
	// future txns on the session.
	BufferedWritesEnabled bool `protobuf:"varint,156,opt,name=buffered_writes_enabled,json=bufferedWritesEnabled,proto3" json:"buffered_writes_enabled,omitempty"`
	// OptimizerCheckInputMinRowCount sets a lower bound on row count estimates
	// for the buffer scan of FK and uniqueness checks. A value of zero indicates
	// no lower bound.
	OptimizerCheckInputMinRowCount float64 `protobuf:"fixed64,157,opt,name=optimizer_check_input_min_row_count,json=optimizerCheckInputMinRowCount,proto3" json:"optimizer_check_input_min_row_count,omitempty"`
	// OptimizerPlanLookupJoinsWithReverseScans enables planning for lookup joins
	// that use reverse scans to get results in reverse index order on each
	// lookup.
	OptimizerPlanLookupJoinsWithReverseScans bool `protobuf:"varint,158,opt,name=optimizer_plan_lookup_joins_with_reverse_scans,json=optimizerPlanLookupJoinsWithReverseScans,proto3" json:"optimizer_plan_lookup_joins_with_reverse_scans,omitempty"`
	// RegisterLatchWaitContentionEvents, when true, causes latch wait contention
	// events to be registered with the *.contention_events virtual tables. It
	// defaults to false in order to avoid registering a large number of
	// uninformative latch wait events.
	RegisterLatchWaitContentionEvents bool `protobuf:"varint,159,opt,name=register_latch_wait_contention_events,json=registerLatchWaitContentionEvents,proto3" json:"register_latch_wait_contention_events,omitempty"`
	// UseCPutsOnNonUniqueIndexes, when true, indicates that CPuts should be used
	// when writing new KVs into the non-unique indexes. It is an escape hatch in
	// case our thinking that we don't need the CPut in such a scenario is wrong.
	//
	// This will have impact regardless of the buffered writes.
	UseCPutsOnNonUniqueIndexes bool `protobuf:"varint,160,opt,name=use_cputs_on_non_unique_indexes,json=useCputsOnNonUniqueIndexes,proto3" json:"use_cputs_on_non_unique_indexes,omitempty"`
	// BufferedWritesUseLockingOnNonUniqueIndexes, when true, indicates that
	// locking Puts and Dels should be used when writing into the non-unique
	// indexes.
	//
	// This will only have impact when BufferedWritesEnabled is set.
	BufferedWritesUseLockingOnNonUniqueIndexes bool `protobuf:"varint,161,opt,name=buffered_writes_use_locking_on_non_unique_indexes,json=bufferedWritesUseLockingOnNonUniqueIndexes,proto3" json:"buffered_writes_use_locking_on_non_unique_indexes,omitempty"`
	// OptimizerUseLockElisionMultipleFamilies, when true, indicates that the lock
	// eliding optimization should be enabled for tables with multiple column
	// families.
	//
	// This will only have impact when BufferedWritesEnabled is set.
	OptimizerUseLockElisionMultipleFamilies bool `protobuf:"varint,162,opt,name=optimizer_use_lock_elision_multiple_families,json=optimizerUseLockElisionMultipleFamilies,proto3" json:"optimizer_use_lock_elision_multiple_families,omitempty"`
	// OptimizerEnableLockElision, when false, indicates that the lock eliding
	// optimization should be disabled for tables with any number of column
	// families. It takes precedence over OptimizerUseLockElisionMultipleFamilies.
	//
	// This will only have impact when BufferedWritesEnabled is set.
	OptimizerEnableLockElision bool `protobuf:"varint,163,opt,name=optimizer_enable_lock_elision,json=optimizerEnableLockElision,proto3" json:"optimizer_enable_lock_elision,omitempty"`
	// OptimizerUseDeleteRangeFastPath, when true, indicates that the optimizer
	// should try to use the delete range fast-path when possible.
	OptimizerUseDeleteRangeFastPath bool `protobuf:"varint,164,opt,name=optimizer_use_delete_range_fast_path,json=optimizerUseDeleteRangeFastPath,proto3" json:"optimizer_use_delete_range_fast_path,omitempty"`
	// AllowCreateTriggerFunctionWithArgvReferences, when true, allows triggers to
	// be created with trigger functions that use the TG_ARGV parameter even
	// though it currently doesn't have Postgres-compatible 0-based indexing
	// behavior.
	AllowCreateTriggerFunctionWithArgvReferences bool `protobuf:"varint,165,opt,name=allow_create_trigger_function_with_argv_references,json=allowCreateTriggerFunctionWithArgvReferences,proto3" json:"allow_create_trigger_function_with_argv_references,omitempty"`
	// CreateTableWithSchemaLocked, when true will create tables as schema_locked
	// by default.
	CreateTableWithSchemaLocked bool `protobuf:"varint,166,opt,name=create_table_with_schema_locked,json=createTableWithSchemaLocked,proto3" json:"create_table_with_schema_locked,omitempty"`
	// UsePre_25_2VariadicBuiltins, when true, will treat variadic builtins with a
	// types.Any variadic argument as types.AnyElement (the pre-25.2 behavior)
	UsePre_25_2VariadicBuiltins bool `protobuf:"varint,167,opt,name=use_pre_25_2_variadic_builtins,json=usePre252VariadicBuiltins,proto3" json:"use_pre_25_2_variadic_builtins,omitempty"`
	// VectorSearchBeamSize controls the number of candidates examined during
	// vector index searches. It represents the number of vector partitions that
	// are considered at each level of the search tree. Higher values increase
	// search accuracy but require more processing resources.
	VectorSearchBeamSize int32 `protobuf:"varint,168,opt,name=vector_search_beam_size,json=vectorSearchBeamSize,proto3" json:"vector_search_beam_size,omitempty"`
	// PropagateAdmissionHeaderToLeafTransactions, when true, causes leaf
	// transactions to inherit the admission header from the root transaction.
	PropagateAdmissionHeaderToLeafTransactions bool `protobuf:"varint,169,opt,name=propagate_admission_header_to_leaf_transactions,json=propagateAdmissionHeaderToLeafTransactions,proto3" json:"propagate_admission_header_to_leaf_transactions,omitempty"`
	// OptimizerUseExistsFilterHoistRule, when true, causes the optimizer to apply
	// the HoistUnboundFilterFromExistsSubquery rule to EXISTS conditions.
	OptimizerUseExistsFilterHoistRule bool `protobuf:"varint,170,opt,name=optimizer_use_exists_filter_hoist_rule,json=optimizerUseExistsFilterHoistRule,proto3" json:"optimizer_use_exists_filter_hoist_rule,omitempty"`
	// InitialRetryBackoffForReadCommitted controls the initial backoff
	// duration for automatic retries of statements in explicit READ COMMITTED
	// transactions that see a transaction retry error. 0 disables backoff.
	InitialRetryBackoffForReadCommitted time.Duration `protobuf:"varint,171,opt,name=initial_retry_backoff_for_read_committed,json=initialRetryBackoffForReadCommitted,proto3,casttype=time.Duration" json:"initial_retry_backoff_for_read_committed,omitempty"`
	// UseImprovedRoutineDependencyTracking, when true, causes newly-created
	// routines to only consider user-specified target columns when determining the
	// dependencies of an INSERT statement in a routine.
	UseImprovedRoutineDependencyTracking bool `protobuf:"varint,172,opt,name=use_improved_routine_dependency_tracking,json=useImprovedRoutineDependencyTracking,proto3" json:"use_improved_routine_dependency_tracking,omitempty"`
	// OptimizerDisableCrossRegionCascadeFastPathForRBRTables, when true, causes the optimizer
	// to unconditionally attempt to apply the fast path for cascading deletes.
	// See also #146705.
	OptimizerDisableCrossRegionCascadeFastPathForRBRTables bool `protobuf:"varint,173,opt,name=optimizer_disable_cross_region_cascade_fast_path_for_rbr_tables,json=optimizerDisableCrossRegionCascadeFastPathForRbrTables,proto3" json:"optimizer_disable_cross_region_cascade_fast_path_for_rbr_tables,omitempty"`
	// DistSQLUseReducedLeafWriteSets, when true, indicates that the DistSQL
	// runner should use the reduced write sets when constructing LeafTxns.
	DistSQLUseReducedLeafWriteSets bool `protobuf:"varint,174,opt,name=distsql_use_reduced_leaf_write_sets,json=distsqlUseReducedLeafWriteSets,proto3" json:"distsql_use_reduced_leaf_write_sets,omitempty"`
	// UseProcTxnControlExtendedProtocolFix, when true, enables the fix for
	// PL/pgSQL transaction control statements (COMMIT, ROLLBACK) when the stored
	// procedure is executed via a portal in the extended wire protocol.
	UseProcTxnControlExtendedProtocolFix bool `protobuf:"varint,175,opt,name=use_proc_txn_control_extended_protocol_fix,json=useProcTxnControlExtendedProtocolFix,proto3" json:"use_proc_txn_control_extended_protocol_fix,omitempty"`
	// EnableScrubJob controls if a job is initiated when the EXPERIMENTAL SCRUB
	// command is used.
	EnableScrubJob bool `protobuf:"varint,176,opt,name=enable_scrub_job,json=enableScrubJob,proto3" json:"enable_scrub_job,omitempty"`
	// AllowViewWithSecurityInvokerClause indicates whether security invoker for views is enabled
	AllowViewWithSecurityInvokerClause bool `protobuf:"varint,177,opt,name=allow_view_with_security_invoker_clause,json=allowViewWithSecurityInvokerClause,proto3" json:"allow_view_with_security_invoker_clause,omitempty"`
	// VectorSearchRerankMultiplier controls how many of the initial search results
	// can be reranked using exact distance calculations with the original
	// full-size vectors. It acts as a multiplier on a base limit derived from the
	// search beam size and the top-k results requested by the query.
	VectorSearchRerankMultiplier int32 `protobuf:"varint,178,opt,name=vector_search_rerank_multiplier,json=vectorSearchRerankMultiplier,proto3" json:"vector_search_rerank_multiplier,omitempty"`
	// ParallelizeMultiKeyLookupJoinsAvgLookupRatio controls the average lookup
	// ratio of the lookup join (i.e. the number of looked up rows we get for each
	// input row) that we consider "safe" for parallelization across ranges. If
	// the estimated average lookup ratio exceeds this, then the parallelization
	// is disabled. Setting it to zero disables this parallelization heuristic.
	// This setting only has impact on multi-key lookup joins that are not powered
	// by the streamer.
	ParallelizeMultiKeyLookupJoinsAvgLookupRatio float64 `protobuf:"fixed64,179,opt,name=parallelize_multi_key_lookup_joins_avg_lookup_ratio,json=parallelizeMultiKeyLookupJoinsAvgLookupRatio,proto3" json:"parallelize_multi_key_lookup_joins_avg_lookup_ratio,omitempty"`
	// ParallelizeMultiKeyLookupJoinsMaxLookupRatio adds a guardrail to the
	// heuristic of ParallelizeMultiKeyLookupJoinsAvgLookupRatio so that if the
	// estimated maximum lookup ratio for a single input row exceeds this, then
	// the heuristic is disabled. In other words, if the lookup table has some
	// "heavy hitters", this setting controls their frequency at which we still
	// consider the heuristic "safe". Setting it to zero disables the guardrail.
	ParallelizeMultiKeyLookupJoinsMaxLookupRatio float64 `protobuf:"fixed64,180,opt,name=parallelize_multi_key_lookup_joins_max_lookup_ratio,json=parallelizeMultiKeyLookupJoinsMaxLookupRatio,proto3" json:"parallelize_multi_key_lookup_joins_max_lookup_ratio,omitempty"`
	// ParallelizeMultiKeyLookupJoinsAvgLookupRowSize adds a guardrail to the
	// heuristic of ParallelizeMultiKeyLookupJoinsAvgLookupRatio so that if the
	// estimated average lookup row size exceeds this, then the heuristic is
	// disabled. In other words, since the looked up rows could be very large in
	// size, this setting controls the size threshold that we still consider to be
	// "safe" for parallelization heuristic. Setting it to zero disables the
	// guardrail.
	ParallelizeMultiKeyLookupJoinsAvgLookupRowSize int64 `protobuf:"varint,181,opt,name=parallelize_multi_key_lookup_joins_avg_lookup_row_size,json=parallelizeMultiKeyLookupJoinsAvgLookupRowSize,proto3" json:"parallelize_multi_key_lookup_joins_avg_lookup_row_size,omitempty"`
	// ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations, if set, indicates that the
	// "average lookup ratio" parallelization heuristic (as controlled via 3 knobs
	// above) should only apply to mutations of multi-region tables. If false,
	// then the heuristic applies to all statements (both read-only and
	// mutations), regardless of the table being multi-region.
	ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations bool `protobuf:"varint,182,opt,name=parallelize_multi_key_lookup_joins_only_on_mr_mutations,json=parallelizeMultiKeyLookupJoinsOnlyOnMrMutations,proto3" json:"parallelize_multi_key_lookup_joins_only_on_mr_mutations,omitempty"`
	// AllowUnsafeInternals allows the caller to access the crdb_internal
	// or system databases within queries.
	AllowUnsafeInternals bool `protobuf:"varint,183,opt,name=allow_unsafe_internals,json=allowUnsafeInternals,proto3" json:"allow_unsafe_internals,omitempty"`
	// DisableOptimizerRules is a list of optimizer rules that should be disabled
	// during query optimization. The names of the rules can be found in the
	// opt/rule_name.og.go file.
	DisableOptimizerRules []string `protobuf:"bytes,184,rep,name=disable_optimizer_rules,json=disableOptimizerRules,proto3" json:"disable_optimizer_rules,omitempty"`
	// UseSoftLimitForDistributeScan, if set, means that we'll use the soft limit
	// hint - if available - when comparing against
	// DistributeScanRowCountThreshold.
	UseSoftLimitForDistributeScan bool `protobuf:"varint,185,opt,name=use_soft_limit_for_distribute_scan,json=useSoftLimitForDistributeScan,proto3" json:"use_soft_limit_for_distribute_scan,omitempty"`
	// OptimizerUseImprovedHoistJoinProject controls whether the
	// HoistJoinProjectLeft normalization rule hoists more kinds of projections
	// above joins.
	OptimizerUseImprovedHoistJoinProject bool `protobuf:"varint,186,opt,name=optimizer_use_improved_hoist_join_project,json=optimizerUseImprovedHoistJoinProject,proto3" json:"optimizer_use_improved_hoist_join_project,omitempty"`
	// EnableInspectCommand controls use of the INSPECT command.
	EnableInspectCommand bool `protobuf:"varint,187,opt,name=enable_inspect_command,json=enableInspectCommand,proto3" json:"enable_inspect_command,omitempty"`
}

func (m *LocalOnlySessionData) Reset()         { *m = LocalOnlySessionData{} }
func (m *LocalOnlySessionData) String() string { return proto.CompactTextString(m) }
func (*LocalOnlySessionData) ProtoMessage()    {}
func (*LocalOnlySessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{0}
}
func (m *LocalOnlySessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalOnlySessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalOnlySessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalOnlySessionData.Merge(m, src)
}
func (m *LocalOnlySessionData) XXX_Size() int {
	return m.Size()
}
func (m *LocalOnlySessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalOnlySessionData.DiscardUnknown(m)
}

var xxx_messageInfo_LocalOnlySessionData proto.InternalMessageInfo

// SequenceCacheEntry is an entry in a SequenceCache.
type SequenceCacheEntry struct {
	// CachedVersion stores the descpb.DescriptorVersion that cached values are associated with.
	// The version is checked to determine if cache needs to be invalidated. The version is stored as
	// a uint32 to prevent an import cycle with the descpb package.
	CachedVersion uint32 `protobuf:"varint,1,opt,name=cached_version,json=cachedVersion,proto3" json:"cached_version,omitempty"`
	// CurrentValue stores the present value of the sequence to be given out.
	CurrentValue int64 `protobuf:"varint,2,opt,name=current_value,json=currentValue,proto3" json:"current_value,omitempty"`
	// Increment stores the amount to Increment the currentVal by each time the
	// currentVal is used. This value corresponds to descpb.TableDescriptor_SequenceOpts.Increment.
	Increment int64 `protobuf:"varint,3,opt,name=increment,proto3" json:"increment,omitempty"`
	// NumValues represents the number of values to cache. The cache is considered
	// to be empty when NumValues is 0.
	NumValues int64 `protobuf:"varint,4,opt,name=num_values,json=numValues,proto3" json:"num_values,omitempty"`
}

func (m *SequenceCacheEntry) Reset()         { *m = SequenceCacheEntry{} }
func (m *SequenceCacheEntry) String() string { return proto.CompactTextString(m) }
func (*SequenceCacheEntry) ProtoMessage()    {}
func (*SequenceCacheEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{1}
}
func (m *SequenceCacheEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceCacheEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceCacheEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceCacheEntry.Merge(m, src)
}
func (m *SequenceCacheEntry) XXX_Size() int {
	return m.Size()
}
func (m *SequenceCacheEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceCacheEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceCacheEntry proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.sessiondatapb.ReplicationMode", ReplicationMode_name, ReplicationMode_value)
	proto.RegisterEnum("cockroach.sql.sessiondatapb.PlanCacheMode", PlanCacheMode_name, PlanCacheMode_value)
	proto.RegisterType((*LocalOnlySessionData)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData.CustomOptionsEntry")
	proto.RegisterMapType((SequenceCache)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData.SequenceCacheEntry")
	proto.RegisterType((*SequenceCacheEntry)(nil), "cockroach.sql.sessiondatapb.SequenceCacheEntry")
}

func init() {
	proto.RegisterFile("sql/sessiondatapb/local_only_session_data.proto", fileDescriptor_21ead158cf36da28)
}

var fileDescriptor_21ead158cf36da28 = []byte{
	// 6034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x7b, 0x5b, 0x7f, 0x1c, 0xc7,
	0x71, 0x2f, 0x57, 0xa2, 0x75, 0xa8, 0xa6, 0x48, 0x82, 0x43, 0x50, 0x18, 0x82, 0x24, 0x16, 0xa4,
	0x48, 0x09, 0xa2, 0x48, 0x40, 0x06, 0xad, 0xab, 0x8f, 0x8f, 0x85, 0x5d, 0x00, 0x22, 0x40, 0x80,
	0x58, 0xee, 0x82, 0xa4, 0x2d, 0x1f, 0x6b, 0x3c, 0x98, 0xe9, 0xdd, 0x6d, 0x61, 0x76, 0x7a, 0xd0,
	0xdd, 0xb3, 0xc0, 0xf2, 0x9c, 0xe3, 0x73, 0xb3, 0x13, 0x47, 0xb9, 0x39, 0x71, 0x6e, 0x4e, 0xa2,
	0xdc, 0xec, 0x38, 0xce, 0xfd, 0x7e, 0xcf, 0x07, 0xf0, 0xa3, 0x1f, 0x9d, 0x17, 0xfc, 0x12, 0xf8,
	0x5b, 0xe8, 0x29, 0xbf, 0xaa, 0xea, 0x99, 0x9d, 0x5d, 0x2c, 0x64, 0x39, 0x6f, 0xc0, 0xd4, 0xbf,
	0xaa, 0x7b, 0x7a, 0xaa, 0xab, 0xfe, 0x55, 0xdd, 0xcb, 0xe6, 0xf4, 0x4e, 0x34, 0xa7, 0xb9, 0xd6,
	0x42, 0xc6, 0xa1, 0x6f, 0xfc, 0x64, 0x6b, 0x2e, 0x92, 0x81, 0x1f, 0x79, 0x32, 0x8e, 0x7a, 0x9e,
	0x15, 0x78, 0x20, 0x99, 0x4d, 0x94, 0x34, 0xd2, 0xb9, 0x18, 0xc8, 0x60, 0x5b, 0x49, 0x3f, 0x68,
	0xcf, 0xea, 0x9d, 0x68, 0x76, 0x40, 0x75, 0x72, 0xbc, 0x25, 0x5b, 0x12, 0x71, 0x73, 0xf0, 0x17,
	0xa9, 0x4c, 0xba, 0xa9, 0x11, 0xd1, 0x5c, 0x3b, 0x0a, 0xe6, 0x8c, 0xe8, 0x70, 0x6d, 0xfc, 0x4e,
	0x42, 0x92, 0xab, 0xff, 0xda, 0x61, 0xe3, 0x6b, 0x30, 0xdc, 0x46, 0x1c, 0xf5, 0x1a, 0x64, 0x6a,
	0xd1, 0x37, 0xbe, 0x73, 0x93, 0x39, 0xda, 0xef, 0x72, 0xcf, 0xf8, 0x5b, 0x11, 0xd7, 0x5e, 0xa2,
	0x78, 0x53, 0xec, 0xb9, 0xa5, 0xe9, 0xd2, 0xcc, 0xd3, 0xf5, 0x31, 0x90, 0x6c, 0xa2, 0xa0, 0x86,
	0xcf, 0x9d, 0x2f, 0xb0, 0x8b, 0x32, 0x31, 0xa2, 0x23, 0x1e, 0x73, 0xe5, 0x35, 0xb7, 0xbd, 0xc0,
	0xd7, 0x81, 0x1f, 0x72, 0xed, 0x45, 0xa2, 0x23, 0x8c, 0xfb, 0xc4, 0x74, 0x69, 0xe6, 0xc9, 0xca,
	0xa5, 0x83, 0xfd, 0xb2, 0xbb, 0x91, 0xc1, 0x96, 0xef, 0x56, 0x2d, 0x68, 0x0d, 0x30, 0x75, 0x37,
	0x37, 0xb0, 0xbc, 0x3d, 0x20, 0x71, 0x3e, 0xc5, 0x9e, 0xd1, 0xa6, 0x63, 0x3c, 0x98, 0xbb, 0x4c,
	0x8d, 0xfb, 0x24, 0x5a, 0x3b, 0xfb, 0xe1, 0x7e, 0xf9, 0x14, 0x3c, 0x9a, 0x5d, 0x4c, 0x95, 0x6f,
	0x84, 0x8c, 0xeb, 0x27, 0x01, 0xb6, 0x49, 0x28, 0xe7, 0x0e, 0x9b, 0x10, 0x61, 0xc4, 0x3d, 0x11,
	0xe7, 0x8b, 0x98, 0x19, 0x38, 0x7e, 0x94, 0x81, 0x71, 0xd0, 0x58, 0x89, 0xed, 0x3a, 0x64, 0x96,
	0x3c, 0xf6, 0x5c, 0x66, 0xc9, 0x28, 0x3f, 0xd6, 0x7e, 0x00, 0xe0, 0x43, 0x56, 0x3f, 0x71, 0x94,
	0xd5, 0x32, 0x59, 0xdd, 0xec, 0xeb, 0x0e, 0x0d, 0xf0, 0x2a, 0x9b, 0x88, 0xa5, 0x11, 0x01, 0xf7,
	0x42, 0xa1, 0x93, 0xc8, 0x87, 0xcf, 0xde, 0xe5, 0x4a, 0x98, 0x9e, 0xfb, 0xd4, 0x74, 0x69, 0xe6,
	0x54, 0xfd, 0x3c, 0x89, 0x17, 0x49, 0xda, 0xb0, 0x42, 0x67, 0x96, 0x9d, 0x53, 0x5c, 0xaa, 0x90,
	0x2b, 0xef, 0x3d, 0x29, 0xe2, 0x6c, 0xb5, 0xff, 0x0b, 0x4c, 0xa4, 0x7e, 0xd6, 0x8a, 0x56, 0x41,
	0x42, 0x0b, 0xf9, 0x32, 0x1b, 0x0f, 0x79, 0xd3, 0x4f, 0x23, 0xe3, 0x99, 0xbd, 0xd8, 0x4b, 0x94,
	0x90, 0x38, 0xc8, 0x09, 0x54, 0x70, 0xac, 0x6c, 0x73, 0x2f, 0xae, 0x59, 0x89, 0xf3, 0x49, 0x76,
	0xbe, 0xa8, 0xa1, 0xb8, 0x1f, 0xa2, 0x5f, 0xba, 0x4f, 0x4f, 0x97, 0x66, 0x4e, 0x14, 0x55, 0xea,
	0xdc, 0x0f, 0xc1, 0x87, 0x9c, 0x0a, 0x9b, 0x2a, 0xaa, 0xa4, 0x9a, 0x7b, 0x4d, 0x19, 0x45, 0x72,
	0x97, 0x2b, 0xd4, 0xd7, 0x2e, 0x43, 0xdd, 0xc9, 0xbe, 0xee, 0x03, 0xcd, 0x97, 0x2d, 0x04, 0xcc,
	0x68, 0x67, 0x83, 0x5d, 0x4b, 0x7c, 0x65, 0x84, 0x1f, 0x45, 0x3d, 0x58, 0x13, 0xa3, 0xc4, 0x56,
	0x6a, 0x78, 0xe8, 0x25, 0x91, 0x1f, 0x6b, 0x78, 0x02, 0xce, 0x17, 0xba, 0x27, 0xd1, 0xd2, 0x95,
	0x1c, 0xbb, 0xd8, 0x87, 0xd6, 0x00, 0xb9, 0x68, 0x81, 0xce, 0xeb, 0xac, 0xef, 0x5e, 0x38, 0xa5,
	0xb6, 0xd0, 0x46, 0xb6, 0x94, 0xdf, 0xd1, 0xee, 0x33, 0x68, 0xe4, 0xd9, 0x5c, 0xfe, 0x40, 0xf3,
	0x3b, 0xb9, 0xd4, 0x79, 0x8b, 0x5d, 0x1e, 0xd4, 0xec, 0xa4, 0x91, 0x11, 0x5e, 0x20, 0x23, 0x4f,
	0x1b, 0xdf, 0x68, 0xf7, 0x14, 0xaa, 0x5f, 0x28, 0xaa, 0xaf, 0x03, 0xa4, 0x2a, 0xa3, 0x06, 0x00,
	0x9c, 0x37, 0xd9, 0x05, 0xdc, 0xd0, 0xc2, 0xf4, 0xbc, 0x0c, 0x15, 0x7a, 0x9a, 0xfb, 0x2a, 0x68,
	0xbb, 0xa7, 0x51, 0x7b, 0x22, 0x03, 0x64, 0xbb, 0x23, 0x6c, 0xa0, 0xd8, 0xb9, 0xc2, 0x9e, 0xd1,
	0x7e, 0x93, 0x7b, 0x69, 0x12, 0xfa, 0x86, 0x6b, 0xf7, 0x0c, 0xc2, 0x4f, 0xc2, 0xb3, 0x07, 0xf4,
	0xc8, 0xf9, 0x3c, 0xbb, 0x08, 0x9b, 0x93, 0x2b, 0x2f, 0x92, 0x72, 0x3b, 0x4d, 0xac, 0x2b, 0x34,
	0x25, 0x6c, 0x44, 0xed, 0x8e, 0x81, 0x46, 0xe5, 0xe2, 0xc1, 0x7e, 0x79, 0xa2, 0x86, 0xb0, 0x35,
	0x44, 0xa1, 0x57, 0x2c, 0x4b, 0xb5, 0x7c, 0x57, 0xd7, 0x27, 0x92, 0x51, 0x82, 0x6d, 0x0d, 0xfe,
	0xf5, 0x58, 0xb4, 0x1e, 0xfb, 0x2d, 0xb4, 0xe9, 0xf1, 0x98, 0x56, 0xfd, 0x2c, 0x4e, 0xe2, 0x2c,
	0x89, 0x00, 0xbf, 0x44, 0x02, 0x67, 0x81, 0x5d, 0x56, 0x7c, 0x27, 0x15, 0x8a, 0x7b, 0x7c, 0x2f,
	0x89, 0x44, 0x20, 0x0c, 0x38, 0x59, 0xc7, 0x57, 0x3d, 0x6f, 0x9b, 0xf7, 0xb4, 0xeb, 0xd0, 0x97,
	0xb7, 0xa0, 0x25, 0x8b, 0xa9, 0x11, 0xe4, 0x2e, 0xef, 0x69, 0xd8, 0x0a, 0x4d, 0xa9, 0x02, 0xee,
	0x41, 0x88, 0x49, 0xa4, 0x88, 0x8d, 0xa7, 0x20, 0x60, 0x29, 0xe3, 0x9e, 0x43, 0xe5, 0xf3, 0x28,
	0x6e, 0x64, 0xd2, 0x3a, 0x09, 0x9d, 0xd7, 0xd9, 0x05, 0x1f, 0x3c, 0x08, 0x02, 0x55, 0xe2, 0x2b,
	0xee, 0xf9, 0x1a, 0x16, 0x1b, 0x1d, 0xc6, 0x1d, 0x27, 0x4d, 0x04, 0xd4, 0x48, 0xbe, 0xa0, 0x37,
	0x12, 0x03, 0x3e, 0x02, 0x2f, 0x69, 0x78, 0x27, 0xc9, 0x02, 0x5d, 0xf6, 0x92, 0xe7, 0xe9, 0x25,
	0x41, 0x44, 0x91, 0x2e, 0x7b, 0xc9, 0x0d, 0x76, 0x4d, 0x74, 0xec, 0xcb, 0x05, 0x32, 0x4a, 0x3b,
	0xb1, 0x87, 0xfe, 0x07, 0xfb, 0x5a, 0xc4, 0xad, 0xdc, 0xc0, 0xb3, 0xe4, 0x9b, 0x19, 0xb6, 0x8a,
	0xd0, 0x5a, 0x01, 0x99, 0x19, 0x7c, 0xc4, 0x5e, 0x94, 0x5d, 0xae, 0x94, 0x08, 0x33, 0xe7, 0x52,
	0xbc, 0x05, 0x81, 0xe5, 0xb1, 0x8c, 0xb9, 0x17, 0xc8, 0xb8, 0x29, 0xfa, 0x56, 0x5d, 0xb4, 0x7a,
	0x2d, 0x53, 0x40, 0x4f, 0xab, 0x23, 0xfc, 0x1d, 0x19, 0xf3, 0x2a, 0x82, 0x33, 0xc3, 0x6f, 0xb0,
	0x0b, 0xb0, 0x53, 0x70, 0x59, 0x9a, 0x69, 0x14, 0xd1, 0x2b, 0x7a, 0x3a, 0xf0, 0x63, 0xed, 0x4e,
	0x92, 0xd7, 0x67, 0x80, 0xe5, 0x34, 0x8a, 0xf0, 0x3d, 0x1b, 0x20, 0x75, 0x3e, 0xcd, 0x26, 0xf3,
	0x97, 0xd4, 0x3c, 0xe2, 0x81, 0x41, 0x87, 0x22, 0x37, 0x74, 0x2f, 0x92, 0xd3, 0x66, 0x88, 0x06,
	0x02, 0x96, 0xa5, 0x22, 0x97, 0x74, 0x66, 0xd8, 0x98, 0x88, 0x35, 0x57, 0xc6, 0x6b, 0xfa, 0xda,
	0x78, 0x89, 0x6f, 0xda, 0xee, 0x25, 0x54, 0x39, 0x4d, 0xcf, 0x97, 0x7d, 0x6d, 0x6a, 0xbe, 0x69,
	0x3b, 0x77, 0xd8, 0x15, 0x3f, 0x32, 0x5c, 0x65, 0x0b, 0x69, 0x7a, 0x09, 0xf7, 0x5a, 0x3c, 0xe6,
	0xca, 0x8f, 0xf2, 0x57, 0xbe, 0x8c, 0xaa, 0x97, 0x11, 0x48, 0xab, 0xb8, 0xd9, 0x4b, 0xf8, 0xdb,
	0x84, 0xca, 0xde, 0xf5, 0x16, 0x73, 0x74, 0x2f, 0x0e, 0xda, 0x4a, 0xc6, 0x32, 0xd5, 0x5e, 0x20,
	0x3b, 0x10, 0x09, 0xa7, 0xe8, 0x23, 0x16, 0x24, 0x55, 0x14, 0x38, 0xcf, 0xb3, 0x33, 0x64, 0xde,
	0xd3, 0x7c, 0x07, 0x57, 0xc4, 0x2d, 0x23, 0xf6, 0x14, 0x3d, 0x6e, 0xf0, 0x1d, 0x58, 0x08, 0x67,
	0x93, 0xbd, 0x60, 0x71, 0x69, 0x2c, 0x76, 0x52, 0xee, 0xed, 0x0a, 0xd3, 0x96, 0xa9, 0xf1, 0x44,
	0x1c, 0xf2, 0x3d, 0xf8, 0x38, 0xda, 0x28, 0x5f, 0xc4, 0x46, 0xbb, 0x57, 0x50, 0xff, 0x39, 0x82,
	0x3f, 0x40, 0xf4, 0x23, 0x02, 0xaf, 0x00, 0xb6, 0xda, 0x87, 0x3a, 0x9f, 0x61, 0x17, 0xb5, 0x49,
	0xb7, 0xbc, 0xc0, 0x37, 0x7e, 0x24, 0x5b, 0xc3, 0xae, 0x77, 0x15, 0x2d, 0xb9, 0x00, 0xa9, 0x12,
	0x62, 0xd0, 0x03, 0xef, 0xb3, 0xeb, 0x7c, 0x2f, 0xe1, 0x4a, 0x74, 0x78, 0x6c, 0xfc, 0x08, 0x5e,
	0x36, 0xc1, 0xe8, 0x68, 0x57, 0x51, 0xf1, 0x5d, 0x25, 0x20, 0x5a, 0x3c, 0x87, 0xd9, 0xfa, 0x6a,
	0x11, 0x5c, 0xb5, 0x58, 0x5a, 0xc8, 0xba, 0x45, 0x42, 0x8c, 0xca, 0xd6, 0xc3, 0x28, 0xee, 0x77,
	0x3c, 0xc5, 0xe1, 0xdb, 0x62, 0xfe, 0x72, 0xaf, 0xd3, 0xe7, 0xb6, 0x2b, 0x83, 0xf2, 0x7a, 0x5f,
	0x4c, 0x59, 0x48, 0xa7, 0x91, 0xd1, 0xde, 0x56, 0xda, 0x84, 0x40, 0xa4, 0xc5, 0x63, 0xee, 0x3e,
	0x9f, 0x65, 0x21, 0x14, 0x55, 0x50, 0xd2, 0x10, 0x8f, 0x39, 0xc4, 0xe2, 0x44, 0xc9, 0xc4, 0x6f,
	0xf9, 0x06, 0x72, 0x6a, 0x92, 0x1a, 0x0f, 0x13, 0x95, 0x88, 0x5b, 0xee, 0x0b, 0xe4, 0x95, 0xb9,
	0x7c, 0x05, 0xc4, 0x1b, 0x56, 0xea, 0x7c, 0xa3, 0xc4, 0x06, 0x5e, 0x06, 0x53, 0x83, 0xde, 0x89,
	0x70, 0x97, 0xe3, 0xe6, 0xeb, 0xc8, 0x90, 0xbb, 0x33, 0x98, 0x88, 0x97, 0x0f, 0xf6, 0xcb, 0xe5,
	0xa5, 0x02, 0x1a, 0x92, 0x43, 0xe3, 0xfe, 0x5a, 0xcd, 0x62, 0xd7, 0x65, 0xc8, 0x3f, 0xfc, 0xd1,
	0x90, 0x7a, 0x99, 0x0f, 0x01, 0xf4, 0x4e, 0x54, 0x04, 0x38, 0xcb, 0xec, 0x14, 0xcc, 0xc3, 0x83,
	0x89, 0xe0, 0xf8, 0x2f, 0xe2, 0xf8, 0x57, 0x0f, 0xf6, 0xcb, 0x27, 0xad, 0x41, 0x3b, 0xd6, 0x19,
	0xfb, 0xef, 0xd2, 0x1e, 0x0f, 0xd0, 0xf6, 0x49, 0x50, 0x6c, 0xec, 0x44, 0x68, 0xe7, 0x11, 0xbb,
	0xa0, 0xb9, 0x12, 0x7e, 0xe4, 0xc5, 0x52, 0x75, 0xfc, 0x48, 0x3c, 0xc6, 0xf5, 0x25, 0x9b, 0x37,
	0xd0, 0xe6, 0xc5, 0x0f, 0xf7, 0xcb, 0x13, 0x0d, 0x04, 0xdd, 0x2b, 0x62, 0xd0, 0xd8, 0x84, 0x1e,
	0x2d, 0x70, 0x36, 0xd8, 0x44, 0xcc, 0x77, 0x3d, 0x1d, 0xb4, 0x79, 0xc7, 0xf7, 0x82, 0xb6, 0x1f,
	0xb7, 0xb8, 0x22, 0xb3, 0x2f, 0xa1, 0x59, 0xf7, 0xc3, 0xfd, 0xf2, 0xf8, 0x3d, 0xbe, 0xdb, 0x40,
	0x44, 0x95, 0x00, 0x68, 0x73, 0x3c, 0x1e, 0xf1, 0xd4, 0xf9, 0x32, 0x3b, 0xad, 0xf9, 0x4e, 0xca,
	0xe3, 0x80, 0x7b, 0x81, 0x1f, 0xb4, 0xb9, 0x7b, 0x73, 0xfa, 0xc9, 0x99, 0x93, 0xf3, 0x8b, 0xb3,
	0x1f, 0x41, 0x4d, 0x67, 0x47, 0xd1, 0xcc, 0xd9, 0x86, 0xb5, 0x53, 0x05, 0x33, 0x4b, 0xb1, 0x51,
	0x3d, 0x62, 0x50, 0x03, 0xcf, 0xeb, 0xa7, 0x74, 0xf1, 0x5f, 0xe7, 0x25, 0x76, 0x36, 0x89, 0xfc,
	0x80, 0xc3, 0x37, 0xc9, 0x77, 0xcd, 0x2d, 0x74, 0x9d, 0xb1, 0x5c, 0x90, 0xed, 0x96, 0x1e, 0x73,
	0x32, 0xa6, 0x96, 0x6a, 0xae, 0x3c, 0xe4, 0xbd, 0xee, 0x2c, 0x6c, 0x8d, 0xca, 0xdd, 0x0f, 0xf7,
	0xcb, 0x6f, 0xb7, 0x84, 0x69, 0xa7, 0x5b, 0xb3, 0x81, 0xec, 0xcc, 0xe5, 0xd3, 0x0f, 0xb7, 0xfa,
	0x7f, 0xcf, 0x25, 0xdb, 0xad, 0x39, 0xcd, 0x83, 0x14, 0x18, 0xd1, 0x1c, 0xd8, 0x88, 0xfd, 0x0e,
	0x9f, 0x6d, 0xdc, 0x5f, 0x7b, 0x60, 0xff, 0xae, 0x81, 0xc9, 0xfa, 0x98, 0x1d, 0x06, 0x9e, 0xe2,
	0x13, 0x67, 0x8e, 0x8d, 0x23, 0x6b, 0x92, 0xbb, 0xda, 0x83, 0x8d, 0x66, 0x78, 0xec, 0x45, 0xb2,
	0xe5, 0xce, 0xd1, 0xd6, 0x30, 0x7b, 0x71, 0x5d, 0xee, 0xea, 0x47, 0x24, 0x59, 0x93, 0xad, 0x91,
	0x0a, 0x5c, 0x29, 0xf7, 0xe5, 0x51, 0x0a, 0x4b, 0x4a, 0x39, 0x2f, 0xb2, 0xb3, 0xb9, 0x02, 0x92,
	0x33, 0x30, 0xff, 0x49, 0x44, 0x9f, 0xb6, 0x68, 0x60, 0x54, 0x60, 0xfb, 0x10, 0x14, 0x0c, 0xcf,
	0x1f, 0x82, 0x82, 0xd5, 0x79, 0x76, 0xde, 0x4f, 0x8d, 0xf4, 0x14, 0x6f, 0xcb, 0x4e, 0x31, 0xa7,
	0xdd, 0xc6, 0x35, 0x3e, 0x07, 0xc2, 0xba, 0x95, 0x65, 0xcb, 0x7c, 0x85, 0x3d, 0x23, 0xb4, 0xa7,
	0xd3, 0x84, 0x2b, 0x58, 0x22, 0xf7, 0x53, 0xc4, 0x54, 0x84, 0x6e, 0x64, 0x8f, 0xe0, 0xed, 0x22,
	0x5f, 0xb5, 0x38, 0x25, 0x23, 0x08, 0xba, 0x38, 0x1b, 0xf7, 0x95, 0xe9, 0xd2, 0x4c, 0xa9, 0x7e,
	0x16, 0x65, 0x90, 0x87, 0x20, 0xf2, 0xc2, 0x74, 0x20, 0x4e, 0x8a, 0xf8, 0x3d, 0x48, 0x3e, 0x8a,
	0x1b, 0xd5, 0x83, 0x19, 0x4b, 0xd5, 0x8f, 0x93, 0xaf, 0x52, 0x9c, 0x24, 0x48, 0x1d, 0x10, 0x4b,
	0x08, 0xc8, 0xa6, 0x74, 0x83, 0x9d, 0x8d, 0x61, 0x24, 0x8c, 0x2e, 0x3c, 0xf4, 0x22, 0x5f, 0x1b,
	0xf7, 0x35, 0x54, 0x3a, 0x03, 0x82, 0x0d, 0x7a, 0xbe, 0xe6, 0x6b, 0x03, 0xe5, 0x8e, 0x65, 0x95,
	0x18, 0x4c, 0xbc, 0x16, 0x6c, 0x74, 0xf7, 0x75, 0xf2, 0x29, 0x2b, 0x81, 0x5d, 0xff, 0x36, 0x3c,
	0x77, 0xb6, 0xd9, 0xe9, 0x20, 0xd5, 0x46, 0x76, 0x90, 0xd0, 0xc9, 0x58, 0xbb, 0x6f, 0xfc, 0x67,
	0x37, 0x40, 0x15, 0xed, 0x6c, 0x90, 0x19, 0xdc, 0x00, 0xf5, 0x53, 0x41, 0xf1, 0x99, 0x53, 0x61,
	0x97, 0x29, 0xdb, 0x28, 0x0e, 0x69, 0x8d, 0x83, 0x39, 0x10, 0xe4, 0xeb, 0xf0, 0x26, 0xce, 0xf2,
	0x22, 0x82, 0xea, 0x83, 0x98, 0x6c, 0x29, 0x5e, 0x60, 0x67, 0xfc, 0xae, 0x14, 0xa1, 0x8d, 0xd0,
	0x10, 0x6a, 0x3f, 0x4d, 0x19, 0x19, 0x1f, 0x57, 0xb2, 0xa7, 0xf0, 0xe9, 0x83, 0x36, 0x0f, 0xb6,
	0xbd, 0x66, 0x1a, 0x53, 0x99, 0xb3, 0x25, 0x43, 0xc1, 0xb5, 0xfb, 0x5f, 0xe9, 0xd3, 0xa3, 0x70,
	0xd9, 0xca, 0x2a, 0x28, 0x72, 0x96, 0xd8, 0x74, 0x20, 0x21, 0x00, 0x02, 0x75, 0xc0, 0x0c, 0xe9,
	0x65, 0x15, 0x00, 0xd2, 0x64, 0xc8, 0x06, 0x9f, 0xa1, 0x39, 0x02, 0x0e, 0x19, 0x06, 0xa4, 0xc6,
	0x45, 0x02, 0x01, 0x51, 0x86, 0xbc, 0x50, 0x1b, 0x2c, 0x1c, 0x76, 0x52, 0x4b, 0x99, 0x9b, 0x9e,
	0xe6, 0xaa, 0x2b, 0x02, 0xee, 0xfe, 0xb7, 0xe9, 0xd2, 0xcc, 0x27, 0x2a, 0xcf, 0x7c, 0xb8, 0x5f,
	0x3e, 0x71, 0x5f, 0x36, 0xd6, 0x78, 0x97, 0x47, 0xc5, 0x32, 0xe2, 0x3e, 0x69, 0x6c, 0x34, 0x1b,
	0x84, 0x07, 0x87, 0x03, 0x0e, 0xa8, 0x93, 0x48, 0xd0, 0xec, 0x6c, 0x81, 0xf4, 0x59, 0xb0, 0x53,
	0x3f, 0x2b, 0x13, 0xd3, 0x00, 0x11, 0x4c, 0x28, 0x2f, 0x90, 0xb2, 0x34, 0x08, 0x5e, 0x6b, 0x89,
	0x98, 0x76, 0xdf, 0xa2, 0x6a, 0xc7, 0x66, 0x40, 0x10, 0x11, 0xe7, 0xd2, 0xce, 0xbb, 0xec, 0x56,
	0x4e, 0xde, 0x88, 0xca, 0x64, 0x84, 0xd7, 0x92, 0x38, 0x28, 0x3f, 0x0b, 0xb6, 0xdc, 0x05, 0x34,
	0xf5, 0x42, 0xa6, 0xb4, 0x00, 0x3a, 0x96, 0x00, 0x93, 0xcd, 0x95, 0xb8, 0x30, 0x80, 0xc3, 0xd9,
	0xcb, 0x76, 0x46, 0x39, 0x1f, 0x2b, 0xd6, 0xa0, 0x40, 0xca, 0xb6, 0x7c, 0x13, 0xb4, 0xb1, 0x18,
	0xc1, 0xb8, 0xa7, 0xdd, 0x0a, 0x0e, 0xf1, 0x12, 0xe9, 0xad, 0x58, 0xb5, 0x42, 0xf5, 0xb9, 0x2c,
	0x55, 0x05, 0x74, 0x1a, 0xb9, 0x8a, 0xf3, 0x45, 0x76, 0x0b, 0xd2, 0x5c, 0x60, 0x3c, 0x3f, 0x0e,
	0x3d, 0xd1, 0x8a, 0xa5, 0xe2, 0x5e, 0x2c, 0x8d, 0xd7, 0x15, 0x5a, 0xc0, 0xe8, 0x44, 0x2d, 0x34,
	0xbc, 0x4e, 0x20, 0x93, 0x9e, 0x5b, 0xc5, 0x31, 0x9e, 0x27, 0xa5, 0x85, 0x38, 0x5c, 0x41, 0x95,
	0x7b, 0xd2, 0x3c, 0x24, 0x05, 0xe2, 0x17, 0x7a, 0x25, 0xae, 0xca, 0xa4, 0xe7, 0x2c, 0xb1, 0x32,
	0x32, 0xdb, 0x24, 0xe2, 0x90, 0x77, 0x44, 0xd3, 0x72, 0x07, 0x0d, 0x5f, 0x17, 0xd9, 0x8f, 0xbb,
	0x88, 0x06, 0x2f, 0x65, 0xb0, 0xf5, 0x22, 0x6a, 0xa3, 0x89, 0x04, 0xc8, 0x69, 0xb1, 0x79, 0xdd,
	0x46, 0x8e, 0x9f, 0xd7, 0x14, 0x05, 0x0a, 0xe6, 0xc9, 0x78, 0xd4, 0x94, 0xdd, 0x25, 0x5a, 0x0e,
	0xd0, 0xec, 0x57, 0x1a, 0x7d, 0x3a, 0xb6, 0x11, 0x1f, 0x9a, 0x35, 0x14, 0x32, 0x86, 0x6b, 0x03,
	0xa1, 0xaf, 0x5f, 0xfc, 0x29, 0x3f, 0x0e, 0x65, 0xc7, 0xd3, 0x9c, 0x87, 0xee, 0x32, 0xc6, 0xcd,
	0x49, 0x0b, 0xca, 0x7b, 0x1a, 0x75, 0x84, 0x34, 0x38, 0x0f, 0x1d, 0x8f, 0xdd, 0x4a, 0xe3, 0x7c,
	0x72, 0x3c, 0xf4, 0x62, 0x09, 0x4b, 0xd7, 0xc5, 0x6d, 0x66, 0xe9, 0x23, 0xba, 0x64, 0xb6, 0x8b,
	0xdf, 0xc6, 0x69, 0xce, 0x0c, 0x28, 0xdd, 0x93, 0x71, 0xd5, 0xaa, 0x20, 0x89, 0x04, 0x4f, 0xcd,
	0xb6, 0xf4, 0x3a, 0x7b, 0xee, 0xf0, 0x1c, 0x71, 0x1f, 0x26, 0x5c, 0x99, 0x54, 0x6d, 0x11, 0x79,
	0xbb, 0x83, 0xc1, 0x75, 0x7a, 0x78, 0xa6, 0x55, 0xa9, 0x4d, 0xad, 0x80, 0x73, 0xde, 0x61, 0x37,
	0x0e, 0x9b, 0xcb, 0x42, 0xa2, 0x4a, 0x21, 0x2e, 0x2a, 0xb9, 0xe5, 0x6f, 0x09, 0xd8, 0x62, 0xee,
	0x0a, 0x5a, 0x7d, 0x7e, 0xd8, 0xaa, 0xad, 0xb7, 0xeb, 0x69, 0x04, 0x39, 0x31, 0x43, 0x03, 0xcd,
	0x1f, 0xac, 0xa1, 0x8b, 0x9f, 0x09, 0x97, 0x82, 0x6b, 0x77, 0x95, 0x68, 0x7e, 0xb1, 0x8e, 0xee,
	0x7f, 0x98, 0x15, 0x02, 0x39, 0xb7, 0xd9, 0xb3, 0xe0, 0x7e, 0xfd, 0xc2, 0x22, 0x5f, 0xbe, 0xbb,
	0x36, 0x3e, 0xc9, 0xa4, 0x97, 0x95, 0x17, 0xd9, 0x4a, 0x7d, 0x81, 0xbd, 0x94, 0xbd, 0x48, 0x5b,
	0x02, 0x53, 0x4b, 0x94, 0x84, 0x94, 0x61, 0xb7, 0x27, 0xd6, 0xb6, 0x18, 0x18, 0x68, 0xc5, 0xd6,
	0xc8, 0xb5, 0xad, 0xca, 0x1d, 0xd0, 0xa8, 0xe5, 0x0a, 0x2b, 0x31, 0x14, 0xbc, 0x6b, 0x39, 0xda,
	0x79, 0x8d, 0xb9, 0x34, 0x23, 0x25, 0x3b, 0x9e, 0x6f, 0x64, 0x47, 0x04, 0xf9, 0x9c, 0xd6, 0xa9,
	0xee, 0xc4, 0x39, 0x29, 0xd9, 0x59, 0x40, 0x69, 0x36, 0xab, 0x59, 0x76, 0x8e, 0xc7, 0x54, 0xeb,
	0xb6, 0x65, 0x87, 0x67, 0xf1, 0xe1, 0x1e, 0x95, 0x2c, 0x56, 0x74, 0x47, 0x76, 0xb8, 0x8d, 0x04,
	0xaf, 0xb2, 0x89, 0xc1, 0x45, 0x6c, 0x4a, 0xc5, 0x03, 0x1f, 0xd2, 0xd4, 0x06, 0x8d, 0x53, 0x5c,
	0xba, 0xe5, 0x4c, 0x08, 0x25, 0x4c, 0xd7, 0x57, 0x82, 0x62, 0x48, 0xcc, 0xb3, 0xb0, 0x5a, 0x68,
	0x16, 0xe4, 0xf3, 0xad, 0x51, 0x09, 0x93, 0xc1, 0x57, 0x72, 0x74, 0xbf, 0x35, 0x90, 0xcd, 0xbe,
	0xc2, 0xce, 0x15, 0xe3, 0x50, 0xd6, 0x03, 0xbb, 0x7f, 0x54, 0x0f, 0xcc, 0x29, 0xa0, 0xb3, 0xb6,
	0xd7, 0x3c, 0x3b, 0xaf, 0x7b, 0xda, 0xf0, 0x8e, 0x27, 0x42, 0x1e, 0x1b, 0x98, 0x15, 0x91, 0xb3,
	0x3a, 0xd6, 0x2d, 0xe7, 0x48, 0xb8, 0x62, 0x65, 0x44, 0xa9, 0xde, 0x61, 0x93, 0x21, 0xd7, 0x81,
	0x12, 0x89, 0x91, 0xca, 0xeb, 0xfa, 0x91, 0x08, 0x0b, 0x2c, 0xb9, 0x41, 0x7d, 0xc6, 0x0f, 0xf7,
	0xcb, 0xee, 0x62, 0x8e, 0x7a, 0x98, 0x83, 0x90, 0xd2, 0xba, 0xe1, 0x11, 0x12, 0xe7, 0x1e, 0xbb,
	0x36, 0x50, 0x5d, 0xb4, 0x7d, 0xdd, 0xf6, 0x5a, 0x4a, 0x0e, 0x2f, 0xd3, 0x26, 0x2e, 0xd3, 0x74,
	0x11, 0x7b, 0xc7, 0xd7, 0xed, 0xb7, 0x01, 0x59, 0x5c, 0xa3, 0x25, 0x56, 0xa6, 0xe2, 0x5b, 0xaa,
	0x50, 0xc4, 0x58, 0xa8, 0xd9, 0xfa, 0xac, 0xc9, 0x15, 0xb0, 0x59, 0xed, 0x3e, 0xa0, 0xa8, 0x87,
	0xb0, 0x0d, 0x42, 0x65, 0x95, 0x59, 0x86, 0x71, 0x1e, 0xb2, 0x99, 0xc1, 0x0f, 0x2f, 0x3a, 0x89,
	0x92, 0x5d, 0x1e, 0xc2, 0xf6, 0x7c, 0x2f, 0x4b, 0xd3, 0xd4, 0x8c, 0x7a, 0x68, 0xdb, 0x03, 0x05,
	0x4f, 0x58, 0xb1, 0xe8, 0xc5, 0x3e, 0x98, 0xfa, 0x52, 0x82, 0xdd, 0x1e, 0xb4, 0x8b, 0x7b, 0x20,
	0xaf, 0xc5, 0x30, 0xb7, 0x50, 0x35, 0x08, 0xff, 0xd1, 0x3a, 0x6c, 0xf5, 0xdc, 0xcf, 0xe1, 0x10,
	0x37, 0x8b, 0x43, 0xe0, 0x76, 0xc8, 0xaa, 0xb4, 0x65, 0xa9, 0x1a, 0x99, 0x16, 0x2e, 0x49, 0xa5,
	0xe7, 0xbc, 0xc1, 0x2e, 0xf4, 0x37, 0x09, 0x70, 0x39, 0x51, 0x28, 0x77, 0x3f, 0x4f, 0x35, 0x5f,
	0xb6, 0x4b, 0xea, 0x24, 0xce, 0x16, 0xf1, 0x21, 0x9b, 0x09, 0x79, 0x10, 0xf9, 0x8a, 0x7b, 0x41,
	0xaa, 0x34, 0xce, 0xc9, 0xa6, 0xad, 0xcc, 0xeb, 0x72, 0x4b, 0xef, 0xd0, 0xdb, 0x5b, 0x7c, 0x15,
	0xe1, 0x79, 0x92, 0xb3, 0x5e, 0x97, 0xd9, 0x6d, 0xb3, 0xf9, 0x23, 0x56, 0x95, 0xe8, 0x42, 0x71,
	0x6d, 0x61, 0x25, 0xb0, 0xab, 0xe6, 0x7e, 0xe1, 0xf0, 0xcb, 0x67, 0xeb, 0x8b, 0x54, 0xa2, 0xb0,
	0xc8, 0xcb, 0x92, 0x5a, 0xaf, 0xce, 0x06, 0xbb, 0x3e, 0x8a, 0xc5, 0x62, 0x3a, 0xe8, 0xc0, 0x8a,
	0x67, 0xd3, 0xff, 0xef, 0xe4, 0x57, 0x87, 0xf8, 0xec, 0x46, 0x4c, 0x5d, 0x8b, 0x82, 0x5f, 0xf5,
	0xa7, 0xee, 0x47, 0xbb, 0x7e, 0x4f, 0x0f, 0xf7, 0x34, 0xdf, 0x25, 0xbf, 0xca, 0x61, 0x0b, 0x88,
	0x1a, 0xec, 0x6c, 0xae, 0xb2, 0xab, 0x96, 0x5a, 0x04, 0x8a, 0x43, 0x2d, 0x8e, 0x2e, 0xe4, 0xa5,
	0x1a, 0x19, 0xff, 0x9e, 0x51, 0xbc, 0xc3, 0xb5, 0xeb, 0xa1, 0xa5, 0x29, 0x42, 0x56, 0x11, 0x88,
	0xee, 0xf3, 0x00, 0x60, 0x4b, 0x16, 0xe5, 0xbc, 0xc7, 0x6e, 0x93, 0xab, 0x2b, 0x09, 0x29, 0x9e,
	0x77, 0xb6, 0xb8, 0xd2, 0x6d, 0x91, 0x68, 0xcf, 0x48, 0x5b, 0x71, 0x7a, 0x61, 0x8a, 0x6e, 0x55,
	0x08, 0x04, 0xee, 0x97, 0xd0, 0xf8, 0x2d, 0x54, 0xad, 0xcb, 0x88, 0xaf, 0xf7, 0x15, 0x37, 0x25,
	0x55, 0x9c, 0x8b, 0xa8, 0x55, 0x60, 0x2f, 0x4e, 0x95, 0x4d, 0xd9, 0x26, 0x5f, 0x58, 0x60, 0x3d,
	0x54, 0x88, 0x12, 0xd9, 0xf4, 0x31, 0x3b, 0x5f, 0xcc, 0x50, 0x7d, 0x9e, 0x83, 0xe5, 0x23, 0x92,
	0xcd, 0x22, 0x23, 0x01, 0xbb, 0x5d, 0xee, 0x25, 0x52, 0x19, 0x3f, 0xea, 0xfb, 0x65, 0x38, 0xc8,
	0x48, 0x16, 0x10, 0x55, 0x23, 0x50, 0xf6, 0x29, 0x5e, 0x67, 0x6e, 0x1a, 0x6f, 0xc9, 0x34, 0x0e,
	0x79, 0xe8, 0x25, 0xbe, 0xf2, 0xa3, 0x88, 0x47, 0xb6, 0xc3, 0xc6, 0xc9, 0xaf, 0x73, 0x79, 0xcd,
	0x8a, 0xa9, 0xc3, 0xd6, 0x64, 0x2f, 0xf7, 0x3f, 0x22, 0xa5, 0x25, 0x48, 0xfd, 0x4a, 0xf1, 0xc8,
	0x37, 0x3c, 0xf4, 0xf2, 0x40, 0xad, 0xd3, 0xad, 0x9d, 0x94, 0xc3, 0x96, 0x70, 0x9b, 0x43, 0xde,
	0x87, 0xb9, 0xe9, 0x41, 0x41, 0x6b, 0xc9, 0x2a, 0x35, 0x72, 0x1d, 0x78, 0xd1, 0xc3, 0x79, 0xdd,
	0xfa, 0x63, 0xe2, 0xc7, 0x22, 0xd0, 0x6e, 0x8b, 0x5e, 0x74, 0x38, 0x99, 0xaf, 0x20, 0xa8, 0x86,
	0x18, 0xa7, 0xcb, 0xde, 0x38, 0x62, 0xbb, 0x0c, 0x77, 0x9f, 0x9a, 0x02, 0x28, 0xad, 0xf6, 0x20,
	0x1a, 0x74, 0x29, 0xa3, 0xb6, 0x71, 0x80, 0xdb, 0xa3, 0x76, 0xcd, 0x60, 0x3f, 0x6a, 0x99, 0x74,
	0x17, 0x73, 0x55, 0x28, 0x01, 0x8b, 0x45, 0x81, 0xd0, 0x32, 0xa2, 0x78, 0x1f, 0x01, 0xfb, 0x77,
	0x05, 0x7e, 0x69, 0xb7, 0x5f, 0x03, 0xac, 0x64, 0x00, 0xac, 0x0e, 0x9c, 0x47, 0x6c, 0xac, 0xd0,
	0xc9, 0xa2, 0x24, 0xf1, 0xde, 0x74, 0x69, 0xe6, 0xf4, 0xfc, 0xcd, 0x8f, 0x2c, 0xd5, 0x0a, 0xfd,
	0x2d, 0x4c, 0x1a, 0x67, 0xd4, 0xe0, 0x03, 0xc8, 0xaa, 0x47, 0xac, 0x07, 0xa5, 0x0a, 0x88, 0xa5,
	0x31, 0xbd, 0xfd, 0x36, 0x65, 0xd5, 0x51, 0x6f, 0x8f, 0xd9, 0xa2, 0x0f, 0x75, 0x4c, 0xa1, 0xb7,
	0xdc, 0xdc, 0xf6, 0x22, 0x19, 0x6c, 0xe7, 0x91, 0x18, 0x9b, 0x3b, 0xe2, 0x31, 0x92, 0xe5, 0x08,
	0x9b, 0xfa, 0xd7, 0x0e, 0xf6, 0xcb, 0xd3, 0x19, 0xbf, 0x5f, 0xbe, 0xbb, 0x46, 0x68, 0x88, 0xbf,
	0x05, 0x6c, 0x7d, 0x3a, 0xb3, 0xb8, 0xbc, 0x3d, 0x1a, 0xe1, 0xbc, 0xcd, 0xa6, 0xc3, 0x54, 0x61,
	0x24, 0x38, 0x72, 0xc4, 0x0e, 0xb1, 0x33, 0x8b, 0x3b, 0xc2, 0xd0, 0x12, 0x2b, 0xeb, 0x36, 0xee,
	0xcb, 0x23, 0xed, 0x24, 0xe4, 0x6b, 0x04, 0x3b, 0xc2, 0x4c, 0x85, 0x4d, 0x75, 0xfc, 0xbd, 0x3c,
	0x4f, 0x80, 0x0d, 0x6c, 0x58, 0x50, 0xb8, 0x34, 0x3c, 0x74, 0x63, 0x2c, 0xe0, 0x26, 0x3b, 0xfe,
	0x9e, 0xcd, 0x16, 0xcb, 0x12, 0x4f, 0x8e, 0xaa, 0x19, 0xc2, 0xb9, 0xc3, 0xc6, 0xb5, 0x51, 0x22,
	0x30, 0x5e, 0x18, 0x46, 0x96, 0x97, 0x01, 0x71, 0x95, 0xb8, 0x72, 0xcf, 0x1e, 0xec, 0x97, 0x9d,
	0x06, 0xca, 0x17, 0x17, 0xd7, 0x16, 0x32, 0x69, 0xdd, 0x21, 0x9d, 0xc5, 0x30, 0xca, 0x9f, 0x39,
	0x9f, 0x65, 0x97, 0xd2, 0x18, 0x0f, 0x61, 0x34, 0x37, 0x86, 0xc8, 0xbb, 0xe1, 0x0a, 0xde, 0x10,
	0x0a, 0x10, 0x77, 0x07, 0xc9, 0xca, 0x05, 0xc2, 0x34, 0x08, 0xb2, 0x92, 0x21, 0xee, 0xf2, 0x9e,
	0x73, 0x9f, 0x3d, 0x3f, 0x94, 0x67, 0x41, 0x55, 0x26, 0x87, 0x17, 0x47, 0xd1, 0x91, 0xc1, 0x40,
	0x6a, 0x95, 0xc1, 0xf6, 0x46, 0x32, 0xbc, 0x42, 0x6b, 0xec, 0xb9, 0x41, 0x93, 0xe0, 0x4e, 0x02,
	0x62, 0x50, 0x3f, 0x7b, 0x8b, 0x3d, 0x57, 0xa3, 0xbd, 0x72, 0xd1, 0x5e, 0xcd, 0x02, 0xf3, 0x6c,
	0x2d, 0xf6, 0x9c, 0x45, 0x36, 0x95, 0xf1, 0x63, 0x0a, 0xd5, 0x4d, 0xce, 0xc3, 0x81, 0x0e, 0xb0,
	0xa1, 0xaf, 0x66, 0x51, 0xd5, 0x1c, 0x54, 0x6c, 0x03, 0xaf, 0xb2, 0x8b, 0x98, 0xe3, 0x8f, 0xa8,
	0xdd, 0xd3, 0x11, 0xb5, 0xfb, 0x04, 0x28, 0x8c, 0x2a, 0xdc, 0x17, 0xd8, 0x65, 0xb4, 0x85, 0xdd,
	0x69, 0x2f, 0x11, 0x09, 0x8f, 0xc4, 0xc0, 0xe1, 0x4a, 0x97, 0x0e, 0x92, 0x00, 0xf4, 0x08, 0x30,
	0xb5, 0x1c, 0x52, 0x38, 0x8b, 0xea, 0x2f, 0x51, 0x87, 0xab, 0x16, 0xb7, 0x07, 0x63, 0x99, 0x89,
	0x5d, 0x32, 0x91, 0x83, 0xd6, 0x01, 0x83, 0x19, 0x3b, 0x33, 0xf1, 0x26, 0xc3, 0x01, 0xbc, 0x38,
	0xed, 0x93, 0x16, 0xa8, 0xe4, 0xb1, 0xe0, 0x76, 0xf7, 0xd0, 0x07, 0x91, 0xb6, 0xdc, 0x4b, 0x33,
	0xd6, 0x52, 0xe3, 0x54, 0x5a, 0x3b, 0x77, 0xa9, 0x85, 0x66, 0x33, 0xfc, 0x16, 0x07, 0xb2, 0x0e,
	0xae, 0xe8, 0xf6, 0xd0, 0x01, 0x27, 0x0e, 0xf6, 0xcb, 0xe7, 0x16, 0x52, 0x23, 0xc9, 0x63, 0x2b,
	0x28, 0x5f, 0x5c, 0x5c, 0xa3, 0xde, 0x5a, 0x50, 0x7c, 0x18, 0x46, 0xce, 0x2b, 0x6c, 0x22, 0x88,
	0xa4, 0xce, 0x18, 0x90, 0xf6, 0x7c, 0x93, 0x9d, 0x70, 0x3c, 0xc6, 0xb7, 0x18, 0x47, 0x31, 0x11,
	0x1e, 0xbd, 0x60, 0xec, 0x21, 0xc7, 0x06, 0x9b, 0x48, 0xa2, 0xa4, 0xa5, 0x77, 0x22, 0xf4, 0x11,
	0xbb, 0x1f, 0x44, 0x6c, 0xa4, 0xfb, 0x3f, 0x70, 0x16, 0xee, 0xc1, 0x7e, 0x79, 0xbc, 0xb6, 0x96,
	0xb4, 0xa8, 0x97, 0x49, 0x1b, 0x62, 0x25, 0x36, 0xb2, 0x3e, 0x6e, 0x15, 0x07, 0x9e, 0x42, 0x21,
	0x35, 0xe8, 0x76, 0x5d, 0xa1, 0x4c, 0x3a, 0xe2, 0x04, 0x82, 0xc8, 0xe8, 0xff, 0xa4, 0x42, 0xaa,
	0xe8, 0x7e, 0x0f, 0x49, 0x61, 0x30, 0xea, 0x13, 0x1d, 0xfd, 0x12, 0xbb, 0x35, 0x68, 0xdc, 0x28,
	0x01, 0x44, 0xc5, 0xd3, 0xa2, 0x23, 0x22, 0x5f, 0x15, 0x8e, 0x4f, 0xc9, 0x29, 0xff, 0x17, 0x9a,
	0x7f, 0xb1, 0x68, 0x7e, 0x93, 0x54, 0x1a, 0xb9, 0xc6, 0x46, 0x41, 0xc1, 0xe9, 0xb0, 0x57, 0x8e,
	0x26, 0xd2, 0x46, 0xc4, 0x01, 0xb6, 0x10, 0x88, 0x05, 0xb7, 0x45, 0x6c, 0xb0, 0x9a, 0x16, 0x71,
	0xcb, 0xfd, 0x32, 0x8e, 0x34, 0x7b, 0x04, 0xab, 0x46, 0xcd, 0x0d, 0xaa, 0x09, 0xef, 0x88, 0xd8,
	0x54, 0x49, 0xcb, 0x91, 0x47, 0x0e, 0x37, 0xe2, 0xcd, 0xe8, 0x90, 0x4d, 0x74, 0x21, 0x46, 0xfd,
	0x6f, 0x1c, 0xee, 0xe5, 0x51, 0xc3, 0x1d, 0x7a, 0xc1, 0x46, 0x5f, 0x0f, 0x4a, 0xf8, 0x23, 0x06,
	0x2c, 0x9e, 0xe2, 0x66, 0x2f, 0xf5, 0x7f, 0x4a, 0x38, 0xcc, 0xf5, 0x51, 0xc3, 0xbc, 0x93, 0x1f,
	0xed, 0x66, 0x2f, 0x93, 0xb2, 0xd7, 0x8f, 0xb0, 0x9d, 0x9f, 0x87, 0xe3, 0x87, 0xef, 0x4f, 0xc7,
	0x03, 0x3a, 0xd1, 0xf1, 0x0d, 0x77, 0xff, 0x2f, 0x8d, 0x34, 0x3f, 0x6a, 0xa4, 0xec, 0xa8, 0x1c,
	0xdc, 0xa0, 0xaf, 0xbb, 0x64, 0x55, 0x9d, 0xdd, 0x22, 0xed, 0x40, 0x0d, 0xdb, 0x07, 0xa3, 0x7c,
	0x8e, 0xbd, 0xc6, 0x23, 0x9c, 0x50, 0xbb, 0xff, 0xaf, 0x34, 0xc4, 0x3b, 0x20, 0xf8, 0xd9, 0x86,
	0x18, 0xea, 0x3f, 0x12, 0xa6, 0x3d, 0xd2, 0x23, 0xb5, 0x53, 0x63, 0xd7, 0x0b, 0x03, 0xa7, 0xba,
	0xed, 0xc9, 0x66, 0x53, 0x73, 0xda, 0x3e, 0xb6, 0x7d, 0x03, 0xcb, 0xe9, 0x7e, 0x85, 0x06, 0x99,
	0xee, 0x0f, 0x92, 0xea, 0xf6, 0x06, 0x62, 0x61, 0xcf, 0x60, 0xe3, 0x02, 0x16, 0xd2, 0x69, 0xb0,
	0x33, 0xd8, 0x59, 0x26, 0x9e, 0x8a, 0x4c, 0xe4, 0xab, 0x25, 0xa4, 0x22, 0x37, 0x3e, 0x92, 0x8a,
	0xd4, 0x22, 0x3f, 0x46, 0xde, 0x8a, 0x44, 0xe4, 0x54, 0x52, 0xfc, 0xd7, 0x79, 0x30, 0x4c, 0x43,
	0x12, 0x19, 0xf5, 0x3a, 0x52, 0x25, 0x6d, 0x11, 0x20, 0x1f, 0xed, 0x70, 0xc3, 0x15, 0x26, 0x83,
	0x9f, 0x28, 0x1d, 0xe6, 0x21, 0xb5, 0x3e, 0xba, 0x96, 0x81, 0x21, 0x23, 0xf4, 0xd8, 0xf3, 0x52,
	0x89, 0x96, 0x88, 0x3d, 0x11, 0x62, 0x9a, 0x8a, 0x64, 0x4b, 0x04, 0x7e, 0x84, 0xd7, 0x90, 0x06,
	0x32, 0xc3, 0x4f, 0x82, 0xd5, 0x53, 0x95, 0xeb, 0x07, 0xfb, 0xe5, 0x2b, 0x1b, 0xa8, 0xb2, 0xb2,
	0xb8, 0x2c, 0xd5, 0x1a, 0xe1, 0x17, 0x7d, 0xe3, 0x17, 0x72, 0x44, 0xfd, 0x0a, 0x59, 0x5d, 0x09,
	0x8f, 0x84, 0x38, 0x5f, 0x64, 0x37, 0x7f, 0x74, 0x55, 0xe2, 0x6d, 0x49, 0x19, 0x79, 0x3c, 0x4e,
	0x3b, 0xee, 0xd7, 0x4a, 0xb6, 0x13, 0xf9, 0x91, 0x05, 0x4a, 0x45, 0xca, 0x68, 0x29, 0x4e, 0x3b,
	0x87, 0x17, 0x0c, 0x53, 0x43, 0xe8, 0xd9, 0x2b, 0x24, 0x38, 0x1a, 0x6c, 0xe9, 0x40, 0xbb, 0x3f,
	0x35, 0x62, 0xc1, 0x30, 0x49, 0x84, 0x35, 0x02, 0x37, 0x72, 0xac, 0xb3, 0x3e, 0x9c, 0x90, 0x03,
	0x19, 0x87, 0x78, 0xd0, 0xef, 0x47, 0x96, 0xdd, 0xc3, 0x37, 0x78, 0xbf, 0x74, 0x38, 0x23, 0x57,
	0xfb, 0x48, 0xe4, 0xf3, 0xb0, 0xfe, 0x01, 0x9b, 0x1b, 0xf2, 0x3e, 0x8a, 0x4a, 0xe8, 0x7c, 0xb6,
	0x7b, 0x65, 0x89, 0x36, 0x14, 0x41, 0x81, 0x1f, 0xbb, 0x3f, 0x5d, 0x1a, 0x0a, 0x87, 0xe0, 0x87,
	0x18, 0x93, 0xc0, 0x0d, 0x6d, 0x03, 0x6b, 0xd9, 0xaa, 0xe0, 0xd9, 0xf6, 0x57, 0x4b, 0xec, 0x96,
	0xfd, 0xca, 0xf9, 0xad, 0xb0, 0x8f, 0xfe, 0xd8, 0x3f, 0x03, 0x63, 0x9c, 0x9c, 0xbf, 0x5c, 0xf0,
	0xd7, 0xd4, 0x88, 0x68, 0xb6, 0x1d, 0x05, 0xb3, 0x9b, 0x99, 0x89, 0xca, 0xf1, 0xef, 0xed, 0x97,
	0x8f, 0xd5, 0x67, 0xc8, 0x74, 0xfe, 0xf8, 0xe8, 0x2f, 0x1e, 0xb0, 0xa9, 0xad, 0x5e, 0xe2, 0x6b,
	0xed, 0x25, 0x01, 0x31, 0x3d, 0xae, 0xf2, 0xa3, 0x71, 0x5f, 0x6a, 0xe3, 0xfe, 0x2c, 0xbe, 0x5b,
	0x65, 0xea, 0x60, 0xbf, 0x3c, 0x59, 0x41, 0x68, 0xad, 0x5a, 0xaf, 0x23, 0xd0, 0x1e, 0x90, 0x2f,
	0x6c, 0x34, 0x36, 0xeb, 0x93, 0x64, 0xa6, 0x16, 0xa8, 0x41, 0x99, 0xd4, 0xc6, 0x79, 0xc4, 0x66,
	0x2c, 0x8b, 0xa3, 0x3a, 0x15, 0x42, 0x70, 0x0b, 0xca, 0x14, 0x6c, 0x47, 0xf7, 0xc0, 0xb9, 0xb2,
	0x3b, 0x6b, 0xee, 0xcf, 0xd1, 0x52, 0x5e, 0x23, 0x85, 0x05, 0xc0, 0x6f, 0x5a, 0xf8, 0x7a, 0x86,
	0xce, 0x6e, 0xa8, 0x39, 0x1b, 0xec, 0x5a, 0x46, 0x9e, 0xba, 0x3c, 0xf0, 0xd2, 0x18, 0xe2, 0x12,
	0xf7, 0x5b, 0xf8, 0x0e, 0x71, 0xc0, 0x23, 0x2a, 0x47, 0xdc, 0x9f, 0xb7, 0x71, 0xc2, 0x82, 0x1f,
	0xf2, 0xe0, 0x01, 0x40, 0x97, 0x00, 0x59, 0x2d, 0x00, 0x9d, 0xdb, 0xec, 0xbc, 0xe2, 0x90, 0xe8,
	0xf1, 0xda, 0x1f, 0x4f, 0x8c, 0xfd, 0xf8, 0xee, 0xd7, 0x4b, 0x58, 0xec, 0x9c, 0xcb, 0xa5, 0x8b,
	0x20, 0xa4, 0x83, 0x8b, 0x4d, 0xf6, 0x42, 0xff, 0x9a, 0x54, 0xde, 0xab, 0xf1, 0x94, 0xdc, 0xf5,
	0x02, 0x99, 0xc6, 0xc6, 0x33, 0x6d, 0xc5, 0x75, 0x5b, 0x46, 0xa1, 0xfb, 0x0b, 0x60, 0xe6, 0x78,
	0xfd, 0x6a, 0x1f, 0x6f, 0xbb, 0x34, 0x75, 0xb9, 0x5b, 0x05, 0xec, 0x66, 0x06, 0x05, 0xaf, 0x2e,
	0x58, 0xd5, 0x52, 0x99, 0x91, 0x16, 0x7f, 0x91, 0x2c, 0x96, 0xfb, 0xd8, 0x86, 0x54, 0xe6, 0x47,
	0x9a, 0xb3, 0xe7, 0x7f, 0x87, 0xcc, 0x7d, 0xe3, 0xb0, 0x39, 0x3a, 0x10, 0x1c, 0x32, 0xf7, 0x16,
	0xbb, 0x64, 0x9b, 0x1f, 0x05, 0xab, 0xf9, 0xd1, 0xa2, 0x76, 0x7f, 0x89, 0x56, 0xfc, 0x02, 0x81,
	0xfa, 0x57, 0xc3, 0xb2, 0x23, 0x46, 0x3d, 0x34, 0x21, 0xcc, 0x8e, 0xa3, 0x26, 0xf4, 0xcb, 0x87,
	0x26, 0x04, 0x01, 0xfd, 0xf0, 0x84, 0x6e, 0xb3, 0xf3, 0x11, 0x6f, 0xf9, 0x41, 0xcf, 0xeb, 0xfa,
	0x2a, 0x68, 0xfb, 0xca, 0x33, 0xbd, 0x04, 0x52, 0xed, 0xaf, 0xd0, 0x4c, 0xce, 0x91, 0xf4, 0x21,
	0x09, 0x37, 0x51, 0x06, 0x54, 0x9e, 0x4e, 0xe6, 0x86, 0x6f, 0xe8, 0x78, 0x22, 0xf6, 0x3a, 0x29,
	0x75, 0x99, 0xb5, 0xfb, 0xab, 0x64, 0x62, 0x0a, 0xb1, 0x83, 0x97, 0x75, 0x56, 0xe2, 0xf5, 0x0c,
	0xe6, 0x34, 0xd8, 0xf3, 0xd9, 0xce, 0x09, 0x45, 0x8b, 0x6b, 0x03, 0x01, 0x2d, 0xe2, 0x31, 0xd7,
	0xda, 0xa3, 0x73, 0xbd, 0x8c, 0xfe, 0x7e, 0x93, 0x0c, 0x5e, 0xb5, 0xf0, 0x45, 0x44, 0x37, 0x32,
	0x70, 0x15, 0xb0, 0x19, 0x0f, 0xae, 0xb1, 0x6b, 0xc5, 0x24, 0x8c, 0x77, 0xcd, 0xb2, 0x9e, 0x47,
	0xe0, 0x53, 0xd7, 0x12, 0x78, 0xcb, 0xaf, 0x97, 0x86, 0xea, 0x17, 0xba, 0x70, 0x56, 0x21, 0x68,
	0xb5, 0x8f, 0x1c, 0xec, 0x65, 0x77, 0x8a, 0xcb, 0xee, 0xfe, 0x46, 0x09, 0x8f, 0x16, 0xc6, 0xfb,
	0xbc, 0xbc, 0xbf, 0xd4, 0xce, 0x6b, 0x6c, 0x82, 0x0e, 0x30, 0x79, 0x48, 0xb5, 0x41, 0x9f, 0xce,
	0xff, 0x26, 0x0d, 0x7e, 0x3e, 0x93, 0x63, 0x59, 0x90, 0x53, 0xf9, 0x81, 0x82, 0x89, 0x16, 0x82,
	0x6e, 0x9e, 0x0c, 0x0e, 0xfe, 0x01, 0x0d, 0x3e, 0x95, 0x63, 0x71, 0x1d, 0xf0, 0x12, 0x4a, 0x71,
	0x1a, 0x3e, 0x9b, 0x2d, 0x2c, 0x08, 0x24, 0xf5, 0x81, 0xab, 0x77, 0xc8, 0x4a, 0x14, 0xef, 0x72,
	0xa5, 0xb3, 0xdb, 0x56, 0xbf, 0x45, 0xb3, 0xeb, 0x37, 0x72, 0x21, 0xab, 0x17, 0x2e, 0xdc, 0x01,
	0x13, 0xa9, 0x93, 0x06, 0xb9, 0xe6, 0x7d, 0x76, 0x5d, 0xf1, 0x96, 0xd0, 0x90, 0xbd, 0x23, 0x3c,
	0xe0, 0xdb, 0xf5, 0xf1, 0xc2, 0x59, 0x6c, 0x78, 0x8c, 0xdc, 0x87, 0x77, 0xf1, 0xb0, 0xef, 0xb7,
	0xed, 0xa2, 0x67, 0xe8, 0x35, 0x00, 0x3f, 0xf2, 0x85, 0xa9, 0xe6, 0xd0, 0x25, 0x44, 0x3a, 0x21,
	0x2b, 0x63, 0x66, 0x4a, 0x52, 0xa3, 0xe9, 0xac, 0x2c, 0xce, 0x6e, 0x35, 0x65, 0x67, 0x30, 0xbf,
	0x53, 0x08, 0xb4, 0x90, 0x9a, 0x6a, 0xa9, 0xd1, 0x1b, 0xf1, 0x3d, 0x19, 0xd3, 0x7d, 0x26, 0x7b,
	0x0a, 0x53, 0x9f, 0x4c, 0x35, 0xaf, 0x26, 0x23, 0x65, 0x4e, 0x93, 0x7d, 0x72, 0xf8, 0x13, 0x65,
	0x35, 0x2f, 0xf6, 0xa0, 0x46, 0x8e, 0xfb, 0xbb, 0xf4, 0x12, 0x37, 0x06, 0x3f, 0x9e, 0x2d, 0x7f,
	0x45, 0xdc, 0x1a, 0x31, 0xce, 0xbb, 0xec, 0xe6, 0x88, 0xaa, 0x9a, 0x47, 0x02, 0xe3, 0x66, 0xde,
	0xdb, 0x6b, 0xfa, 0x1d, 0x11, 0x09, 0xae, 0xdd, 0xdf, 0x2b, 0xd9, 0x83, 0xd7, 0xa1, 0xe2, 0x7a,
	0x89, 0x34, 0xd6, 0xad, 0xc2, 0xb2, 0xc5, 0x3b, 0x95, 0x62, 0xfd, 0x68, 0x19, 0x49, 0x71, 0x08,
	0xf7, 0x5b, 0xa5, 0xa1, 0x02, 0x92, 0x7c, 0xad, 0x60, 0xd3, 0xb9, 0x57, 0xdc, 0x38, 0x30, 0xc7,
	0x90, 0x47, 0xdc, 0x70, 0x4f, 0x61, 0x3f, 0xb4, 0x7f, 0x39, 0xee, 0xdb, 0x23, 0x68, 0xc1, 0x22,
	0x42, 0xeb, 0x80, 0xcc, 0xaf, 0xcb, 0x09, 0x36, 0x4f, 0xd9, 0xcb, 0x52, 0x23, 0x9b, 0xc4, 0xfa,
	0x67, 0xf5, 0xe8, 0x79, 0xbe, 0x6a, 0x75, 0x8b, 0x67, 0x0c, 0xbf, 0x4f, 0xd6, 0x6f, 0xa2, 0x2a,
	0x11, 0x24, 0x9b, 0xce, 0xb2, 0x73, 0x7c, 0xf0, 0xbe, 0x05, 0xd5, 0xea, 0x16, 0x0e, 0x1d, 0x96,
	0x58, 0x39, 0x1b, 0x04, 0x5f, 0x1d, 0x2d, 0xdb, 0x1b, 0x44, 0xb0, 0x0c, 0x3c, 0x74, 0xbf, 0x53,
	0xb2, 0x67, 0xfa, 0x64, 0x12, 0x60, 0x60, 0x88, 0xae, 0x0b, 0xad, 0x21, 0xc6, 0xa9, 0xb0, 0x29,
	0x6a, 0x4f, 0x70, 0x6f, 0xfe, 0x15, 0x6f, 0xde, 0xc3, 0xa3, 0xa5, 0x50, 0x04, 0xde, 0x56, 0x2a,
	0x22, 0x23, 0x62, 0xed, 0xfe, 0x81, 0x8d, 0xd2, 0xa9, 0xe6, 0x35, 0xc5, 0xe7, 0x5f, 0x99, 0x7f,
	0x68, 0x21, 0x15, 0x8b, 0x80, 0x60, 0xd1, 0xe5, 0x81, 0xc1, 0x66, 0x09, 0x84, 0x4e, 0x6f, 0x8b,
	0x63, 0xed, 0xf4, 0x98, 0xbb, 0xdf, 0x2d, 0x61, 0x11, 0x3e, 0x4e, 0x72, 0xba, 0x33, 0x5b, 0xe1,
	0x50, 0x1f, 0x3d, 0xe6, 0x4e, 0xc8, 0xe6, 0xfa, 0xf7, 0xcc, 0xfc, 0xb0, 0x23, 0xe8, 0x12, 0x50,
	0x9b, 0x08, 0x86, 0x91, 0x5e, 0xc4, 0xfd, 0x66, 0xb1, 0x1d, 0xad, 0xdd, 0x3f, 0xb4, 0x7e, 0x98,
	0xeb, 0x2d, 0x64, 0x6a, 0x77, 0x50, 0x6b, 0x53, 0xae, 0x71, 0xbf, 0x59, 0x68, 0x46, 0x6b, 0xa7,
	0x3e, 0xdc, 0xdd, 0xe1, 0x7b, 0x42, 0x1b, 0x6d, 0xd9, 0x99, 0xe5, 0x7e, 0x2a, 0x8d, 0xb8, 0xfb,
	0x47, 0xa5, 0xc3, 0xed, 0x9d, 0x25, 0x04, 0x13, 0x2d, 0x43, 0xf6, 0x57, 0x4f, 0x23, 0xee, 0x08,
	0x36, 0x23, 0x62, 0x81, 0x7c, 0x94, 0x8e, 0x0c, 0xb6, 0xfc, 0x60, 0x5b, 0x36, 0x9b, 0xa3, 0x5a,
	0x61, 0x7f, 0x5c, 0x3a, 0xea, 0xc8, 0xed, 0x39, 0x6b, 0x03, 0x4f, 0x12, 0x2a, 0x64, 0xe1, 0x50,
	0x9f, 0x0c, 0x78, 0x51, 0xb1, 0x9a, 0x53, 0x32, 0x35, 0x22, 0x06, 0x4f, 0x4d, 0x78, 0x1c, 0xf2,
	0x38, 0xe8, 0xc1, 0x0a, 0xe1, 0x26, 0x74, 0xff, 0x24, 0xe3, 0x45, 0xfd, 0xf2, 0xad, 0x4e, 0xf0,
	0xc5, 0x1c, 0xbd, 0x69, 0xc1, 0xce, 0xbf, 0x94, 0xd8, 0x67, 0x0f, 0x1f, 0x24, 0x07, 0x4a, 0x6a,
	0x9d, 0x5d, 0x8d, 0xb0, 0x84, 0xab, 0x70, 0x98, 0x8b, 0xef, 0xb7, 0xa5, 0xec, 0x85, 0x48, 0xf7,
	0x4f, 0x29, 0x1c, 0xbd, 0x79, 0xb0, 0x5f, 0x7e, 0x75, 0xf8, 0x8c, 0xb9, 0x0a, 0x96, 0xe8, 0x68,
	0xd4, 0x72, 0xb1, 0x6c, 0x9b, 0xc0, 0x3b, 0x56, 0xea, 0x74, 0x65, 0xb2, 0xfe, 0xaa, 0xfc, 0xb1,
	0xf4, 0xb6, 0x14, 0xe9, 0x39, 0x09, 0x51, 0x83, 0xac, 0x77, 0xa2, 0x78, 0x98, 0x06, 0x3c, 0x24,
	0x97, 0xa1, 0xae, 0x94, 0xe6, 0x46, 0xbb, 0x7f, 0x46, 0x33, 0xbc, 0x7a, 0xb0, 0x5f, 0x9e, 0xb2,
	0x97, 0xfb, 0x1e, 0x68, 0x5e, 0x27, 0x34, 0xf8, 0x0a, 0x46, 0xb2, 0x06, 0x37, 0xba, 0x3e, 0x65,
	0xed, 0x1d, 0x21, 0x77, 0x3e, 0xcf, 0x6e, 0xd8, 0x4e, 0x5e, 0x80, 0x3d, 0x34, 0x08, 0xf5, 0x0a,
	0xaa, 0x9c, 0x3d, 0xc3, 0xe9, 0x78, 0x41, 0x49, 0x23, 0x03, 0x19, 0x61, 0x25, 0xf1, 0xe7, 0xfd,
	0x6f, 0x51, 0x53, 0x32, 0xd8, 0xdc, 0x8b, 0xab, 0x84, 0x5f, 0xb2, 0xf0, 0x9a, 0x45, 0x43, 0x39,
	0xf1, 0x22, 0x1b, 0xcb, 0xae, 0xb5, 0x04, 0x2a, 0xdd, 0xf2, 0xde, 0x93, 0x5b, 0xee, 0x5f, 0x90,
	0x81, 0xd3, 0xf6, 0x4e, 0x0b, 0x3c, 0x5f, 0x95, 0x5b, 0x40, 0x24, 0x29, 0xc4, 0x74, 0x05, 0xdf,
	0xb5, 0xbb, 0xde, 0x5e, 0x7d, 0xf3, 0x44, 0xdc, 0x95, 0xdb, 0x90, 0x3f, 0x23, 0x3f, 0xd5, 0xdc,
	0xfd, 0x4b, 0xcb, 0x20, 0x10, 0xff, 0x50, 0xf0, 0x5d, 0xdc, 0xfd, 0x16, 0xbc, 0x42, 0xd8, 0x2a,
	0x42, 0x9d, 0x65, 0x56, 0x1e, 0xdc, 0xc2, 0x8a, 0x2b, 0x3f, 0xde, 0xce, 0xc2, 0xb4, 0xe0, 0xca,
	0xfd, 0x2b, 0xda, 0xca, 0x97, 0x8a, 0x5b, 0xb9, 0x8e, 0xa8, 0xf5, 0x1c, 0xe4, 0xbc, 0xc7, 0x6e,
	0x67, 0x87, 0x2c, 0xe2, 0x71, 0x76, 0x5b, 0x7a, 0x9b, 0xf7, 0x06, 0xf3, 0xaf, 0xdf, 0x6d, 0x65,
	0x0f, 0x70, 0x2b, 0xb8, 0x7f, 0x4d, 0x69, 0xfd, 0x66, 0x41, 0x17, 0x8d, 0xde, 0xe5, 0x85, 0x93,
	0x6d, 0xbd, 0xd0, 0x6d, 0xd1, 0x7f, 0x75, 0x50, 0xfa, 0x98, 0x63, 0x75, 0xfc, 0xbd, 0xc1, 0xb1,
	0xfe, 0xe6, 0x63, 0x8d, 0xb5, 0xee, 0xef, 0x15, 0xc7, 0x92, 0xec, 0xd5, 0x1f, 0xf3, 0xbd, 0xe4,
	0x2e, 0x45, 0xc0, 0xbf, 0xa5, 0xa2, 0x60, 0xf6, 0xe3, 0xbe, 0x9a, 0xdc, 0xc5, 0xd8, 0xf8, 0x9d,
	0x12, 0x7b, 0xed, 0x63, 0x8c, 0x88, 0x3f, 0x41, 0x82, 0x74, 0xaa, 0x0a, 0x54, 0xf4, 0xef, 0xc8,
	0xe7, 0x6f, 0x1f, 0xec, 0x97, 0xe7, 0x6a, 0x1f, 0x39, 0xec, 0x46, 0x1c, 0xf5, 0x36, 0xe2, 0xf5,
	0x7a, 0xce, 0x4f, 0xeb, 0x73, 0xc9, 0xc7, 0x51, 0x50, 0x7d, 0x42, 0xfb, 0x0a, 0x7b, 0x96, 0xfc,
	0xd1, 0x56, 0x6f, 0xd8, 0x7b, 0x8f, 0xfd, 0x48, 0xbb, 0x7f, 0x4f, 0xee, 0x37, 0x8e, 0xe2, 0x07,
	0x28, 0x5d, 0xc9, 0x84, 0x40, 0x14, 0xb3, 0x90, 0x53, 0xb8, 0xc0, 0x93, 0x42, 0x50, 0xf9, 0x87,
	0xd2, 0xf4, 0x93, 0x33, 0x4f, 0xd7, 0xcf, 0x5b, 0x79, 0xff, 0xee, 0x0e, 0x48, 0x9d, 0x55, 0x76,
	0x15, 0x7b, 0xa5, 0xb2, 0x69, 0x6c, 0xcd, 0x0d, 0x31, 0x69, 0xa8, 0x6c, 0x71, 0xff, 0x91, 0xc6,
	0xbe, 0x9c, 0x6a, 0xde, 0x90, 0x4d, 0x83, 0x35, 0xd8, 0xb2, 0x54, 0x8b, 0x03, 0x15, 0x8b, 0xf3,
	0x39, 0xf6, 0xe2, 0x11, 0x3d, 0x33, 0xca, 0x0a, 0x58, 0x70, 0xd8, 0x6a, 0xde, 0xfd, 0xa7, 0xd2,
	0xd1, 0x47, 0xf7, 0x98, 0x19, 0x60, 0x81, 0x6c, 0x19, 0x0f, 0xab, 0x92, 0xdd, 0x0a, 0x8b, 0x35,
	0x5e, 0xdb, 0x82, 0x84, 0xe0, 0xc7, 0xa1, 0xfb, 0xcf, 0x76, 0x55, 0xec, 0xe5, 0x2f, 0x92, 0x56,
	0x49, 0x38, 0xb9, 0xc3, 0x9c, 0xc3, 0xf7, 0x6d, 0x9d, 0x31, 0xf6, 0xe4, 0x36, 0xef, 0xe1, 0x4f,
	0xbb, 0x4e, 0xd5, 0xe1, 0x4f, 0x67, 0x89, 0x7d, 0xa2, 0xeb, 0x47, 0x29, 0xc7, 0xdf, 0x6d, 0x9d,
	0x9c, 0x9f, 0xfb, 0xc8, 0xfe, 0xd4, 0x61, 0x8b, 0x75, 0xd2, 0x7e, 0xf3, 0x89, 0xd7, 0x4b, 0x93,
	0x6f, 0x31, 0xe7, 0xf0, 0x0d, 0xc7, 0xe2, 0x90, 0x4f, 0xd3, 0x90, 0xe3, 0xc5, 0x21, 0x9f, 0x2e,
	0x58, 0x58, 0x3d, 0x7e, 0x62, 0x62, 0xcc, 0x5d, 0x3d, 0x7e, 0xe2, 0xc2, 0xd8, 0xe4, 0xea, 0xf1,
	0x13, 0xd3, 0x63, 0x57, 0x56, 0x8f, 0x9f, 0xb8, 0x36, 0x76, 0x7d, 0xf5, 0xf8, 0x89, 0x2f, 0x8e,
	0xbd, 0xbb, 0x7a, 0xfc, 0xc4, 0xd6, 0x58, 0xb0, 0x7a, 0xfc, 0x44, 0x30, 0x16, 0xae, 0x3e, 0x75,
	0xe2, 0xff, 0x97, 0xc6, 0xbe, 0x52, 0x5a, 0x7d, 0xea, 0xc4, 0xaf, 0x95, 0xc6, 0xbe, 0x59, 0xba,
	0xfa, 0x41, 0x69, 0xe4, 0xfb, 0x5e, 0x67, 0xa7, 0xb1, 0x07, 0x17, 0x7a, 0xc0, 0xb7, 0x81, 0xca,
	0xd1, 0xab, 0x9f, 0xa2, 0xa7, 0x0f, 0xe9, 0xa1, 0xf3, 0x1c, 0x3b, 0x15, 0xa4, 0x4a, 0xf1, 0xd8,
	0x78, 0xfd, 0x99, 0x3d, 0x59, 0x7f, 0xc6, 0x3e, 0x7c, 0x08, 0xcf, 0x9c, 0x4b, 0xec, 0x69, 0x11,
	0x07, 0x0a, 0x4f, 0x97, 0xe9, 0x77, 0x69, 0xf5, 0xfe, 0x03, 0xe7, 0x32, 0x63, 0x71, 0xda, 0x21,
	0x75, 0x4d, 0xbf, 0x3a, 0xab, 0x3f, 0x1d, 0xa7, 0x1d, 0xd4, 0xd5, 0x37, 0x3a, 0xec, 0xcc, 0xd0,
	0x39, 0xa3, 0x73, 0x99, 0x5d, 0xa8, 0x2f, 0xd5, 0xd6, 0x56, 0xaa, 0x0b, 0x9b, 0x2b, 0x1b, 0xf7,
	0xbc, 0xf5, 0x8d, 0xc5, 0x25, 0x6f, 0x71, 0xa5, 0xb1, 0x50, 0x59, 0x5b, 0x5a, 0x1c, 0x3b, 0xe6,
	0x5c, 0x62, 0xee, 0x21, 0xf1, 0xd2, 0x3d, 0x92, 0x96, 0x46, 0x2b, 0x2f, 0x6c, 0x2e, 0x54, 0x16,
	0x1a, 0x4b, 0x63, 0x4f, 0xdc, 0xf8, 0x4e, 0x89, 0x9d, 0x1a, 0x68, 0x26, 0x3a, 0xb7, 0xd9, 0x59,
	0xba, 0x80, 0x64, 0x2f, 0xb3, 0x42, 0x29, 0x33, 0x76, 0x6c, 0xf2, 0xd2, 0xfb, 0x1f, 0x4c, 0xbb,
	0x03, 0xc8, 0x65, 0x40, 0xd1, 0x77, 0x74, 0x5e, 0x61, 0x0e, 0x29, 0xe1, 0xef, 0x34, 0x44, 0x40,
	0x5a, 0xa5, 0xc9, 0xcb, 0xef, 0x7f, 0x30, 0x7d, 0xe1, 0xb0, 0xd6, 0xdb, 0x84, 0x72, 0xca, 0xec,
	0xb8, 0x9f, 0x1a, 0x39, 0xf6, 0xc4, 0xe4, 0xf9, 0xf7, 0x3f, 0x98, 0x3e, 0x3b, 0x00, 0x5c, 0x48,
	0x8d, 0x9c, 0x3c, 0xf1, 0xb5, 0x6f, 0x4d, 0x1d, 0xfb, 0xee, 0xb7, 0xa7, 0x8e, 0x55, 0x3e, 0xf7,
	0xbd, 0x7f, 0x9f, 0x3a, 0xf6, 0xbd, 0x83, 0xa9, 0xd2, 0xf7, 0x0f, 0xa6, 0x4a, 0x3f, 0x38, 0x98,
	0x2a, 0xfd, 0xdb, 0xc1, 0x54, 0xe9, 0xeb, 0x3f, 0x9c, 0x3a, 0xf6, 0xfd, 0x1f, 0x4e, 0x1d, 0xfb,
	0xc1, 0x0f, 0xa7, 0x8e, 0xbd, 0xf3, 0xea, 0xc7, 0xbb, 0xb3, 0x3d, 0xfc, 0xc3, 0xca, 0xad, 0xa7,
	0x30, 0x87, 0xde, 0xfe, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x40, 0x9d, 0xd0, 0x30, 0x74, 0x39,
	0x00, 0x00,
}

func (m *LocalOnlySessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalOnlySessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalOnlySessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableInspectCommand {
		i--
		if m.EnableInspectCommand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xd8
	}
	if m.OptimizerUseImprovedHoistJoinProject {
		i--
		if m.OptimizerUseImprovedHoistJoinProject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xd0
	}
	if m.UseSoftLimitForDistributeScan {
		i--
		if m.UseSoftLimitForDistributeScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xc8
	}
	if len(m.DisableOptimizerRules) > 0 {
		for iNdEx := len(m.DisableOptimizerRules) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DisableOptimizerRules[iNdEx])
			copy(dAtA[i:], m.DisableOptimizerRules[iNdEx])
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.DisableOptimizerRules[iNdEx])))
			i--
			dAtA[i] = 0xb
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.AllowUnsafeInternals {
		i--
		if m.AllowUnsafeInternals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xb8
	}
	if m.ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations {
		i--
		if m.ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xb0
	}
	if m.ParallelizeMultiKeyLookupJoinsAvgLookupRowSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ParallelizeMultiKeyLookupJoinsAvgLookupRowSize))
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xa8
	}
	if m.ParallelizeMultiKeyLookupJoinsMaxLookupRatio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ParallelizeMultiKeyLookupJoinsMaxLookupRatio))))
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xa1
	}
	if m.ParallelizeMultiKeyLookupJoinsAvgLookupRatio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ParallelizeMultiKeyLookupJoinsAvgLookupRatio))))
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0x99
	}
	if m.VectorSearchRerankMultiplier != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.VectorSearchRerankMultiplier))
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0x90
	}
	if m.AllowViewWithSecurityInvokerClause {
		i--
		if m.AllowViewWithSecurityInvokerClause {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0x88
	}
	if m.EnableScrubJob {
		i--
		if m.EnableScrubJob {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0x80
	}
	if m.UseProcTxnControlExtendedProtocolFix {
		i--
		if m.UseProcTxnControlExtendedProtocolFix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xf8
	}
	if m.DistSQLUseReducedLeafWriteSets {
		i--
		if m.DistSQLUseReducedLeafWriteSets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xf0
	}
	if m.OptimizerDisableCrossRegionCascadeFastPathForRBRTables {
		i--
		if m.OptimizerDisableCrossRegionCascadeFastPathForRBRTables {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xe8
	}
	if m.UseImprovedRoutineDependencyTracking {
		i--
		if m.UseImprovedRoutineDependencyTracking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xe0
	}
	if m.InitialRetryBackoffForReadCommitted != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.InitialRetryBackoffForReadCommitted))
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xd8
	}
	if m.OptimizerUseExistsFilterHoistRule {
		i--
		if m.OptimizerUseExistsFilterHoistRule {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xd0
	}
	if m.PropagateAdmissionHeaderToLeafTransactions {
		i--
		if m.PropagateAdmissionHeaderToLeafTransactions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xc8
	}
	if m.VectorSearchBeamSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.VectorSearchBeamSize))
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xc0
	}
	if m.UsePre_25_2VariadicBuiltins {
		i--
		if m.UsePre_25_2VariadicBuiltins {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xb8
	}
	if m.CreateTableWithSchemaLocked {
		i--
		if m.CreateTableWithSchemaLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xb0
	}
	if m.AllowCreateTriggerFunctionWithArgvReferences {
		i--
		if m.AllowCreateTriggerFunctionWithArgvReferences {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xa8
	}
	if m.OptimizerUseDeleteRangeFastPath {
		i--
		if m.OptimizerUseDeleteRangeFastPath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xa0
	}
	if m.OptimizerEnableLockElision {
		i--
		if m.OptimizerEnableLockElision {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x98
	}
	if m.OptimizerUseLockElisionMultipleFamilies {
		i--
		if m.OptimizerUseLockElisionMultipleFamilies {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x90
	}
	if m.BufferedWritesUseLockingOnNonUniqueIndexes {
		i--
		if m.BufferedWritesUseLockingOnNonUniqueIndexes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x88
	}
	if m.UseCPutsOnNonUniqueIndexes {
		i--
		if m.UseCPutsOnNonUniqueIndexes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x80
	}
	if m.RegisterLatchWaitContentionEvents {
		i--
		if m.RegisterLatchWaitContentionEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xf8
	}
	if m.OptimizerPlanLookupJoinsWithReverseScans {
		i--
		if m.OptimizerPlanLookupJoinsWithReverseScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xf0
	}
	if m.OptimizerCheckInputMinRowCount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptimizerCheckInputMinRowCount))))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xe9
	}
	if m.BufferedWritesEnabled {
		i--
		if m.BufferedWritesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xe0
	}
	if m.OptimizerMinRowCount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptimizerMinRowCount))))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xd9
	}
	if m.OptimizerPreferBoundedCardinality {
		i--
		if m.OptimizerPreferBoundedCardinality {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xd0
	}
	if m.CatalogDigestStalenessCheckEnabled {
		i--
		if m.CatalogDigestStalenessCheckEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc8
	}
	if m.AvoidFullTableScansInMutations {
		i--
		if m.AvoidFullTableScansInMutations {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xb8
	}
	if m.LegacyVarcharTyping {
		i--
		if m.LegacyVarcharTyping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xb0
	}
	if m.DistributeJoinRowCountThreshold != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistributeJoinRowCountThreshold))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xa8
	}
	if m.AlwaysDistributeFullScans {
		i--
		if m.AlwaysDistributeFullScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xa0
	}
	if m.DistributeScanRowCountThreshold != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistributeScanRowCountThreshold))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x98
	}
	if m.DistributeSortRowCountThreshold != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistributeSortRowCountThreshold))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x90
	}
	if m.DistributeGroupByRowCountThreshold != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistributeGroupByRowCountThreshold))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x88
	}
	if m.RecursionDepthLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.RecursionDepthLimit))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x80
	}
	if m.DisableVecUnionEagerCancellation {
		i--
		if m.DisableVecUnionEagerCancellation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf8
	}
	if m.UnsafeAllowTriggersModifyingCascades {
		i--
		if m.UnsafeAllowTriggersModifyingCascades {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf0
	}
	if m.BypassPCRReaderCatalogAOST {
		i--
		if m.BypassPCRReaderCatalogAOST {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xe8
	}
	{
		size, err := m.OriginTimestampForLogicalDataReplication.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x8
	i--
	dAtA[i] = 0xe2
	if m.OptimizerPushLimitIntoProjectFilteredScan {
		i--
		if m.OptimizerPushLimitIntoProjectFilteredScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xd8
	}
	if m.OptimizerUseConditionalHoistFix {
		i--
		if m.OptimizerUseConditionalHoistFix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xd0
	}
	if m.OptimizerUseMergedPartialStatistics {
		i--
		if m.OptimizerUseMergedPartialStatistics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xc8
	}
	if m.EnableCreateStatsUsingExtremesBoolEnum {
		i--
		if m.EnableCreateStatsUsingExtremesBoolEnum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xc0
	}
	if m.OriginIDForLogicalDataReplication != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.OriginIDForLogicalDataReplication))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb8
	}
	if m.OptimizerUsePolymorphicParameterFix {
		i--
		if m.OptimizerUsePolymorphicParameterFix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb0
	}
	if m.PlanCacheMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.PlanCacheMode))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa8
	}
	if m.OptimizerPushOffsetIntoIndexJoin {
		i--
		if m.OptimizerPushOffsetIntoIndexJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa0
	}
	if m.OptimizerProveImplicationWithVirtualComputedColumns {
		i--
		if m.OptimizerProveImplicationWithVirtualComputedColumns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x90
	}
	if m.OptimizerUseImprovedMultiColumnSelectivityEstimate {
		i--
		if m.OptimizerUseImprovedMultiColumnSelectivityEstimate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x88
	}
	if m.OptimizerUseImprovedZigzagJoinCosting {
		i--
		if m.OptimizerUseImprovedZigzagJoinCosting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x80
	}
	if m.OptimizerUseImprovedTrigramSimilaritySelectivity {
		i--
		if m.OptimizerUseImprovedTrigramSimilaritySelectivity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf8
	}
	if m.OptimizerUseImprovedDistinctOnLimitHintCosting {
		i--
		if m.OptimizerUseImprovedDistinctOnLimitHintCosting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf0
	}
	if m.OptimizerUseTrigramSimilarityOptimization {
		i--
		if m.OptimizerUseTrigramSimilarityOptimization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe8
	}
	if m.OptimizerUseVirtualComputedColumnStats {
		i--
		if m.OptimizerUseVirtualComputedColumnStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe0
	}
	if m.PLpgSQLUseStrictInto {
		i--
		if m.PLpgSQLUseStrictInto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd8
	}
	if m.CloseCursorsAtCommit {
		i--
		if m.CloseCursorsAtCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd0
	}
	if m.AutoCommitBeforeDDL {
		i--
		if m.AutoCommitBeforeDDL {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if m.CopyNumRetriesPerBatch != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CopyNumRetriesPerBatch))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.OptimizerMergeJoinsEnabled {
		i--
		if m.OptimizerMergeJoinsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb8
	}
	if m.CopyWritePipeliningEnabled {
		i--
		if m.CopyWritePipeliningEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb0
	}
	if m.CopyTxnQualityOfService != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CopyTxnQualityOfService))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa8
	}
	if m.DisableChangefeedReplication {
		i--
		if m.DisableChangefeedReplication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa0
	}
	if m.OptimizerUseProvidedOrderingFix {
		i--
		if m.OptimizerUseProvidedOrderingFix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x98
	}
	if m.OptimizerUseLockOpForSerializable {
		i--
		if m.OptimizerUseLockOpForSerializable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x90
	}
	if len(m.UnsafeSettingInterlockKey) > 0 {
		i -= len(m.UnsafeSettingInterlockKey)
		copy(dAtA[i:], m.UnsafeSettingInterlockKey)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.UnsafeSettingInterlockKey)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x8a
	}
	if m.SharedLockingForSerializable {
		i--
		if m.SharedLockingForSerializable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x80
	}
	if m.StrictDDLAtomicity {
		i--
		if m.StrictDDLAtomicity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf8
	}
	if m.MaxRetriesForReadCommitted != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.MaxRetriesForReadCommitted))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if m.DurableLockingForSerializable {
		i--
		if m.DurableLockingForSerializable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe8
	}
	if m.ImplicitFKLockingForSerializable {
		i--
		if m.ImplicitFKLockingForSerializable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe0
	}
	if m.OptimizerUseImprovedJoinElimination {
		i--
		if m.OptimizerUseImprovedJoinElimination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd8
	}
	if m.ReplicationMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ReplicationMode))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd0
	}
	if m.DefaultTxnIsolationLevel != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DefaultTxnIsolationLevel))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc8
	}
	if m.OptimizerUseImprovedComputedColumnFiltersDerivation {
		i--
		if m.OptimizerUseImprovedComputedColumnFiltersDerivation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc0
	}
	if m.TestingOptimizerInjectPanics {
		i--
		if m.TestingOptimizerInjectPanics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if m.OptimizerHoistUncorrelatedEqualitySubqueries {
		i--
		if m.OptimizerHoistUncorrelatedEqualitySubqueries {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UnboundedParallelScans {
		i--
		if m.UnboundedParallelScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.MultipleActivePortalsEnabled {
		i--
		if m.MultipleActivePortalsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.PreparedStatementsCacheSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.PreparedStatementsCacheSize))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x88
	}
	if m.AllowRoleMembershipsToChangeDuringTransaction {
		i--
		if m.AllowRoleMembershipsToChangeDuringTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x80
	}
	if m.EnableCreateStatsUsingExtremes {
		i--
		if m.EnableCreateStatsUsingExtremes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xf8
	}
	if m.OptimizerAlwaysUseHistograms {
		i--
		if m.OptimizerAlwaysUseHistograms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xf0
	}
	if m.InjectRetryErrorsOnCommitEnabled {
		i--
		if m.InjectRetryErrorsOnCommitEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xe0
	}
	if m.OptimizerUseImprovedSplitDisjunctionForJoins {
		i--
		if m.OptimizerUseImprovedSplitDisjunctionForJoins {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd8
	}
	if m.DeclareCursorStatementTimeoutEnabled {
		i--
		if m.DeclareCursorStatementTimeoutEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.CopyFromRetriesEnabled {
		i--
		if m.CopyFromRetriesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc8
	}
	if m.OptimizerUseLimitOrderingForStreamingGroupBy {
		i--
		if m.OptimizerUseLimitOrderingForStreamingGroupBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc0
	}
	if m.OptimizerUseImprovedDisjunctionStats {
		i--
		if m.OptimizerUseImprovedDisjunctionStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb0
	}
	if m.AllowOrdinalColumnReferences {
		i--
		if m.AllowOrdinalColumnReferences {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa8
	}
	if m.ExperimentalHashGroupJoinEnabled {
		i--
		if m.ExperimentalHashGroupJoinEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa0
	}
	if m.DescriptorValidationMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DescriptorValidationMode))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x98
	}
	if len(m.SystemIdentityProto) > 0 {
		i -= len(m.SystemIdentityProto)
		copy(dAtA[i:], m.SystemIdentityProto)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SystemIdentityProto)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if m.TransactionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TransactionTimeout))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x88
	}
	if m.VariableInequalityLookupJoinEnabled {
		i--
		if m.VariableInequalityLookupJoinEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if m.OptimizerUseForecasts {
		i--
		if m.OptimizerUseForecasts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf8
	}
	if m.EnforceHomeRegion {
		i--
		if m.EnforceHomeRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf0
	}
	if m.CopyFromAtomicEnabled {
		i--
		if m.CopyFromAtomicEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe8
	}
	if m.DisableHoistProjectionInJoinLimitation {
		i--
		if m.DisableHoistProjectionInJoinLimitation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe0
	}
	if m.CopyFastPathEnabled {
		i--
		if m.CopyFastPathEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.OptimizerUseNotVisibleIndexes {
		i--
		if m.OptimizerUseNotVisibleIndexes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.TestingOptimizerDisableRuleProbability != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestingOptimizerDisableRuleProbability))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc9
	}
	if m.TestingOptimizerCostPerturbation != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestingOptimizerCostPerturbation))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc1
	}
	if m.UnconstrainedNonCoveringIndexScanEnabled {
		i--
		if m.UnconstrainedNonCoveringIndexScanEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.TestingOptimizerRandomSeed != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TestingOptimizerRandomSeed))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if m.ShowPrimaryKeyConstraintOnNotVisibleColumns {
		i--
		if m.ShowPrimaryKeyConstraintOnNotVisibleColumns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa8
	}
	if m.MultipleModificationsOfTable {
		i--
		if m.MultipleModificationsOfTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.ExpectAndIgnoreNotVisibleColumnsInCopy {
		i--
		if m.ExpectAndIgnoreNotVisibleColumnsInCopy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.EnableImplicitTransactionForBatchStatements {
		i--
		if m.EnableImplicitTransactionForBatchStatements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.OverrideAlterPrimaryRegionInSuperRegion {
		i--
		if m.OverrideAlterPrimaryRegionInSuperRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.EnableSuperRegions {
		i--
		if m.EnableSuperRegions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.OptSplitScanLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.OptSplitScanLimit))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.DefaultTxnQualityOfService != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DefaultTxnQualityOfService))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.CostScansWithDefaultColSize {
		i--
		if m.CostScansWithDefaultColSize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.CheckFunctionBodies {
		i--
		if m.CheckFunctionBodies {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.AvoidBuffering {
		i--
		if m.AvoidBuffering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.IndexRecommendationsEnabled {
		i--
		if m.IndexRecommendationsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if len(m.CustomOptions) > 0 {
		keysForCustomOptions := make([]string, 0, len(m.CustomOptions))
		for k := range m.CustomOptions {
			keysForCustomOptions = append(keysForCustomOptions, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForCustomOptions)
		for iNdEx := len(keysForCustomOptions) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomOptions[string(keysForCustomOptions[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForCustomOptions[iNdEx])
			copy(dAtA[i:], keysForCustomOptions[iNdEx])
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(keysForCustomOptions[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if m.DisablePlanGists {
		i--
		if m.DisablePlanGists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.NullOrderedLast {
		i--
		if m.NullOrderedLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.InjectRetryErrorsEnabled {
		i--
		if m.InjectRetryErrorsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.LargeFullScanRows != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LargeFullScanRows))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa9
	}
	if m.IsSuperuser {
		i--
		if m.IsSuperuser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.AutoRehomingEnabled {
		i--
		if m.AutoRehomingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.TxnRowsReadErr != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsReadErr))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.TxnRowsReadLog != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsReadLog))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.TxnRowsWrittenErr != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsWrittenErr))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.TxnRowsWrittenLog != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsWrittenLog))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if len(m.SessionUserProto) > 0 {
		i -= len(m.SessionUserProto)
		copy(dAtA[i:], m.SessionUserProto)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SessionUserProto)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.PlacementEnabled {
		i--
		if m.PlacementEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if len(m.SequenceCache) > 0 {
		keysForSequenceCache := make([]uint32, 0, len(m.SequenceCache))
		for k := range m.SequenceCache {
			keysForSequenceCache = append(keysForSequenceCache, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForSequenceCache)
		for iNdEx := len(keysForSequenceCache) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SequenceCache[uint32(keysForSequenceCache[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(keysForSequenceCache[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.NewSchemaChangerMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NewSchemaChangerMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.SerialNormalizationMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.SerialNormalizationMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.DistSQLMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistSQLMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ExperimentalDistSQLPlanningMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ExperimentalDistSQLPlanningMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.PropagateInputOrdering {
		i--
		if m.PropagateInputOrdering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ResultsBufferSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ResultsBufferSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.EnableStreamReplication {
		i--
		if m.EnableStreamReplication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ExperimentalComputedColumnRewrites) > 0 {
		i -= len(m.ExperimentalComputedColumnRewrites)
		copy(dAtA[i:], m.ExperimentalComputedColumnRewrites)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.ExperimentalComputedColumnRewrites)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.StubCatalogTablesEnabled {
		i--
		if m.StubCatalogTablesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.EnableUniqueWithoutIndexConstraints {
		i--
		if m.EnableUniqueWithoutIndexConstraints {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.EnableSeqScan {
		i--
		if m.EnableSeqScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.SynchronousCommit {
		i--
		if m.SynchronousCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.AlterColumnTypeGeneralEnabled {
		i--
		if m.AlterColumnTypeGeneralEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.InsertFastPath {
		i--
		if m.InsertFastPath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ImplicitSelectForUpdate {
		i--
		if m.ImplicitSelectForUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.DisallowFullTableScans {
		i--
		if m.DisallowFullTableScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.OverrideMultiRegionZoneConfigEnabled {
		i--
		if m.OverrideMultiRegionZoneConfigEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ImplicitColumnPartitioningEnabled {
		i--
		if m.ImplicitColumnPartitioningEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TempTablesEnabled {
		i--
		if m.TempTablesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AllowPrepareAsOptPlan {
		i--
		if m.AllowPrepareAsOptPlan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ForceSavepointRestart {
		i--
		if m.ForceSavepointRestart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RequireExplicitPrimaryKeys {
		i--
		if m.RequireExplicitPrimaryKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ZigzagJoinEnabled {
		i--
		if m.ZigzagJoinEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PreferLookupJoinsForFKs {
		i--
		if m.PreferLookupJoinsForFKs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SafeUpdates {
		i--
		if m.SafeUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.LocalityOptimizedSearch {
		i--
		if m.LocalityOptimizedSearch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.OptimizerUseMultiColStats {
		i--
		if m.OptimizerUseMultiColStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptimizerUseHistograms {
		i--
		if m.OptimizerUseHistograms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.PartiallyDistributedPlansDisabled {
		i--
		if m.PartiallyDistributedPlansDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.DefaultTxnUseFollowerReads {
		i--
		if m.DefaultTxnUseFollowerReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DefaultTxnReadOnly {
		i--
		if m.DefaultTxnReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DefaultTxnPriority != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DefaultTxnPriority))
		i--
		dAtA[i] = 0x40
	}
	if m.ReorderJoinsLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ReorderJoinsLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.NoticeDisplaySeverity != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NoticeDisplaySeverity))
		i--
		dAtA[i] = 0x30
	}
	if m.IdleInTransactionSessionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.IdleInTransactionSessionTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.IdleInSessionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.IdleInSessionTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.StmtTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.StmtTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.OptimizerFKCascadesLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.OptimizerFKCascadesLimit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SaveTablesPrefix) > 0 {
		i -= len(m.SaveTablesPrefix)
		copy(dAtA[i:], m.SaveTablesPrefix)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SaveTablesPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SequenceCacheEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceCacheEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceCacheEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumValues != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NumValues))
		i--
		dAtA[i] = 0x20
	}
	if m.Increment != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.Increment))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentValue != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CurrentValue))
		i--
		dAtA[i] = 0x10
	}
	if m.CachedVersion != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CachedVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLocalOnlySessionData(dAtA []byte, offset int, v uint64) int {
	offset -= sovLocalOnlySessionData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LocalOnlySessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SaveTablesPrefix)
	if l > 0 {
		n += 1 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.OptimizerFKCascadesLimit != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.OptimizerFKCascadesLimit))
	}
	if m.StmtTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.StmtTimeout))
	}
	if m.IdleInSessionTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.IdleInSessionTimeout))
	}
	if m.IdleInTransactionSessionTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.IdleInTransactionSessionTimeout))
	}
	if m.NoticeDisplaySeverity != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.NoticeDisplaySeverity))
	}
	if m.ReorderJoinsLimit != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.ReorderJoinsLimit))
	}
	if m.DefaultTxnPriority != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.DefaultTxnPriority))
	}
	if m.DefaultTxnReadOnly {
		n += 2
	}
	if m.DefaultTxnUseFollowerReads {
		n += 2
	}
	if m.PartiallyDistributedPlansDisabled {
		n += 2
	}
	if m.OptimizerUseHistograms {
		n += 2
	}
	if m.OptimizerUseMultiColStats {
		n += 2
	}
	if m.LocalityOptimizedSearch {
		n += 2
	}
	if m.SafeUpdates {
		n += 2
	}
	if m.PreferLookupJoinsForFKs {
		n += 3
	}
	if m.ZigzagJoinEnabled {
		n += 3
	}
	if m.RequireExplicitPrimaryKeys {
		n += 3
	}
	if m.ForceSavepointRestart {
		n += 3
	}
	if m.AllowPrepareAsOptPlan {
		n += 3
	}
	if m.TempTablesEnabled {
		n += 3
	}
	if m.ImplicitColumnPartitioningEnabled {
		n += 3
	}
	if m.OverrideMultiRegionZoneConfigEnabled {
		n += 3
	}
	if m.DisallowFullTableScans {
		n += 3
	}
	if m.ImplicitSelectForUpdate {
		n += 3
	}
	if m.InsertFastPath {
		n += 3
	}
	if m.AlterColumnTypeGeneralEnabled {
		n += 3
	}
	if m.SynchronousCommit {
		n += 3
	}
	if m.EnableSeqScan {
		n += 3
	}
	if m.EnableUniqueWithoutIndexConstraints {
		n += 3
	}
	if m.StubCatalogTablesEnabled {
		n += 3
	}
	l = len(m.ExperimentalComputedColumnRewrites)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.EnableStreamReplication {
		n += 3
	}
	if m.ResultsBufferSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ResultsBufferSize))
	}
	if m.PropagateInputOrdering {
		n += 3
	}
	if m.ExperimentalDistSQLPlanningMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ExperimentalDistSQLPlanningMode))
	}
	if m.DistSQLMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistSQLMode))
	}
	if m.SerialNormalizationMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.SerialNormalizationMode))
	}
	if m.NewSchemaChangerMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.NewSchemaChangerMode))
	}
	if len(m.SequenceCache) > 0 {
		for k, v := range m.SequenceCache {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLocalOnlySessionData(uint64(l))
			}
			mapEntrySize := 1 + sovLocalOnlySessionData(uint64(k)) + l
			n += mapEntrySize + 2 + sovLocalOnlySessionData(uint64(mapEntrySize))
		}
	}
	if m.PlacementEnabled {
		n += 3
	}
	l = len(m.SessionUserProto)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.TxnRowsWrittenLog != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsWrittenLog))
	}
	if m.TxnRowsWrittenErr != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsWrittenErr))
	}
	if m.TxnRowsReadLog != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsReadLog))
	}
	if m.TxnRowsReadErr != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsReadErr))
	}
	if m.AutoRehomingEnabled {
		n += 3
	}
	if m.IsSuperuser {
		n += 3
	}
	if m.LargeFullScanRows != 0 {
		n += 10
	}
	if m.InjectRetryErrorsEnabled {
		n += 3
	}
	if m.NullOrderedLast {
		n += 3
	}
	if m.DisablePlanGists {
		n += 3
	}
	if len(m.CustomOptions) > 0 {
		for k, v := range m.CustomOptions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocalOnlySessionData(uint64(len(k))) + 1 + len(v) + sovLocalOnlySessionData(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocalOnlySessionData(uint64(mapEntrySize))
		}
	}
	if m.IndexRecommendationsEnabled {
		n += 3
	}
	if m.AvoidBuffering {
		n += 3
	}
	if m.CheckFunctionBodies {
		n += 3
	}
	if m.CostScansWithDefaultColSize {
		n += 3
	}
	if m.DefaultTxnQualityOfService != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DefaultTxnQualityOfService))
	}
	if m.OptSplitScanLimit != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.OptSplitScanLimit))
	}
	if m.EnableSuperRegions {
		n += 3
	}
	if m.OverrideAlterPrimaryRegionInSuperRegion {
		n += 3
	}
	if m.EnableImplicitTransactionForBatchStatements {
		n += 3
	}
	if m.ExpectAndIgnoreNotVisibleColumnsInCopy {
		n += 3
	}
	if m.MultipleModificationsOfTable {
		n += 3
	}
	if m.ShowPrimaryKeyConstraintOnNotVisibleColumns {
		n += 3
	}
	if m.TestingOptimizerRandomSeed != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TestingOptimizerRandomSeed))
	}
	if m.UnconstrainedNonCoveringIndexScanEnabled {
		n += 3
	}
	if m.TestingOptimizerCostPerturbation != 0 {
		n += 10
	}
	if m.TestingOptimizerDisableRuleProbability != 0 {
		n += 10
	}
	if m.OptimizerUseNotVisibleIndexes {
		n += 3
	}
	if m.CopyFastPathEnabled {
		n += 3
	}
	if m.DisableHoistProjectionInJoinLimitation {
		n += 3
	}
	if m.CopyFromAtomicEnabled {
		n += 3
	}
	if m.EnforceHomeRegion {
		n += 3
	}
	if m.OptimizerUseForecasts {
		n += 3
	}
	if m.VariableInequalityLookupJoinEnabled {
		n += 3
	}
	if m.TransactionTimeout != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TransactionTimeout))
	}
	l = len(m.SystemIdentityProto)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.DescriptorValidationMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DescriptorValidationMode))
	}
	if m.ExperimentalHashGroupJoinEnabled {
		n += 3
	}
	if m.AllowOrdinalColumnReferences {
		n += 3
	}
	if m.OptimizerUseImprovedDisjunctionStats {
		n += 3
	}
	if m.OptimizerUseLimitOrderingForStreamingGroupBy {
		n += 3
	}
	if m.CopyFromRetriesEnabled {
		n += 3
	}
	if m.DeclareCursorStatementTimeoutEnabled {
		n += 3
	}
	if m.OptimizerUseImprovedSplitDisjunctionForJoins {
		n += 3
	}
	if m.InjectRetryErrorsOnCommitEnabled {
		n += 3
	}
	if m.OptimizerAlwaysUseHistograms {
		n += 3
	}
	if m.EnableCreateStatsUsingExtremes {
		n += 3
	}
	if m.AllowRoleMembershipsToChangeDuringTransaction {
		n += 3
	}
	if m.PreparedStatementsCacheSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.PreparedStatementsCacheSize))
	}
	if m.MultipleActivePortalsEnabled {
		n += 3
	}
	if m.UnboundedParallelScans {
		n += 3
	}
	if m.OptimizerHoistUncorrelatedEqualitySubqueries {
		n += 3
	}
	if m.TestingOptimizerInjectPanics {
		n += 3
	}
	if m.OptimizerUseImprovedComputedColumnFiltersDerivation {
		n += 3
	}
	if m.DefaultTxnIsolationLevel != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DefaultTxnIsolationLevel))
	}
	if m.ReplicationMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ReplicationMode))
	}
	if m.OptimizerUseImprovedJoinElimination {
		n += 3
	}
	if m.ImplicitFKLockingForSerializable {
		n += 3
	}
	if m.DurableLockingForSerializable {
		n += 3
	}
	if m.MaxRetriesForReadCommitted != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.MaxRetriesForReadCommitted))
	}
	if m.StrictDDLAtomicity {
		n += 3
	}
	if m.SharedLockingForSerializable {
		n += 3
	}
	l = len(m.UnsafeSettingInterlockKey)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.OptimizerUseLockOpForSerializable {
		n += 3
	}
	if m.OptimizerUseProvidedOrderingFix {
		n += 3
	}
	if m.DisableChangefeedReplication {
		n += 3
	}
	if m.CopyTxnQualityOfService != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.CopyTxnQualityOfService))
	}
	if m.CopyWritePipeliningEnabled {
		n += 3
	}
	if m.OptimizerMergeJoinsEnabled {
		n += 3
	}
	if m.CopyNumRetriesPerBatch != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.CopyNumRetriesPerBatch))
	}
	if m.AutoCommitBeforeDDL {
		n += 3
	}
	if m.CloseCursorsAtCommit {
		n += 3
	}
	if m.PLpgSQLUseStrictInto {
		n += 3
	}
	if m.OptimizerUseVirtualComputedColumnStats {
		n += 3
	}
	if m.OptimizerUseTrigramSimilarityOptimization {
		n += 3
	}
	if m.OptimizerUseImprovedDistinctOnLimitHintCosting {
		n += 3
	}
	if m.OptimizerUseImprovedTrigramSimilaritySelectivity {
		n += 3
	}
	if m.OptimizerUseImprovedZigzagJoinCosting {
		n += 3
	}
	if m.OptimizerUseImprovedMultiColumnSelectivityEstimate {
		n += 3
	}
	if m.OptimizerProveImplicationWithVirtualComputedColumns {
		n += 3
	}
	if m.OptimizerPushOffsetIntoIndexJoin {
		n += 3
	}
	if m.PlanCacheMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.PlanCacheMode))
	}
	if m.OptimizerUsePolymorphicParameterFix {
		n += 3
	}
	if m.OriginIDForLogicalDataReplication != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.OriginIDForLogicalDataReplication))
	}
	if m.EnableCreateStatsUsingExtremesBoolEnum {
		n += 3
	}
	if m.OptimizerUseMergedPartialStatistics {
		n += 3
	}
	if m.OptimizerUseConditionalHoistFix {
		n += 3
	}
	if m.OptimizerPushLimitIntoProjectFilteredScan {
		n += 3
	}
	l = m.OriginTimestampForLogicalDataReplication.Size()
	n += 2 + l + sovLocalOnlySessionData(uint64(l))
	if m.BypassPCRReaderCatalogAOST {
		n += 3
	}
	if m.UnsafeAllowTriggersModifyingCascades {
		n += 3
	}
	if m.DisableVecUnionEagerCancellation {
		n += 3
	}
	if m.RecursionDepthLimit != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.RecursionDepthLimit))
	}
	if m.DistributeGroupByRowCountThreshold != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistributeGroupByRowCountThreshold))
	}
	if m.DistributeSortRowCountThreshold != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistributeSortRowCountThreshold))
	}
	if m.DistributeScanRowCountThreshold != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistributeScanRowCountThreshold))
	}
	if m.AlwaysDistributeFullScans {
		n += 3
	}
	if m.DistributeJoinRowCountThreshold != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistributeJoinRowCountThreshold))
	}
	if m.LegacyVarcharTyping {
		n += 3
	}
	if m.AvoidFullTableScansInMutations {
		n += 3
	}
	if m.CatalogDigestStalenessCheckEnabled {
		n += 3
	}
	if m.OptimizerPreferBoundedCardinality {
		n += 3
	}
	if m.OptimizerMinRowCount != 0 {
		n += 10
	}
	if m.BufferedWritesEnabled {
		n += 3
	}
	if m.OptimizerCheckInputMinRowCount != 0 {
		n += 10
	}
	if m.OptimizerPlanLookupJoinsWithReverseScans {
		n += 3
	}
	if m.RegisterLatchWaitContentionEvents {
		n += 3
	}
	if m.UseCPutsOnNonUniqueIndexes {
		n += 3
	}
	if m.BufferedWritesUseLockingOnNonUniqueIndexes {
		n += 3
	}
	if m.OptimizerUseLockElisionMultipleFamilies {
		n += 3
	}
	if m.OptimizerEnableLockElision {
		n += 3
	}
	if m.OptimizerUseDeleteRangeFastPath {
		n += 3
	}
	if m.AllowCreateTriggerFunctionWithArgvReferences {
		n += 3
	}
	if m.CreateTableWithSchemaLocked {
		n += 3
	}
	if m.UsePre_25_2VariadicBuiltins {
		n += 3
	}
	if m.VectorSearchBeamSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.VectorSearchBeamSize))
	}
	if m.PropagateAdmissionHeaderToLeafTransactions {
		n += 3
	}
	if m.OptimizerUseExistsFilterHoistRule {
		n += 3
	}
	if m.InitialRetryBackoffForReadCommitted != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.InitialRetryBackoffForReadCommitted))
	}
	if m.UseImprovedRoutineDependencyTracking {
		n += 3
	}
	if m.OptimizerDisableCrossRegionCascadeFastPathForRBRTables {
		n += 3
	}
	if m.DistSQLUseReducedLeafWriteSets {
		n += 3
	}
	if m.UseProcTxnControlExtendedProtocolFix {
		n += 3
	}
	if m.EnableScrubJob {
		n += 3
	}
	if m.AllowViewWithSecurityInvokerClause {
		n += 3
	}
	if m.VectorSearchRerankMultiplier != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.VectorSearchRerankMultiplier))
	}
	if m.ParallelizeMultiKeyLookupJoinsAvgLookupRatio != 0 {
		n += 10
	}
	if m.ParallelizeMultiKeyLookupJoinsMaxLookupRatio != 0 {
		n += 10
	}
	if m.ParallelizeMultiKeyLookupJoinsAvgLookupRowSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ParallelizeMultiKeyLookupJoinsAvgLookupRowSize))
	}
	if m.ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations {
		n += 3
	}
	if m.AllowUnsafeInternals {
		n += 3
	}
	if len(m.DisableOptimizerRules) > 0 {
		for _, s := range m.DisableOptimizerRules {
			l = len(s)
			n += 2 + l + sovLocalOnlySessionData(uint64(l))
		}
	}
	if m.UseSoftLimitForDistributeScan {
		n += 3
	}
	if m.OptimizerUseImprovedHoistJoinProject {
		n += 3
	}
	if m.EnableInspectCommand {
		n += 3
	}
	return n
}

func (m *SequenceCacheEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CachedVersion != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.CachedVersion))
	}
	if m.CurrentValue != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.CurrentValue))
	}
	if m.Increment != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.Increment))
	}
	if m.NumValues != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.NumValues))
	}
	return n
}

func sovLocalOnlySessionData(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozLocalOnlySessionData(x uint64) (n int) {
	return sovLocalOnlySessionData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LocalOnlySessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalOnlySessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalOnlySessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveTablesPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaveTablesPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerFKCascadesLimit", wireType)
			}
			m.OptimizerFKCascadesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptimizerFKCascadesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtTimeout", wireType)
			}
			m.StmtTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleInSessionTimeout", wireType)
			}
			m.IdleInSessionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleInSessionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleInTransactionSessionTimeout", wireType)
			}
			m.IdleInTransactionSessionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleInTransactionSessionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeDisplaySeverity", wireType)
			}
			m.NoticeDisplaySeverity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoticeDisplaySeverity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReorderJoinsLimit", wireType)
			}
			m.ReorderJoinsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReorderJoinsLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnPriority", wireType)
			}
			m.DefaultTxnPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTxnPriority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTxnReadOnly = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnUseFollowerReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTxnUseFollowerReads = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiallyDistributedPlansDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartiallyDistributedPlansDisabled = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseHistograms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseHistograms = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseMultiColStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseMultiColStats = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityOptimizedSearch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalityOptimizedSearch = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SafeUpdates = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferLookupJoinsForFKs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferLookupJoinsForFKs = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigzagJoinEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZigzagJoinEnabled = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireExplicitPrimaryKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireExplicitPrimaryKeys = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceSavepointRestart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceSavepointRestart = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrepareAsOptPlan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrepareAsOptPlan = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempTablesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TempTablesEnabled = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitColumnPartitioningEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitColumnPartitioningEnabled = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideMultiRegionZoneConfigEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideMultiRegionZoneConfigEnabled = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowFullTableScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisallowFullTableScans = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitSelectForUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitSelectForUpdate = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertFastPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsertFastPath = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterColumnTypeGeneralEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlterColumnTypeGeneralEnabled = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousCommit = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSeqScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSeqScan = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableUniqueWithoutIndexConstraints", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableUniqueWithoutIndexConstraints = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StubCatalogTablesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StubCatalogTablesEnabled = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalComputedColumnRewrites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExperimentalComputedColumnRewrites = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStreamReplication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStreamReplication = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultsBufferSize", wireType)
			}
			m.ResultsBufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultsBufferSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagateInputOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropagateInputOrdering = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalDistSQLPlanningMode", wireType)
			}
			m.ExperimentalDistSQLPlanningMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExperimentalDistSQLPlanningMode |= ExperimentalDistSQLPlanningMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQLMode", wireType)
			}
			m.DistSQLMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistSQLMode |= DistSQLExecMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNormalizationMode", wireType)
			}
			m.SerialNormalizationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialNormalizationMode |= SerialNormalizationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSchemaChangerMode", wireType)
			}
			m.NewSchemaChangerMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSchemaChangerMode |= NewSchemaChangerMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceCache == nil {
				m.SequenceCache = make(SequenceCache)
			}
			var mapkey uint32
			var mapvalue *SequenceCacheEntry
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalOnlySessionData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SequenceCacheEntry{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SequenceCache[mapkey] = mapvalue
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacementEnabled = bool(v != 0)
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionUserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionUserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsWrittenLog", wireType)
			}
			m.TxnRowsWrittenLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsWrittenLog |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsWrittenErr", wireType)
			}
			m.TxnRowsWrittenErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsWrittenErr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsReadLog", wireType)
			}
			m.TxnRowsReadLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsReadLog |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsReadErr", wireType)
			}
			m.TxnRowsReadErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsReadErr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRehomingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRehomingEnabled = bool(v != 0)
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuperuser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuperuser = bool(v != 0)
		case 53:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeFullScanRows", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LargeFullScanRows = float64(math.Float64frombits(v))
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectRetryErrorsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InjectRetryErrorsEnabled = bool(v != 0)
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullOrderedLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullOrderedLast = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePlanGists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePlanGists = bool(v != 0)
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomOptions == nil {
				m.CustomOptions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalOnlySessionData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexRecommendationsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexRecommendationsEnabled = bool(v != 0)
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvoidBuffering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvoidBuffering = bool(v != 0)
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFunctionBodies", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckFunctionBodies = bool(v != 0)
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostScansWithDefaultColSize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CostScansWithDefaultColSize = bool(v != 0)
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnQualityOfService", wireType)
			}
			m.DefaultTxnQualityOfService = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTxnQualityOfService |= QoSLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptSplitScanLimit", wireType)
			}
			m.OptSplitScanLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptSplitScanLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSuperRegions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSuperRegions = bool(v != 0)
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideAlterPrimaryRegionInSuperRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideAlterPrimaryRegionInSuperRegion = bool(v != 0)
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableImplicitTransactionForBatchStatements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableImplicitTransactionForBatchStatements = bool(v != 0)
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectAndIgnoreNotVisibleColumnsInCopy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpectAndIgnoreNotVisibleColumnsInCopy = bool(v != 0)
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleModificationsOfTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultipleModificationsOfTable = bool(v != 0)
		case 69:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrimaryKeyConstraintOnNotVisibleColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowPrimaryKeyConstraintOnNotVisibleColumns = bool(v != 0)
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerRandomSeed", wireType)
			}
			m.TestingOptimizerRandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingOptimizerRandomSeed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnconstrainedNonCoveringIndexScanEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnconstrainedNonCoveringIndexScanEnabled = bool(v != 0)
		case 72:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerCostPerturbation", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestingOptimizerCostPerturbation = float64(math.Float64frombits(v))
		case 73:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerDisableRuleProbability", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestingOptimizerDisableRuleProbability = float64(math.Float64frombits(v))
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseNotVisibleIndexes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseNotVisibleIndexes = bool(v != 0)
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFastPathEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFastPathEnabled = bool(v != 0)
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableHoistProjectionInJoinLimitation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableHoistProjectionInJoinLimitation = bool(v != 0)
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFromAtomicEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFromAtomicEnabled = bool(v != 0)
		case 78:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforceHomeRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnforceHomeRegion = bool(v != 0)
		case 79:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseForecasts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseForecasts = bool(v != 0)
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariableInequalityLookupJoinEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VariableInequalityLookupJoinEnabled = bool(v != 0)
		case 81:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionTimeout", wireType)
			}
			m.TransactionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemIdentityProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemIdentityProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 83:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValidationMode", wireType)
			}
			m.DescriptorValidationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorValidationMode |= DescriptorValidationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 84:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalHashGroupJoinEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExperimentalHashGroupJoinEnabled = bool(v != 0)
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrdinalColumnReferences", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOrdinalColumnReferences = bool(v != 0)
		case 86:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedDisjunctionStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedDisjunctionStats = bool(v != 0)
		case 88:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseLimitOrderingForStreamingGroupBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseLimitOrderingForStreamingGroupBy = bool(v != 0)
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFromRetriesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFromRetriesEnabled = bool(v != 0)
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclareCursorStatementTimeoutEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeclareCursorStatementTimeoutEnabled = bool(v != 0)
		case 91:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedSplitDisjunctionForJoins", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedSplitDisjunctionForJoins = bool(v != 0)
		case 92:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectRetryErrorsOnCommitEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InjectRetryErrorsOnCommitEnabled = bool(v != 0)
		case 94:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerAlwaysUseHistograms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerAlwaysUseHistograms = bool(v != 0)
		case 95:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCreateStatsUsingExtremes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCreateStatsUsingExtremes = bool(v != 0)
		case 96:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowRoleMembershipsToChangeDuringTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowRoleMembershipsToChangeDuringTransaction = bool(v != 0)
		case 97:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedStatementsCacheSize", wireType)
			}
			m.PreparedStatementsCacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparedStatementsCacheSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleActivePortalsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultipleActivePortalsEnabled = bool(v != 0)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnboundedParallelScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnboundedParallelScans = bool(v != 0)
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerHoistUncorrelatedEqualitySubqueries", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerHoistUncorrelatedEqualitySubqueries = bool(v != 0)
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerInjectPanics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestingOptimizerInjectPanics = bool(v != 0)
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedComputedColumnFiltersDerivation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedComputedColumnFiltersDerivation = bool(v != 0)
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnIsolationLevel", wireType)
			}
			m.DefaultTxnIsolationLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTxnIsolationLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationMode", wireType)
			}
			m.ReplicationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationMode |= ReplicationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 107:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedJoinElimination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedJoinElimination = bool(v != 0)
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitFKLockingForSerializable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitFKLockingForSerializable = bool(v != 0)
		case 109:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurableLockingForSerializable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DurableLockingForSerializable = bool(v != 0)
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetriesForReadCommitted", wireType)
			}
			m.MaxRetriesForReadCommitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetriesForReadCommitted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictDDLAtomicity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrictDDLAtomicity = bool(v != 0)
		case 112:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedLockingForSerializable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SharedLockingForSerializable = bool(v != 0)
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsafeSettingInterlockKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnsafeSettingInterlockKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 114:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseLockOpForSerializable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseLockOpForSerializable = bool(v != 0)
		case 115:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseProvidedOrderingFix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseProvidedOrderingFix = bool(v != 0)
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableChangefeedReplication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableChangefeedReplication = bool(v != 0)
		case 117:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyTxnQualityOfService", wireType)
			}
			m.CopyTxnQualityOfService = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyTxnQualityOfService |= QoSLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 118:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyWritePipeliningEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyWritePipeliningEnabled = bool(v != 0)
		case 119:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerMergeJoinsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerMergeJoinsEnabled = bool(v != 0)
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyNumRetriesPerBatch", wireType)
			}
			m.CopyNumRetriesPerBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyNumRetriesPerBatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCommitBeforeDDL", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoCommitBeforeDDL = bool(v != 0)
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCursorsAtCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseCursorsAtCommit = bool(v != 0)
		case 123:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PLpgSQLUseStrictInto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PLpgSQLUseStrictInto = bool(v != 0)
		case 124:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseVirtualComputedColumnStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseVirtualComputedColumnStats = bool(v != 0)
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseTrigramSimilarityOptimization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseTrigramSimilarityOptimization = bool(v != 0)
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedDistinctOnLimitHintCosting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedDistinctOnLimitHintCosting = bool(v != 0)
		case 127:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedTrigramSimilaritySelectivity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedTrigramSimilaritySelectivity = bool(v != 0)
		case 128:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedZigzagJoinCosting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedZigzagJoinCosting = bool(v != 0)
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedMultiColumnSelectivityEstimate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedMultiColumnSelectivityEstimate = bool(v != 0)
		case 130:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerProveImplicationWithVirtualComputedColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerProveImplicationWithVirtualComputedColumns = bool(v != 0)
		case 132:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerPushOffsetIntoIndexJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerPushOffsetIntoIndexJoin = bool(v != 0)
		case 133:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanCacheMode", wireType)
			}
			m.PlanCacheMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanCacheMode |= PlanCacheMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUsePolymorphicParameterFix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUsePolymorphicParameterFix = bool(v != 0)
		case 135:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginIDForLogicalDataReplication", wireType)
			}
			m.OriginIDForLogicalDataReplication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginIDForLogicalDataReplication |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 136:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCreateStatsUsingExtremesBoolEnum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCreateStatsUsingExtremesBoolEnum = bool(v != 0)
		case 137:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseMergedPartialStatistics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseMergedPartialStatistics = bool(v != 0)
		case 138:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseConditionalHoistFix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseConditionalHoistFix = bool(v != 0)
		case 139:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerPushLimitIntoProjectFilteredScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerPushLimitIntoProjectFilteredScan = bool(v != 0)
		case 140:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTimestampForLogicalDataReplication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginTimestampForLogicalDataReplication.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 141:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassPCRReaderCatalogAOST", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BypassPCRReaderCatalogAOST = bool(v != 0)
		case 142:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsafeAllowTriggersModifyingCascades", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnsafeAllowTriggersModifyingCascades = bool(v != 0)
		case 143:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableVecUnionEagerCancellation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableVecUnionEagerCancellation = bool(v != 0)
		case 144:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursionDepthLimit", wireType)
			}
			m.RecursionDepthLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecursionDepthLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 145:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributeGroupByRowCountThreshold", wireType)
			}
			m.DistributeGroupByRowCountThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributeGroupByRowCountThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 146:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributeSortRowCountThreshold", wireType)
			}
			m.DistributeSortRowCountThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributeSortRowCountThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 147:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributeScanRowCountThreshold", wireType)
			}
			m.DistributeScanRowCountThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributeScanRowCountThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 148:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysDistributeFullScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysDistributeFullScans = bool(v != 0)
		case 149:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributeJoinRowCountThreshold", wireType)
			}
			m.DistributeJoinRowCountThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributeJoinRowCountThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 150:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyVarcharTyping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LegacyVarcharTyping = bool(v != 0)
		case 151:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvoidFullTableScansInMutations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvoidFullTableScansInMutations = bool(v != 0)
		case 153:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogDigestStalenessCheckEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CatalogDigestStalenessCheckEnabled = bool(v != 0)
		case 154:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerPreferBoundedCardinality", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerPreferBoundedCardinality = bool(v != 0)
		case 155:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerMinRowCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptimizerMinRowCount = float64(math.Float64frombits(v))
		case 156:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferedWritesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BufferedWritesEnabled = bool(v != 0)
		case 157:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerCheckInputMinRowCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptimizerCheckInputMinRowCount = float64(math.Float64frombits(v))
		case 158:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerPlanLookupJoinsWithReverseScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerPlanLookupJoinsWithReverseScans = bool(v != 0)
		case 159:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterLatchWaitContentionEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RegisterLatchWaitContentionEvents = bool(v != 0)
		case 160:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCPutsOnNonUniqueIndexes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCPutsOnNonUniqueIndexes = bool(v != 0)
		case 161:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferedWritesUseLockingOnNonUniqueIndexes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BufferedWritesUseLockingOnNonUniqueIndexes = bool(v != 0)
		case 162:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseLockElisionMultipleFamilies", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseLockElisionMultipleFamilies = bool(v != 0)
		case 163:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerEnableLockElision", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerEnableLockElision = bool(v != 0)
		case 164:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseDeleteRangeFastPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseDeleteRangeFastPath = bool(v != 0)
		case 165:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCreateTriggerFunctionWithArgvReferences", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCreateTriggerFunctionWithArgvReferences = bool(v != 0)
		case 166:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTableWithSchemaLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateTableWithSchemaLocked = bool(v != 0)
		case 167:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePre_25_2VariadicBuiltins", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePre_25_2VariadicBuiltins = bool(v != 0)
		case 168:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorSearchBeamSize", wireType)
			}
			m.VectorSearchBeamSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VectorSearchBeamSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 169:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagateAdmissionHeaderToLeafTransactions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropagateAdmissionHeaderToLeafTransactions = bool(v != 0)
		case 170:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseExistsFilterHoistRule", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseExistsFilterHoistRule = bool(v != 0)
		case 171:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRetryBackoffForReadCommitted", wireType)
			}
			m.InitialRetryBackoffForReadCommitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialRetryBackoffForReadCommitted |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 172:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseImprovedRoutineDependencyTracking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseImprovedRoutineDependencyTracking = bool(v != 0)
		case 173:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerDisableCrossRegionCascadeFastPathForRBRTables", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerDisableCrossRegionCascadeFastPathForRBRTables = bool(v != 0)
		case 174:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQLUseReducedLeafWriteSets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DistSQLUseReducedLeafWriteSets = bool(v != 0)
		case 175:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseProcTxnControlExtendedProtocolFix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseProcTxnControlExtendedProtocolFix = bool(v != 0)
		case 176:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableScrubJob", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableScrubJob = bool(v != 0)
		case 177:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowViewWithSecurityInvokerClause", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowViewWithSecurityInvokerClause = bool(v != 0)
		case 178:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorSearchRerankMultiplier", wireType)
			}
			m.VectorSearchRerankMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VectorSearchRerankMultiplier |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 179:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelizeMultiKeyLookupJoinsAvgLookupRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ParallelizeMultiKeyLookupJoinsAvgLookupRatio = float64(math.Float64frombits(v))
		case 180:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelizeMultiKeyLookupJoinsMaxLookupRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ParallelizeMultiKeyLookupJoinsMaxLookupRatio = float64(math.Float64frombits(v))
		case 181:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelizeMultiKeyLookupJoinsAvgLookupRowSize", wireType)
			}
			m.ParallelizeMultiKeyLookupJoinsAvgLookupRowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParallelizeMultiKeyLookupJoinsAvgLookupRowSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 182:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ParallelizeMultiKeyLookupJoinsOnlyOnMRMutations = bool(v != 0)
		case 183:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowUnsafeInternals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowUnsafeInternals = bool(v != 0)
		case 184:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOptimizerRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableOptimizerRules = append(m.DisableOptimizerRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 185:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSoftLimitForDistributeScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSoftLimitForDistributeScan = bool(v != 0)
		case 186:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedHoistJoinProject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedHoistJoinProject = bool(v != 0)
		case 187:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInspectCommand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableInspectCommand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceCacheEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceCacheEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceCacheEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedVersion", wireType)
			}
			m.CachedVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentValue", wireType)
			}
			m.CurrentValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			m.Increment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Increment |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumValues", wireType)
			}
			m.NumValues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumValues |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocalOnlySessionData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocalOnlySessionData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLocalOnlySessionData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLocalOnlySessionData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLocalOnlySessionData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocalOnlySessionData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLocalOnlySessionData = fmt.Errorf("proto: unexpected end of group")
)

