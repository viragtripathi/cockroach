// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/schemachanger/scpb/elements.proto

package scpb

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	zonepb "github.com/cockroachdb/cockroach/pkg/config/zonepb"
	geopb "github.com/cockroachdb/cockroach/pkg/geo/geopb"
	catenumpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catenumpb"
	catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_sem_catid "github.com/cockroachdb/cockroach/pkg/sql/sem/catid"
	idxtype "github.com/cockroachdb/cockroach/pkg/sql/sem/idxtype"
	semenumpb "github.com/cockroachdb/cockroach/pkg/sql/sem/semenumpb"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	vecpb "github.com/cockroachdb/cockroach/pkg/sql/vecindex/vecpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Usage indicates that this expression is being added for. We need to identify
// usages, such as the the USING clause of an ALTER COLUMN .. TYPE operation,
// to properly order dependency rules.
type ColumnComputeExpression_Usage int32

const (
	// REGULAR means its added by the user as an explicit compute expression.
	ColumnComputeExpression_REGULAR ColumnComputeExpression_Usage = 0
	// ALTER_TYPE_USING means it is part of the USING clause
	// in an ALTER COLUMN ... TYPE operation.
	ColumnComputeExpression_ALTER_TYPE_USING ColumnComputeExpression_Usage = 1
)

var ColumnComputeExpression_Usage_name = map[int32]string{
	0: "REGULAR",
	1: "ALTER_TYPE_USING",
}

var ColumnComputeExpression_Usage_value = map[string]int32{
	"REGULAR":          0,
	"ALTER_TYPE_USING": 1,
}

func (x ColumnComputeExpression_Usage) String() string {
	return proto.EnumName(ColumnComputeExpression_Usage_name, int32(x))
}

func (ColumnComputeExpression_Usage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{5, 0}
}

type IndexColumn_Kind int32

const (
	IndexColumn_KEY        IndexColumn_Kind = 0
	IndexColumn_KEY_SUFFIX IndexColumn_Kind = 1
	IndexColumn_STORED     IndexColumn_Kind = 2
)

var IndexColumn_Kind_name = map[int32]string{
	0: "KEY",
	1: "KEY_SUFFIX",
	2: "STORED",
}

var IndexColumn_Kind_value = map[string]int32{
	"KEY":        0,
	"KEY_SUFFIX": 1,
	"STORED":     2,
}

func (x IndexColumn_Kind) String() string {
	return proto.EnumName(IndexColumn_Kind_name, int32(x))
}

func (IndexColumn_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{73, 0}
}

// ElementProto is the union type of all _elements_, which are the foundation
// of how we model schema changes in the declarative schema changer.
//
// A core design principle is that each element owns its back-references, that
// is to say, it is responsible for updating any back-references in the
// descriptors that it references as part of its lifecycle, i.e. going from
// ABSENT to PUBLIC or vice-versa. As a corollary, back-references are not
// modelled as elements at all, they exist purely as a side-effect. In an ideal
// world, they would be modelled as elements just like everything else, however
// we currently don't have 1:1 relationships between forward and back-references
// in all cases: we do for foreign keys for example, but we don't for type
// references (back-references are modelled as a set in the type descriptor).
//
// Regardless, this principle does have the inherent virtue of keeping the
// element model relatively simple, if at the expense of pushing the complexity
// down to the execution layer in scmutationexec. This trade-off is acceptable
// though: the back-reference update code is quite self-contained and the
// added complexity consists in making these operations work on a best-effort
// basis, i.e. with not many assumptions about whether something is dropped or
// not, etc.
//
// A less strong principle is that each element should remain immutable
// throughout its lifecycle. In practice we sometimes deviate from this for
// elements which have only just had targets defined for them and thus haven't
// yet undergone any status changes. In any case, that kind of hackery is best
// kept at a minimum.
type ElementProto struct {
	// Types that are valid to be assigned to ElementOneOf:
	//	*ElementProto_Database
	//	*ElementProto_Schema
	//	*ElementProto_View
	//	*ElementProto_Sequence
	//	*ElementProto_Table
	//	*ElementProto_EnumType
	//	*ElementProto_AliasType
	//	*ElementProto_CompositeType
	//	*ElementProto_Function
	//	*ElementProto_NamedRangeZoneConfig
	//	*ElementProto_ColumnFamily
	//	*ElementProto_Column
	//	*ElementProto_PrimaryIndex
	//	*ElementProto_SecondaryIndex
	//	*ElementProto_TemporaryIndex
	//	*ElementProto_UniqueWithoutIndexConstraint
	//	*ElementProto_UniqueWithoutIndexConstraintUnvalidated
	//	*ElementProto_CheckConstraint
	//	*ElementProto_CheckConstraintUnvalidated
	//	*ElementProto_ForeignKeyConstraint
	//	*ElementProto_ForeignKeyConstraintUnvalidated
	//	*ElementProto_TableComment
	//	*ElementProto_RowLevelTTL
	//	*ElementProto_TableZoneConfig
	//	*ElementProto_IndexZoneConfig
	//	*ElementProto_TableData
	//	*ElementProto_TablePartitioning
	//	*ElementProto_TableSchemaLocked
	//	*ElementProto_LDRJobIDs
	//	*ElementProto_PartitionZoneConfig
	//	*ElementProto_Trigger
	//	*ElementProto_Policy
	//	*ElementProto_RowLevelSecurityEnabled
	//	*ElementProto_RowLevelSecurityForced
	//	*ElementProto_TableLocalityGlobal
	//	*ElementProto_TableLocalityPrimaryRegion
	//	*ElementProto_TableLocalitySecondaryRegion
	//	*ElementProto_TableLocalityRegionalByRow
	//	*ElementProto_TableLocalityRegionalByRowUsingConstraint
	//	*ElementProto_ColumnName
	//	*ElementProto_ColumnType
	//	*ElementProto_ColumnDefaultExpression
	//	*ElementProto_ColumnOnUpdateExpression
	//	*ElementProto_SequenceOwner
	//	*ElementProto_ColumnComment
	//	*ElementProto_ColumnNotNull
	//	*ElementProto_ColumnComputeExpression
	//	*ElementProto_SequenceOption
	//	*ElementProto_IndexName
	//	*ElementProto_IndexPartitioning
	//	*ElementProto_IndexComment
	//	*ElementProto_IndexColumn
	//	*ElementProto_IndexData
	//	*ElementProto_ConstraintWithoutIndexName
	//	*ElementProto_ConstraintComment
	//	*ElementProto_Namespace
	//	*ElementProto_Owner
	//	*ElementProto_UserPrivileges
	//	*ElementProto_DatabaseRegionConfig
	//	*ElementProto_DatabaseRoleSetting
	//	*ElementProto_DatabaseComment
	//	*ElementProto_DatabaseData
	//	*ElementProto_DatabaseZoneConfig
	//	*ElementProto_SchemaParent
	//	*ElementProto_SchemaComment
	//	*ElementProto_SchemaChild
	//	*ElementProto_EnumTypeValue
	//	*ElementProto_CompositeTypeAttrType
	//	*ElementProto_CompositeTypeAttrName
	//	*ElementProto_FunctionName
	//	*ElementProto_FunctionVolatility
	//	*ElementProto_FunctionLeakProof
	//	*ElementProto_FunctionNullInputBehavior
	//	*ElementProto_FunctionBody
	//	*ElementProto_FunctionSecurity
	//	*ElementProto_TypeComment
	//	*ElementProto_TriggerName
	//	*ElementProto_TriggerEnabled
	//	*ElementProto_TriggerTiming
	//	*ElementProto_TriggerEvents
	//	*ElementProto_TriggerTransition
	//	*ElementProto_TriggerWhen
	//	*ElementProto_TriggerFunctionCall
	//	*ElementProto_TriggerDeps
	//	*ElementProto_PolicyName
	//	*ElementProto_PolicyRole
	//	*ElementProto_PolicyUsingExpr
	//	*ElementProto_PolicyWithCheckExpr
	//	*ElementProto_PolicyDeps
	ElementOneOf isElementProto_ElementOneOf `protobuf_oneof:"element_one_of"`
}

func (m *ElementProto) Reset()         { *m = ElementProto{} }
func (m *ElementProto) String() string { return proto.CompactTextString(m) }
func (*ElementProto) ProtoMessage()    {}
func (*ElementProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{0}
}
func (m *ElementProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElementProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElementProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementProto.Merge(m, src)
}
func (m *ElementProto) XXX_Size() int {
	return m.Size()
}
func (m *ElementProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementProto.DiscardUnknown(m)
}

var xxx_messageInfo_ElementProto proto.InternalMessageInfo

type isElementProto_ElementOneOf interface {
	isElementProto_ElementOneOf()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ElementProto_Database struct {
	Database *Database `protobuf:"bytes,1,opt,name=database,proto3,oneof" json:"database,omitempty"`
}
type ElementProto_Schema struct {
	Schema *Schema `protobuf:"bytes,2,opt,name=schema,proto3,oneof" json:"schema,omitempty"`
}
type ElementProto_View struct {
	View *View `protobuf:"bytes,3,opt,name=view,proto3,oneof" json:"view,omitempty"`
}
type ElementProto_Sequence struct {
	Sequence *Sequence `protobuf:"bytes,4,opt,name=sequence,proto3,oneof" json:"sequence,omitempty"`
}
type ElementProto_Table struct {
	Table *Table `protobuf:"bytes,5,opt,name=table,proto3,oneof" json:"table,omitempty"`
}
type ElementProto_EnumType struct {
	EnumType *EnumType `protobuf:"bytes,6,opt,name=enum_type,json=enumType,proto3,oneof" json:"enum_type,omitempty"`
}
type ElementProto_AliasType struct {
	AliasType *AliasType `protobuf:"bytes,7,opt,name=alias_type,json=aliasType,proto3,oneof" json:"alias_type,omitempty"`
}
type ElementProto_CompositeType struct {
	CompositeType *CompositeType `protobuf:"bytes,8,opt,name=composite_type,json=compositeType,proto3,oneof" json:"composite_type,omitempty"`
}
type ElementProto_Function struct {
	Function *Function `protobuf:"bytes,9,opt,name=function,proto3,oneof" json:"function,omitempty"`
}
type ElementProto_NamedRangeZoneConfig struct {
	NamedRangeZoneConfig *NamedRangeZoneConfig `protobuf:"bytes,220,opt,name=named_range_zone_config,json=namedRangeZoneConfig,proto3,oneof" json:"named_range_zone_config,omitempty"`
}
type ElementProto_ColumnFamily struct {
	ColumnFamily *ColumnFamily `protobuf:"bytes,20,opt,name=column_family,json=columnFamily,proto3,oneof" json:"column_family,omitempty" parent:"Table"`
}
type ElementProto_Column struct {
	Column *Column `protobuf:"bytes,21,opt,name=column,proto3,oneof" json:"column,omitempty" parent:"Table, View"`
}
type ElementProto_PrimaryIndex struct {
	PrimaryIndex *PrimaryIndex `protobuf:"bytes,22,opt,name=primary_index,json=primaryIndex,proto3,oneof" json:"primary_index,omitempty" parent:"Table, View"`
}
type ElementProto_SecondaryIndex struct {
	SecondaryIndex *SecondaryIndex `protobuf:"bytes,23,opt,name=secondary_index,json=secondaryIndex,proto3,oneof" json:"secondary_index,omitempty" parent:"Table, View"`
}
type ElementProto_TemporaryIndex struct {
	TemporaryIndex *TemporaryIndex `protobuf:"bytes,24,opt,name=temporary_index,json=temporaryIndex,proto3,oneof" json:"temporary_index,omitempty" parent:"Table, View"`
}
type ElementProto_UniqueWithoutIndexConstraint struct {
	UniqueWithoutIndexConstraint *UniqueWithoutIndexConstraint `protobuf:"bytes,25,opt,name=unique_without_index_constraint,json=uniqueWithoutIndexConstraint,proto3,oneof" json:"unique_without_index_constraint,omitempty" parent:"Table"`
}
type ElementProto_UniqueWithoutIndexConstraintUnvalidated struct {
	UniqueWithoutIndexConstraintUnvalidated *UniqueWithoutIndexConstraintUnvalidated `protobuf:"bytes,171,opt,name=unique_without_index_constraint_unvalidated,json=uniqueWithoutIndexConstraintUnvalidated,proto3,oneof" json:"unique_without_index_constraint_unvalidated,omitempty" parent:"Table"`
}
type ElementProto_CheckConstraint struct {
	CheckConstraint *CheckConstraint `protobuf:"bytes,26,opt,name=check_constraint,json=checkConstraint,proto3,oneof" json:"check_constraint,omitempty" parent:"Table"`
}
type ElementProto_CheckConstraintUnvalidated struct {
	CheckConstraintUnvalidated *CheckConstraintUnvalidated `protobuf:"bytes,170,opt,name=check_constraint_unvalidated,json=checkConstraintUnvalidated,proto3,oneof" json:"check_constraint_unvalidated,omitempty" parent:"Table"`
}
type ElementProto_ForeignKeyConstraint struct {
	ForeignKeyConstraint *ForeignKeyConstraint `protobuf:"bytes,27,opt,name=foreign_key_constraint,json=foreignKeyConstraint,proto3,oneof" json:"foreign_key_constraint,omitempty" parent:"Table"`
}
type ElementProto_ForeignKeyConstraintUnvalidated struct {
	ForeignKeyConstraintUnvalidated *ForeignKeyConstraintUnvalidated `protobuf:"bytes,172,opt,name=foreign_key_constraint_unvalidated,json=foreignKeyConstraintUnvalidated,proto3,oneof" json:"foreign_key_constraint_unvalidated,omitempty" parent:"Table"`
}
type ElementProto_TableComment struct {
	TableComment *TableComment `protobuf:"bytes,28,opt,name=table_comment,json=tableComment,proto3,oneof" json:"table_comment,omitempty" parent:"Table, View, Sequence"`
}
type ElementProto_RowLevelTTL struct {
	RowLevelTTL *RowLevelTTL `protobuf:"bytes,29,opt,name=row_level_ttl,json=rowLevelTtl,proto3,oneof" json:"row_level_ttl,omitempty" parent:"Table"`
}
type ElementProto_TableZoneConfig struct {
	TableZoneConfig *TableZoneConfig `protobuf:"bytes,121,opt,name=table_zone_config,json=tableZoneConfig,proto3,oneof" json:"table_zone_config,omitempty" parent:"Table, View"`
}
type ElementProto_IndexZoneConfig struct {
	IndexZoneConfig *IndexZoneConfig `protobuf:"bytes,122,opt,name=index_zone_config,json=indexZoneConfig,proto3,oneof" json:"index_zone_config,omitempty" parent:"Index"`
}
type ElementProto_TableData struct {
	TableData *TableData `protobuf:"bytes,131,opt,name=table_data,json=tableData,proto3,oneof" json:"table_data,omitempty" parent:"Table, View, Sequence"`
}
type ElementProto_TablePartitioning struct {
	TablePartitioning *TablePartitioning `protobuf:"bytes,132,opt,name=table_partitioning,json=tablePartitioning,proto3,oneof" json:"table_partitioning,omitempty" parent:"Table"`
}
type ElementProto_TableSchemaLocked struct {
	TableSchemaLocked *TableSchemaLocked `protobuf:"bytes,133,opt,name=table_schema_locked,json=tableSchemaLocked,proto3,oneof" json:"table_schema_locked,omitempty" parent:"Table"`
}
type ElementProto_LDRJobIDs struct {
	LDRJobIDs *LDRJobIDs `protobuf:"bytes,134,opt,name=ldr_job_ids,json=ldrJobIds,proto3,oneof" json:"ldr_job_ids,omitempty" parent:"Table"`
}
type ElementProto_PartitionZoneConfig struct {
	PartitionZoneConfig *PartitionZoneConfig `protobuf:"bytes,135,opt,name=partition_zone_config,json=partitionZoneConfig,proto3,oneof" json:"partition_zone_config,omitempty" parent:"TablePartitioning"`
}
type ElementProto_Trigger struct {
	Trigger *Trigger `protobuf:"bytes,136,opt,name=trigger,proto3,oneof" json:"trigger,omitempty" parent:"Table, View"`
}
type ElementProto_Policy struct {
	Policy *Policy `protobuf:"bytes,137,opt,name=policy,proto3,oneof" json:"policy,omitempty" parent:"Table"`
}
type ElementProto_RowLevelSecurityEnabled struct {
	RowLevelSecurityEnabled *RowLevelSecurityEnabled `protobuf:"bytes,138,opt,name=row_level_security_enabled,json=rowLevelSecurityEnabled,proto3,oneof" json:"row_level_security_enabled,omitempty" parent:"Table"`
}
type ElementProto_RowLevelSecurityForced struct {
	RowLevelSecurityForced *RowLevelSecurityForced `protobuf:"bytes,139,opt,name=row_level_security_forced,json=rowLevelSecurityForced,proto3,oneof" json:"row_level_security_forced,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityGlobal struct {
	TableLocalityGlobal *TableLocalityGlobal `protobuf:"bytes,110,opt,name=table_locality_global,json=tableLocalityGlobal,proto3,oneof" json:"table_locality_global,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityPrimaryRegion struct {
	TableLocalityPrimaryRegion *TableLocalityPrimaryRegion `protobuf:"bytes,111,opt,name=table_locality_primary_region,json=tableLocalityPrimaryRegion,proto3,oneof" json:"table_locality_primary_region,omitempty" parent:"Table"`
}
type ElementProto_TableLocalitySecondaryRegion struct {
	TableLocalitySecondaryRegion *TableLocalitySecondaryRegion `protobuf:"bytes,112,opt,name=table_locality_secondary_region,json=tableLocalitySecondaryRegion,proto3,oneof" json:"table_locality_secondary_region,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityRegionalByRow struct {
	TableLocalityRegionalByRow *TableLocalityRegionalByRow `protobuf:"bytes,113,opt,name=table_locality_regional_by_row,json=tableLocalityRegionalByRow,proto3,oneof" json:"table_locality_regional_by_row,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityRegionalByRowUsingConstraint struct {
	TableLocalityRegionalByRowUsingConstraint *TableLocalityRegionalByRowUsingConstraint `protobuf:"bytes,114,opt,name=table_locality_regional_by_row_using_constraint,json=tableLocalityRegionalByRowUsingConstraint,proto3,oneof" json:"table_locality_regional_by_row_using_constraint,omitempty" parent:"Table"`
}
type ElementProto_ColumnName struct {
	ColumnName *ColumnName `protobuf:"bytes,30,opt,name=column_name,json=columnName,proto3,oneof" json:"column_name,omitempty" parent:"Column"`
}
type ElementProto_ColumnType struct {
	ColumnType *ColumnType `protobuf:"bytes,31,opt,name=column_type,json=columnType,proto3,oneof" json:"column_type,omitempty" parent:"Column"`
}
type ElementProto_ColumnDefaultExpression struct {
	ColumnDefaultExpression *ColumnDefaultExpression `protobuf:"bytes,32,opt,name=column_default_expression,json=columnDefaultExpression,proto3,oneof" json:"column_default_expression,omitempty" parent:"Column"`
}
type ElementProto_ColumnOnUpdateExpression struct {
	ColumnOnUpdateExpression *ColumnOnUpdateExpression `protobuf:"bytes,33,opt,name=column_on_update_expression,json=columnOnUpdateExpression,proto3,oneof" json:"column_on_update_expression,omitempty" parent:"Column"`
}
type ElementProto_SequenceOwner struct {
	SequenceOwner *SequenceOwner `protobuf:"bytes,34,opt,name=sequence_owner,json=sequenceOwner,proto3,oneof" json:"sequence_owner,omitempty" parent:"Column"`
}
type ElementProto_ColumnComment struct {
	ColumnComment *ColumnComment `protobuf:"bytes,35,opt,name=column_comment,json=columnComment,proto3,oneof" json:"column_comment,omitempty" parent:"Column"`
}
type ElementProto_ColumnNotNull struct {
	ColumnNotNull *ColumnNotNull `protobuf:"bytes,36,opt,name=column_not_null,json=columnNotNull,proto3,oneof" json:"column_not_null,omitempty" parent:"Column"`
}
type ElementProto_ColumnComputeExpression struct {
	ColumnComputeExpression *ColumnComputeExpression `protobuf:"bytes,190,opt,name=column_compute_expression,json=columnComputeExpression,proto3,oneof" json:"column_compute_expression,omitempty" parent:"Column"`
}
type ElementProto_SequenceOption struct {
	SequenceOption *SequenceOption `protobuf:"bytes,37,opt,name=sequence_option,json=sequenceOption,proto3,oneof" json:"sequence_option,omitempty" parent:"Sequence"`
}
type ElementProto_IndexName struct {
	IndexName *IndexName `protobuf:"bytes,40,opt,name=index_name,json=indexName,proto3,oneof" json:"index_name,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
}
type ElementProto_IndexPartitioning struct {
	IndexPartitioning *IndexPartitioning `protobuf:"bytes,41,opt,name=index_partitioning,json=indexPartitioning,proto3,oneof" json:"index_partitioning,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
}
type ElementProto_IndexComment struct {
	IndexComment *IndexComment `protobuf:"bytes,43,opt,name=index_comment,json=indexComment,proto3,oneof" json:"index_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
}
type ElementProto_IndexColumn struct {
	IndexColumn *IndexColumn `protobuf:"bytes,44,opt,name=index_column,json=indexColumn,proto3,oneof" json:"index_column,omitempty" parent:"PrimaryIndex, SecondaryIndex, TemporaryIndex, Column"`
}
type ElementProto_IndexData struct {
	IndexData *IndexData `protobuf:"bytes,45,opt,name=index_data,json=indexData,proto3,oneof" json:"index_data,omitempty" parent:"PrimaryIndex, SecondaryIndex, TemporaryIndex"`
}
type ElementProto_ConstraintWithoutIndexName struct {
	ConstraintWithoutIndexName *ConstraintWithoutIndexName `protobuf:"bytes,51,opt,name=constraint_without_index_name,json=constraintWithoutIndexName,proto3,oneof" json:"constraint_without_index_name,omitempty" parent:"UniqueWithoutIndexConstraint, CheckConstraint, ForeignKeyConstraint"`
}
type ElementProto_ConstraintComment struct {
	ConstraintComment *ConstraintComment `protobuf:"bytes,52,opt,name=constraint_comment,json=constraintComment,proto3,oneof" json:"constraint_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex, UniqueWithoutIndexConstraint, CheckConstraint, ForeignKeyConstraint"`
}
type ElementProto_Namespace struct {
	Namespace *Namespace `protobuf:"bytes,60,opt,name=namespace,proto3,oneof" json:"namespace,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
}
type ElementProto_Owner struct {
	Owner *Owner `protobuf:"bytes,61,opt,name=owner,proto3,oneof" json:"owner,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
}
type ElementProto_UserPrivileges struct {
	UserPrivileges *UserPrivileges `protobuf:"bytes,62,opt,name=user_privileges,json=userPrivileges,proto3,oneof" json:"user_privileges,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
}
type ElementProto_DatabaseRegionConfig struct {
	DatabaseRegionConfig *DatabaseRegionConfig `protobuf:"bytes,80,opt,name=database_region_config,json=databaseRegionConfig,proto3,oneof" json:"database_region_config,omitempty" parent:"Database"`
}
type ElementProto_DatabaseRoleSetting struct {
	DatabaseRoleSetting *DatabaseRoleSetting `protobuf:"bytes,81,opt,name=database_role_setting,json=databaseRoleSetting,proto3,oneof" json:"database_role_setting,omitempty" parent:"Database"`
}
type ElementProto_DatabaseComment struct {
	DatabaseComment *DatabaseComment `protobuf:"bytes,82,opt,name=database_comment,json=databaseComment,proto3,oneof" json:"database_comment,omitempty" parent:"Database"`
}
type ElementProto_DatabaseData struct {
	DatabaseData *DatabaseData `protobuf:"bytes,83,opt,name=database_data,json=databaseData,proto3,oneof" json:"database_data,omitempty" parent:"Database"`
}
type ElementProto_DatabaseZoneConfig struct {
	DatabaseZoneConfig *DatabaseZoneConfig `protobuf:"bytes,84,opt,name=database_zone_config,json=databaseZoneConfig,proto3,oneof" json:"database_zone_config,omitempty" parent:"Database"`
}
type ElementProto_SchemaParent struct {
	SchemaParent *SchemaParent `protobuf:"bytes,90,opt,name=schema_parent,json=schemaParent,proto3,oneof" json:"schema_parent,omitempty" parent:"Schema"`
}
type ElementProto_SchemaComment struct {
	SchemaComment *SchemaComment `protobuf:"bytes,91,opt,name=schema_comment,json=schemaComment,proto3,oneof" json:"schema_comment,omitempty" parent:"Schema"`
}
type ElementProto_SchemaChild struct {
	SchemaChild *SchemaChild `protobuf:"bytes,100,opt,name=schema_child,json=schemaChild,proto3,oneof" json:"schema_child,omitempty" parent:"AliasType, EnumType, Table, View, Sequence"`
}
type ElementProto_EnumTypeValue struct {
	EnumTypeValue *EnumTypeValue `protobuf:"bytes,120,opt,name=enum_type_value,json=enumTypeValue,proto3,oneof" json:"enum_type_value,omitempty" parent:"EnumType"`
}
type ElementProto_CompositeTypeAttrType struct {
	CompositeTypeAttrType *CompositeTypeAttrType `protobuf:"bytes,140,opt,name=composite_type_attr_type,json=compositeTypeAttrType,proto3,oneof" json:"composite_type_attr_type,omitempty" parent:"CompositeType"`
}
type ElementProto_CompositeTypeAttrName struct {
	CompositeTypeAttrName *CompositeTypeAttrName `protobuf:"bytes,141,opt,name=composite_type_attr_name,json=compositeTypeAttrName,proto3,oneof" json:"composite_type_attr_name,omitempty" parent:"CompositeType"`
}
type ElementProto_FunctionName struct {
	FunctionName *FunctionName `protobuf:"bytes,160,opt,name=function_name,json=functionName,proto3,oneof" json:"function_name,omitempty" parent:"Function"`
}
type ElementProto_FunctionVolatility struct {
	FunctionVolatility *FunctionVolatility `protobuf:"bytes,161,opt,name=function_volatility,json=functionVolatility,proto3,oneof" json:"function_volatility,omitempty" parent:"Function"`
}
type ElementProto_FunctionLeakProof struct {
	FunctionLeakProof *FunctionLeakProof `protobuf:"bytes,162,opt,name=function_leak_proof,json=functionLeakProof,proto3,oneof" json:"function_leak_proof,omitempty" parent:"Function"`
}
type ElementProto_FunctionNullInputBehavior struct {
	FunctionNullInputBehavior *FunctionNullInputBehavior `protobuf:"bytes,163,opt,name=function_null_input_behavior,json=functionNullInputBehavior,proto3,oneof" json:"function_null_input_behavior,omitempty" parent:"Function"`
}
type ElementProto_FunctionBody struct {
	FunctionBody *FunctionBody `protobuf:"bytes,164,opt,name=function_body,json=functionBody,proto3,oneof" json:"function_body,omitempty" parent:"Function"`
}
type ElementProto_FunctionSecurity struct {
	FunctionSecurity *FunctionSecurity `protobuf:"bytes,165,opt,name=function_security,json=functionSecurity,proto3,oneof" json:"function_security,omitempty" parent:"Function"`
}
type ElementProto_TypeComment struct {
	TypeComment *TypeComment `protobuf:"bytes,180,opt,name=type_comment,json=typeComment,proto3,oneof" json:"type_comment,omitempty" parent:"CompositeType,EnumType"`
}
type ElementProto_TriggerName struct {
	TriggerName *TriggerName `protobuf:"bytes,200,opt,name=trigger_name,json=triggerName,proto3,oneof" json:"trigger_name,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerEnabled struct {
	TriggerEnabled *TriggerEnabled `protobuf:"bytes,201,opt,name=trigger_enabled,json=triggerEnabled,proto3,oneof" json:"trigger_enabled,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerTiming struct {
	TriggerTiming *TriggerTiming `protobuf:"bytes,202,opt,name=trigger_timing,json=triggerTiming,proto3,oneof" json:"trigger_timing,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerEvents struct {
	TriggerEvents *TriggerEvents `protobuf:"bytes,203,opt,name=trigger_events,json=triggerEvents,proto3,oneof" json:"trigger_events,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerTransition struct {
	TriggerTransition *TriggerTransition `protobuf:"bytes,204,opt,name=trigger_transition,json=triggerTransition,proto3,oneof" json:"trigger_transition,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerWhen struct {
	TriggerWhen *TriggerWhen `protobuf:"bytes,205,opt,name=trigger_when,json=triggerWhen,proto3,oneof" json:"trigger_when,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerFunctionCall struct {
	TriggerFunctionCall *TriggerFunctionCall `protobuf:"bytes,206,opt,name=trigger_function_call,json=triggerFunctionCall,proto3,oneof" json:"trigger_function_call,omitempty" parent:"Trigger"`
}
type ElementProto_TriggerDeps struct {
	TriggerDeps *TriggerDeps `protobuf:"bytes,207,opt,name=trigger_deps,json=triggerDeps,proto3,oneof" json:"trigger_deps,omitempty" parent:"Trigger"`
}
type ElementProto_PolicyName struct {
	PolicyName *PolicyName `protobuf:"bytes,240,opt,name=policy_name,json=policyName,proto3,oneof" json:"policy_name,omitempty" parent:"Policy"`
}
type ElementProto_PolicyRole struct {
	PolicyRole *PolicyRole `protobuf:"bytes,241,opt,name=policy_role,json=policyRole,proto3,oneof" json:"policy_role,omitempty" parent:"Policy"`
}
type ElementProto_PolicyUsingExpr struct {
	PolicyUsingExpr *PolicyUsingExpr `protobuf:"bytes,242,opt,name=policy_using_expr,json=policyUsingExpr,proto3,oneof" json:"policy_using_expr,omitempty" parent:"Policy"`
}
type ElementProto_PolicyWithCheckExpr struct {
	PolicyWithCheckExpr *PolicyWithCheckExpr `protobuf:"bytes,243,opt,name=policy_with_check_expr,json=policyWithCheckExpr,proto3,oneof" json:"policy_with_check_expr,omitempty" parent:"Policy"`
}
type ElementProto_PolicyDeps struct {
	PolicyDeps *PolicyDeps `protobuf:"bytes,244,opt,name=policy_deps,json=policyDeps,proto3,oneof" json:"policy_deps,omitempty" parent:"Policy"`
}

func (*ElementProto_Database) isElementProto_ElementOneOf()                                  {}
func (*ElementProto_Schema) isElementProto_ElementOneOf()                                    {}
func (*ElementProto_View) isElementProto_ElementOneOf()                                      {}
func (*ElementProto_Sequence) isElementProto_ElementOneOf()                                  {}
func (*ElementProto_Table) isElementProto_ElementOneOf()                                     {}
func (*ElementProto_EnumType) isElementProto_ElementOneOf()                                  {}
func (*ElementProto_AliasType) isElementProto_ElementOneOf()                                 {}
func (*ElementProto_CompositeType) isElementProto_ElementOneOf()                             {}
func (*ElementProto_Function) isElementProto_ElementOneOf()                                  {}
func (*ElementProto_NamedRangeZoneConfig) isElementProto_ElementOneOf()                      {}
func (*ElementProto_ColumnFamily) isElementProto_ElementOneOf()                              {}
func (*ElementProto_Column) isElementProto_ElementOneOf()                                    {}
func (*ElementProto_PrimaryIndex) isElementProto_ElementOneOf()                              {}
func (*ElementProto_SecondaryIndex) isElementProto_ElementOneOf()                            {}
func (*ElementProto_TemporaryIndex) isElementProto_ElementOneOf()                            {}
func (*ElementProto_UniqueWithoutIndexConstraint) isElementProto_ElementOneOf()              {}
func (*ElementProto_UniqueWithoutIndexConstraintUnvalidated) isElementProto_ElementOneOf()   {}
func (*ElementProto_CheckConstraint) isElementProto_ElementOneOf()                           {}
func (*ElementProto_CheckConstraintUnvalidated) isElementProto_ElementOneOf()                {}
func (*ElementProto_ForeignKeyConstraint) isElementProto_ElementOneOf()                      {}
func (*ElementProto_ForeignKeyConstraintUnvalidated) isElementProto_ElementOneOf()           {}
func (*ElementProto_TableComment) isElementProto_ElementOneOf()                              {}
func (*ElementProto_RowLevelTTL) isElementProto_ElementOneOf()                               {}
func (*ElementProto_TableZoneConfig) isElementProto_ElementOneOf()                           {}
func (*ElementProto_IndexZoneConfig) isElementProto_ElementOneOf()                           {}
func (*ElementProto_TableData) isElementProto_ElementOneOf()                                 {}
func (*ElementProto_TablePartitioning) isElementProto_ElementOneOf()                         {}
func (*ElementProto_TableSchemaLocked) isElementProto_ElementOneOf()                         {}
func (*ElementProto_LDRJobIDs) isElementProto_ElementOneOf()                                 {}
func (*ElementProto_PartitionZoneConfig) isElementProto_ElementOneOf()                       {}
func (*ElementProto_Trigger) isElementProto_ElementOneOf()                                   {}
func (*ElementProto_Policy) isElementProto_ElementOneOf()                                    {}
func (*ElementProto_RowLevelSecurityEnabled) isElementProto_ElementOneOf()                   {}
func (*ElementProto_RowLevelSecurityForced) isElementProto_ElementOneOf()                    {}
func (*ElementProto_TableLocalityGlobal) isElementProto_ElementOneOf()                       {}
func (*ElementProto_TableLocalityPrimaryRegion) isElementProto_ElementOneOf()                {}
func (*ElementProto_TableLocalitySecondaryRegion) isElementProto_ElementOneOf()              {}
func (*ElementProto_TableLocalityRegionalByRow) isElementProto_ElementOneOf()                {}
func (*ElementProto_TableLocalityRegionalByRowUsingConstraint) isElementProto_ElementOneOf() {}
func (*ElementProto_ColumnName) isElementProto_ElementOneOf()                                {}
func (*ElementProto_ColumnType) isElementProto_ElementOneOf()                                {}
func (*ElementProto_ColumnDefaultExpression) isElementProto_ElementOneOf()                   {}
func (*ElementProto_ColumnOnUpdateExpression) isElementProto_ElementOneOf()                  {}
func (*ElementProto_SequenceOwner) isElementProto_ElementOneOf()                             {}
func (*ElementProto_ColumnComment) isElementProto_ElementOneOf()                             {}
func (*ElementProto_ColumnNotNull) isElementProto_ElementOneOf()                             {}
func (*ElementProto_ColumnComputeExpression) isElementProto_ElementOneOf()                   {}
func (*ElementProto_SequenceOption) isElementProto_ElementOneOf()                            {}
func (*ElementProto_IndexName) isElementProto_ElementOneOf()                                 {}
func (*ElementProto_IndexPartitioning) isElementProto_ElementOneOf()                         {}
func (*ElementProto_IndexComment) isElementProto_ElementOneOf()                              {}
func (*ElementProto_IndexColumn) isElementProto_ElementOneOf()                               {}
func (*ElementProto_IndexData) isElementProto_ElementOneOf()                                 {}
func (*ElementProto_ConstraintWithoutIndexName) isElementProto_ElementOneOf()                {}
func (*ElementProto_ConstraintComment) isElementProto_ElementOneOf()                         {}
func (*ElementProto_Namespace) isElementProto_ElementOneOf()                                 {}
func (*ElementProto_Owner) isElementProto_ElementOneOf()                                     {}
func (*ElementProto_UserPrivileges) isElementProto_ElementOneOf()                            {}
func (*ElementProto_DatabaseRegionConfig) isElementProto_ElementOneOf()                      {}
func (*ElementProto_DatabaseRoleSetting) isElementProto_ElementOneOf()                       {}
func (*ElementProto_DatabaseComment) isElementProto_ElementOneOf()                           {}
func (*ElementProto_DatabaseData) isElementProto_ElementOneOf()                              {}
func (*ElementProto_DatabaseZoneConfig) isElementProto_ElementOneOf()                        {}
func (*ElementProto_SchemaParent) isElementProto_ElementOneOf()                              {}
func (*ElementProto_SchemaComment) isElementProto_ElementOneOf()                             {}
func (*ElementProto_SchemaChild) isElementProto_ElementOneOf()                               {}
func (*ElementProto_EnumTypeValue) isElementProto_ElementOneOf()                             {}
func (*ElementProto_CompositeTypeAttrType) isElementProto_ElementOneOf()                     {}
func (*ElementProto_CompositeTypeAttrName) isElementProto_ElementOneOf()                     {}
func (*ElementProto_FunctionName) isElementProto_ElementOneOf()                              {}
func (*ElementProto_FunctionVolatility) isElementProto_ElementOneOf()                        {}
func (*ElementProto_FunctionLeakProof) isElementProto_ElementOneOf()                         {}
func (*ElementProto_FunctionNullInputBehavior) isElementProto_ElementOneOf()                 {}
func (*ElementProto_FunctionBody) isElementProto_ElementOneOf()                              {}
func (*ElementProto_FunctionSecurity) isElementProto_ElementOneOf()                          {}
func (*ElementProto_TypeComment) isElementProto_ElementOneOf()                               {}
func (*ElementProto_TriggerName) isElementProto_ElementOneOf()                               {}
func (*ElementProto_TriggerEnabled) isElementProto_ElementOneOf()                            {}
func (*ElementProto_TriggerTiming) isElementProto_ElementOneOf()                             {}
func (*ElementProto_TriggerEvents) isElementProto_ElementOneOf()                             {}
func (*ElementProto_TriggerTransition) isElementProto_ElementOneOf()                         {}
func (*ElementProto_TriggerWhen) isElementProto_ElementOneOf()                               {}
func (*ElementProto_TriggerFunctionCall) isElementProto_ElementOneOf()                       {}
func (*ElementProto_TriggerDeps) isElementProto_ElementOneOf()                               {}
func (*ElementProto_PolicyName) isElementProto_ElementOneOf()                                {}
func (*ElementProto_PolicyRole) isElementProto_ElementOneOf()                                {}
func (*ElementProto_PolicyUsingExpr) isElementProto_ElementOneOf()                           {}
func (*ElementProto_PolicyWithCheckExpr) isElementProto_ElementOneOf()                       {}
func (*ElementProto_PolicyDeps) isElementProto_ElementOneOf()                                {}

func (m *ElementProto) GetElementOneOf() isElementProto_ElementOneOf {
	if m != nil {
		return m.ElementOneOf
	}
	return nil
}

func (m *ElementProto) GetDatabase() *Database {
	if x, ok := m.GetElementOneOf().(*ElementProto_Database); ok {
		return x.Database
	}
	return nil
}

func (m *ElementProto) GetSchema() *Schema {
	if x, ok := m.GetElementOneOf().(*ElementProto_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *ElementProto) GetView() *View {
	if x, ok := m.GetElementOneOf().(*ElementProto_View); ok {
		return x.View
	}
	return nil
}

func (m *ElementProto) GetSequence() *Sequence {
	if x, ok := m.GetElementOneOf().(*ElementProto_Sequence); ok {
		return x.Sequence
	}
	return nil
}

func (m *ElementProto) GetTable() *Table {
	if x, ok := m.GetElementOneOf().(*ElementProto_Table); ok {
		return x.Table
	}
	return nil
}

func (m *ElementProto) GetEnumType() *EnumType {
	if x, ok := m.GetElementOneOf().(*ElementProto_EnumType); ok {
		return x.EnumType
	}
	return nil
}

func (m *ElementProto) GetAliasType() *AliasType {
	if x, ok := m.GetElementOneOf().(*ElementProto_AliasType); ok {
		return x.AliasType
	}
	return nil
}

func (m *ElementProto) GetCompositeType() *CompositeType {
	if x, ok := m.GetElementOneOf().(*ElementProto_CompositeType); ok {
		return x.CompositeType
	}
	return nil
}

func (m *ElementProto) GetFunction() *Function {
	if x, ok := m.GetElementOneOf().(*ElementProto_Function); ok {
		return x.Function
	}
	return nil
}

func (m *ElementProto) GetNamedRangeZoneConfig() *NamedRangeZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_NamedRangeZoneConfig); ok {
		return x.NamedRangeZoneConfig
	}
	return nil
}

func (m *ElementProto) GetColumnFamily() *ColumnFamily {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnFamily); ok {
		return x.ColumnFamily
	}
	return nil
}

func (m *ElementProto) GetColumn() *Column {
	if x, ok := m.GetElementOneOf().(*ElementProto_Column); ok {
		return x.Column
	}
	return nil
}

func (m *ElementProto) GetPrimaryIndex() *PrimaryIndex {
	if x, ok := m.GetElementOneOf().(*ElementProto_PrimaryIndex); ok {
		return x.PrimaryIndex
	}
	return nil
}

func (m *ElementProto) GetSecondaryIndex() *SecondaryIndex {
	if x, ok := m.GetElementOneOf().(*ElementProto_SecondaryIndex); ok {
		return x.SecondaryIndex
	}
	return nil
}

func (m *ElementProto) GetTemporaryIndex() *TemporaryIndex {
	if x, ok := m.GetElementOneOf().(*ElementProto_TemporaryIndex); ok {
		return x.TemporaryIndex
	}
	return nil
}

func (m *ElementProto) GetUniqueWithoutIndexConstraint() *UniqueWithoutIndexConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_UniqueWithoutIndexConstraint); ok {
		return x.UniqueWithoutIndexConstraint
	}
	return nil
}

func (m *ElementProto) GetUniqueWithoutIndexConstraintUnvalidated() *UniqueWithoutIndexConstraintUnvalidated {
	if x, ok := m.GetElementOneOf().(*ElementProto_UniqueWithoutIndexConstraintUnvalidated); ok {
		return x.UniqueWithoutIndexConstraintUnvalidated
	}
	return nil
}

func (m *ElementProto) GetCheckConstraint() *CheckConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_CheckConstraint); ok {
		return x.CheckConstraint
	}
	return nil
}

func (m *ElementProto) GetCheckConstraintUnvalidated() *CheckConstraintUnvalidated {
	if x, ok := m.GetElementOneOf().(*ElementProto_CheckConstraintUnvalidated); ok {
		return x.CheckConstraintUnvalidated
	}
	return nil
}

func (m *ElementProto) GetForeignKeyConstraint() *ForeignKeyConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_ForeignKeyConstraint); ok {
		return x.ForeignKeyConstraint
	}
	return nil
}

func (m *ElementProto) GetForeignKeyConstraintUnvalidated() *ForeignKeyConstraintUnvalidated {
	if x, ok := m.GetElementOneOf().(*ElementProto_ForeignKeyConstraintUnvalidated); ok {
		return x.ForeignKeyConstraintUnvalidated
	}
	return nil
}

func (m *ElementProto) GetTableComment() *TableComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableComment); ok {
		return x.TableComment
	}
	return nil
}

func (m *ElementProto) GetRowLevelTTL() *RowLevelTTL {
	if x, ok := m.GetElementOneOf().(*ElementProto_RowLevelTTL); ok {
		return x.RowLevelTTL
	}
	return nil
}

func (m *ElementProto) GetTableZoneConfig() *TableZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableZoneConfig); ok {
		return x.TableZoneConfig
	}
	return nil
}

func (m *ElementProto) GetIndexZoneConfig() *IndexZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexZoneConfig); ok {
		return x.IndexZoneConfig
	}
	return nil
}

func (m *ElementProto) GetTableData() *TableData {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableData); ok {
		return x.TableData
	}
	return nil
}

func (m *ElementProto) GetTablePartitioning() *TablePartitioning {
	if x, ok := m.GetElementOneOf().(*ElementProto_TablePartitioning); ok {
		return x.TablePartitioning
	}
	return nil
}

func (m *ElementProto) GetTableSchemaLocked() *TableSchemaLocked {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableSchemaLocked); ok {
		return x.TableSchemaLocked
	}
	return nil
}

func (m *ElementProto) GetLDRJobIDs() *LDRJobIDs {
	if x, ok := m.GetElementOneOf().(*ElementProto_LDRJobIDs); ok {
		return x.LDRJobIDs
	}
	return nil
}

func (m *ElementProto) GetPartitionZoneConfig() *PartitionZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_PartitionZoneConfig); ok {
		return x.PartitionZoneConfig
	}
	return nil
}

func (m *ElementProto) GetTrigger() *Trigger {
	if x, ok := m.GetElementOneOf().(*ElementProto_Trigger); ok {
		return x.Trigger
	}
	return nil
}

func (m *ElementProto) GetPolicy() *Policy {
	if x, ok := m.GetElementOneOf().(*ElementProto_Policy); ok {
		return x.Policy
	}
	return nil
}

func (m *ElementProto) GetRowLevelSecurityEnabled() *RowLevelSecurityEnabled {
	if x, ok := m.GetElementOneOf().(*ElementProto_RowLevelSecurityEnabled); ok {
		return x.RowLevelSecurityEnabled
	}
	return nil
}

func (m *ElementProto) GetRowLevelSecurityForced() *RowLevelSecurityForced {
	if x, ok := m.GetElementOneOf().(*ElementProto_RowLevelSecurityForced); ok {
		return x.RowLevelSecurityForced
	}
	return nil
}

func (m *ElementProto) GetTableLocalityGlobal() *TableLocalityGlobal {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityGlobal); ok {
		return x.TableLocalityGlobal
	}
	return nil
}

func (m *ElementProto) GetTableLocalityPrimaryRegion() *TableLocalityPrimaryRegion {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityPrimaryRegion); ok {
		return x.TableLocalityPrimaryRegion
	}
	return nil
}

func (m *ElementProto) GetTableLocalitySecondaryRegion() *TableLocalitySecondaryRegion {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalitySecondaryRegion); ok {
		return x.TableLocalitySecondaryRegion
	}
	return nil
}

func (m *ElementProto) GetTableLocalityRegionalByRow() *TableLocalityRegionalByRow {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityRegionalByRow); ok {
		return x.TableLocalityRegionalByRow
	}
	return nil
}

func (m *ElementProto) GetTableLocalityRegionalByRowUsingConstraint() *TableLocalityRegionalByRowUsingConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityRegionalByRowUsingConstraint); ok {
		return x.TableLocalityRegionalByRowUsingConstraint
	}
	return nil
}

func (m *ElementProto) GetColumnName() *ColumnName {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnName); ok {
		return x.ColumnName
	}
	return nil
}

func (m *ElementProto) GetColumnType() *ColumnType {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnType); ok {
		return x.ColumnType
	}
	return nil
}

func (m *ElementProto) GetColumnDefaultExpression() *ColumnDefaultExpression {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnDefaultExpression); ok {
		return x.ColumnDefaultExpression
	}
	return nil
}

func (m *ElementProto) GetColumnOnUpdateExpression() *ColumnOnUpdateExpression {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnOnUpdateExpression); ok {
		return x.ColumnOnUpdateExpression
	}
	return nil
}

func (m *ElementProto) GetSequenceOwner() *SequenceOwner {
	if x, ok := m.GetElementOneOf().(*ElementProto_SequenceOwner); ok {
		return x.SequenceOwner
	}
	return nil
}

func (m *ElementProto) GetColumnComment() *ColumnComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnComment); ok {
		return x.ColumnComment
	}
	return nil
}

func (m *ElementProto) GetColumnNotNull() *ColumnNotNull {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnNotNull); ok {
		return x.ColumnNotNull
	}
	return nil
}

func (m *ElementProto) GetColumnComputeExpression() *ColumnComputeExpression {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnComputeExpression); ok {
		return x.ColumnComputeExpression
	}
	return nil
}

func (m *ElementProto) GetSequenceOption() *SequenceOption {
	if x, ok := m.GetElementOneOf().(*ElementProto_SequenceOption); ok {
		return x.SequenceOption
	}
	return nil
}

func (m *ElementProto) GetIndexName() *IndexName {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexName); ok {
		return x.IndexName
	}
	return nil
}

func (m *ElementProto) GetIndexPartitioning() *IndexPartitioning {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexPartitioning); ok {
		return x.IndexPartitioning
	}
	return nil
}

func (m *ElementProto) GetIndexComment() *IndexComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexComment); ok {
		return x.IndexComment
	}
	return nil
}

func (m *ElementProto) GetIndexColumn() *IndexColumn {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexColumn); ok {
		return x.IndexColumn
	}
	return nil
}

func (m *ElementProto) GetIndexData() *IndexData {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexData); ok {
		return x.IndexData
	}
	return nil
}

func (m *ElementProto) GetConstraintWithoutIndexName() *ConstraintWithoutIndexName {
	if x, ok := m.GetElementOneOf().(*ElementProto_ConstraintWithoutIndexName); ok {
		return x.ConstraintWithoutIndexName
	}
	return nil
}

func (m *ElementProto) GetConstraintComment() *ConstraintComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_ConstraintComment); ok {
		return x.ConstraintComment
	}
	return nil
}

func (m *ElementProto) GetNamespace() *Namespace {
	if x, ok := m.GetElementOneOf().(*ElementProto_Namespace); ok {
		return x.Namespace
	}
	return nil
}

func (m *ElementProto) GetOwner() *Owner {
	if x, ok := m.GetElementOneOf().(*ElementProto_Owner); ok {
		return x.Owner
	}
	return nil
}

func (m *ElementProto) GetUserPrivileges() *UserPrivileges {
	if x, ok := m.GetElementOneOf().(*ElementProto_UserPrivileges); ok {
		return x.UserPrivileges
	}
	return nil
}

func (m *ElementProto) GetDatabaseRegionConfig() *DatabaseRegionConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseRegionConfig); ok {
		return x.DatabaseRegionConfig
	}
	return nil
}

func (m *ElementProto) GetDatabaseRoleSetting() *DatabaseRoleSetting {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseRoleSetting); ok {
		return x.DatabaseRoleSetting
	}
	return nil
}

func (m *ElementProto) GetDatabaseComment() *DatabaseComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseComment); ok {
		return x.DatabaseComment
	}
	return nil
}

func (m *ElementProto) GetDatabaseData() *DatabaseData {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseData); ok {
		return x.DatabaseData
	}
	return nil
}

func (m *ElementProto) GetDatabaseZoneConfig() *DatabaseZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseZoneConfig); ok {
		return x.DatabaseZoneConfig
	}
	return nil
}

func (m *ElementProto) GetSchemaParent() *SchemaParent {
	if x, ok := m.GetElementOneOf().(*ElementProto_SchemaParent); ok {
		return x.SchemaParent
	}
	return nil
}

func (m *ElementProto) GetSchemaComment() *SchemaComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_SchemaComment); ok {
		return x.SchemaComment
	}
	return nil
}

func (m *ElementProto) GetSchemaChild() *SchemaChild {
	if x, ok := m.GetElementOneOf().(*ElementProto_SchemaChild); ok {
		return x.SchemaChild
	}
	return nil
}

func (m *ElementProto) GetEnumTypeValue() *EnumTypeValue {
	if x, ok := m.GetElementOneOf().(*ElementProto_EnumTypeValue); ok {
		return x.EnumTypeValue
	}
	return nil
}

func (m *ElementProto) GetCompositeTypeAttrType() *CompositeTypeAttrType {
	if x, ok := m.GetElementOneOf().(*ElementProto_CompositeTypeAttrType); ok {
		return x.CompositeTypeAttrType
	}
	return nil
}

func (m *ElementProto) GetCompositeTypeAttrName() *CompositeTypeAttrName {
	if x, ok := m.GetElementOneOf().(*ElementProto_CompositeTypeAttrName); ok {
		return x.CompositeTypeAttrName
	}
	return nil
}

func (m *ElementProto) GetFunctionName() *FunctionName {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionName); ok {
		return x.FunctionName
	}
	return nil
}

func (m *ElementProto) GetFunctionVolatility() *FunctionVolatility {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionVolatility); ok {
		return x.FunctionVolatility
	}
	return nil
}

func (m *ElementProto) GetFunctionLeakProof() *FunctionLeakProof {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionLeakProof); ok {
		return x.FunctionLeakProof
	}
	return nil
}

func (m *ElementProto) GetFunctionNullInputBehavior() *FunctionNullInputBehavior {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionNullInputBehavior); ok {
		return x.FunctionNullInputBehavior
	}
	return nil
}

func (m *ElementProto) GetFunctionBody() *FunctionBody {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionBody); ok {
		return x.FunctionBody
	}
	return nil
}

func (m *ElementProto) GetFunctionSecurity() *FunctionSecurity {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionSecurity); ok {
		return x.FunctionSecurity
	}
	return nil
}

func (m *ElementProto) GetTypeComment() *TypeComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_TypeComment); ok {
		return x.TypeComment
	}
	return nil
}

func (m *ElementProto) GetTriggerName() *TriggerName {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerName); ok {
		return x.TriggerName
	}
	return nil
}

func (m *ElementProto) GetTriggerEnabled() *TriggerEnabled {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerEnabled); ok {
		return x.TriggerEnabled
	}
	return nil
}

func (m *ElementProto) GetTriggerTiming() *TriggerTiming {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerTiming); ok {
		return x.TriggerTiming
	}
	return nil
}

func (m *ElementProto) GetTriggerEvents() *TriggerEvents {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerEvents); ok {
		return x.TriggerEvents
	}
	return nil
}

func (m *ElementProto) GetTriggerTransition() *TriggerTransition {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerTransition); ok {
		return x.TriggerTransition
	}
	return nil
}

func (m *ElementProto) GetTriggerWhen() *TriggerWhen {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerWhen); ok {
		return x.TriggerWhen
	}
	return nil
}

func (m *ElementProto) GetTriggerFunctionCall() *TriggerFunctionCall {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerFunctionCall); ok {
		return x.TriggerFunctionCall
	}
	return nil
}

func (m *ElementProto) GetTriggerDeps() *TriggerDeps {
	if x, ok := m.GetElementOneOf().(*ElementProto_TriggerDeps); ok {
		return x.TriggerDeps
	}
	return nil
}

func (m *ElementProto) GetPolicyName() *PolicyName {
	if x, ok := m.GetElementOneOf().(*ElementProto_PolicyName); ok {
		return x.PolicyName
	}
	return nil
}

func (m *ElementProto) GetPolicyRole() *PolicyRole {
	if x, ok := m.GetElementOneOf().(*ElementProto_PolicyRole); ok {
		return x.PolicyRole
	}
	return nil
}

func (m *ElementProto) GetPolicyUsingExpr() *PolicyUsingExpr {
	if x, ok := m.GetElementOneOf().(*ElementProto_PolicyUsingExpr); ok {
		return x.PolicyUsingExpr
	}
	return nil
}

func (m *ElementProto) GetPolicyWithCheckExpr() *PolicyWithCheckExpr {
	if x, ok := m.GetElementOneOf().(*ElementProto_PolicyWithCheckExpr); ok {
		return x.PolicyWithCheckExpr
	}
	return nil
}

func (m *ElementProto) GetPolicyDeps() *PolicyDeps {
	if x, ok := m.GetElementOneOf().(*ElementProto_PolicyDeps); ok {
		return x.PolicyDeps
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ElementProto) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ElementProto_Database)(nil),
		(*ElementProto_Schema)(nil),
		(*ElementProto_View)(nil),
		(*ElementProto_Sequence)(nil),
		(*ElementProto_Table)(nil),
		(*ElementProto_EnumType)(nil),
		(*ElementProto_AliasType)(nil),
		(*ElementProto_CompositeType)(nil),
		(*ElementProto_Function)(nil),
		(*ElementProto_NamedRangeZoneConfig)(nil),
		(*ElementProto_ColumnFamily)(nil),
		(*ElementProto_Column)(nil),
		(*ElementProto_PrimaryIndex)(nil),
		(*ElementProto_SecondaryIndex)(nil),
		(*ElementProto_TemporaryIndex)(nil),
		(*ElementProto_UniqueWithoutIndexConstraint)(nil),
		(*ElementProto_UniqueWithoutIndexConstraintUnvalidated)(nil),
		(*ElementProto_CheckConstraint)(nil),
		(*ElementProto_CheckConstraintUnvalidated)(nil),
		(*ElementProto_ForeignKeyConstraint)(nil),
		(*ElementProto_ForeignKeyConstraintUnvalidated)(nil),
		(*ElementProto_TableComment)(nil),
		(*ElementProto_RowLevelTTL)(nil),
		(*ElementProto_TableZoneConfig)(nil),
		(*ElementProto_IndexZoneConfig)(nil),
		(*ElementProto_TableData)(nil),
		(*ElementProto_TablePartitioning)(nil),
		(*ElementProto_TableSchemaLocked)(nil),
		(*ElementProto_LDRJobIDs)(nil),
		(*ElementProto_PartitionZoneConfig)(nil),
		(*ElementProto_Trigger)(nil),
		(*ElementProto_Policy)(nil),
		(*ElementProto_RowLevelSecurityEnabled)(nil),
		(*ElementProto_RowLevelSecurityForced)(nil),
		(*ElementProto_TableLocalityGlobal)(nil),
		(*ElementProto_TableLocalityPrimaryRegion)(nil),
		(*ElementProto_TableLocalitySecondaryRegion)(nil),
		(*ElementProto_TableLocalityRegionalByRow)(nil),
		(*ElementProto_TableLocalityRegionalByRowUsingConstraint)(nil),
		(*ElementProto_ColumnName)(nil),
		(*ElementProto_ColumnType)(nil),
		(*ElementProto_ColumnDefaultExpression)(nil),
		(*ElementProto_ColumnOnUpdateExpression)(nil),
		(*ElementProto_SequenceOwner)(nil),
		(*ElementProto_ColumnComment)(nil),
		(*ElementProto_ColumnNotNull)(nil),
		(*ElementProto_ColumnComputeExpression)(nil),
		(*ElementProto_SequenceOption)(nil),
		(*ElementProto_IndexName)(nil),
		(*ElementProto_IndexPartitioning)(nil),
		(*ElementProto_IndexComment)(nil),
		(*ElementProto_IndexColumn)(nil),
		(*ElementProto_IndexData)(nil),
		(*ElementProto_ConstraintWithoutIndexName)(nil),
		(*ElementProto_ConstraintComment)(nil),
		(*ElementProto_Namespace)(nil),
		(*ElementProto_Owner)(nil),
		(*ElementProto_UserPrivileges)(nil),
		(*ElementProto_DatabaseRegionConfig)(nil),
		(*ElementProto_DatabaseRoleSetting)(nil),
		(*ElementProto_DatabaseComment)(nil),
		(*ElementProto_DatabaseData)(nil),
		(*ElementProto_DatabaseZoneConfig)(nil),
		(*ElementProto_SchemaParent)(nil),
		(*ElementProto_SchemaComment)(nil),
		(*ElementProto_SchemaChild)(nil),
		(*ElementProto_EnumTypeValue)(nil),
		(*ElementProto_CompositeTypeAttrType)(nil),
		(*ElementProto_CompositeTypeAttrName)(nil),
		(*ElementProto_FunctionName)(nil),
		(*ElementProto_FunctionVolatility)(nil),
		(*ElementProto_FunctionLeakProof)(nil),
		(*ElementProto_FunctionNullInputBehavior)(nil),
		(*ElementProto_FunctionBody)(nil),
		(*ElementProto_FunctionSecurity)(nil),
		(*ElementProto_TypeComment)(nil),
		(*ElementProto_TriggerName)(nil),
		(*ElementProto_TriggerEnabled)(nil),
		(*ElementProto_TriggerTiming)(nil),
		(*ElementProto_TriggerEvents)(nil),
		(*ElementProto_TriggerTransition)(nil),
		(*ElementProto_TriggerWhen)(nil),
		(*ElementProto_TriggerFunctionCall)(nil),
		(*ElementProto_TriggerDeps)(nil),
		(*ElementProto_PolicyName)(nil),
		(*ElementProto_PolicyRole)(nil),
		(*ElementProto_PolicyUsingExpr)(nil),
		(*ElementProto_PolicyWithCheckExpr)(nil),
		(*ElementProto_PolicyDeps)(nil),
	}
}

// TypeT is a wrapper for a types.T which contains its user-defined type ID
// closure, explicitly keeping track of the IDs of all the type descriptors
// which will have a back-reference to the owner of the TypeT.
// For example, a wrapped type.Int will have an empty type ID closure, but
// a wrapped user-defined enum type will have the IDs of the enum type and
// its array alias type in the closure.
type TypeT struct {
	Type          *types.T                                                    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	ClosedTypeIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,rep,packed,name=closed_type_ids,json=closedTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"closed_type_ids,omitempty"`
	// Include the SQL name of the type here. This is redundant with the type
	// field. However, it allows us to use the type as an attribute. Something
	// that can't be done easily with types.T.
	TypeName string `protobuf:"bytes,3,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
}

func (m *TypeT) Reset()         { *m = TypeT{} }
func (m *TypeT) String() string { return proto.CompactTextString(m) }
func (*TypeT) ProtoMessage()    {}
func (*TypeT) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{1}
}
func (m *TypeT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TypeT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeT.Merge(m, src)
}
func (m *TypeT) XXX_Size() int {
	return m.Size()
}
func (m *TypeT) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeT.DiscardUnknown(m)
}

var xxx_messageInfo_TypeT proto.InternalMessageInfo

// Expression is a wrapper for a column or check constraint expression, which,
// much like the TypeT wrapper, tracks its dependent descriptor IDs. Here these
// include also sequence descriptor IDs.
type Expression struct {
	Expr            github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.Expression `protobuf:"bytes,1,opt,name=expr,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.Expression" json:"expr,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,2,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesSequenceIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,3,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
	// ReferencedColumnIDs stores the IDs of the columns referenced by the expression.
	ReferencedColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,4,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
	UsesFunctionIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,5,rep,packed,name=uses_function_ids,json=usesFunctionIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_function_ids,omitempty"`
}

func (m *Expression) Reset()         { *m = Expression{} }
func (m *Expression) String() string { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()    {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{2}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(m, src)
}
func (m *Expression) XXX_Size() int {
	return m.Size()
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

type Column struct {
	TableID                           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID                      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID                          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID                    `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	IsHidden                          bool                                                                           `protobuf:"varint,3,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"`
	IsInaccessible                    bool                                                                           `protobuf:"varint,4,opt,name=is_inaccessible,json=isInaccessible,proto3" json:"is_inaccessible,omitempty"`
	GeneratedAsIdentityType           github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType `protobuf:"varint,5,opt,name=generated_as_identity_type,json=generatedAsIdentityType,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.GeneratedAsIdentityType" json:"generated_as_identity_type,omitempty"`
	GeneratedAsIdentitySequenceOption string                                                                         `protobuf:"bytes,6,opt,name=generated_as_identity_sequence_option,json=generatedAsIdentitySequenceOption,proto3" json:"generated_as_identity_sequence_option,omitempty"`
	PgAttributeNum                    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum              `protobuf:"varint,7,opt,name=pg_attribute_num,json=pgAttributeNum,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PGAttributeNum" json:"pg_attribute_num,omitempty"`
	IsSystemColumn                    bool                                                                           `protobuf:"varint,8,opt,name=is_system_column,json=isSystemColumn,proto3" json:"is_system_column,omitempty"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{3}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

// ColumnType needs to be an element distinct from Column although they have a
// 1:1 relationship because their lifecycle is not the same.
// Column transitions through the two-version-invariant status path:
//
//	PUBLIC -> WRITE_ONLY -> DELETE_ONLY -> ABSENT
//
// regardless of whether only the column is dropped (meaning ABSENT is reached
// post-commit) or whether the whole table is dropped. We accommodate the
// latter case by having ColumnType reach ABSENT in the pre-commit phase
// independently of its sister column element. This is important, because this
// clears back-references in referenced type descriptors for columns which
// have user-defined types, or reference user-defined types in their compute
// expression.
type ColumnType struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	FamilyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,2,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeT    `protobuf:"bytes,4,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
	// Deprecated
	// We changed element modelling for NOT NULL constraint in V23_1 and thus
	// deprecated `is_nullable`. The new way is to handle NOT NULL constraint
	// through a newly introduced `ColumnNotNull` element. This change is
	// necessary to support adding/dropping NOT NULL constraint on an existing
	// column.
	IsNullable bool `protobuf:"varint,5,opt,name=is_nullable,json=isNullable,proto3" json:"is_nullable,omitempty"` // Deprecated: Do not use.
	// Deprecated
	// compute expression is now handled as a separate element (see ColumnComputeExpression).
	ComputeExpr *Expression `protobuf:"bytes,6,opt,name=compute_expr,json=computeExpr,proto3" json:"compute_expr,omitempty"` // Deprecated: Do not use.
	IsVirtual   bool        `protobuf:"varint,7,opt,name=is_virtual,json=isVirtual,proto3" json:"is_virtual,omitempty"`
	// ElementCreationMetadata stores information about when this element is created.
	// It can be used in a similar way to version gates to ensure compatibility
	// in mixed version state.
	ElementCreationMetadata *ElementCreationMetadata `protobuf:"bytes,11,opt,name=element_creation_metadata,json=elementCreationMetadata,proto3" json:"element_creation_metadata,omitempty"`
	// If non-zero, the column will be added to the column family after the column with
	// this ID. This is used for operations like 'ALTER COLUMN .. TYPE', where
	// maintaining column family order is necessary when replacing columns.
	ColumnFamilyOrderFollowsColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,12,opt,name=column_family_order_follows_column_id,json=columnFamilyOrderFollowsColumnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_family_order_follows_column_id,omitempty"`
}

func (m *ColumnType) Reset()         { *m = ColumnType{} }
func (m *ColumnType) String() string { return proto.CompactTextString(m) }
func (*ColumnType) ProtoMessage()    {}
func (*ColumnType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{4}
}
func (m *ColumnType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnType.Merge(m, src)
}
func (m *ColumnType) XXX_Size() int {
	return m.Size()
}
func (m *ColumnType) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnType.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnType proto.InternalMessageInfo

type ColumnComputeExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
	Usage      ColumnComputeExpression_Usage `protobuf:"varint,5,opt,name=usage,proto3,enum=cockroach.sql.schemachanger.scpb.ColumnComputeExpression_Usage" json:"usage,omitempty"`
}

func (m *ColumnComputeExpression) Reset()         { *m = ColumnComputeExpression{} }
func (m *ColumnComputeExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnComputeExpression) ProtoMessage()    {}
func (*ColumnComputeExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{5}
}
func (m *ColumnComputeExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnComputeExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnComputeExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnComputeExpression.Merge(m, src)
}
func (m *ColumnComputeExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnComputeExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnComputeExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnComputeExpression proto.InternalMessageInfo

type ColumnFamily struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	FamilyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,2,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnFamily) Reset()         { *m = ColumnFamily{} }
func (m *ColumnFamily) String() string { return proto.CompactTextString(m) }
func (*ColumnFamily) ProtoMessage()    {}
func (*ColumnFamily) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{6}
}
func (m *ColumnFamily) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnFamily) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnFamily) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnFamily.Merge(m, src)
}
func (m *ColumnFamily) XXX_Size() int {
	return m.Size()
}
func (m *ColumnFamily) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnFamily.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnFamily proto.InternalMessageInfo

// Index is a wrapper for index definition data that gets embedded in both
// PrimaryIndex and SecondaryIndex. These two are not so different, but need
// to be distinguished by type (instead of, say, via a boolean flag in the
// element) to make for sane dependency rules.
type Index struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	IsUnique bool                                                       `protobuf:"varint,10,opt,name=is_unique,json=isUnique,proto3" json:"is_unique,omitempty"`
	// IsInverted is replaced by the Type enumeration.
	IsInverted bool                     `protobuf:"varint,11,opt,name=is_inverted,json=isInverted,proto3" json:"is_inverted,omitempty"` // Deprecated: Do not use.
	Type       idxtype.T                `protobuf:"varint,26,opt,name=type,proto3,enum=cockroach.sql.sem.idxtype.T" json:"type,omitempty"`
	Sharding   *catpb.ShardedDescriptor `protobuf:"bytes,12,opt,name=sharding,proto3" json:"sharding,omitempty"`
	// IsCreatedExplicitly specifies whether this index was created explicitly
	// (i.e. via 'CREATE INDEX' statement) and not implicitly (i.e. created for
	// unique constraint).
	IsCreatedExplicitly bool `protobuf:"varint,13,opt,name=is_created_explicitly,json=isCreatedExplicitly,proto3" json:"is_created_explicitly,omitempty"`
	// ConstraintID is only set for primary keys and unique secondary indexes. It
	// can be used to uniquely identify a constraint.
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,14,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	// Spec fields.
	// These fields only make sense if the element is for ABSENT -> PUBLIC.
	//
	// TODO(postamar): try to get rid of these altogether
	//
	//	Perhaps move these to the target metadata instead?
	IsConcurrently bool `protobuf:"varint,20,opt,name=is_concurrently,json=isConcurrently,proto3" json:"is_concurrently,omitempty"`
	// SourceIndexID refers back to the primary index for which a secondary index
	// was created.
	SourceIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,21,opt,name=source_index_id,json=sourceIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"source_index_id,omitempty"`
	// TemporaryIndexID refers to the temporary index that was created while this
	// index is being backfilled.
	TemporaryIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,22,opt,name=temporary_index_id,json=temporaryIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"temporary_index_id,omitempty"`
	GeoConfig        *geopb.Config                                              `protobuf:"bytes,24,opt,name=geo_config,json=geoConfig,proto3" json:"geo_config,omitempty"`
	// IsNotVisible specifies whether this index is not visible.
	// NOTE: THIS FIELD IS DEPRECATED in favor of invisibility.
	IsNotVisible bool `protobuf:"varint,23,opt,name=is_not_visible,json=isNotVisible,proto3" json:"is_not_visible,omitempty"` // Deprecated: Do not use.
	// Invisibility specifies index invisibility to the optimizer.
	Invisibility float64       `protobuf:"fixed64,25,opt,name=invisibility,proto3" json:"invisibility,omitempty"`
	VecConfig    *vecpb.Config `protobuf:"bytes,27,opt,name=vec_config,json=vecConfig,proto3" json:"vec_config,omitempty"`
}

func (m *Index) Reset()         { *m = Index{} }
func (m *Index) String() string { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()    {}
func (*Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{7}
}
func (m *Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Index.Merge(m, src)
}
func (m *Index) XXX_Size() int {
	return m.Size()
}
func (m *Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Index proto.InternalMessageInfo

type PrimaryIndex struct {
	Index `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
}

func (m *PrimaryIndex) Reset()         { *m = PrimaryIndex{} }
func (m *PrimaryIndex) String() string { return proto.CompactTextString(m) }
func (*PrimaryIndex) ProtoMessage()    {}
func (*PrimaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{8}
}
func (m *PrimaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrimaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryIndex.Merge(m, src)
}
func (m *PrimaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryIndex proto.InternalMessageInfo

type SecondaryIndex struct {
	Index        `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
	EmbeddedExpr *Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3" json:"embedded_expr,omitempty"`
	// If an index is being recreated, this is the original
	// secondary index that we are trying to replace (this
	// is done for primary key changes).
	RecreateSourceIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,4,opt,name=recreate_source_id,json=recreateSourceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"recreate_source_id,omitempty"`
	// If an index is being recreated, this is the final primary
	// index that will make it usable (i.e. the columns required
	// to back this index will be public in this index)
	RecreateTargetIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,5,opt,name=recreate_target_id,json=recreateTargetId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"recreate_target_id,omitempty"`
	// In a mixed version environment indicates if its safe to hide the
	// element using the new HideForPrimaryKeyRecreate flag.
	HideForPrimaryKeyRecreated bool `protobuf:"varint,6,opt,name=hide_for_primary_key_recreated,json=hideForPrimaryKeyRecreated,proto3" json:"hide_for_primary_key_recreated,omitempty"`
}

func (m *SecondaryIndex) Reset()         { *m = SecondaryIndex{} }
func (m *SecondaryIndex) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndex) ProtoMessage()    {}
func (*SecondaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{9}
}
func (m *SecondaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecondaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndex.Merge(m, src)
}
func (m *SecondaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndex proto.InternalMessageInfo

type TemporaryIndex struct {
	Index                    `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
	IsUsingSecondaryEncoding bool        `protobuf:"varint,2,opt,name=is_using_secondary_encoding,json=isUsingSecondaryEncoding,proto3" json:"is_using_secondary_encoding,omitempty"`
	Expr                     *Expression `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
}

func (m *TemporaryIndex) Reset()         { *m = TemporaryIndex{} }
func (m *TemporaryIndex) String() string { return proto.CompactTextString(m) }
func (*TemporaryIndex) ProtoMessage()    {}
func (*TemporaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{10}
}
func (m *TemporaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TemporaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TemporaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemporaryIndex.Merge(m, src)
}
func (m *TemporaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *TemporaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_TemporaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_TemporaryIndex proto.InternalMessageInfo

// SchemaParent models the schema to parent database relationship.
// Every schema has a parent, so there is a 1:1 relationship between
// the Schema and the SchemaParent relationship. This is modeled as a separate
// element because this one owns the updating of the corresponding
// back-reference in the parent database descriptor as part of its lifecycle.
type SchemaParent struct {
	SchemaID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	ParentDatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=parent_database_id,json=parentDatabaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"parent_database_id,omitempty"`
}

func (m *SchemaParent) Reset()         { *m = SchemaParent{} }
func (m *SchemaParent) String() string { return proto.CompactTextString(m) }
func (*SchemaParent) ProtoMessage()    {}
func (*SchemaParent) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{11}
}
func (m *SchemaParent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaParent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaParent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaParent.Merge(m, src)
}
func (m *SchemaParent) XXX_Size() int {
	return m.Size()
}
func (m *SchemaParent) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaParent.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaParent proto.InternalMessageInfo

// SchemaChild is like SchemaParent but for objects.
// This is a bit useless since schemas don't maintain a set of back-references
// to their children. Still, it exists as a convenient join relation.
type SchemaChild struct {
	ChildObjectID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=child_object_id,json=childObjectId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"child_object_id,omitempty"`
	SchemaID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
}

func (m *SchemaChild) Reset()         { *m = SchemaChild{} }
func (m *SchemaChild) String() string { return proto.CompactTextString(m) }
func (*SchemaChild) ProtoMessage()    {}
func (*SchemaChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{12}
}
func (m *SchemaChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChild.Merge(m, src)
}
func (m *SchemaChild) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChild) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChild.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChild proto.InternalMessageInfo

// Policy represents a row-level security policy for a table.
// Note: This struct only stores the immutable parts of a policy. Any mutable
// components should be stored in separate elements so that an ALTER can update
// the policy by add/drop new elements.
type Policy struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID            `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	PolicyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID          `protobuf:"varint,2,opt,name=policy_id,json=policyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PolicyID" json:"policy_id,omitempty"`
	Type     github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.PolicyType    `protobuf:"varint,3,opt,name=type,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.PolicyType" json:"type,omitempty"`
	Command  github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.PolicyCommand `protobuf:"varint,4,opt,name=command,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.PolicyCommand" json:"command,omitempty"`
}

func (m *Policy) Reset()         { *m = Policy{} }
func (m *Policy) String() string { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()    {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{13}
}
func (m *Policy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return m.Size()
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

// PolicyName is the name assigned to a specific policy, based on its ID.
type PolicyName struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	PolicyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID `protobuf:"varint,2,opt,name=policy_id,json=policyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PolicyID" json:"policy_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PolicyName) Reset()         { *m = PolicyName{} }
func (m *PolicyName) String() string { return proto.CompactTextString(m) }
func (*PolicyName) ProtoMessage()    {}
func (*PolicyName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{14}
}
func (m *PolicyName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyName.Merge(m, src)
}
func (m *PolicyName) XXX_Size() int {
	return m.Size()
}
func (m *PolicyName) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyName.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyName proto.InternalMessageInfo

// PolicyRole is the role that is attached to a specific policy.
type PolicyRole struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	PolicyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID `protobuf:"varint,2,opt,name=policy_id,json=policyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PolicyID" json:"policy_id,omitempty"`
	RoleName string                                                      `protobuf:"bytes,3,opt,name=role_name,json=roleName,proto3" json:"role_name,omitempty"`
}

func (m *PolicyRole) Reset()         { *m = PolicyRole{} }
func (m *PolicyRole) String() string { return proto.CompactTextString(m) }
func (*PolicyRole) ProtoMessage()    {}
func (*PolicyRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{15}
}
func (m *PolicyRole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRole.Merge(m, src)
}
func (m *PolicyRole) XXX_Size() int {
	return m.Size()
}
func (m *PolicyRole) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRole.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRole proto.InternalMessageInfo

// PolicyUsingExpr represents the expression used in the USING clause of a policy.
type PolicyUsingExpr struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	PolicyID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID `protobuf:"varint,2,opt,name=policy_id,json=policyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PolicyID" json:"policy_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *PolicyUsingExpr) Reset()         { *m = PolicyUsingExpr{} }
func (m *PolicyUsingExpr) String() string { return proto.CompactTextString(m) }
func (*PolicyUsingExpr) ProtoMessage()    {}
func (*PolicyUsingExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{16}
}
func (m *PolicyUsingExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyUsingExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyUsingExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyUsingExpr.Merge(m, src)
}
func (m *PolicyUsingExpr) XXX_Size() int {
	return m.Size()
}
func (m *PolicyUsingExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyUsingExpr.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyUsingExpr proto.InternalMessageInfo

// PolicyWithCheckExpression represents the expression used in the WITH CHECK
// clause of a policy.
type PolicyWithCheckExpr struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	PolicyID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID `protobuf:"varint,2,opt,name=policy_id,json=policyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PolicyID" json:"policy_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *PolicyWithCheckExpr) Reset()         { *m = PolicyWithCheckExpr{} }
func (m *PolicyWithCheckExpr) String() string { return proto.CompactTextString(m) }
func (*PolicyWithCheckExpr) ProtoMessage()    {}
func (*PolicyWithCheckExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{17}
}
func (m *PolicyWithCheckExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyWithCheckExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyWithCheckExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyWithCheckExpr.Merge(m, src)
}
func (m *PolicyWithCheckExpr) XXX_Size() int {
	return m.Size()
}
func (m *PolicyWithCheckExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyWithCheckExpr.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyWithCheckExpr proto.InternalMessageInfo

// PolicyDeps includes the dependencies for types, sequences, or functions referenced
// by both the USING and WITH CHECK expressions in the policy.
type PolicyDeps struct {
	TableID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	PolicyID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID `protobuf:"varint,2,opt,name=policy_id,json=policyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PolicyID" json:"policy_id,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesRelationIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,4,rep,packed,name=uses_relation_ids,json=usesRelationIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_relation_ids,omitempty"`
	UsesFunctionIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,5,rep,packed,name=uses_function_ids,json=usesFunctionIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_function_ids,omitempty"`
}

func (m *PolicyDeps) Reset()         { *m = PolicyDeps{} }
func (m *PolicyDeps) String() string { return proto.CompactTextString(m) }
func (*PolicyDeps) ProtoMessage()    {}
func (*PolicyDeps) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{18}
}
func (m *PolicyDeps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyDeps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyDeps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyDeps.Merge(m, src)
}
func (m *PolicyDeps) XXX_Size() int {
	return m.Size()
}
func (m *PolicyDeps) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyDeps.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyDeps proto.InternalMessageInfo

// RowLevelSecurityEnabled handles enabling and disabling row level security of a table.
type RowLevelSecurityEnabled struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *RowLevelSecurityEnabled) Reset()         { *m = RowLevelSecurityEnabled{} }
func (m *RowLevelSecurityEnabled) String() string { return proto.CompactTextString(m) }
func (*RowLevelSecurityEnabled) ProtoMessage()    {}
func (*RowLevelSecurityEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{19}
}
func (m *RowLevelSecurityEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelSecurityEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelSecurityEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelSecurityEnabled.Merge(m, src)
}
func (m *RowLevelSecurityEnabled) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelSecurityEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelSecurityEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelSecurityEnabled proto.InternalMessageInfo

// RowLevelSecurityForced handles forced and no-force row level security of a table.
type RowLevelSecurityForced struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IsForced bool                                                      `protobuf:"varint,2,opt,name=is_forced,json=isForced,proto3" json:"is_forced,omitempty"`
}

func (m *RowLevelSecurityForced) Reset()         { *m = RowLevelSecurityForced{} }
func (m *RowLevelSecurityForced) String() string { return proto.CompactTextString(m) }
func (*RowLevelSecurityForced) ProtoMessage()    {}
func (*RowLevelSecurityForced) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{20}
}
func (m *RowLevelSecurityForced) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelSecurityForced) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelSecurityForced) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelSecurityForced.Merge(m, src)
}
func (m *RowLevelSecurityForced) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelSecurityForced) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelSecurityForced.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelSecurityForced proto.InternalMessageInfo

type Sequence struct {
	SequenceID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	RestartWith    int64                                                     `protobuf:"varint,2,opt,name=restart_with,json=restartWith,proto3" json:"restart_with,omitempty"`
	UseRestartWith bool                                                      `protobuf:"varint,3,opt,name=use_restart_with,json=useRestartWith,proto3" json:"use_restart_with,omitempty"`
	IsTemporary    bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
}

func (m *Sequence) Reset()         { *m = Sequence{} }
func (m *Sequence) String() string { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()    {}
func (*Sequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{21}
}
func (m *Sequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sequence.Merge(m, src)
}
func (m *Sequence) XXX_Size() int {
	return m.Size()
}
func (m *Sequence) XXX_DiscardUnknown() {
	xxx_messageInfo_Sequence.DiscardUnknown(m)
}

var xxx_messageInfo_Sequence proto.InternalMessageInfo

type SequenceOption struct {
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	Key        string                                                    `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value      string                                                    `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SequenceOption) Reset()         { *m = SequenceOption{} }
func (m *SequenceOption) String() string { return proto.CompactTextString(m) }
func (*SequenceOption) ProtoMessage()    {}
func (*SequenceOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{22}
}
func (m *SequenceOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceOption.Merge(m, src)
}
func (m *SequenceOption) XXX_Size() int {
	return m.Size()
}
func (m *SequenceOption) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceOption.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceOption proto.InternalMessageInfo

type SequenceOwner struct {
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
}

func (m *SequenceOwner) Reset()         { *m = SequenceOwner{} }
func (m *SequenceOwner) String() string { return proto.CompactTextString(m) }
func (*SequenceOwner) ProtoMessage()    {}
func (*SequenceOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{23}
}
func (m *SequenceOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceOwner.Merge(m, src)
}
func (m *SequenceOwner) XXX_Size() int {
	return m.Size()
}
func (m *SequenceOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceOwner.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceOwner proto.InternalMessageInfo

type ColumnDefaultExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *ColumnDefaultExpression) Reset()         { *m = ColumnDefaultExpression{} }
func (m *ColumnDefaultExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnDefaultExpression) ProtoMessage()    {}
func (*ColumnDefaultExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{24}
}
func (m *ColumnDefaultExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnDefaultExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnDefaultExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnDefaultExpression.Merge(m, src)
}
func (m *ColumnDefaultExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnDefaultExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnDefaultExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnDefaultExpression proto.InternalMessageInfo

type ColumnOnUpdateExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *ColumnOnUpdateExpression) Reset()         { *m = ColumnOnUpdateExpression{} }
func (m *ColumnOnUpdateExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnOnUpdateExpression) ProtoMessage()    {}
func (*ColumnOnUpdateExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{25}
}
func (m *ColumnOnUpdateExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOnUpdateExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnOnUpdateExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOnUpdateExpression.Merge(m, src)
}
func (m *ColumnOnUpdateExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOnUpdateExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOnUpdateExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOnUpdateExpression proto.InternalMessageInfo

type View struct {
	ViewID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=view_id,json=viewId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"view_id,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesRelationIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=uses_relation_ids,json=usesRelationIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_relation_ids,omitempty"`
	UsesRoutineIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,12,rep,packed,name=uses_routine_ids,json=usesRoutineIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_routine_ids,omitempty"`
	// all forward reference from this view -- it gives more details of those references than just
	// referenced relation ids (which is stored in `uses_relation_ids`).
	ForwardReferences []*View_Reference `protobuf:"bytes,4,rep,name=forward_references,json=forwardReferences,proto3" json:"forward_references,omitempty"`
	IsTemporary       bool              `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	IsMaterialized    bool              `protobuf:"varint,11,opt,name=is_materialized,json=isMaterialized,proto3" json:"is_materialized,omitempty"`
}

func (m *View) Reset()         { *m = View{} }
func (m *View) String() string { return proto.CompactTextString(m) }
func (*View) ProtoMessage()    {}
func (*View) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{26}
}
func (m *View) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *View) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View.Merge(m, src)
}
func (m *View) XXX_Size() int {
	return m.Size()
}
func (m *View) XXX_DiscardUnknown() {
	xxx_messageInfo_View.DiscardUnknown(m)
}

var xxx_messageInfo_View proto.InternalMessageInfo

// a reference from this view to another relation, tracked down to index/column level.
type View_Reference struct {
	ToID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=to_id,json=toId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"to_id,omitempty"`
	// If applicable, the ID of `ToID` relation's index that is referenced by this view.
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	// The IDs of `ToID` relation's columns that are referenced by this view.
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
}

func (m *View_Reference) Reset()         { *m = View_Reference{} }
func (m *View_Reference) String() string { return proto.CompactTextString(m) }
func (*View_Reference) ProtoMessage()    {}
func (*View_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{26, 0}
}
func (m *View_Reference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View_Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *View_Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View_Reference.Merge(m, src)
}
func (m *View_Reference) XXX_Size() int {
	return m.Size()
}
func (m *View_Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_View_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_View_Reference proto.InternalMessageInfo

type Table struct {
	TableID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{27}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

type UniqueWithoutIndexConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	// Predicate, if non-nil, means a partial uniqueness constraint.
	Predicate *Expression `protobuf:"bytes,4,opt,name=predicate,proto3" json:"predicate,omitempty"`
	// IndexIDForValidation is the index id to hint to the unique_without_index
	// constraint validation SQL query about which index to validate against.
	// It is used exclusively by sql.validateUniqueConstraint.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,5,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *UniqueWithoutIndexConstraint) Reset()         { *m = UniqueWithoutIndexConstraint{} }
func (m *UniqueWithoutIndexConstraint) String() string { return proto.CompactTextString(m) }
func (*UniqueWithoutIndexConstraint) ProtoMessage()    {}
func (*UniqueWithoutIndexConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{28}
}
func (m *UniqueWithoutIndexConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueWithoutIndexConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UniqueWithoutIndexConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueWithoutIndexConstraint.Merge(m, src)
}
func (m *UniqueWithoutIndexConstraint) XXX_Size() int {
	return m.Size()
}
func (m *UniqueWithoutIndexConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueWithoutIndexConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueWithoutIndexConstraint proto.InternalMessageInfo

type UniqueWithoutIndexConstraintUnvalidated struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	// Predicate, if non-nil, means a partial uniqueness constraint.
	Predicate *Expression `protobuf:"bytes,4,opt,name=predicate,proto3" json:"predicate,omitempty"`
}

func (m *UniqueWithoutIndexConstraintUnvalidated) Reset() {
	*m = UniqueWithoutIndexConstraintUnvalidated{}
}
func (m *UniqueWithoutIndexConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*UniqueWithoutIndexConstraintUnvalidated) ProtoMessage()    {}
func (*UniqueWithoutIndexConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{29}
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueWithoutIndexConstraintUnvalidated.Merge(m, src)
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueWithoutIndexConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueWithoutIndexConstraintUnvalidated proto.InternalMessageInfo

type CheckConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	Expression   `protobuf:"bytes,4,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
	// FromHashShardedColumn indicates whether this check constraint comes from a hash sharded column.
	FromHashShardedColumn bool `protobuf:"varint,5,opt,name=from_hash_sharded_column,json=fromHashShardedColumn,proto3" json:"from_hash_sharded_column,omitempty"`
	// IndexIDForValidation is the index id to hint to the check constraint validation SQL query about which index
	// to check against. It is used exclusively by sql.validateCheckExpr.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,6,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *CheckConstraint) Reset()         { *m = CheckConstraint{} }
func (m *CheckConstraint) String() string { return proto.CompactTextString(m) }
func (*CheckConstraint) ProtoMessage()    {}
func (*CheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{30}
}
func (m *CheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraint.Merge(m, src)
}
func (m *CheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraint proto.InternalMessageInfo

type CheckConstraintUnvalidated struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	Expression   `protobuf:"bytes,4,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *CheckConstraintUnvalidated) Reset()         { *m = CheckConstraintUnvalidated{} }
func (m *CheckConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*CheckConstraintUnvalidated) ProtoMessage()    {}
func (*CheckConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{31}
}
func (m *CheckConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraintUnvalidated.Merge(m, src)
}
func (m *CheckConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraintUnvalidated proto.InternalMessageInfo

type ForeignKeyConstraint struct {
	TableID                 github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID            github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs               []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	ReferencedTableID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,4,opt,name=referenced_table_id,json=referencedTableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"referenced_table_id,omitempty"`
	ReferencedColumnIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,5,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
	OnUpdateAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,6,opt,name=on_update_action,json=onUpdateAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_update_action,omitempty"`
	OnDeleteAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,7,opt,name=on_delete_action,json=onDeleteAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_delete_action,omitempty"`
	CompositeKeyMatchMethod semenumpb.Match                                                 `protobuf:"varint,8,opt,name=composite_key_match_method,json=compositeKeyMatchMethod,proto3,enum=cockroach.sql.sem.semenumpb.Match" json:"composite_key_match_method,omitempty"`
	// IndexIDForValidation is the index id to hint to the foreign key constraint validation SQL query about which index
	// to validate against. It is used exclusively by sql.validateFKExpr.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,9,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *ForeignKeyConstraint) Reset()         { *m = ForeignKeyConstraint{} }
func (m *ForeignKeyConstraint) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyConstraint) ProtoMessage()    {}
func (*ForeignKeyConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{32}
}
func (m *ForeignKeyConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKeyConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyConstraint.Merge(m, src)
}
func (m *ForeignKeyConstraint) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyConstraint proto.InternalMessageInfo

type ForeignKeyConstraintUnvalidated struct {
	TableID                 github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID            github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs               []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	ReferencedTableID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,4,opt,name=referenced_table_id,json=referencedTableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"referenced_table_id,omitempty"`
	ReferencedColumnIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,5,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
	OnUpdateAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,6,opt,name=on_update_action,json=onUpdateAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_update_action,omitempty"`
	OnDeleteAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,7,opt,name=on_delete_action,json=onDeleteAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_delete_action,omitempty"`
	CompositeKeyMatchMethod semenumpb.Match                                                 `protobuf:"varint,8,opt,name=composite_key_match_method,json=compositeKeyMatchMethod,proto3,enum=cockroach.sql.sem.semenumpb.Match" json:"composite_key_match_method,omitempty"`
}

func (m *ForeignKeyConstraintUnvalidated) Reset()         { *m = ForeignKeyConstraintUnvalidated{} }
func (m *ForeignKeyConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyConstraintUnvalidated) ProtoMessage()    {}
func (*ForeignKeyConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{33}
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyConstraintUnvalidated.Merge(m, src)
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyConstraintUnvalidated proto.InternalMessageInfo

type Trigger struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
}

func (m *Trigger) Reset()         { *m = Trigger{} }
func (m *Trigger) String() string { return proto.CompactTextString(m) }
func (*Trigger) ProtoMessage()    {}
func (*Trigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{34}
}
func (m *Trigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Trigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trigger.Merge(m, src)
}
func (m *Trigger) XXX_Size() int {
	return m.Size()
}
func (m *Trigger) XXX_DiscardUnknown() {
	xxx_messageInfo_Trigger.DiscardUnknown(m)
}

var xxx_messageInfo_Trigger proto.InternalMessageInfo

type TriggerName struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	Name      string                                                       `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *TriggerName) Reset()         { *m = TriggerName{} }
func (m *TriggerName) String() string { return proto.CompactTextString(m) }
func (*TriggerName) ProtoMessage()    {}
func (*TriggerName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{35}
}
func (m *TriggerName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerName.Merge(m, src)
}
func (m *TriggerName) XXX_Size() int {
	return m.Size()
}
func (m *TriggerName) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerName.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerName proto.InternalMessageInfo

type TriggerEnabled struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	Enabled   bool                                                         `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *TriggerEnabled) Reset()         { *m = TriggerEnabled{} }
func (m *TriggerEnabled) String() string { return proto.CompactTextString(m) }
func (*TriggerEnabled) ProtoMessage()    {}
func (*TriggerEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{36}
}
func (m *TriggerEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEnabled.Merge(m, src)
}
func (m *TriggerEnabled) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEnabled proto.InternalMessageInfo

type TriggerTiming struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	ActionTime semenumpb.TriggerActionTime                                  `protobuf:"varint,3,opt,name=action_time,json=actionTime,proto3,enum=cockroach.sql.sem.semenumpb.TriggerActionTime" json:"action_time,omitempty"`
	ForEachRow bool                                                         `protobuf:"varint,4,opt,name=for_each_row,json=forEachRow,proto3" json:"for_each_row,omitempty"`
}

func (m *TriggerTiming) Reset()         { *m = TriggerTiming{} }
func (m *TriggerTiming) String() string { return proto.CompactTextString(m) }
func (*TriggerTiming) ProtoMessage()    {}
func (*TriggerTiming) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{37}
}
func (m *TriggerTiming) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerTiming) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerTiming) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerTiming.Merge(m, src)
}
func (m *TriggerTiming) XXX_Size() int {
	return m.Size()
}
func (m *TriggerTiming) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerTiming.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerTiming proto.InternalMessageInfo

type TriggerEvent struct {
	Type        semenumpb.TriggerEventType `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.sql.sem.semenumpb.TriggerEventType" json:"type,omitempty"`
	ColumnNames []string                   `protobuf:"bytes,2,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
}

func (m *TriggerEvent) Reset()         { *m = TriggerEvent{} }
func (m *TriggerEvent) String() string { return proto.CompactTextString(m) }
func (*TriggerEvent) ProtoMessage()    {}
func (*TriggerEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{38}
}
func (m *TriggerEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEvent.Merge(m, src)
}
func (m *TriggerEvent) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEvent proto.InternalMessageInfo

type TriggerEvents struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	Events    []*TriggerEvent                                              `protobuf:"bytes,3,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *TriggerEvents) Reset()         { *m = TriggerEvents{} }
func (m *TriggerEvents) String() string { return proto.CompactTextString(m) }
func (*TriggerEvents) ProtoMessage()    {}
func (*TriggerEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{39}
}
func (m *TriggerEvents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEvents.Merge(m, src)
}
func (m *TriggerEvents) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEvents.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEvents proto.InternalMessageInfo

type TriggerTransition struct {
	TableID            github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	NewTransitionAlias string                                                       `protobuf:"bytes,3,opt,name=new_transition_alias,json=newTransitionAlias,proto3" json:"new_transition_alias,omitempty"`
	OldTransitionAlias string                                                       `protobuf:"bytes,4,opt,name=old_transition_alias,json=oldTransitionAlias,proto3" json:"old_transition_alias,omitempty"`
}

func (m *TriggerTransition) Reset()         { *m = TriggerTransition{} }
func (m *TriggerTransition) String() string { return proto.CompactTextString(m) }
func (*TriggerTransition) ProtoMessage()    {}
func (*TriggerTransition) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{40}
}
func (m *TriggerTransition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerTransition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerTransition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerTransition.Merge(m, src)
}
func (m *TriggerTransition) XXX_Size() int {
	return m.Size()
}
func (m *TriggerTransition) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerTransition.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerTransition proto.InternalMessageInfo

type TriggerWhen struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	WhenExpr  string                                                       `protobuf:"bytes,3,opt,name=when_expr,json=whenExpr,proto3" json:"when_expr,omitempty"`
}

func (m *TriggerWhen) Reset()         { *m = TriggerWhen{} }
func (m *TriggerWhen) String() string { return proto.CompactTextString(m) }
func (*TriggerWhen) ProtoMessage()    {}
func (*TriggerWhen) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{41}
}
func (m *TriggerWhen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerWhen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerWhen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerWhen.Merge(m, src)
}
func (m *TriggerWhen) XXX_Size() int {
	return m.Size()
}
func (m *TriggerWhen) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerWhen.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerWhen proto.InternalMessageInfo

type TriggerFunctionCall struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	FuncID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,3,opt,name=func_id,json=funcId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"func_id,omitempty"`
	FuncArgs  []string                                                     `protobuf:"bytes,4,rep,name=func_args,json=funcArgs,proto3" json:"func_args,omitempty"`
	FuncBody  string                                                       `protobuf:"bytes,5,opt,name=func_body,json=funcBody,proto3" json:"func_body,omitempty"`
}

func (m *TriggerFunctionCall) Reset()         { *m = TriggerFunctionCall{} }
func (m *TriggerFunctionCall) String() string { return proto.CompactTextString(m) }
func (*TriggerFunctionCall) ProtoMessage()    {}
func (*TriggerFunctionCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{42}
}
func (m *TriggerFunctionCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerFunctionCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerFunctionCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerFunctionCall.Merge(m, src)
}
func (m *TriggerFunctionCall) XXX_Size() int {
	return m.Size()
}
func (m *TriggerFunctionCall) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerFunctionCall.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerFunctionCall proto.InternalMessageInfo

type TriggerDeps struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID    `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TriggerID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID `protobuf:"varint,2,opt,name=trigger_id,json=triggerId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.TriggerID" json:"trigger_id,omitempty"`
	// UsesRelationIDs is a deprecated field that tracks the IDs of relations
	// used by this trigger. It remains for backward compatibility with older
	// versions and is superseded by UsesRelations.
	UsesRelationIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=uses_relation_ids,json=usesRelationIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_relation_ids,omitempty"` // Deprecated: Do not use.
	// UsesRelations specifies the relations that this trigger depends on.
	// In addition to the relation itself, it may include optional ColumnIDs
	// or IndexIDs to capture fine-grained dependencies.
	UsesRelations  []TriggerDeps_RelationReference                             `protobuf:"bytes,6,rep,name=uses_relations,json=usesRelations,proto3" json:"uses_relations"`
	UsesTypeIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,4,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesRoutineIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,5,rep,packed,name=uses_routine_ids,json=usesRoutineIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_routine_ids,omitempty"`
}

func (m *TriggerDeps) Reset()         { *m = TriggerDeps{} }
func (m *TriggerDeps) String() string { return proto.CompactTextString(m) }
func (*TriggerDeps) ProtoMessage()    {}
func (*TriggerDeps) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{43}
}
func (m *TriggerDeps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerDeps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerDeps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerDeps.Merge(m, src)
}
func (m *TriggerDeps) XXX_Size() int {
	return m.Size()
}
func (m *TriggerDeps) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerDeps.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerDeps proto.InternalMessageInfo

type TriggerDeps_RelationReference struct {
	ID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	IndexID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
}

func (m *TriggerDeps_RelationReference) Reset()         { *m = TriggerDeps_RelationReference{} }
func (m *TriggerDeps_RelationReference) String() string { return proto.CompactTextString(m) }
func (*TriggerDeps_RelationReference) ProtoMessage()    {}
func (*TriggerDeps_RelationReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{43, 0}
}
func (m *TriggerDeps_RelationReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerDeps_RelationReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerDeps_RelationReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerDeps_RelationReference.Merge(m, src)
}
func (m *TriggerDeps_RelationReference) XXX_Size() int {
	return m.Size()
}
func (m *TriggerDeps_RelationReference) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerDeps_RelationReference.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerDeps_RelationReference proto.InternalMessageInfo

type EnumType struct {
	TypeID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	ArrayTypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=array_type_id,json=arrayTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"array_type_id,omitempty"`
	IsMultiRegion bool                                                      `protobuf:"varint,3,opt,name=is_multi_region,json=isMultiRegion,proto3" json:"is_multi_region,omitempty"`
}

func (m *EnumType) Reset()         { *m = EnumType{} }
func (m *EnumType) String() string { return proto.CompactTextString(m) }
func (*EnumType) ProtoMessage()    {}
func (*EnumType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{44}
}
func (m *EnumType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnumType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnumType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnumType.Merge(m, src)
}
func (m *EnumType) XXX_Size() int {
	return m.Size()
}
func (m *EnumType) XXX_DiscardUnknown() {
	xxx_messageInfo_EnumType.DiscardUnknown(m)
}

var xxx_messageInfo_EnumType proto.InternalMessageInfo

type AliasType struct {
	TypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	TypeT  `protobuf:"bytes,2,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
}

func (m *AliasType) Reset()         { *m = AliasType{} }
func (m *AliasType) String() string { return proto.CompactTextString(m) }
func (*AliasType) ProtoMessage()    {}
func (*AliasType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{45}
}
func (m *AliasType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AliasType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasType.Merge(m, src)
}
func (m *AliasType) XXX_Size() int {
	return m.Size()
}
func (m *AliasType) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasType.DiscardUnknown(m)
}

var xxx_messageInfo_AliasType proto.InternalMessageInfo

type CompositeType struct {
	TypeID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	ArrayTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=array_type_id,json=arrayTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"array_type_id,omitempty"`
}

func (m *CompositeType) Reset()         { *m = CompositeType{} }
func (m *CompositeType) String() string { return proto.CompactTextString(m) }
func (*CompositeType) ProtoMessage()    {}
func (*CompositeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{46}
}
func (m *CompositeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompositeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeType.Merge(m, src)
}
func (m *CompositeType) XXX_Size() int {
	return m.Size()
}
func (m *CompositeType) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeType.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeType proto.InternalMessageInfo

type Schema struct {
	SchemaID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	IsPublic    bool                                                      `protobuf:"varint,11,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
	IsVirtual   bool                                                      `protobuf:"varint,12,opt,name=is_virtual,json=isVirtual,proto3" json:"is_virtual,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{47}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

type Database struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *Database) Reset()         { *m = Database{} }
func (m *Database) String() string { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()    {}
func (*Database) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{48}
}
func (m *Database) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Database) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Database) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Database.Merge(m, src)
}
func (m *Database) XXX_Size() int {
	return m.Size()
}
func (m *Database) XXX_DiscardUnknown() {
	xxx_messageInfo_Database.DiscardUnknown(m)
}

var xxx_messageInfo_Database proto.InternalMessageInfo

type Namespace struct {
	DatabaseID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	SchemaID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Name         string                                                    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{49}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

type Owner struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Owner        string                                                    `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *Owner) Reset()         { *m = Owner{} }
func (m *Owner) String() string { return proto.CompactTextString(m) }
func (*Owner) ProtoMessage()    {}
func (*Owner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{50}
}
func (m *Owner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Owner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Owner.Merge(m, src)
}
func (m *Owner) XXX_Size() int {
	return m.Size()
}
func (m *Owner) XXX_DiscardUnknown() {
	xxx_messageInfo_Owner.DiscardUnknown(m)
}

var xxx_messageInfo_Owner proto.InternalMessageInfo

type UserPrivileges struct {
	DescriptorID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	UserName        string                                                    `protobuf:"bytes,2,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Privileges      uint64                                                    `protobuf:"varint,3,opt,name=privileges,proto3" json:"privileges,omitempty"`
	WithGrantOption uint64                                                    `protobuf:"varint,4,opt,name=with_grant_option,json=withGrantOption,proto3" json:"with_grant_option,omitempty"`
}

func (m *UserPrivileges) Reset()         { *m = UserPrivileges{} }
func (m *UserPrivileges) String() string { return proto.CompactTextString(m) }
func (*UserPrivileges) ProtoMessage()    {}
func (*UserPrivileges) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{51}
}
func (m *UserPrivileges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPrivileges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserPrivileges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPrivileges.Merge(m, src)
}
func (m *UserPrivileges) XXX_Size() int {
	return m.Size()
}
func (m *UserPrivileges) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPrivileges.DiscardUnknown(m)
}

var xxx_messageInfo_UserPrivileges proto.InternalMessageInfo

type NamedRangeZoneConfig struct {
	RangeID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"range_id,omitempty"`
	ZoneConfig *zonepb.ZoneConfig                                        `protobuf:"bytes,2,opt,name=zone_config,json=zoneConfig,proto3" json:"zone_config,omitempty"`
	// `seq_num` is used to differentiate different zone config elements tied to
	// the same range. E.g. If we attempt to update a range's zone config,
	// our solution is to drop the existing element and add a new element, with
	// different `seq_num`.
	SeqNum uint32 `protobuf:"varint,3,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *NamedRangeZoneConfig) Reset()         { *m = NamedRangeZoneConfig{} }
func (m *NamedRangeZoneConfig) String() string { return proto.CompactTextString(m) }
func (*NamedRangeZoneConfig) ProtoMessage()    {}
func (*NamedRangeZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{52}
}
func (m *NamedRangeZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedRangeZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NamedRangeZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedRangeZoneConfig.Merge(m, src)
}
func (m *NamedRangeZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *NamedRangeZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedRangeZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NamedRangeZoneConfig proto.InternalMessageInfo

type TableLocalityGlobal struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableLocalityGlobal) Reset()         { *m = TableLocalityGlobal{} }
func (m *TableLocalityGlobal) String() string { return proto.CompactTextString(m) }
func (*TableLocalityGlobal) ProtoMessage()    {}
func (*TableLocalityGlobal) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{53}
}
func (m *TableLocalityGlobal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityGlobal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityGlobal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityGlobal.Merge(m, src)
}
func (m *TableLocalityGlobal) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityGlobal) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityGlobal.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityGlobal proto.InternalMessageInfo

type TableLocalityPrimaryRegion struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableLocalityPrimaryRegion) Reset()         { *m = TableLocalityPrimaryRegion{} }
func (m *TableLocalityPrimaryRegion) String() string { return proto.CompactTextString(m) }
func (*TableLocalityPrimaryRegion) ProtoMessage()    {}
func (*TableLocalityPrimaryRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{54}
}
func (m *TableLocalityPrimaryRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityPrimaryRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityPrimaryRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityPrimaryRegion.Merge(m, src)
}
func (m *TableLocalityPrimaryRegion) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityPrimaryRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityPrimaryRegion.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityPrimaryRegion proto.InternalMessageInfo

type TableLocalitySecondaryRegion struct {
	TableID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	RegionEnumTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,2,opt,name=region_enum_type_id,json=regionEnumTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"region_enum_type_id,omitempty"`
	RegionName       github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName `protobuf:"bytes,3,opt,name=region_name,json=regionName,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.RegionName" json:"region_name,omitempty"`
}

func (m *TableLocalitySecondaryRegion) Reset()         { *m = TableLocalitySecondaryRegion{} }
func (m *TableLocalitySecondaryRegion) String() string { return proto.CompactTextString(m) }
func (*TableLocalitySecondaryRegion) ProtoMessage()    {}
func (*TableLocalitySecondaryRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{55}
}
func (m *TableLocalitySecondaryRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalitySecondaryRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalitySecondaryRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalitySecondaryRegion.Merge(m, src)
}
func (m *TableLocalitySecondaryRegion) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalitySecondaryRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalitySecondaryRegion.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalitySecondaryRegion proto.InternalMessageInfo

type TableLocalityRegionalByRow struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	As      string                                                    `protobuf:"bytes,2,opt,name=as,proto3" json:"as,omitempty"`
}

func (m *TableLocalityRegionalByRow) Reset()         { *m = TableLocalityRegionalByRow{} }
func (m *TableLocalityRegionalByRow) String() string { return proto.CompactTextString(m) }
func (*TableLocalityRegionalByRow) ProtoMessage()    {}
func (*TableLocalityRegionalByRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{56}
}
func (m *TableLocalityRegionalByRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityRegionalByRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityRegionalByRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityRegionalByRow.Merge(m, src)
}
func (m *TableLocalityRegionalByRow) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityRegionalByRow) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityRegionalByRow.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityRegionalByRow proto.InternalMessageInfo

type TableLocalityRegionalByRowUsingConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
}

func (m *TableLocalityRegionalByRowUsingConstraint) Reset() {
	*m = TableLocalityRegionalByRowUsingConstraint{}
}
func (m *TableLocalityRegionalByRowUsingConstraint) String() string {
	return proto.CompactTextString(m)
}
func (*TableLocalityRegionalByRowUsingConstraint) ProtoMessage() {}
func (*TableLocalityRegionalByRowUsingConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{57}
}
func (m *TableLocalityRegionalByRowUsingConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityRegionalByRowUsingConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityRegionalByRowUsingConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityRegionalByRowUsingConstraint.Merge(m, src)
}
func (m *TableLocalityRegionalByRowUsingConstraint) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityRegionalByRowUsingConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityRegionalByRowUsingConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityRegionalByRowUsingConstraint proto.InternalMessageInfo

type IndexPartitioning struct {
	TableID                      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID                      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	catpb.PartitioningDescriptor `protobuf:"bytes,3,opt,name=partitioning,proto3,embedded=partitioning" json:"partitioning"`
}

func (m *IndexPartitioning) Reset()         { *m = IndexPartitioning{} }
func (m *IndexPartitioning) String() string { return proto.CompactTextString(m) }
func (*IndexPartitioning) ProtoMessage()    {}
func (*IndexPartitioning) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{58}
}
func (m *IndexPartitioning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexPartitioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexPartitioning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexPartitioning.Merge(m, src)
}
func (m *IndexPartitioning) XXX_Size() int {
	return m.Size()
}
func (m *IndexPartitioning) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexPartitioning.DiscardUnknown(m)
}

var xxx_messageInfo_IndexPartitioning proto.InternalMessageInfo

type RowLevelTTL struct {
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	catpb.RowLevelTTL `protobuf:"bytes,2,opt,name=row_level_ttl,json=rowLevelTtl,proto3,embedded=row_level_ttl" json:"row_level_ttl"`
	// The expression for the TTL column. It represents either the custom
	// expression specified in ExpirationExpr, or the default expression if
	// ExpirationExpr is not set. This expression is used to establish column
	// dependencies.
	TTLExpr *Expression `protobuf:"bytes,3,opt,name=ttl_expr,json=ttlExpr,proto3" json:"ttl_expr,omitempty"`
}

func (m *RowLevelTTL) Reset()         { *m = RowLevelTTL{} }
func (m *RowLevelTTL) String() string { return proto.CompactTextString(m) }
func (*RowLevelTTL) ProtoMessage()    {}
func (*RowLevelTTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{59}
}
func (m *RowLevelTTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelTTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelTTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelTTL.Merge(m, src)
}
func (m *RowLevelTTL) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelTTL) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelTTL.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelTTL proto.InternalMessageInfo

type ColumnName struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnName) Reset()         { *m = ColumnName{} }
func (m *ColumnName) String() string { return proto.CompactTextString(m) }
func (*ColumnName) ProtoMessage()    {}
func (*ColumnName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{60}
}
func (m *ColumnName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnName.Merge(m, src)
}
func (m *ColumnName) XXX_Size() int {
	return m.Size()
}
func (m *ColumnName) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnName.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnName proto.InternalMessageInfo

type IndexName struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Name    string                                                     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *IndexName) Reset()         { *m = IndexName{} }
func (m *IndexName) String() string { return proto.CompactTextString(m) }
func (*IndexName) ProtoMessage()    {}
func (*IndexName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{61}
}
func (m *IndexName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexName.Merge(m, src)
}
func (m *IndexName) XXX_Size() int {
	return m.Size()
}
func (m *IndexName) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexName.DiscardUnknown(m)
}

var xxx_messageInfo_IndexName proto.InternalMessageInfo

type ConstraintWithoutIndexName struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Name         string                                                          `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ConstraintWithoutIndexName) Reset()         { *m = ConstraintWithoutIndexName{} }
func (m *ConstraintWithoutIndexName) String() string { return proto.CompactTextString(m) }
func (*ConstraintWithoutIndexName) ProtoMessage()    {}
func (*ConstraintWithoutIndexName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{62}
}
func (m *ConstraintWithoutIndexName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintWithoutIndexName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintWithoutIndexName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintWithoutIndexName.Merge(m, src)
}
func (m *ConstraintWithoutIndexName) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintWithoutIndexName) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintWithoutIndexName.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintWithoutIndexName proto.InternalMessageInfo

type TableComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	Comment string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *TableComment) Reset()         { *m = TableComment{} }
func (m *TableComment) String() string { return proto.CompactTextString(m) }
func (*TableComment) ProtoMessage()    {}
func (*TableComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{63}
}
func (m *TableComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableComment.Merge(m, src)
}
func (m *TableComment) XXX_Size() int {
	return m.Size()
}
func (m *TableComment) XXX_DiscardUnknown() {
	xxx_messageInfo_TableComment.DiscardUnknown(m)
}

var xxx_messageInfo_TableComment proto.InternalMessageInfo

type TypeComment struct {
	TypeID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	Comment string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *TypeComment) Reset()         { *m = TypeComment{} }
func (m *TypeComment) String() string { return proto.CompactTextString(m) }
func (*TypeComment) ProtoMessage()    {}
func (*TypeComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{64}
}
func (m *TypeComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TypeComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeComment.Merge(m, src)
}
func (m *TypeComment) XXX_Size() int {
	return m.Size()
}
func (m *TypeComment) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeComment.DiscardUnknown(m)
}

var xxx_messageInfo_TypeComment proto.InternalMessageInfo

type DatabaseComment struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	Comment    string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *DatabaseComment) Reset()         { *m = DatabaseComment{} }
func (m *DatabaseComment) String() string { return proto.CompactTextString(m) }
func (*DatabaseComment) ProtoMessage()    {}
func (*DatabaseComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{65}
}
func (m *DatabaseComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseComment.Merge(m, src)
}
func (m *DatabaseComment) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseComment) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseComment.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseComment proto.InternalMessageInfo

type SchemaComment struct {
	SchemaID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	Comment  string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *SchemaComment) Reset()         { *m = SchemaComment{} }
func (m *SchemaComment) String() string { return proto.CompactTextString(m) }
func (*SchemaComment) ProtoMessage()    {}
func (*SchemaComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{66}
}
func (m *SchemaComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaComment.Merge(m, src)
}
func (m *SchemaComment) XXX_Size() int {
	return m.Size()
}
func (m *SchemaComment) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaComment.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaComment proto.InternalMessageInfo

type IndexComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Comment string                                                     `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *IndexComment) Reset()         { *m = IndexComment{} }
func (m *IndexComment) String() string { return proto.CompactTextString(m) }
func (*IndexComment) ProtoMessage()    {}
func (*IndexComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{67}
}
func (m *IndexComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexComment.Merge(m, src)
}
func (m *IndexComment) XXX_Size() int {
	return m.Size()
}
func (m *IndexComment) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexComment.DiscardUnknown(m)
}

var xxx_messageInfo_IndexComment proto.InternalMessageInfo

type ColumnComment struct {
	TableID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID       `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Comment        string                                                            `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	PgAttributeNum github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum `protobuf:"varint,4,opt,name=pg_attribute_num,json=pgAttributeNum,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PGAttributeNum" json:"pg_attribute_num,omitempty"`
}

func (m *ColumnComment) Reset()         { *m = ColumnComment{} }
func (m *ColumnComment) String() string { return proto.CompactTextString(m) }
func (*ColumnComment) ProtoMessage()    {}
func (*ColumnComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{68}
}
func (m *ColumnComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnComment.Merge(m, src)
}
func (m *ColumnComment) XXX_Size() int {
	return m.Size()
}
func (m *ColumnComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnComment.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnComment proto.InternalMessageInfo

type ColumnNotNull struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	// IndexIDForValidation is the index id to hint to the check constraint validation SQL query about which index
	// to check against the not-null-ness of the column. It is used exclusively by sql.validateCheckExpr.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,3,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *ColumnNotNull) Reset()         { *m = ColumnNotNull{} }
func (m *ColumnNotNull) String() string { return proto.CompactTextString(m) }
func (*ColumnNotNull) ProtoMessage()    {}
func (*ColumnNotNull) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{69}
}
func (m *ColumnNotNull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnNotNull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnNotNull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnNotNull.Merge(m, src)
}
func (m *ColumnNotNull) XXX_Size() int {
	return m.Size()
}
func (m *ColumnNotNull) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnNotNull.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnNotNull proto.InternalMessageInfo

type ConstraintComment struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Comment      string                                                          `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ConstraintComment) Reset()         { *m = ConstraintComment{} }
func (m *ConstraintComment) String() string { return proto.CompactTextString(m) }
func (*ConstraintComment) ProtoMessage()    {}
func (*ConstraintComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{70}
}
func (m *ConstraintComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintComment.Merge(m, src)
}
func (m *ConstraintComment) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintComment.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintComment proto.InternalMessageInfo

type DatabaseRegionConfig struct {
	DatabaseID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RegionEnumTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=region_enum_type_id,json=regionEnumTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"region_enum_type_id,omitempty"`
}

func (m *DatabaseRegionConfig) Reset()         { *m = DatabaseRegionConfig{} }
func (m *DatabaseRegionConfig) String() string { return proto.CompactTextString(m) }
func (*DatabaseRegionConfig) ProtoMessage()    {}
func (*DatabaseRegionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{71}
}
func (m *DatabaseRegionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRegionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRegionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRegionConfig.Merge(m, src)
}
func (m *DatabaseRegionConfig) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRegionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRegionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRegionConfig proto.InternalMessageInfo

type DatabaseRoleSetting struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RoleName   string                                                    `protobuf:"bytes,2,opt,name=role_name,json=roleName,proto3" json:"role_name,omitempty"`
}

func (m *DatabaseRoleSetting) Reset()         { *m = DatabaseRoleSetting{} }
func (m *DatabaseRoleSetting) String() string { return proto.CompactTextString(m) }
func (*DatabaseRoleSetting) ProtoMessage()    {}
func (*DatabaseRoleSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{72}
}
func (m *DatabaseRoleSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRoleSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRoleSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRoleSetting.Merge(m, src)
}
func (m *DatabaseRoleSetting) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRoleSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRoleSetting.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRoleSetting proto.InternalMessageInfo

// IndexColumn models column membership in an index.
type IndexColumn struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID  `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	// OrdinalInKind is the slice index of this column in the relevant slice
	// as indicated by the IndexColumn's Kind.
	OrdinalInKind uint32           `protobuf:"varint,4,opt,name=ordinal_in_kind,json=ordinalInKind,proto3" json:"ordinal_in_kind,omitempty"`
	Kind          IndexColumn_Kind `protobuf:"varint,5,opt,name=kind,proto3,enum=cockroach.sql.schemachanger.scpb.IndexColumn_Kind" json:"kind,omitempty"`
	// Direction is only populated for KEY columns.
	Direction catenumpb.IndexColumn_Direction `protobuf:"varint,6,opt,name=direction,proto3,enum=cockroach.sql.catalog.catpb.IndexColumn_Direction" json:"direction,omitempty"`
	// Indicates if this column is implicitly included within the index for
	// partitioning.
	Implicit bool `protobuf:"varint,7,opt,name=implicit,proto3" json:"implicit,omitempty"`
	// InvertedKind determines if this column is inverted and how the information
	// is stored.
	InvertedKind github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.InvertedIndexColumnKind `protobuf:"varint,8,opt,name=inverted_kind,json=invertedKind,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.InvertedIndexColumnKind" json:"inverted_kind,omitempty"`
}

func (m *IndexColumn) Reset()         { *m = IndexColumn{} }
func (m *IndexColumn) String() string { return proto.CompactTextString(m) }
func (*IndexColumn) ProtoMessage()    {}
func (*IndexColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{73}
}
func (m *IndexColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexColumn.Merge(m, src)
}
func (m *IndexColumn) XXX_Size() int {
	return m.Size()
}
func (m *IndexColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexColumn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexColumn proto.InternalMessageInfo

type EnumTypeValue struct {
	TypeID                 github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	PhysicalRepresentation []byte                                                    `protobuf:"bytes,2,opt,name=physical_representation,json=physicalRepresentation,proto3" json:"physical_representation,omitempty"`
	LogicalRepresentation  string                                                    `protobuf:"bytes,3,opt,name=logical_representation,json=logicalRepresentation,proto3" json:"logical_representation,omitempty"`
}

func (m *EnumTypeValue) Reset()         { *m = EnumTypeValue{} }
func (m *EnumTypeValue) String() string { return proto.CompactTextString(m) }
func (*EnumTypeValue) ProtoMessage()    {}
func (*EnumTypeValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{74}
}
func (m *EnumTypeValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnumTypeValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnumTypeValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnumTypeValue.Merge(m, src)
}
func (m *EnumTypeValue) XXX_Size() int {
	return m.Size()
}
func (m *EnumTypeValue) XXX_DiscardUnknown() {
	xxx_messageInfo_EnumTypeValue.DiscardUnknown(m)
}

var xxx_messageInfo_EnumTypeValue proto.InternalMessageInfo

type CompositeTypeAttrName struct {
	CompositeTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=composite_type_id,json=compositeTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"composite_type_id,omitempty"`
	Name            string                                                    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CompositeTypeAttrName) Reset()         { *m = CompositeTypeAttrName{} }
func (m *CompositeTypeAttrName) String() string { return proto.CompactTextString(m) }
func (*CompositeTypeAttrName) ProtoMessage()    {}
func (*CompositeTypeAttrName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{75}
}
func (m *CompositeTypeAttrName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeTypeAttrName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompositeTypeAttrName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeTypeAttrName.Merge(m, src)
}
func (m *CompositeTypeAttrName) XXX_Size() int {
	return m.Size()
}
func (m *CompositeTypeAttrName) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeTypeAttrName.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeTypeAttrName proto.InternalMessageInfo

type CompositeTypeAttrType struct {
	CompositeTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=composite_type_id,json=compositeTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"composite_type_id,omitempty"`
	TypeT           `protobuf:"bytes,2,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
}

func (m *CompositeTypeAttrType) Reset()         { *m = CompositeTypeAttrType{} }
func (m *CompositeTypeAttrType) String() string { return proto.CompactTextString(m) }
func (*CompositeTypeAttrType) ProtoMessage()    {}
func (*CompositeTypeAttrType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{76}
}
func (m *CompositeTypeAttrType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeTypeAttrType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompositeTypeAttrType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeTypeAttrType.Merge(m, src)
}
func (m *CompositeTypeAttrType) XXX_Size() int {
	return m.Size()
}
func (m *CompositeTypeAttrType) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeTypeAttrType.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeTypeAttrType proto.InternalMessageInfo

// DatabaseZoneConfig represents a database's zone configuration.
type DatabaseZoneConfig struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	ZoneConfig *zonepb.ZoneConfig                                        `protobuf:"bytes,2,opt,name=zone_config,json=zoneConfig,proto3" json:"zone_config,omitempty"`
	// `seq_num` is used to differentiate different zone config elements tied to
	// the same database. E.g. If we attempt to update a database's zone config,
	// our solution is to drop the existing element and add a new element, with
	// different `seq_num`.
	SeqNum uint32 `protobuf:"varint,3,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *DatabaseZoneConfig) Reset()         { *m = DatabaseZoneConfig{} }
func (m *DatabaseZoneConfig) String() string { return proto.CompactTextString(m) }
func (*DatabaseZoneConfig) ProtoMessage()    {}
func (*DatabaseZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{77}
}
func (m *DatabaseZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseZoneConfig.Merge(m, src)
}
func (m *DatabaseZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseZoneConfig proto.InternalMessageInfo

type TableZoneConfig struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ZoneConfig *zonepb.ZoneConfig                                        `protobuf:"bytes,2,opt,name=zone_config,json=zoneConfig,proto3" json:"zone_config,omitempty"`
	// `seq_num` is used to differentiate different zone config elements tied to
	// the same table. E.g. If we attempt to update a table's zone config,
	// our solution is to drop the existing element and add a new element, with
	// different `seq_num`.
	SeqNum uint32 `protobuf:"varint,3,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *TableZoneConfig) Reset()         { *m = TableZoneConfig{} }
func (m *TableZoneConfig) String() string { return proto.CompactTextString(m) }
func (*TableZoneConfig) ProtoMessage()    {}
func (*TableZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{78}
}
func (m *TableZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableZoneConfig.Merge(m, src)
}
func (m *TableZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *TableZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TableZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TableZoneConfig proto.InternalMessageInfo

type IndexZoneConfig struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Subzone      zonepb.Subzone                                             `protobuf:"bytes,4,opt,name=subzone,proto3" json:"subzone"`
	SubzoneSpans []zonepb.SubzoneSpan                                       `protobuf:"bytes,5,rep,name=subzone_spans,json=subzoneSpans,proto3" json:"subzone_spans"`
	// `seq_num` is used to differentiate different subzone config elements tied
	// to the same index. E.g. If we attempt to update an index subzone config,
	// our solution is to drop the existing element and add a new element, with
	// different `seq_num`.
	SeqNum    uint32 `protobuf:"varint,6,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	OldIdxRef int32  `protobuf:"varint,7,opt,name=old_idx_ref,json=oldIdxRef,proto3" json:"old_idx_ref,omitempty"`
}

func (m *IndexZoneConfig) Reset()         { *m = IndexZoneConfig{} }
func (m *IndexZoneConfig) String() string { return proto.CompactTextString(m) }
func (*IndexZoneConfig) ProtoMessage()    {}
func (*IndexZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{79}
}
func (m *IndexZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexZoneConfig.Merge(m, src)
}
func (m *IndexZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *IndexZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IndexZoneConfig proto.InternalMessageInfo

type PartitionZoneConfig struct {
	TableID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	PartitionName string                                                     `protobuf:"bytes,3,opt,name=partition_name,json=partitionName,proto3" json:"partition_name,omitempty"`
	Subzone       zonepb.Subzone                                             `protobuf:"bytes,4,opt,name=subzone,proto3" json:"subzone"`
	SubzoneSpans  []zonepb.SubzoneSpan                                       `protobuf:"bytes,5,rep,name=subzone_spans,json=subzoneSpans,proto3" json:"subzone_spans"`
	// `seq_num` is used to differentiate different subzone config elements tied
	// to the same partition. E.g. If we attempt to update a partition's subzone
	// config, our solution is to drop the existing element and add a new element,
	// with different `seq_num`.
	SeqNum    uint32 `protobuf:"varint,6,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	OldIdxRef int32  `protobuf:"varint,7,opt,name=old_idx_ref,json=oldIdxRef,proto3" json:"old_idx_ref,omitempty"`
}

func (m *PartitionZoneConfig) Reset()         { *m = PartitionZoneConfig{} }
func (m *PartitionZoneConfig) String() string { return proto.CompactTextString(m) }
func (*PartitionZoneConfig) ProtoMessage()    {}
func (*PartitionZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{80}
}
func (m *PartitionZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PartitionZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionZoneConfig.Merge(m, src)
}
func (m *PartitionZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *PartitionZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionZoneConfig proto.InternalMessageInfo

// DatabaseData models what needs to be GCed when a database is dropped.
type DatabaseData struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *DatabaseData) Reset()         { *m = DatabaseData{} }
func (m *DatabaseData) String() string { return proto.CompactTextString(m) }
func (*DatabaseData) ProtoMessage()    {}
func (*DatabaseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{81}
}
func (m *DatabaseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseData.Merge(m, src)
}
func (m *DatabaseData) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseData) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseData.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseData proto.InternalMessageInfo

// TableData models what needs to be GCed when a table is dropped.
type TableData struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *TableData) Reset()         { *m = TableData{} }
func (m *TableData) String() string { return proto.CompactTextString(m) }
func (*TableData) ProtoMessage()    {}
func (*TableData) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{82}
}
func (m *TableData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableData.Merge(m, src)
}
func (m *TableData) XXX_Size() int {
	return m.Size()
}
func (m *TableData) XXX_DiscardUnknown() {
	xxx_messageInfo_TableData.DiscardUnknown(m)
}

var xxx_messageInfo_TableData proto.InternalMessageInfo

// IndexData models what needs to be GCed when an index is dropped.
type IndexData struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
}

func (m *IndexData) Reset()         { *m = IndexData{} }
func (m *IndexData) String() string { return proto.CompactTextString(m) }
func (*IndexData) ProtoMessage()    {}
func (*IndexData) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{83}
}
func (m *IndexData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexData.Merge(m, src)
}
func (m *IndexData) XXX_Size() int {
	return m.Size()
}
func (m *IndexData) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexData.DiscardUnknown(m)
}

var xxx_messageInfo_IndexData proto.InternalMessageInfo

type TablePartitioning struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TablePartitioning) Reset()         { *m = TablePartitioning{} }
func (m *TablePartitioning) String() string { return proto.CompactTextString(m) }
func (*TablePartitioning) ProtoMessage()    {}
func (*TablePartitioning) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{84}
}
func (m *TablePartitioning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TablePartitioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TablePartitioning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TablePartitioning.Merge(m, src)
}
func (m *TablePartitioning) XXX_Size() int {
	return m.Size()
}
func (m *TablePartitioning) XXX_DiscardUnknown() {
	xxx_messageInfo_TablePartitioning.DiscardUnknown(m)
}

var xxx_messageInfo_TablePartitioning proto.InternalMessageInfo

// TableSchemaLocked models storage parameter `schema_locked` of a table.
type TableSchemaLocked struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableSchemaLocked) Reset()         { *m = TableSchemaLocked{} }
func (m *TableSchemaLocked) String() string { return proto.CompactTextString(m) }
func (*TableSchemaLocked) ProtoMessage()    {}
func (*TableSchemaLocked) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{85}
}
func (m *TableSchemaLocked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableSchemaLocked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableSchemaLocked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableSchemaLocked.Merge(m, src)
}
func (m *TableSchemaLocked) XXX_Size() int {
	return m.Size()
}
func (m *TableSchemaLocked) XXX_DiscardUnknown() {
	xxx_messageInfo_TableSchemaLocked.DiscardUnknown(m)
}

var xxx_messageInfo_TableSchemaLocked proto.InternalMessageInfo

// LDRJobIDs models the field `ldr_job_ids` of a table descriptor.
type LDRJobIDs struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	JobIDs  []github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID `protobuf:"varint,2,rep,packed,name=job_ids,json=jobIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.JobID" json:"job_ids,omitempty"`
}

func (m *LDRJobIDs) Reset()         { *m = LDRJobIDs{} }
func (m *LDRJobIDs) String() string { return proto.CompactTextString(m) }
func (*LDRJobIDs) ProtoMessage()    {}
func (*LDRJobIDs) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{86}
}
func (m *LDRJobIDs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LDRJobIDs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LDRJobIDs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LDRJobIDs.Merge(m, src)
}
func (m *LDRJobIDs) XXX_Size() int {
	return m.Size()
}
func (m *LDRJobIDs) XXX_DiscardUnknown() {
	xxx_messageInfo_LDRJobIDs.DiscardUnknown(m)
}

var xxx_messageInfo_LDRJobIDs proto.InternalMessageInfo

type Function struct {
	FunctionID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Params      []Function_Parameter                                      `protobuf:"bytes,2,rep,name=params,proto3" json:"params"`
	ReturnSet   bool                                                      `protobuf:"varint,3,opt,name=return_set,json=returnSet,proto3" json:"return_set,omitempty"`
	ReturnType  TypeT                                                     `protobuf:"bytes,4,opt,name=return_type,json=returnType,proto3" json:"return_type"`
	IsProcedure bool                                                      `protobuf:"varint,5,opt,name=is_procedure,json=isProcedure,proto3" json:"is_procedure,omitempty"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{87}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

type Function_Parameter struct {
	Name        string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Class       catpb.FunctionParamClass `protobuf:"bytes,2,opt,name=class,proto3" json:"class"`
	Type        TypeT                    `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	DefaultExpr string                   `protobuf:"bytes,4,opt,name=default_expr,json=defaultExpr,proto3" json:"default_expr,omitempty"`
}

func (m *Function_Parameter) Reset()         { *m = Function_Parameter{} }
func (m *Function_Parameter) String() string { return proto.CompactTextString(m) }
func (*Function_Parameter) ProtoMessage()    {}
func (*Function_Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{87, 0}
}
func (m *Function_Parameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function_Parameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Function_Parameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function_Parameter.Merge(m, src)
}
func (m *Function_Parameter) XXX_Size() int {
	return m.Size()
}
func (m *Function_Parameter) XXX_DiscardUnknown() {
	xxx_messageInfo_Function_Parameter.DiscardUnknown(m)
}

var xxx_messageInfo_Function_Parameter proto.InternalMessageInfo

type FunctionName struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Name       string                                                    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *FunctionName) Reset()         { *m = FunctionName{} }
func (m *FunctionName) String() string { return proto.CompactTextString(m) }
func (*FunctionName) ProtoMessage()    {}
func (*FunctionName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{88}
}
func (m *FunctionName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionName.Merge(m, src)
}
func (m *FunctionName) XXX_Size() int {
	return m.Size()
}
func (m *FunctionName) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionName.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionName proto.InternalMessageInfo

type FunctionVolatility struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Volatility catpb.FunctionVolatility                                  `protobuf:"bytes,2,opt,name=volatility,proto3" json:"volatility"`
}

func (m *FunctionVolatility) Reset()         { *m = FunctionVolatility{} }
func (m *FunctionVolatility) String() string { return proto.CompactTextString(m) }
func (*FunctionVolatility) ProtoMessage()    {}
func (*FunctionVolatility) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{89}
}
func (m *FunctionVolatility) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionVolatility) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionVolatility) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionVolatility.Merge(m, src)
}
func (m *FunctionVolatility) XXX_Size() int {
	return m.Size()
}
func (m *FunctionVolatility) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionVolatility.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionVolatility proto.InternalMessageInfo

type FunctionLeakProof struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	LeakProof  bool                                                      `protobuf:"varint,2,opt,name=leak_proof,json=leakProof,proto3" json:"leak_proof,omitempty"`
}

func (m *FunctionLeakProof) Reset()         { *m = FunctionLeakProof{} }
func (m *FunctionLeakProof) String() string { return proto.CompactTextString(m) }
func (*FunctionLeakProof) ProtoMessage()    {}
func (*FunctionLeakProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{90}
}
func (m *FunctionLeakProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionLeakProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionLeakProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionLeakProof.Merge(m, src)
}
func (m *FunctionLeakProof) XXX_Size() int {
	return m.Size()
}
func (m *FunctionLeakProof) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionLeakProof.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionLeakProof proto.InternalMessageInfo

type FunctionNullInputBehavior struct {
	FunctionID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	NullInputBehavior catpb.FunctionNullInputBehavior                           `protobuf:"bytes,11,opt,name=null_input_behavior,json=nullInputBehavior,proto3" json:"null_input_behavior"`
}

func (m *FunctionNullInputBehavior) Reset()         { *m = FunctionNullInputBehavior{} }
func (m *FunctionNullInputBehavior) String() string { return proto.CompactTextString(m) }
func (*FunctionNullInputBehavior) ProtoMessage()    {}
func (*FunctionNullInputBehavior) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{91}
}
func (m *FunctionNullInputBehavior) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionNullInputBehavior) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionNullInputBehavior) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionNullInputBehavior.Merge(m, src)
}
func (m *FunctionNullInputBehavior) XXX_Size() int {
	return m.Size()
}
func (m *FunctionNullInputBehavior) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionNullInputBehavior.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionNullInputBehavior proto.InternalMessageInfo

type FunctionBody struct {
	FunctionID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Body            string                                                      `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	Lang            catpb.FunctionLanguage                                      `protobuf:"bytes,3,opt,name=lang,proto3" json:"lang"`
	UsesTables      []FunctionBody_TableReference                               `protobuf:"bytes,4,rep,name=uses_tables,json=usesTables,proto3" json:"uses_tables"`
	UsesViews       []FunctionBody_ViewReference                                `protobuf:"bytes,5,rep,name=uses_views,json=usesViews,proto3" json:"uses_views"`
	UsesSequenceIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,6,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,7,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesFunctionIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,8,rep,packed,name=uses_function_ids,json=usesFunctionIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_function_ids,omitempty"`
}

func (m *FunctionBody) Reset()         { *m = FunctionBody{} }
func (m *FunctionBody) String() string { return proto.CompactTextString(m) }
func (*FunctionBody) ProtoMessage()    {}
func (*FunctionBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{92}
}
func (m *FunctionBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionBody.Merge(m, src)
}
func (m *FunctionBody) XXX_Size() int {
	return m.Size()
}
func (m *FunctionBody) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionBody.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionBody proto.InternalMessageInfo

type FunctionBody_TableReference struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	IndexID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
}

func (m *FunctionBody_TableReference) Reset()         { *m = FunctionBody_TableReference{} }
func (m *FunctionBody_TableReference) String() string { return proto.CompactTextString(m) }
func (*FunctionBody_TableReference) ProtoMessage()    {}
func (*FunctionBody_TableReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{92, 0}
}
func (m *FunctionBody_TableReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionBody_TableReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionBody_TableReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionBody_TableReference.Merge(m, src)
}
func (m *FunctionBody_TableReference) XXX_Size() int {
	return m.Size()
}
func (m *FunctionBody_TableReference) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionBody_TableReference.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionBody_TableReference proto.InternalMessageInfo

type FunctionBody_ViewReference struct {
	ViewID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=view_id,json=viewId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"view_id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
}

func (m *FunctionBody_ViewReference) Reset()         { *m = FunctionBody_ViewReference{} }
func (m *FunctionBody_ViewReference) String() string { return proto.CompactTextString(m) }
func (*FunctionBody_ViewReference) ProtoMessage()    {}
func (*FunctionBody_ViewReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{92, 1}
}
func (m *FunctionBody_ViewReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionBody_ViewReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionBody_ViewReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionBody_ViewReference.Merge(m, src)
}
func (m *FunctionBody_ViewReference) XXX_Size() int {
	return m.Size()
}
func (m *FunctionBody_ViewReference) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionBody_ViewReference.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionBody_ViewReference proto.InternalMessageInfo

type FunctionSecurity struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Security   catpb.FunctionSecurity                                    `protobuf:"bytes,2,opt,name=security,proto3" json:"security"`
}

func (m *FunctionSecurity) Reset()         { *m = FunctionSecurity{} }
func (m *FunctionSecurity) String() string { return proto.CompactTextString(m) }
func (*FunctionSecurity) ProtoMessage()    {}
func (*FunctionSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{93}
}
func (m *FunctionSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionSecurity.Merge(m, src)
}
func (m *FunctionSecurity) XXX_Size() int {
	return m.Size()
}
func (m *FunctionSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionSecurity proto.InternalMessageInfo

type ElementCreationMetadata struct {
	In_23_1OrLater bool `protobuf:"varint,1,opt,name=in_23_1_or_later,json=in231OrLater,proto3" json:"in_23_1_or_later,omitempty"`
	In_24_3OrLater bool `protobuf:"varint,2,opt,name=in_24_3_or_later,json=in243OrLater,proto3" json:"in_24_3_or_later,omitempty"`
}

func (m *ElementCreationMetadata) Reset()         { *m = ElementCreationMetadata{} }
func (m *ElementCreationMetadata) String() string { return proto.CompactTextString(m) }
func (*ElementCreationMetadata) ProtoMessage()    {}
func (*ElementCreationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{94}
}
func (m *ElementCreationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElementCreationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElementCreationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementCreationMetadata.Merge(m, src)
}
func (m *ElementCreationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ElementCreationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementCreationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ElementCreationMetadata proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.ColumnComputeExpression_Usage", ColumnComputeExpression_Usage_name, ColumnComputeExpression_Usage_value)
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.IndexColumn_Kind", IndexColumn_Kind_name, IndexColumn_Kind_value)
	proto.RegisterType((*ElementProto)(nil), "cockroach.sql.schemachanger.scpb.ElementProto")
	proto.RegisterType((*TypeT)(nil), "cockroach.sql.schemachanger.scpb.TypeT")
	proto.RegisterType((*Expression)(nil), "cockroach.sql.schemachanger.scpb.Expression")
	proto.RegisterType((*Column)(nil), "cockroach.sql.schemachanger.scpb.Column")
	proto.RegisterType((*ColumnType)(nil), "cockroach.sql.schemachanger.scpb.ColumnType")
	proto.RegisterType((*ColumnComputeExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnComputeExpression")
	proto.RegisterType((*ColumnFamily)(nil), "cockroach.sql.schemachanger.scpb.ColumnFamily")
	proto.RegisterType((*Index)(nil), "cockroach.sql.schemachanger.scpb.Index")
	proto.RegisterType((*PrimaryIndex)(nil), "cockroach.sql.schemachanger.scpb.PrimaryIndex")
	proto.RegisterType((*SecondaryIndex)(nil), "cockroach.sql.schemachanger.scpb.SecondaryIndex")
	proto.RegisterType((*TemporaryIndex)(nil), "cockroach.sql.schemachanger.scpb.TemporaryIndex")
	proto.RegisterType((*SchemaParent)(nil), "cockroach.sql.schemachanger.scpb.SchemaParent")
	proto.RegisterType((*SchemaChild)(nil), "cockroach.sql.schemachanger.scpb.SchemaChild")
	proto.RegisterType((*Policy)(nil), "cockroach.sql.schemachanger.scpb.Policy")
	proto.RegisterType((*PolicyName)(nil), "cockroach.sql.schemachanger.scpb.PolicyName")
	proto.RegisterType((*PolicyRole)(nil), "cockroach.sql.schemachanger.scpb.PolicyRole")
	proto.RegisterType((*PolicyUsingExpr)(nil), "cockroach.sql.schemachanger.scpb.PolicyUsingExpr")
	proto.RegisterType((*PolicyWithCheckExpr)(nil), "cockroach.sql.schemachanger.scpb.PolicyWithCheckExpr")
	proto.RegisterType((*PolicyDeps)(nil), "cockroach.sql.schemachanger.scpb.PolicyDeps")
	proto.RegisterType((*RowLevelSecurityEnabled)(nil), "cockroach.sql.schemachanger.scpb.RowLevelSecurityEnabled")
	proto.RegisterType((*RowLevelSecurityForced)(nil), "cockroach.sql.schemachanger.scpb.RowLevelSecurityForced")
	proto.RegisterType((*Sequence)(nil), "cockroach.sql.schemachanger.scpb.Sequence")
	proto.RegisterType((*SequenceOption)(nil), "cockroach.sql.schemachanger.scpb.SequenceOption")
	proto.RegisterType((*SequenceOwner)(nil), "cockroach.sql.schemachanger.scpb.SequenceOwner")
	proto.RegisterType((*ColumnDefaultExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnDefaultExpression")
	proto.RegisterType((*ColumnOnUpdateExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnOnUpdateExpression")
	proto.RegisterType((*View)(nil), "cockroach.sql.schemachanger.scpb.View")
	proto.RegisterType((*View_Reference)(nil), "cockroach.sql.schemachanger.scpb.View.Reference")
	proto.RegisterType((*Table)(nil), "cockroach.sql.schemachanger.scpb.Table")
	proto.RegisterType((*UniqueWithoutIndexConstraint)(nil), "cockroach.sql.schemachanger.scpb.UniqueWithoutIndexConstraint")
	proto.RegisterType((*UniqueWithoutIndexConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.scpb.UniqueWithoutIndexConstraintUnvalidated")
	proto.RegisterType((*CheckConstraint)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraint")
	proto.RegisterType((*CheckConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraintUnvalidated")
	proto.RegisterType((*ForeignKeyConstraint)(nil), "cockroach.sql.schemachanger.scpb.ForeignKeyConstraint")
	proto.RegisterType((*ForeignKeyConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.scpb.ForeignKeyConstraintUnvalidated")
	proto.RegisterType((*Trigger)(nil), "cockroach.sql.schemachanger.scpb.Trigger")
	proto.RegisterType((*TriggerName)(nil), "cockroach.sql.schemachanger.scpb.TriggerName")
	proto.RegisterType((*TriggerEnabled)(nil), "cockroach.sql.schemachanger.scpb.TriggerEnabled")
	proto.RegisterType((*TriggerTiming)(nil), "cockroach.sql.schemachanger.scpb.TriggerTiming")
	proto.RegisterType((*TriggerEvent)(nil), "cockroach.sql.schemachanger.scpb.TriggerEvent")
	proto.RegisterType((*TriggerEvents)(nil), "cockroach.sql.schemachanger.scpb.TriggerEvents")
	proto.RegisterType((*TriggerTransition)(nil), "cockroach.sql.schemachanger.scpb.TriggerTransition")
	proto.RegisterType((*TriggerWhen)(nil), "cockroach.sql.schemachanger.scpb.TriggerWhen")
	proto.RegisterType((*TriggerFunctionCall)(nil), "cockroach.sql.schemachanger.scpb.TriggerFunctionCall")
	proto.RegisterType((*TriggerDeps)(nil), "cockroach.sql.schemachanger.scpb.TriggerDeps")
	proto.RegisterType((*TriggerDeps_RelationReference)(nil), "cockroach.sql.schemachanger.scpb.TriggerDeps.RelationReference")
	proto.RegisterType((*EnumType)(nil), "cockroach.sql.schemachanger.scpb.EnumType")
	proto.RegisterType((*AliasType)(nil), "cockroach.sql.schemachanger.scpb.AliasType")
	proto.RegisterType((*CompositeType)(nil), "cockroach.sql.schemachanger.scpb.CompositeType")
	proto.RegisterType((*Schema)(nil), "cockroach.sql.schemachanger.scpb.Schema")
	proto.RegisterType((*Database)(nil), "cockroach.sql.schemachanger.scpb.Database")
	proto.RegisterType((*Namespace)(nil), "cockroach.sql.schemachanger.scpb.Namespace")
	proto.RegisterType((*Owner)(nil), "cockroach.sql.schemachanger.scpb.Owner")
	proto.RegisterType((*UserPrivileges)(nil), "cockroach.sql.schemachanger.scpb.UserPrivileges")
	proto.RegisterType((*NamedRangeZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.NamedRangeZoneConfig")
	proto.RegisterType((*TableLocalityGlobal)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityGlobal")
	proto.RegisterType((*TableLocalityPrimaryRegion)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityPrimaryRegion")
	proto.RegisterType((*TableLocalitySecondaryRegion)(nil), "cockroach.sql.schemachanger.scpb.TableLocalitySecondaryRegion")
	proto.RegisterType((*TableLocalityRegionalByRow)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityRegionalByRow")
	proto.RegisterType((*TableLocalityRegionalByRowUsingConstraint)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityRegionalByRowUsingConstraint")
	proto.RegisterType((*IndexPartitioning)(nil), "cockroach.sql.schemachanger.scpb.IndexPartitioning")
	proto.RegisterType((*RowLevelTTL)(nil), "cockroach.sql.schemachanger.scpb.RowLevelTTL")
	proto.RegisterType((*ColumnName)(nil), "cockroach.sql.schemachanger.scpb.ColumnName")
	proto.RegisterType((*IndexName)(nil), "cockroach.sql.schemachanger.scpb.IndexName")
	proto.RegisterType((*ConstraintWithoutIndexName)(nil), "cockroach.sql.schemachanger.scpb.ConstraintWithoutIndexName")
	proto.RegisterType((*TableComment)(nil), "cockroach.sql.schemachanger.scpb.TableComment")
	proto.RegisterType((*TypeComment)(nil), "cockroach.sql.schemachanger.scpb.TypeComment")
	proto.RegisterType((*DatabaseComment)(nil), "cockroach.sql.schemachanger.scpb.DatabaseComment")
	proto.RegisterType((*SchemaComment)(nil), "cockroach.sql.schemachanger.scpb.SchemaComment")
	proto.RegisterType((*IndexComment)(nil), "cockroach.sql.schemachanger.scpb.IndexComment")
	proto.RegisterType((*ColumnComment)(nil), "cockroach.sql.schemachanger.scpb.ColumnComment")
	proto.RegisterType((*ColumnNotNull)(nil), "cockroach.sql.schemachanger.scpb.ColumnNotNull")
	proto.RegisterType((*ConstraintComment)(nil), "cockroach.sql.schemachanger.scpb.ConstraintComment")
	proto.RegisterType((*DatabaseRegionConfig)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRegionConfig")
	proto.RegisterType((*DatabaseRoleSetting)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRoleSetting")
	proto.RegisterType((*IndexColumn)(nil), "cockroach.sql.schemachanger.scpb.IndexColumn")
	proto.RegisterType((*EnumTypeValue)(nil), "cockroach.sql.schemachanger.scpb.EnumTypeValue")
	proto.RegisterType((*CompositeTypeAttrName)(nil), "cockroach.sql.schemachanger.scpb.CompositeTypeAttrName")
	proto.RegisterType((*CompositeTypeAttrType)(nil), "cockroach.sql.schemachanger.scpb.CompositeTypeAttrType")
	proto.RegisterType((*DatabaseZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.DatabaseZoneConfig")
	proto.RegisterType((*TableZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.TableZoneConfig")
	proto.RegisterType((*IndexZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.IndexZoneConfig")
	proto.RegisterType((*PartitionZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.PartitionZoneConfig")
	proto.RegisterType((*DatabaseData)(nil), "cockroach.sql.schemachanger.scpb.DatabaseData")
	proto.RegisterType((*TableData)(nil), "cockroach.sql.schemachanger.scpb.TableData")
	proto.RegisterType((*IndexData)(nil), "cockroach.sql.schemachanger.scpb.IndexData")
	proto.RegisterType((*TablePartitioning)(nil), "cockroach.sql.schemachanger.scpb.TablePartitioning")
	proto.RegisterType((*TableSchemaLocked)(nil), "cockroach.sql.schemachanger.scpb.TableSchemaLocked")
	proto.RegisterType((*LDRJobIDs)(nil), "cockroach.sql.schemachanger.scpb.LDRJobIDs")
	proto.RegisterType((*Function)(nil), "cockroach.sql.schemachanger.scpb.Function")
	proto.RegisterType((*Function_Parameter)(nil), "cockroach.sql.schemachanger.scpb.Function.Parameter")
	proto.RegisterType((*FunctionName)(nil), "cockroach.sql.schemachanger.scpb.FunctionName")
	proto.RegisterType((*FunctionVolatility)(nil), "cockroach.sql.schemachanger.scpb.FunctionVolatility")
	proto.RegisterType((*FunctionLeakProof)(nil), "cockroach.sql.schemachanger.scpb.FunctionLeakProof")
	proto.RegisterType((*FunctionNullInputBehavior)(nil), "cockroach.sql.schemachanger.scpb.FunctionNullInputBehavior")
	proto.RegisterType((*FunctionBody)(nil), "cockroach.sql.schemachanger.scpb.FunctionBody")
	proto.RegisterType((*FunctionBody_TableReference)(nil), "cockroach.sql.schemachanger.scpb.FunctionBody.TableReference")
	proto.RegisterType((*FunctionBody_ViewReference)(nil), "cockroach.sql.schemachanger.scpb.FunctionBody.ViewReference")
	proto.RegisterType((*FunctionSecurity)(nil), "cockroach.sql.schemachanger.scpb.FunctionSecurity")
	proto.RegisterType((*ElementCreationMetadata)(nil), "cockroach.sql.schemachanger.scpb.ElementCreationMetadata")
}

func init() {
	proto.RegisterFile("sql/schemachanger/scpb/elements.proto", fileDescriptor_49b58fafa7b67c5d)
}

var fileDescriptor_49b58fafa7b67c5d = []byte{
	// 7390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5b, 0x70, 0x1c, 0xc7,
	0x75, 0x28, 0x67, 0xb1, 0x00, 0x76, 0xcf, 0xee, 0xe2, 0xd1, 0xe0, 0x63, 0x08, 0x52, 0x58, 0x68,
	0x64, 0x49, 0x94, 0x44, 0x03, 0x36, 0x29, 0x5b, 0xd7, 0xb2, 0x64, 0x5d, 0x82, 0x00, 0x49, 0x90,
	0x10, 0x09, 0x0f, 0x40, 0xca, 0x92, 0x6f, 0xd5, 0x78, 0x30, 0xd3, 0x58, 0x8c, 0x38, 0x3b, 0xb3,
	0x9a, 0x99, 0x05, 0x08, 0x5d, 0x5d, 0xcb, 0x6f, 0x5f, 0xcb, 0xd2, 0xb5, 0x5d, 0xf7, 0x5e, 0xdf,
	0xba, 0xc9, 0x8f, 0xf2, 0xb0, 0x2b, 0x71, 0x52, 0xc9, 0x47, 0xfc, 0x97, 0xc4, 0x15, 0x7f, 0xd8,
	0x45, 0x3b, 0x4e, 0xac, 0xc4, 0x51, 0xe2, 0xb8, 0x5c, 0x5b, 0x11, 0xf4, 0xe3, 0xa4, 0xca, 0xb1,
	0x0d, 0xbb, 0xca, 0xb1, 0x2a, 0xa9, 0x4a, 0x75, 0xf7, 0xf4, 0x3c, 0xf6, 0x01, 0xcc, 0x02, 0xe0,
	0xb0, 0x8c, 0xe2, 0x87, 0x44, 0x6c, 0xcf, 0x79, 0x75, 0xf7, 0xe9, 0xee, 0xd3, 0xe7, 0x74, 0x9f,
	0x86, 0x7b, 0xdd, 0xe7, 0xcc, 0x49, 0x57, 0x5b, 0xc1, 0x55, 0x55, 0x5b, 0x51, 0xad, 0x0a, 0x76,
	0x26, 0x5d, 0xad, 0xb6, 0x34, 0x89, 0x4d, 0x5c, 0xc5, 0x96, 0xe7, 0x4e, 0xd4, 0x1c, 0xdb, 0xb3,
	0xd1, 0xb8, 0x66, 0x6b, 0xd7, 0x1d, 0x5b, 0xd5, 0x56, 0x26, 0xdc, 0xe7, 0xcc, 0x89, 0x18, 0xc2,
	0x04, 0x41, 0x18, 0xbd, 0x9b, 0x10, 0xd2, 0x54, 0x4f, 0x35, 0xed, 0x0a, 0xf9, 0x17, 0x5b, 0xf5,
	0x6a, 0x6d, 0x69, 0xd2, 0xb0, 0x74, 0x7c, 0x83, 0x11, 0x19, 0x2d, 0x37, 0x81, 0xd4, 0x96, 0xf8,
	0x2f, 0x1f, 0xe0, 0x2e, 0x2a, 0x0c, 0xae, 0x4e, 0x1a, 0xfa, 0x0d, 0x6f, 0xbd, 0x86, 0xf9, 0xbf,
	0xfe, 0x67, 0x89, 0x7f, 0x76, 0x89, 0x6c, 0x94, 0xbc, 0x66, 0x5b, 0xae, 0xe7, 0xa8, 0x86, 0xe5,
	0x45, 0x79, 0xc4, 0x61, 0x3c, 0xc7, 0xa8, 0x10, 0x31, 0x19, 0xc0, 0x78, 0xab, 0x10, 0xcb, 0x75,
	0x4b, 0xf3, 0x0c, 0xdb, 0xf2, 0x21, 0x0e, 0x11, 0x08, 0xc2, 0xd6, 0x65, 0xff, 0xf7, 0x8b, 0x8f,
	0x93, 0xe2, 0x55, 0xac, 0xd1, 0x1a, 0x91, 0x3f, 0x6a, 0x4b, 0xe4, 0xff, 0xfe, 0xd7, 0x83, 0x15,
	0xbb, 0x62, 0xd3, 0x3f, 0x27, 0xc9, 0x5f, 0x7e, 0xe9, 0xe1, 0x0a, 0xb6, 0x27, 0x2b, 0xd8, 0x66,
	0x92, 0x2e, 0x1b, 0xbc, 0xa2, 0x22, 0xfb, 0x35, 0xf9, 0xbc, 0x6d, 0xe1, 0xda, 0x12, 0xfd, 0x87,
	0x7d, 0x91, 0xfe, 0xf7, 0x53, 0x50, 0x9c, 0x61, 0x6d, 0x3f, 0x4f, 0x5b, 0xfe, 0x02, 0xe4, 0x74,
	0xd5, 0x53, 0x97, 0x54, 0x17, 0x8b, 0xc2, 0xb8, 0x70, 0xa2, 0x70, 0xea, 0xc1, 0x89, 0xed, 0x3a,
	0x63, 0x62, 0xda, 0xc7, 0xb8, 0x70, 0x40, 0x0e, 0xb0, 0xd1, 0x14, 0xf4, 0x31, 0x50, 0x31, 0x43,
	0xe9, 0x9c, 0xd8, 0x9e, 0xce, 0x02, 0x2d, 0xba, 0x70, 0x40, 0xf6, 0x31, 0xd1, 0x63, 0x90, 0x5d,
	0x35, 0xf0, 0x9a, 0xd8, 0x43, 0x29, 0xdc, 0xb7, 0x3d, 0x85, 0x6b, 0x06, 0x5e, 0xbb, 0x70, 0x40,
	0xa6, 0x58, 0xa4, 0x2e, 0x2e, 0x7e, 0xae, 0x8e, 0x2d, 0x0d, 0x8b, 0xd9, 0xa4, 0x75, 0x59, 0xf0,
	0x31, 0x48, 0x5d, 0x38, 0x36, 0x7a, 0x02, 0x7a, 0x3d, 0x75, 0xc9, 0xc4, 0x62, 0x2f, 0x25, 0x73,
	0xff, 0xf6, 0x64, 0x16, 0x09, 0xf8, 0x85, 0x03, 0x32, 0xc3, 0x43, 0xb3, 0x90, 0x27, 0xea, 0xa1,
	0x90, 0x1e, 0x16, 0xfb, 0x92, 0xca, 0x32, 0x63, 0xd5, 0xab, 0x8b, 0xeb, 0x35, 0x2a, 0x0b, 0xf6,
	0xff, 0x46, 0x73, 0x00, 0xaa, 0x69, 0xa8, 0x2e, 0xa3, 0xd5, 0x4f, 0x69, 0x3d, 0xb4, 0x3d, 0xad,
	0x33, 0x04, 0xc7, 0x27, 0x96, 0x57, 0xf9, 0x0f, 0xf4, 0x01, 0x18, 0xd0, 0xec, 0x6a, 0xcd, 0x76,
	0x0d, 0x0f, 0x33, 0x8a, 0x39, 0x4a, 0x71, 0x72, 0x7b, 0x8a, 0x67, 0x39, 0x9e, 0x4f, 0xb5, 0xa4,
	0x45, 0x0b, 0x48, 0xeb, 0x73, 0x4d, 0x17, 0xf3, 0x49, 0x6b, 0x7c, 0xce, 0xc7, 0x20, 0x35, 0xe6,
	0xd8, 0xa8, 0x06, 0x47, 0x2c, 0xb5, 0x8a, 0x75, 0xc5, 0x21, 0x90, 0x0a, 0x51, 0x5f, 0x85, 0x69,
	0xb4, 0xf8, 0x43, 0xa6, 0xa3, 0xef, 0xde, 0x9e, 0xf2, 0x65, 0x42, 0x41, 0x26, 0x05, 0xcf, 0xd8,
	0x16, 0x3e, 0x4b, 0xd1, 0x2f, 0x1c, 0x90, 0x0f, 0x5a, 0x6d, 0xca, 0x91, 0x01, 0x25, 0xcd, 0x36,
	0xeb, 0x55, 0x4b, 0x59, 0x56, 0xab, 0x86, 0xb9, 0x2e, 0x1e, 0xa4, 0x6c, 0x26, 0x92, 0x34, 0x0a,
	0x41, 0x3b, 0x47, 0xb1, 0xa6, 0xd0, 0x66, 0xa3, 0x3c, 0x50, 0x53, 0x1d, 0x6c, 0x79, 0x8f, 0x4a,
	0x54, 0x23, 0xa4, 0x0b, 0x07, 0xe4, 0xa2, 0x16, 0x81, 0x41, 0xff, 0x0d, 0xfa, 0xd8, 0x6f, 0xf1,
	0x50, 0xd2, 0x61, 0xc2, 0x78, 0x4c, 0x89, 0x9b, 0x8d, 0xf2, 0xc1, 0x18, 0xf5, 0x93, 0xe3, 0x44,
	0xff, 0x09, 0x0f, 0x9f, 0x26, 0xb2, 0xa1, 0x54, 0x73, 0x8c, 0xaa, 0xea, 0xac, 0x2b, 0x74, 0x22,
	0x11, 0x0f, 0x27, 0xad, 0xc8, 0x3c, 0x43, 0x9b, 0x25, 0x58, 0x5b, 0xb2, 0x2a, 0xd6, 0x22, 0x90,
	0xa8, 0x0e, 0x83, 0x2e, 0xd6, 0x6c, 0x4b, 0x0f, 0x59, 0x1e, 0xa1, 0x2c, 0xdf, 0x91, 0x64, 0xe8,
	0xf9, 0x88, 0xdb, 0x33, 0x1d, 0x70, 0x63, 0xb0, 0x84, 0xad, 0x87, 0xab, 0x35, 0xdb, 0x09, 0xd9,
	0x8a, 0x49, 0xd9, 0x2e, 0x72, 0xc4, 0x04, 0x6c, 0xbd, 0x18, 0x2c, 0xfa, 0x4d, 0x01, 0xca, 0x75,
	0xcb, 0x78, 0xae, 0x8e, 0x95, 0x35, 0xc3, 0x5b, 0xb1, 0xeb, 0x1e, 0x63, 0xae, 0x84, 0x0b, 0x85,
	0x78, 0x94, 0xca, 0xf1, 0xbe, 0xed, 0xe5, 0xb8, 0x4a, 0x09, 0x3d, 0xc5, 0xe8, 0x50, 0xfa, 0x67,
	0x03, 0x2a, 0x1d, 0x54, 0xe9, 0x78, 0x7d, 0x0b, 0x1c, 0xf4, 0x35, 0x01, 0x1e, 0xda, 0x46, 0x3a,
	0xa5, 0x6e, 0xad, 0xaa, 0xa6, 0xa1, 0xab, 0x1e, 0xd6, 0xc5, 0x3f, 0x60, 0x83, 0x69, 0x76, 0x77,
	0xa2, 0x5e, 0x0d, 0x29, 0x76, 0x90, 0xfa, 0xfe, 0x7a, 0x32, 0x74, 0xe4, 0xc0, 0x90, 0xb6, 0x82,
	0xb5, 0xeb, 0xd1, 0xe6, 0x1c, 0xa5, 0x32, 0xbe, 0x33, 0xc1, 0x28, 0x21, 0x98, 0xdb, 0xb6, 0xe0,
	0xa0, 0x16, 0x07, 0x43, 0xff, 0x57, 0x80, 0xe3, 0xcd, 0x4c, 0x63, 0xad, 0xf4, 0x15, 0xd6, 0x4a,
	0x8f, 0x75, 0x2d, 0xc1, 0xf6, 0x0d, 0x33, 0xaa, 0x75, 0xc4, 0x40, 0x1f, 0x13, 0xe0, 0xf0, 0xb2,
	0xed, 0x60, 0xa3, 0x62, 0x29, 0xd7, 0xf1, 0x7a, 0xb4, 0x49, 0x8e, 0x25, 0x9d, 0x03, 0xcf, 0x31,
	0xfc, 0x4b, 0x78, 0x7d, 0xdb, 0x76, 0x39, 0xb8, 0xdc, 0x06, 0x16, 0x7d, 0x49, 0x00, 0xa9, 0xbd,
	0x10, 0xb1, 0x26, 0xfa, 0x43, 0xd6, 0x44, 0x67, 0x76, 0x26, 0xd1, 0xf6, 0xed, 0x54, 0x5e, 0xde,
	0x1a, 0x0d, 0xad, 0x43, 0x89, 0xae, 0xbb, 0x8a, 0x66, 0x57, 0x89, 0x6d, 0x23, 0x1e, 0x4f, 0x3a,
	0xed, 0x51, 0x1e, 0x67, 0x19, 0xd6, 0x94, 0xb4, 0xd9, 0x28, 0x8f, 0xb5, 0x99, 0x0a, 0x4e, 0x8e,
	0x73, 0x2b, 0x81, 0x4e, 0x80, 0x5e, 0x04, 0x07, 0xad, 0x42, 0xc9, 0xb1, 0xd7, 0x14, 0x13, 0xaf,
	0x62, 0x53, 0xf1, 0x3c, 0x53, 0xbc, 0x8b, 0xb2, 0x7e, 0xfb, 0xf6, 0xac, 0x65, 0x7b, 0x6d, 0x8e,
	0x60, 0x2d, 0x2e, 0xce, 0x4d, 0xdd, 0xbd, 0xd1, 0x28, 0x17, 0x22, 0x05, 0x6d, 0x9b, 0xa1, 0xe0,
	0x70, 0x00, 0xcf, 0x44, 0xeb, 0x30, 0xcc, 0xaa, 0x1c, 0x5d, 0x1e, 0xd7, 0x93, 0x0e, 0x16, 0x4a,
	0x33, 0x5c, 0x00, 0xb7, 0x9c, 0x04, 0x07, 0xbd, 0x38, 0x30, 0x72, 0x61, 0x98, 0xcd, 0x2b, 0x51,
	0xd6, 0xcf, 0x27, 0x65, 0x4d, 0xc7, 0x7f, 0x84, 0x75, 0xac, 0xcb, 0xe9, 0x47, 0xca, 0xd4, 0x88,
	0x83, 0xa1, 0x0f, 0x03, 0xb0, 0xfa, 0x12, 0x83, 0x53, 0xfc, 0xb8, 0x90, 0xd4, 0x0e, 0xa2, 0x95,
	0x21, 0x06, 0xeb, 0xd4, 0xe4, 0x46, 0xa3, 0x9c, 0x0f, 0x7e, 0x26, 0xea, 0xea, 0xbc, 0xc7, 0xc1,
	0xd1, 0xff, 0x12, 0x00, 0x31, 0x01, 0x6a, 0xaa, 0xe3, 0x19, 0xc4, 0x50, 0x31, 0xac, 0x8a, 0xf8,
	0x09, 0x26, 0xc8, 0xe9, 0x84, 0x82, 0xcc, 0x47, 0x70, 0xa7, 0xee, 0xdf, 0x68, 0x94, 0x87, 0x5b,
	0x8a, 0xdb, 0x76, 0x3d, 0xeb, 0xeb, 0x28, 0x18, 0xfa, 0x9c, 0x00, 0x23, 0x4c, 0x20, 0xc6, 0x4c,
	0x31, 0x6d, 0xed, 0x3a, 0xd6, 0xc5, 0x4f, 0x76, 0x27, 0x11, 0xb3, 0xc1, 0xe7, 0x28, 0x6e, 0x44,
	0xa2, 0x68, 0xf1, 0x16, 0x12, 0x45, 0xc1, 0x90, 0x0d, 0x05, 0x53, 0x77, 0x94, 0x67, 0xed, 0x25,
	0xc5, 0xd0, 0x5d, 0xf1, 0x53, 0x89, 0xfb, 0x68, 0x6e, 0x5a, 0xbe, 0x68, 0x2f, 0xcd, 0x4e, 0xbb,
	0x53, 0x65, 0xd2, 0x47, 0xc1, 0xcf, 0xb6, 0x8c, 0xf3, 0xa6, 0xee, 0x90, 0xcf, 0xba, 0x8b, 0x5e,
	0x16, 0xe0, 0x50, 0xd0, 0x1b, 0x31, 0x6d, 0xfc, 0x34, 0xe3, 0xfd, 0xae, 0x04, 0x76, 0x0f, 0xc7,
	0x8f, 0xa8, 0xe4, 0xd8, 0x66, 0xa3, 0x3c, 0x1a, 0x63, 0x1c, 0x6d, 0x79, 0x22, 0xc4, 0x48, 0xad,
	0x15, 0x0d, 0x7d, 0x08, 0xfa, 0xfd, 0xcd, 0xa0, 0xf8, 0x3f, 0x19, 0xff, 0x07, 0x12, 0x74, 0x02,
	0xc3, 0xd8, 0x72, 0x04, 0x72, 0xb2, 0xe8, 0x29, 0xe8, 0xab, 0xd9, 0xa6, 0xa1, 0xad, 0x8b, 0x9f,
	0x11, 0x92, 0x5a, 0x8f, 0xf3, 0x14, 0xa1, 0xc3, 0xcc, 0xea, 0x93, 0x43, 0xaf, 0x08, 0x30, 0x1a,
	0x4e, 0x63, 0x2e, 0xd6, 0xea, 0x8e, 0xe1, 0xad, 0x2b, 0xd8, 0x22, 0x80, 0xba, 0xf8, 0x12, 0xe3,
	0xf6, 0x9e, 0xe4, 0x93, 0xda, 0x82, 0x4f, 0x62, 0x86, 0x51, 0xe8, 0xc0, 0xfe, 0x88, 0xd3, 0x1e,
	0x1c, 0xbd, 0x24, 0xc0, 0xd1, 0x36, 0xf2, 0x2c, 0xdb, 0x8e, 0x86, 0x75, 0xf1, 0xb3, 0x4c, 0x9c,
	0xff, 0xd2, 0xbd, 0x38, 0xe7, 0x28, 0x81, 0x0e, 0xd2, 0x1c, 0x76, 0xda, 0x42, 0xa3, 0x17, 0xe1,
	0x10, 0x1b, 0x68, 0xa6, 0xad, 0xa9, 0x26, 0x91, 0xa3, 0x62, 0xda, 0x4b, 0xaa, 0x29, 0x5a, 0x49,
	0x95, 0x8c, 0xb2, 0x98, 0xf3, 0xb1, 0xcf, 0x53, 0xe4, 0x0e, 0x32, 0xb0, 0x21, 0x1d, 0x07, 0x25,
	0x36, 0xca, 0x5d, 0x4d, 0x12, 0x70, 0x2b, 0xdf, 0xc1, 0x15, 0xb2, 0xe1, 0xb2, 0x93, 0xda, 0x28,
	0x31, 0x49, 0x7c, 0x9b, 0x5f, 0xa6, 0x34, 0x3a, 0xd9, 0x28, 0x5e, 0x47, 0x0c, 0x6a, 0x0e, 0x37,
	0xc9, 0x15, 0x6e, 0x06, 0x7c, 0xc9, 0x6a, 0x49, 0xcd, 0xe1, 0x98, 0x64, 0xc1, 0xd6, 0x60, 0x4b,
	0xd9, 0x8e, 0x7b, 0x5b, 0xe0, 0xa0, 0x2f, 0x0a, 0x30, 0xd6, 0x24, 0x1d, 0x93, 0x49, 0x35, 0x95,
	0xa5, 0x75, 0xc5, 0xb1, 0xd7, 0xc4, 0xe7, 0x76, 0xd4, 0x6c, 0xb2, 0x4f, 0x65, 0x6a, 0x5d, 0xb6,
	0xd7, 0x12, 0x35, 0x5b, 0x0c, 0x03, 0x7d, 0x43, 0x80, 0xc9, 0xad, 0x05, 0x53, 0xea, 0xae, 0x61,
	0x55, 0xa2, 0x36, 0x9f, 0x43, 0x25, 0xbd, 0xb4, 0x1b, 0x49, 0xaf, 0x12, 0x9a, 0xdb, 0x1a, 0x82,
	0x0f, 0x78, 0x49, 0x09, 0x20, 0x1d, 0x0a, 0xfe, 0xae, 0x99, 0x6c, 0xaa, 0xc5, 0x31, 0x2a, 0xe2,
	0xc9, 0xa4, 0xfb, 0x59, 0xb2, 0x41, 0x9f, 0x1a, 0xd9, 0x6c, 0x94, 0x07, 0xb9, 0x0c, 0xac, 0x9c,
	0x08, 0x01, 0x5a, 0x00, 0x12, 0xe1, 0x42, 0xdd, 0x15, 0xe5, 0xee, 0xb8, 0x2c, 0xae, 0xd7, 0xb6,
	0xe3, 0x42, 0xbd, 0x17, 0x2f, 0x0b, 0x70, 0xd4, 0x67, 0xa3, 0xe3, 0x65, 0xb5, 0x6e, 0x7a, 0x0a,
	0xbe, 0x51, 0x73, 0xb0, 0xeb, 0x12, 0x25, 0x1e, 0x4f, 0x3a, 0xfd, 0x31, 0xe2, 0xd3, 0x8c, 0xc2,
	0x4c, 0x40, 0xa0, 0x93, 0x04, 0x47, 0xb4, 0xf6, 0xf0, 0xe8, 0xf3, 0x02, 0x1c, 0xf3, 0xc5, 0xb1,
	0x2d, 0xa5, 0x5e, 0x23, 0x66, 0x6e, 0x54, 0xa0, 0xbb, 0xa9, 0x40, 0x8f, 0x26, 0x15, 0xe8, 0x8a,
	0x75, 0x95, 0x92, 0xd8, 0x5e, 0x22, 0x51, 0xeb, 0x80, 0x80, 0xaa, 0x30, 0xc0, 0xfd, 0x63, 0x8a,
	0xbd, 0x66, 0x61, 0x47, 0x94, 0x92, 0x7a, 0x8e, 0xb8, 0x49, 0x75, 0x85, 0xa0, 0x75, 0xe2, 0x5c,
	0x72, 0xa3, 0x50, 0x84, 0x9d, 0xdf, 0x00, 0xdc, 0xa6, 0xbf, 0x27, 0xb9, 0xa3, 0x8a, 0xe0, 0x71,
	0xa3, 0xbe, 0x13, 0x3b, 0x2d, 0x0a, 0x85, 0x2c, 0x18, 0xe4, 0xba, 0x6c, 0x7b, 0x8a, 0x55, 0x37,
	0x4d, 0xf1, 0x6d, 0xdd, 0xf1, 0xbb, 0x6c, 0x7b, 0x97, 0xeb, 0xa6, 0xb9, 0x0d, 0x3f, 0x1f, 0x8a,
	0x2c, 0xb8, 0x47, 0xc3, 0xfa, 0xd5, 0xea, 0xf1, 0xee, 0xfd, 0x9a, 0xd0, 0x9d, 0xc2, 0x9d, 0x65,
	0x24, 0x12, 0x2b, 0x5c, 0x0b, 0x3c, 0x72, 0x60, 0x30, 0xec, 0xdd, 0x1a, 0x75, 0xe2, 0xdd, 0x9b,
	0xdc, 0x8f, 0xe3, 0x77, 0x1c, 0xc5, 0x9b, 0x3a, 0xb4, 0xd9, 0x28, 0x0f, 0x73, 0xd6, 0x51, 0x6b,
	0x3a, 0xd0, 0x1f, 0x06, 0x88, 0xd6, 0x00, 0xd8, 0x3e, 0x82, 0x4e, 0x1f, 0x27, 0x92, 0x5a, 0x8b,
	0x74, 0x8f, 0x40, 0x67, 0x8f, 0x07, 0x36, 0x1b, 0xe5, 0x7b, 0x39, 0xa7, 0xa8, 0x03, 0x8b, 0x58,
	0xf1, 0x51, 0x7f, 0x11, 0xb5, 0x1b, 0x0d, 0x8e, 0x47, 0x4c, 0x67, 0xc4, 0x38, 0xc7, 0x6c, 0xf9,
	0x07, 0x92, 0x1a, 0xce, 0x94, 0x66, 0xcc, 0x94, 0xef, 0x4a, 0x12, 0xb6, 0x7b, 0x8a, 0x19, 0xf3,
	0x1f, 0x11, 0xa0, 0xc4, 0x7d, 0x35, 0x4c, 0xdb, 0x1f, 0x4a, 0xba, 0x83, 0xf5, 0xfd, 0x29, 0x4c,
	0xd9, 0xbb, 0x92, 0xa3, 0x68, 0x44, 0x50, 0x89, 0x91, 0x51, 0xe4, 0x22, 0x50, 0xff, 0xe4, 0xc9,
	0xa4, 0x1b, 0x59, 0x5f, 0x02, 0xea, 0xa4, 0x3c, 0xb3, 0xd9, 0x28, 0x3f, 0x9e, 0x44, 0x80, 0x93,
	0xe3, 0x71, 0x3f, 0xdc, 0xc9, 0xf1, 0x50, 0x4b, 0x0b, 0x46, 0x48, 0x11, 0xfd, 0x1f, 0x81, 0xab,
	0x09, 0xdd, 0xf9, 0xbd, 0xbd, 0x2b, 0x35, 0xa1, 0x1b, 0xbf, 0x73, 0x64, 0x53, 0x11, 0xfc, 0xdc,
	0x6c, 0x94, 0xdf, 0xb5, 0x13, 0x01, 0x43, 0x1d, 0xa2, 0xfb, 0xc1, 0xef, 0x09, 0x70, 0x57, 0xc4,
	0x1d, 0x12, 0x77, 0xb8, 0x51, 0x85, 0x3e, 0x9d, 0xd8, 0x6f, 0x14, 0x90, 0x89, 0xba, 0xc8, 0xa8,
	0x86, 0xcf, 0x6f, 0x36, 0xca, 0x73, 0x5c, 0xda, 0xad, 0xbc, 0x70, 0x27, 0xc7, 0x9b, 0xbc, 0x4f,
	0x27, 0xc7, 0xdb, 0xf9, 0x5a, 0x98, 0xd7, 0xa9, 0x23, 0x3f, 0xf4, 0x77, 0x02, 0xa0, 0x48, 0xad,
	0xb8, 0x32, 0x3e, 0x9c, 0x74, 0x64, 0x84, 0x9c, 0xb8, 0x46, 0x5a, 0x9b, 0x8d, 0xf2, 0xb3, 0xc9,
	0xda, 0x7b, 0x8f, 0xea, 0x37, 0xac, 0x35, 0x0b, 0x41, 0x4c, 0xc1, 0x3c, 0xe9, 0x13, 0xb7, 0xa6,
	0x6a, 0x58, 0x7c, 0x2c, 0xa9, 0x0a, 0x5d, 0xe6, 0x28, 0x53, 0xb3, 0x9b, 0x8d, 0xf2, 0xcc, 0x96,
	0xee, 0x82, 0x93, 0xe3, 0x3c, 0x2a, 0x76, 0x72, 0x9c, 0xed, 0x8a, 0x4f, 0x8e, 0x07, 0x31, 0x98,
	0x93, 0xe3, 0x3c, 0xb4, 0x43, 0xb5, 0x28, 0x10, 0x85, 0xec, 0x73, 0x7a, 0xd9, 0x62, 0xfa, 0x78,
	0xd2, 0x48, 0x13, 0x5b, 0x44, 0xf7, 0x54, 0x20, 0x26, 0x02, 0xfa, 0xb2, 0x00, 0x83, 0x75, 0x17,
	0x3b, 0x64, 0x73, 0xb1, 0x6a, 0x98, 0xb8, 0x82, 0x5d, 0xf1, 0x7d, 0x49, 0x17, 0x81, 0xab, 0x2e,
	0x76, 0xe6, 0x03, 0xbc, 0xbd, 0x95, 0x6f, 0xa0, 0x1e, 0x23, 0x8e, 0x3e, 0x29, 0xc0, 0x61, 0x1e,
	0x77, 0xf4, 0x4d, 0x67, 0xbe, 0xf1, 0x9f, 0x4f, 0xea, 0x1b, 0xe5, 0xcc, 0x99, 0x85, 0xeb, 0x6f,
	0xfc, 0x63, 0x4b, 0x17, 0x87, 0xa0, 0xee, 0x51, 0xbd, 0x0d, 0x38, 0xfa, 0x98, 0x00, 0x87, 0x42,
	0x39, 0x6c, 0x13, 0x2b, 0x2e, 0xf6, 0x3c, 0xb2, 0x94, 0xbc, 0x3f, 0xe9, 0xce, 0x30, 0x10, 0xc3,
	0x36, 0xf1, 0x02, 0x43, 0xee, 0x2c, 0xc5, 0x88, 0xde, 0x0a, 0x8d, 0xea, 0x30, 0x14, 0xc8, 0xc0,
	0xc7, 0xab, 0x9c, 0xd4, 0x19, 0xc7, 0xa9, 0xf3, 0xd1, 0xda, 0x91, 0xf5, 0xa0, 0x1e, 0x87, 0x44,
	0x2f, 0x40, 0x29, 0x60, 0x4b, 0x27, 0xe6, 0x85, 0xa4, 0x0b, 0x16, 0x27, 0x4b, 0xe7, 0xe6, 0x7b,
	0x37, 0x1a, 0xe5, 0x62, 0xb4, 0xa4, 0x93, 0x00, 0x45, 0x3d, 0x02, 0x84, 0x5e, 0x84, 0xa0, 0x47,
	0x62, 0x7e, 0x9f, 0x45, 0x2a, 0xc4, 0xc3, 0xc9, 0x85, 0x88, 0x78, 0x7d, 0x3a, 0xd6, 0x1d, 0xe9,
	0x2d, 0xc0, 0xe8, 0x59, 0x28, 0xf9, 0x6e, 0x37, 0x86, 0x21, 0x3e, 0x93, 0xb4, 0xfa, 0x4c, 0xd7,
	0xe7, 0x29, 0x56, 0xdc, 0x4c, 0x63, 0x5f, 0x68, 0x65, 0xdd, 0x08, 0x10, 0xb5, 0xbc, 0x19, 0x2f,
	0xde, 0xbf, 0x1f, 0x4c, 0x6c, 0x79, 0xd3, 0xa2, 0xb6, 0xa6, 0x70, 0xc8, 0xcd, 0xaf, 0x09, 0xef,
	0xd9, 0xcf, 0x0a, 0x50, 0xe4, 0xfc, 0x56, 0x0c, 0x53, 0x17, 0xf5, 0xa4, 0x86, 0x80, 0xcf, 0x8d,
	0x20, 0x4d, 0x3d, 0xb2, 0xd9, 0x28, 0x9f, 0xe6, 0xbc, 0xda, 0x8c, 0xeb, 0x93, 0xe3, 0x1d, 0xbd,
	0xae, 0x05, 0x37, 0xa4, 0x83, 0x6a, 0x30, 0x18, 0x44, 0xd2, 0x95, 0x55, 0xd5, 0xac, 0x63, 0xf1,
	0x46, 0xd2, 0xda, 0x73, 0x5e, 0xd7, 0x08, 0x5a, 0xbc, 0x7f, 0xa3, 0xd3, 0x4b, 0x09, 0x47, 0xe1,
	0x88, 0x75, 0x28, 0xc6, 0x63, 0xe4, 0x8a, 0xea, 0x79, 0x0e, 0xdb, 0x7e, 0xbe, 0xcc, 0x2c, 0xf3,
	0x47, 0xba, 0x0c, 0x97, 0x9f, 0xf1, 0x3c, 0x87, 0x6e, 0x45, 0x47, 0x37, 0x1b, 0xe5, 0xc3, 0xa1,
	0x5d, 0x1e, 0x01, 0x21, 0x92, 0x1c, 0xd2, 0xda, 0x21, 0x75, 0x94, 0x88, 0x9a, 0x19, 0xaf, 0xec,
	0x5c, 0x22, 0x6a, 0x62, 0x74, 0x2b, 0x11, 0xb5, 0x13, 0xaa, 0x50, 0xe2, 0xe1, 0x7a, 0x26, 0xc5,
	0xab, 0x42, 0x52, 0xfd, 0xe7, 0x21, 0x7f, 0xca, 0x3c, 0xd6, 0x27, 0xfc, 0x0b, 0x1d, 0x01, 0xcb,
	0x11, 0x30, 0xf4, 0x22, 0x8c, 0x04, 0xec, 0x56, 0x6d, 0x53, 0xf5, 0x0c, 0xd3, 0xf0, 0xd6, 0xc5,
	0xdf, 0x12, 0x92, 0x0e, 0x77, 0x4e, 0xfa, 0x5a, 0x80, 0xdc, 0x99, 0x35, 0x5a, 0x6e, 0x01, 0x46,
	0xff, 0x23, 0x22, 0x80, 0x89, 0xd5, 0xeb, 0x4a, 0xcd, 0xb1, 0xed, 0x65, 0xf1, 0xb7, 0x13, 0xfb,
	0xda, 0x39, 0x83, 0x39, 0xac, 0x5e, 0x9f, 0x27, 0xb8, 0x9d, 0xf9, 0x0f, 0x2f, 0x37, 0xc3, 0x12,
	0xfb, 0xe5, 0x78, 0xd8, 0xde, 0x75, 0xd3, 0x54, 0x0c, 0xab, 0x56, 0xf7, 0x94, 0x25, 0xbc, 0xa2,
	0xae, 0x1a, 0xb6, 0x23, 0xfe, 0x0e, 0x13, 0xe4, 0xbd, 0x5d, 0x34, 0x7f, 0xdd, 0x34, 0x67, 0x09,
	0x91, 0x29, 0x9f, 0x46, 0x67, 0x81, 0x8e, 0x2e, 0x77, 0xc2, 0x89, 0xe9, 0xc1, 0x92, 0xad, 0xaf,
	0x8b, 0xbf, 0xdb, 0xb5, 0x1e, 0x4c, 0xd9, 0xfa, 0x7a, 0x02, 0x3d, 0x20, 0x60, 0x68, 0x1d, 0x82,
	0xc6, 0x09, 0x9c, 0xc2, 0xe2, 0x97, 0x18, 0xcb, 0x53, 0xc9, 0x59, 0x72, 0xff, 0x6e, 0x67, 0xb6,
	0x43, 0xcb, 0x4d, 0xa0, 0xe8, 0x06, 0x14, 0xe9, 0xc0, 0xe3, 0x53, 0xf0, 0x57, 0x85, 0xa4, 0xb3,
	0x22, 0x19, 0x38, 0x7c, 0x06, 0xbe, 0x67, 0xb3, 0x51, 0x2e, 0xb7, 0x1d, 0x6c, 0x27, 0xa3, 0x33,
	0x52, 0xc1, 0x0b, 0x71, 0x90, 0x01, 0x45, 0xdf, 0xff, 0xcf, 0x86, 0xda, 0xcd, 0xe4, 0x9c, 0x19,
	0x1a, 0x1d, 0x69, 0x07, 0x37, 0x1b, 0xe5, 0xa1, 0xc0, 0x20, 0x63, 0x1f, 0x18, 0xab, 0x10, 0x08,
	0x39, 0x30, 0xc8, 0x59, 0x71, 0xd7, 0xff, 0xb7, 0x84, 0xc4, 0xe7, 0x2a, 0x18, 0x26, 0xf7, 0xf8,
	0x77, 0x62, 0x38, 0xe0, 0xc5, 0xe0, 0x90, 0x0d, 0xbc, 0x44, 0xf1, 0x8c, 0x2a, 0x31, 0x9e, 0xbe,
	0x2d, 0x24, 0x9d, 0xe0, 0x7d, 0xb2, 0x8b, 0x14, 0xaf, 0x23, 0xc7, 0x92, 0x17, 0x05, 0x8b, 0x32,
	0xc4, 0xab, 0xd8, 0xf2, 0x5c, 0xf1, 0x2f, 0xbb, 0x65, 0x38, 0x43, 0xf1, 0xb6, 0x65, 0xc8, 0xc0,
	0xd0, 0x7f, 0x07, 0x14, 0xd4, 0xd0, 0x51, 0x2d, 0x97, 0xee, 0xfa, 0xc5, 0xef, 0x24, 0x8f, 0xd3,
	0xf9, 0xe2, 0x07, 0xb8, 0x1d, 0x19, 0x0f, 0x7b, 0xcd, 0xa0, 0x51, 0xed, 0x59, 0x5b, 0xc1, 0x96,
	0xf8, 0x57, 0xdd, 0x6a, 0xcf, 0x53, 0x2b, 0xd8, 0xda, 0x56, 0x7b, 0x08, 0x10, 0x35, 0x87, 0x39,
	0xaf, 0x60, 0x98, 0x6a, 0xaa, 0x69, 0x8a, 0x7f, 0x9d, 0x38, 0x1c, 0xe7, 0xd3, 0xe6, 0x63, 0xf1,
	0xac, 0x6a, 0x9a, 0x1d, 0x99, 0x8f, 0x78, 0xad, 0xc0, 0xd1, 0xfa, 0xea, 0xb8, 0xe6, 0x8a, 0xdf,
	0xed, 0xb6, 0xbe, 0xd3, 0xb8, 0xe6, 0x6e, 0x5b, 0x5f, 0x02, 0x84, 0x30, 0x14, 0x58, 0xf8, 0x8c,
	0x8d, 0xcb, 0x9f, 0x0a, 0x49, 0x5d, 0xd3, 0x2c, 0x24, 0xd7, 0xea, 0x00, 0x67, 0xe5, 0xd4, 0x35,
	0x5d, 0x0b, 0x40, 0x22, 0x6c, 0xc8, 0x16, 0x43, 0xfc, 0x59, 0x97, 0x6c, 0xc8, 0x5e, 0x61, 0x1b,
	0x36, 0x04, 0x04, 0xd5, 0x61, 0xd8, 0x67, 0xc3, 0x82, 0x0f, 0xf8, 0x46, 0xcd, 0x11, 0x37, 0x85,
	0xa4, 0x3b, 0x09, 0x46, 0x94, 0x86, 0x08, 0x66, 0x6e, 0xd4, 0x9c, 0x4e, 0x1c, 0x07, 0x6b, 0x71,
	0x38, 0x7a, 0xce, 0xc5, 0xe7, 0xbb, 0x66, 0x78, 0x2b, 0x0a, 0x3b, 0x8b, 0x43, 0x99, 0xff, 0x3c,
	0x79, 0x10, 0x97, 0x12, 0x78, 0xca, 0xf0, 0x56, 0xa8, 0x97, 0x60, 0x2b, 0x01, 0x46, 0x6a, 0xad,
	0xb0, 0x91, 0x26, 0xa6, 0x3a, 0xf3, 0x8b, 0x2e, 0x9b, 0x98, 0xaa, 0xcc, 0xd6, 0x4d, 0x4c, 0x41,
	0x86, 0x60, 0xc0, 0x3f, 0xf8, 0xac, 0x90, 0x3d, 0x8b, 0xbd, 0x7c, 0x31, 0x9b, 0x7b, 0x70, 0xe8,
	0x21, 0xe9, 0x3b, 0x02, 0xf4, 0x92, 0xa9, 0x7f, 0x11, 0x4d, 0x40, 0x96, 0x9a, 0x99, 0x4c, 0x80,
	0xd1, 0x66, 0x01, 0x70, 0x75, 0x82, 0x9d, 0x19, 0x5e, 0x94, 0x29, 0x1c, 0x5a, 0x85, 0x41, 0xcd,
	0xb4, 0x5d, 0xac, 0x33, 0xab, 0xd0, 0xd0, 0x5d, 0x31, 0x33, 0xde, 0x73, 0xa2, 0x34, 0x75, 0x79,
	0xa3, 0x51, 0x2e, 0x9d, 0xa5, 0x9f, 0x08, 0xe5, 0xd9, 0x69, 0xf7, 0xad, 0x46, 0xf9, 0x3d, 0x15,
	0xc3, 0x5b, 0xa9, 0x2f, 0x4d, 0x68, 0x76, 0x75, 0x32, 0xa0, 0xac, 0x2f, 0x85, 0x7f, 0x4f, 0xd6,
	0xae, 0x57, 0x26, 0xf9, 0x11, 0x67, 0x4d, 0xf5, 0x0c, 0x7d, 0x62, 0x1a, 0xbb, 0xda, 0xec, 0xb4,
	0x5c, 0xd2, 0x42, 0x5a, 0xba, 0x8b, 0x8e, 0x41, 0x9e, 0x32, 0xa4, 0x8a, 0xdf, 0x33, 0x2e, 0x9c,
	0xc8, 0xcb, 0x39, 0x52, 0x40, 0x14, 0x56, 0xda, 0xc8, 0x02, 0x44, 0x5c, 0xcb, 0x4f, 0x43, 0x96,
	0x76, 0x27, 0xa9, 0x53, 0x7e, 0x6a, 0xe6, 0xad, 0x46, 0xf9, 0x4c, 0x62, 0x39, 0x62, 0x27, 0xa9,
	0x27, 0x42, 0xa2, 0x32, 0x25, 0x89, 0x6a, 0x50, 0xaa, 0xbb, 0xd8, 0x6d, 0xae, 0xfc, 0xdc, 0x46,
	0xa3, 0x5c, 0xb8, 0xea, 0x62, 0x77, 0x4f, 0xaa, 0x5e, 0xa8, 0x73, 0x4a, 0xba, 0x8b, 0x5e, 0x80,
	0x61, 0xca, 0x31, 0x70, 0x96, 0x13, 0xae, 0x3d, 0x94, 0xeb, 0xfc, 0x46, 0xa3, 0x3c, 0x48, 0xb8,
	0xf2, 0xbd, 0xcc, 0xae, 0x39, 0x0f, 0xd6, 0xa3, 0xd4, 0x74, 0x17, 0xbd, 0x24, 0xc0, 0x21, 0x07,
	0x2f, 0x63, 0x87, 0x14, 0xe8, 0xbe, 0xa3, 0x96, 0x8a, 0x90, 0xa5, 0x22, 0x5c, 0xdb, 0x68, 0x94,
	0x47, 0xe4, 0x00, 0x80, 0x79, 0x50, 0x99, 0x18, 0xef, 0xdd, 0x81, 0x18, 0x1c, 0x5f, 0x1e, 0x71,
	0x9a, 0x69, 0x46, 0x9a, 0x22, 0x98, 0xea, 0x89, 0x1c, 0xbd, 0xf1, 0xa6, 0xe0, 0x53, 0xf3, 0xde,
	0x34, 0x45, 0x40, 0x4d, 0x77, 0xa5, 0x3f, 0xee, 0x85, 0x3e, 0xdf, 0x43, 0xac, 0x41, 0x8e, 0x85,
	0x53, 0x0d, 0x9d, 0x2a, 0x59, 0x69, 0xea, 0xc2, 0x46, 0xa3, 0xdc, 0x4f, 0xf7, 0x97, 0xb3, 0xd3,
	0xbb, 0xe3, 0xdb, 0x4f, 0x29, 0xcf, 0xea, 0x68, 0x05, 0xf2, 0x41, 0x73, 0xd3, 0x13, 0xee, 0xa5,
	0xa9, 0x4b, 0x1b, 0x8d, 0x72, 0x8e, 0xb7, 0xd1, 0x6e, 0x9b, 0x38, 0xa7, 0xf9, 0x0d, 0x4b, 0xc6,
	0x96, 0xe1, 0x2a, 0x2b, 0x86, 0xae, 0x63, 0x8b, 0x8e, 0xad, 0x9c, 0x9c, 0x33, 0xdc, 0x0b, 0xf4,
	0x37, 0xba, 0x1f, 0x06, 0x0d, 0x57, 0x31, 0x2c, 0x55, 0xd3, 0xc8, 0x48, 0x58, 0x32, 0xd9, 0x51,
	0xf7, 0x9c, 0x3c, 0x60, 0xb8, 0xb3, 0x91, 0x52, 0xb2, 0x67, 0x1c, 0xad, 0x60, 0x0b, 0x3b, 0xaa,
	0x87, 0x75, 0x45, 0x75, 0x15, 0x43, 0xc7, 0x96, 0x67, 0x78, 0xeb, 0x6c, 0x1f, 0xdb, 0x4b, 0x6b,
	0x20, 0xbf, 0xd5, 0x28, 0x5f, 0xde, 0xe1, 0x60, 0x3c, 0xcf, 0x89, 0x9f, 0x71, 0x67, 0x7d, 0xd2,
	0x64, 0x90, 0xc8, 0x47, 0x2a, 0xed, 0x3f, 0xa0, 0x79, 0xb8, 0xb7, 0xbd, 0x40, 0xcd, 0x81, 0xa7,
	0x3e, 0x3a, 0x9f, 0xdc, 0xdd, 0x86, 0x4e, 0x3c, 0xd2, 0x84, 0x3e, 0x2a, 0xc0, 0x50, 0xad, 0x42,
	0xf7, 0xc2, 0xc6, 0x52, 0xdd, 0xc3, 0x8a, 0x55, 0xaf, 0xd2, 0x13, 0xf2, 0xa5, 0xa9, 0xa7, 0x36,
	0x1a, 0xe5, 0x81, 0xf9, 0xca, 0x19, 0xfe, 0xe9, 0x72, 0xbd, 0xda, 0xd5, 0xc4, 0x13, 0xf6, 0xd0,
	0xfc, 0xf9, 0x28, 0x11, 0x79, 0xa0, 0x16, 0x23, 0x8a, 0x4e, 0xc0, 0x90, 0xe1, 0x2a, 0xee, 0xba,
	0xeb, 0xe1, 0x2a, 0x8f, 0x9c, 0xe4, 0x78, 0x8f, 0x2c, 0xd0, 0x62, 0x3f, 0xb0, 0xf1, 0xab, 0x3e,
	0x80, 0x30, 0x28, 0x9d, 0x9a, 0xd6, 0xb2, 0x13, 0xed, 0x4d, 0x5a, 0xcb, 0x0e, 0xa3, 0xef, 0x58,
	0x6b, 0x39, 0xba, 0x9c, 0x63, 0xd4, 0x9b, 0xc7, 0x47, 0xcf, 0xad, 0x1c, 0x1f, 0x4f, 0xc3, 0x20,
	0xae, 0x2e, 0x61, 0x5d, 0xe7, 0xab, 0x9e, 0xe7, 0xdf, 0xf6, 0xb8, 0x3f, 0xd9, 0x5e, 0x6c, 0x71,
	0x2a, 0x77, 0xb3, 0x51, 0x3e, 0xf0, 0x5a, 0xa3, 0x2c, 0xc8, 0x25, 0x4e, 0x89, 0x2d, 0xbf, 0xf7,
	0x40, 0xc1, 0x70, 0xe9, 0x06, 0x3b, 0xb8, 0xfd, 0x91, 0x9b, 0xca, 0x88, 0x82, 0x0c, 0x86, 0x7b,
	0xd9, 0x2f, 0x45, 0x0b, 0x50, 0x8c, 0x86, 0x6c, 0xfd, 0xeb, 0x1d, 0x09, 0x8c, 0x85, 0x48, 0x78,
	0x96, 0xd0, 0x2c, 0x68, 0x61, 0x14, 0x16, 0xdd, 0x05, 0x60, 0xb8, 0xca, 0xaa, 0xe1, 0x78, 0x75,
	0xd5, 0xa4, 0x3a, 0x9c, 0x93, 0xf3, 0x86, 0x7b, 0x8d, 0x15, 0xa0, 0x3a, 0x1c, 0xe5, 0x96, 0x83,
	0xe6, 0x60, 0x95, 0x4e, 0xb7, 0x55, 0xec, 0xa9, 0xd4, 0xf3, 0x5a, 0x48, 0x1a, 0x2c, 0xf6, 0x6f,
	0xfe, 0x9c, 0xf5, 0x29, 0x3c, 0xe9, 0x13, 0x90, 0x8f, 0xe0, 0xf6, 0x1f, 0xd0, 0x57, 0x05, 0xb8,
	0x37, 0x76, 0x31, 0x42, 0xb1, 0x1d, 0x9d, 0x58, 0xf7, 0xb6, 0x69, 0xda, 0x6b, 0x6e, 0xb8, 0x00,
	0x89, 0x45, 0xda, 0xe3, 0xda, 0x46, 0xa3, 0x3c, 0x1e, 0xbd, 0x12, 0x71, 0x85, 0x80, 0x9f, 0x63,
	0xd0, 0x7b, 0xa5, 0x09, 0xe3, 0xda, 0xd6, 0x0c, 0xf4, 0x8b, 0xd9, 0x5c, 0x6e, 0x28, 0x7f, 0x31,
	0x9b, 0xcb, 0x0f, 0xc1, 0xc5, 0x6c, 0x0e, 0x86, 0x0a, 0xd2, 0xcd, 0x1e, 0x38, 0xd2, 0x21, 0x54,
	0xbe, 0xdf, 0x96, 0x8f, 0x0f, 0x42, 0xa0, 0xd4, 0x4c, 0x3f, 0x7b, 0x76, 0xa0, 0x9f, 0xe1, 0x08,
	0x29, 0x72, 0x62, 0x54, 0x4d, 0xaf, 0x42, 0x6f, 0xdd, 0x55, 0x2b, 0x6c, 0x68, 0x0c, 0x9c, 0x7a,
	0x62, 0xc7, 0x07, 0x14, 0x26, 0xae, 0x12, 0x32, 0x32, 0xa3, 0x26, 0x3d, 0x08, 0xbd, 0xf4, 0x37,
	0x2a, 0x40, 0xbf, 0x3c, 0x73, 0xfe, 0xea, 0xdc, 0x19, 0x79, 0xe8, 0x00, 0x3a, 0x08, 0x43, 0x67,
	0xe6, 0x16, 0x67, 0x64, 0x65, 0xf1, 0xe9, 0xf9, 0x19, 0xe5, 0xea, 0xc2, 0xec, 0xe5, 0xf3, 0x43,
	0x82, 0xf4, 0x33, 0x01, 0x8a, 0x51, 0x15, 0xdb, 0x6f, 0x13, 0x29, 0x82, 0x6c, 0xc4, 0xaa, 0xa6,
	0x7f, 0x4b, 0x6f, 0xe4, 0xa0, 0x97, 0xdd, 0x40, 0x49, 0xa5, 0xb2, 0x3a, 0xe4, 0x58, 0x1c, 0x3b,
	0xa8, 0xeb, 0x2c, 0x61, 0x42, 0x25, 0xa0, 0x4c, 0x1e, 0xdd, 0x01, 0x13, 0x1f, 0x5b, 0xee, 0xa7,
	0xa4, 0x03, 0x3b, 0x87, 0xdd, 0x0d, 0x11, 0x81, 0xdb, 0x39, 0x2c, 0x08, 0xec, 0xcf, 0xc4, 0x86,
	0xb5, 0x8a, 0x1d, 0x0f, 0xeb, 0x74, 0x8a, 0x0b, 0x66, 0xe2, 0x59, 0xbf, 0x14, 0xbd, 0xc3, 0xdf,
	0x2d, 0x8d, 0x52, 0x65, 0x3c, 0xde, 0x66, 0xb7, 0xc4, 0x6f, 0x78, 0xf2, 0xfd, 0xd2, 0x45, 0xc8,
	0xb9, 0x2b, 0xaa, 0xa3, 0x1b, 0x56, 0x85, 0x4e, 0x59, 0xad, 0x9e, 0x4a, 0x7e, 0x65, 0x94, 0x19,
	0x39, 0x0b, 0x04, 0x18, 0xeb, 0xa4, 0x81, 0x1c, 0xa3, 0xe6, 0xd9, 0x8e, 0x1c, 0xe0, 0xa3, 0x53,
	0x70, 0xc8, 0x70, 0xd9, 0x74, 0xcc, 0x86, 0x9a, 0x69, 0x68, 0x86, 0x67, 0xae, 0x8b, 0x25, 0x5a,
	0x97, 0x11, 0xc3, 0x3d, 0xcb, 0xbe, 0xcd, 0x04, 0x9f, 0xd0, 0x0d, 0x28, 0x45, 0xc2, 0xeb, 0x86,
	0x2e, 0x0e, 0xd0, 0xe6, 0x5d, 0xd8, 0x68, 0x94, 0x8b, 0x61, 0x14, 0x9b, 0xb6, 0xf1, 0x13, 0x3b,
	0x9a, 0x0e, 0x42, 0x12, 0x72, 0x31, 0xe4, 0x34, 0xab, 0xfb, 0x86, 0xa3, 0x66, 0x5b, 0x5a, 0xdd,
	0x21, 0x7b, 0x54, 0xff, 0x92, 0x1b, 0x35, 0x53, 0xce, 0x46, 0x4a, 0xd1, 0x1a, 0x0c, 0xba, 0x76,
	0xdd, 0x21, 0x5b, 0x1b, 0xae, 0x03, 0x87, 0xa8, 0x90, 0x57, 0xc8, 0x96, 0x72, 0x81, 0x7e, 0xda,
	0x1b, 0x4d, 0x28, 0xb9, 0x11, 0x62, 0x3a, 0xfa, 0x88, 0x00, 0xa8, 0xe9, 0x52, 0x17, 0x61, 0x7e,
	0x98, 0x59, 0xaa, 0x1b, 0x8d, 0xf2, 0x50, 0xfc, 0x40, 0xc6, 0xae, 0xf9, 0x0f, 0xc5, 0x6f, 0x77,
	0xcd, 0xea, 0xe8, 0x2c, 0x40, 0x05, 0xdb, 0x3c, 0x98, 0xc8, 0x6e, 0x94, 0x8d, 0x45, 0x14, 0xa4,
	0x82, 0x6d, 0xf2, 0x1f, 0xbb, 0x75, 0xec, 0x87, 0x0d, 0xb3, 0x37, 0xc9, 0x34, 0x99, 0xaf, 0x60,
	0xdb, 0x0f, 0x0d, 0x9e, 0x80, 0x01, 0x62, 0x44, 0xd8, 0x9e, 0xb2, 0x6a, 0x30, 0x0b, 0xfd, 0x48,
	0xa0, 0xbd, 0x45, 0xc3, 0xbd, 0x6c, 0x7b, 0xd7, 0x58, 0x39, 0x92, 0xa0, 0x68, 0x58, 0x14, 0x88,
	0xc5, 0x33, 0x8e, 0x8e, 0x0b, 0x27, 0x08, 0x4c, 0xa4, 0x0c, 0xcd, 0x02, 0xac, 0x62, 0x8d, 0x8b,
	0xc4, 0xae, 0xfe, 0xbc, 0xad, 0x49, 0x67, 0xf9, 0xb5, 0xe1, 0x09, 0x7a, 0x6d, 0xb8, 0x49, 0xb0,
	0x55, 0xac, 0xb1, 0x82, 0x8b, 0xd9, 0x5c, 0xcf, 0x50, 0xf6, 0x62, 0x36, 0x97, 0x1d, 0xea, 0xbd,
	0x98, 0xcd, 0xf5, 0x0e, 0xf5, 0x5d, 0xcc, 0xe6, 0xfa, 0x86, 0xfa, 0x2f, 0x66, 0x73, 0xfd, 0x43,
	0x39, 0x69, 0x05, 0x8a, 0xd1, 0xe3, 0x19, 0xe8, 0x03, 0x30, 0x10, 0xac, 0x23, 0xec, 0x86, 0x9d,
	0x90, 0xd4, 0xca, 0x62, 0x17, 0xeb, 0xda, 0x58, 0x59, 0xec, 0x20, 0xcd, 0xff, 0xcb, 0xc2, 0x40,
	0xfc, 0xec, 0xc7, 0xad, 0x63, 0x86, 0x9e, 0xda, 0x8b, 0xe5, 0x90, 0x35, 0x65, 0x7c, 0x29, 0xfc,
	0xa4, 0x00, 0xc8, 0xc1, 0x6c, 0xf8, 0x2b, 0x7c, 0xc4, 0xe8, 0xd4, 0x14, 0x65, 0xdb, 0x8f, 0x43,
	0xb2, 0xff, 0x75, 0x2f, 0xc7, 0xcc, 0x90, 0x13, 0x27, 0xaa, 0xc7, 0xe5, 0xf0, 0x54, 0xa7, 0x82,
	0xe9, 0xc4, 0xd2, 0xdb, 0x2a, 0xc7, 0x22, 0xfd, 0xb8, 0xc7, 0x72, 0xf8, 0x44, 0x75, 0x34, 0x05,
	0x63, 0x2b, 0x86, 0x8e, 0x95, 0x65, 0xdb, 0x09, 0x4e, 0xa7, 0x5f, 0xc7, 0xeb, 0x0a, 0x07, 0xd4,
	0xa9, 0xa1, 0x9c, 0x93, 0x47, 0x09, 0xd4, 0x39, 0xdb, 0xf1, 0x95, 0xed, 0x12, 0x5e, 0xe7, 0xf2,
	0xe9, 0x64, 0x6d, 0x1f, 0x88, 0x0f, 0xf2, 0x5b, 0xa8, 0x19, 0x8f, 0xc3, 0x31, 0xb2, 0xfe, 0x50,
	0x67, 0x67, 0x78, 0x6c, 0x1d, 0x5b, 0x9a, 0x4d, 0x97, 0x87, 0x0c, 0x95, 0x56, 0x34, 0x5c, 0xea,
	0xab, 0x0c, 0xf4, 0x75, 0xc6, 0xff, 0x8e, 0xce, 0xf9, 0x6e, 0xad, 0x9d, 0xeb, 0x13, 0xc5, 0x97,
	0x7e, 0x29, 0x40, 0x31, 0x7a, 0x26, 0x00, 0x2d, 0x43, 0xde, 0x0f, 0xbf, 0x07, 0x6b, 0x3c, 0x59,
	0x7e, 0x73, 0x0c, 0x68, 0xb7, 0x8b, 0x7c, 0x8e, 0xd1, 0x9e, 0xd5, 0xd1, 0x8b, 0x80, 0x98, 0xbb,
	0x52, 0x09, 0x8e, 0x52, 0x04, 0xeb, 0xfd, 0xfb, 0xc9, 0x74, 0xcb, 0xe4, 0xe1, 0x27, 0x21, 0x76,
	0xcb, 0xd8, 0x77, 0xa7, 0x07, 0xe4, 0x74, 0xe9, 0xc7, 0x02, 0x14, 0x22, 0x47, 0x06, 0xa8, 0x33,
	0x93, 0xfc, 0xa1, 0xd8, 0x4b, 0xcf, 0x62, 0xcd, 0x0b, 0xab, 0xcf, 0x9c, 0x99, 0xe4, 0xd3, 0x15,
	0xfa, 0x65, 0xb7, 0xa2, 0x94, 0xb4, 0x08, 0x2d, 0x3d, 0xde, 0xe0, 0x99, 0x5b, 0xd6, 0xe0, 0xd2,
	0x17, 0x7b, 0xa0, 0x8f, 0x39, 0x86, 0x53, 0xb3, 0x59, 0x7d, 0xaf, 0x76, 0xdc, 0x66, 0x65, 0x32,
	0xec, 0xd8, 0x66, 0xe5, 0xe8, 0x72, 0x8e, 0x51, 0xa7, 0x5b, 0x72, 0x66, 0x88, 0xb1, 0x7d, 0xff,
	0x6e, 0x5c, 0xbc, 0x8c, 0x38, 0x75, 0x24, 0x31, 0x8b, 0x6d, 0x09, 0xfa, 0x35, 0xbb, 0x5a, 0x55,
	0x2d, 0x3e, 0xb5, 0x5e, 0x78, 0xab, 0x51, 0x9e, 0xde, 0x15, 0xf5, 0xb3, 0x8c, 0x9e, 0xcc, 0x09,
	0x4b, 0x3f, 0x11, 0x00, 0xc2, 0x98, 0xcc, 0x7e, 0xeb, 0x9c, 0x76, 0x1b, 0x8a, 0x7f, 0x0b, 0x6a,
	0x4c, 0x63, 0x3f, 0xfb, 0xac, 0xc6, 0xc7, 0x20, 0x4f, 0x4f, 0xe3, 0x45, 0xa3, 0x13, 0xa4, 0x80,
	0x46, 0x27, 0xfe, 0x3c, 0x03, 0x83, 0x4d, 0xc1, 0xaa, 0xfd, 0x56, 0xff, 0x5b, 0xe9, 0x02, 0x90,
	0xbe, 0x9e, 0x81, 0x91, 0x36, 0xf1, 0xb6, 0x3b, 0x6d, 0xd8, 0x45, 0x1b, 0x7e, 0x2b, 0xcb, 0x87,
	0x1f, 0x0d, 0x24, 0xef, 0xb3, 0xa6, 0x6b, 0x89, 0xca, 0xf5, 0xa4, 0x15, 0x95, 0x73, 0xb0, 0xa9,
	0x06, 0xa1, 0xa8, 0x6c, 0x3c, 0x14, 0x25, 0xfb, 0xdf, 0xf6, 0x26, 0x14, 0x15, 0x50, 0xbb, 0xed,
	0x81, 0xb0, 0x0f, 0xc3, 0x91, 0x0e, 0x97, 0x6e, 0x53, 0xd1, 0x2b, 0xe9, 0x37, 0x04, 0x38, 0xdc,
	0xfe, 0x9a, 0x6d, 0x3a, 0x7a, 0xcd, 0xdc, 0x48, 0xfe, 0xcd, 0xe0, 0x0c, 0x77, 0x23, 0x31, 0x09,
	0xa4, 0x1f, 0x09, 0x90, 0xe3, 0x41, 0x23, 0x64, 0x42, 0x21, 0x12, 0xb6, 0xf5, 0x25, 0x22, 0x63,
	0x00, 0xc2, 0x88, 0xed, 0xee, 0x84, 0x02, 0x37, 0x08, 0xd6, 0xa2, 0xbb, 0xa1, 0xe8, 0x60, 0xd7,
	0x53, 0x1d, 0x76, 0x39, 0x84, 0x8a, 0xd6, 0x23, 0x17, 0xfc, 0x32, 0x32, 0x77, 0xa2, 0x13, 0x30,
	0x54, 0xa7, 0x27, 0xd8, 0x23, 0x60, 0x2c, 0xe0, 0x37, 0x50, 0x77, 0xb1, 0x1c, 0x81, 0xbc, 0x1b,
	0x8a, 0x86, 0xab, 0x04, 0xfe, 0x0a, 0xdf, 0x5d, 0x56, 0x30, 0xdc, 0x60, 0xb7, 0x24, 0x7d, 0x59,
	0x20, 0xbb, 0xea, 0x58, 0x7c, 0x2c, 0xdd, 0x0a, 0x0f, 0x41, 0xcf, 0x75, 0xbc, 0x4e, 0xeb, 0x99,
	0x97, 0xc9, 0x9f, 0xe8, 0x20, 0xf4, 0xb2, 0x13, 0xbb, 0x6c, 0x0d, 0x66, 0x3f, 0xa4, 0xef, 0x64,
	0xa0, 0x14, 0xbb, 0x11, 0x98, 0xb2, 0x9c, 0x51, 0xad, 0xcc, 0xa4, 0xe2, 0xef, 0xbf, 0x95, 0xe1,
	0x30, 0xe9, 0x1b, 0x19, 0x1e, 0xda, 0x68, 0xbd, 0x46, 0x7a, 0x27, 0xb4, 0x91, 0x7c, 0x4d, 0xfe,
	0x66, 0x06, 0xc4, 0x4e, 0xb7, 0x65, 0xef, 0x34, 0x64, 0x17, 0x0d, 0xf9, 0x83, 0x7e, 0xc8, 0x5e,
	0x33, 0xf0, 0x1a, 0xfa, 0x10, 0xf4, 0xaf, 0x1a, 0x78, 0x2d, 0x6c, 0xb3, 0xf3, 0x1b, 0x8d, 0x72,
	0x1f, 0xf9, 0xb4, 0xdb, 0x26, 0xeb, 0x23, 0x74, 0xdb, 0x59, 0x1a, 0x99, 0xdb, 0x62, 0x69, 0xf4,
	0xa4, 0x65, 0x69, 0xac, 0xd3, 0x05, 0xc3, 0x55, 0x1c, 0xbb, 0xee, 0x19, 0x16, 0xab, 0x72, 0x91,
	0x32, 0xbf, 0xb2, 0xd1, 0x28, 0x0f, 0x50, 0xe6, 0xec, 0xd3, 0xae, 0x79, 0x0f, 0xd4, 0x23, 0xc4,
	0x74, 0x17, 0xad, 0x02, 0x5a, 0xb6, 0x9d, 0x35, 0xd5, 0xd1, 0x95, 0xe0, 0x30, 0x10, 0xb3, 0xb1,
	0x12, 0x1d, 0x0e, 0x26, 0xbd, 0x3e, 0x11, 0x9c, 0x4c, 0x9a, 0x3a, 0xb4, 0xd1, 0x28, 0x0f, 0x9f,
	0x63, 0xf4, 0x82, 0x52, 0x57, 0x1e, 0x5e, 0x6e, 0x2e, 0x4a, 0xb0, 0xf2, 0xf9, 0xa1, 0x8d, 0xaa,
	0xea, 0x61, 0xc7, 0x50, 0x4d, 0xe3, 0x79, 0x1e, 0x2f, 0x92, 0x07, 0x0c, 0xf7, 0xc9, 0x48, 0xe9,
	0xe8, 0x5f, 0x64, 0x20, 0x1f, 0x90, 0x46, 0xcf, 0x40, 0xaf, 0x67, 0x87, 0xca, 0x39, 0xb3, 0xd1,
	0x28, 0x67, 0x17, 0xed, 0xdd, 0xaa, 0x66, 0xd6, 0xb3, 0x53, 0x8b, 0xa0, 0x5d, 0x07, 0x88, 0x1c,
	0x01, 0x0b, 0xad, 0xec, 0xfc, 0x9e, 0x1d, 0xfc, 0xca, 0xf3, 0x29, 0xc3, 0x7d, 0x34, 0xfb, 0xa3,
	0x57, 0xcb, 0x82, 0xf4, 0x39, 0x01, 0x7a, 0xe9, 0xac, 0x97, 0xce, 0x94, 0x98, 0xc0, 0xee, 0x79,
	0x3d, 0x0b, 0xc7, 0xb7, 0xba, 0x39, 0x9a, 0x8e, 0xa0, 0x2d, 0x81, 0xbd, 0x4c, 0x5a, 0x81, 0xbd,
	0x34, 0x95, 0x00, 0x3d, 0x0d, 0xf9, 0x9a, 0x83, 0x75, 0x43, 0x53, 0x3d, 0x9e, 0x63, 0xb5, 0xbb,
	0x45, 0xa3, 0x44, 0x24, 0x9b, 0xe7, 0x24, 0xe4, 0x90, 0x1a, 0x7a, 0x45, 0x80, 0x23, 0x7c, 0xcc,
	0xd0, 0x20, 0x82, 0x9f, 0xde, 0xcd, 0xb0, 0x2d, 0x3f, 0x98, 0x71, 0x6d, 0xa3, 0x51, 0x3e, 0xe8,
	0x0f, 0x82, 0x73, 0xb6, 0x73, 0x2d, 0xf8, 0xbe, 0xcb, 0xf1, 0x74, 0xd0, 0x1f, 0x4f, 0x31, 0x9a,
	0xd2, 0x6b, 0x3d, 0x70, 0x7f, 0xc2, 0xbc, 0x87, 0x77, 0x54, 0xec, 0xd7, 0x42, 0xc5, 0xa4, 0x8f,
	0xf7, 0xc2, 0x60, 0xd3, 0x35, 0xf2, 0x3b, 0x5d, 0xb7, 0x87, 0x5d, 0xd7, 0x62, 0x56, 0x66, 0xf7,
	0xf0, 0xe8, 0xd1, 0x23, 0x20, 0x2e, 0x3b, 0x76, 0x55, 0x59, 0x51, 0xdd, 0x15, 0xc5, 0x65, 0xe7,
	0x32, 0xf8, 0x81, 0x4b, 0x7a, 0x50, 0x4f, 0x3e, 0x44, 0xbe, 0x5f, 0x50, 0xdd, 0x15, 0xff, 0xd4,
	0x86, 0x7f, 0x3c, 0x78, 0xab, 0x89, 0xa5, 0xef, 0x36, 0x4c, 0x2c, 0xdf, 0xe8, 0x81, 0xd1, 0xce,
	0xa9, 0x42, 0xef, 0x28, 0xe4, 0xaf, 0x89, 0x42, 0x4a, 0x3f, 0xcc, 0xc1, 0xc1, 0x76, 0x39, 0x28,
	0xee, 0xf4, 0xe0, 0x1e, 0xf6, 0xe0, 0xc7, 0x04, 0x88, 0x5c, 0x3e, 0x50, 0x82, 0x76, 0xcd, 0x06,
	0xa7, 0x82, 0x86, 0xc3, 0xfb, 0x0e, 0x7b, 0xd2, 0xc2, 0xc3, 0x4e, 0x13, 0x3d, 0x7d, 0x8b, 0x6b,
	0x17, 0xbd, 0xe9, 0x5f, 0xbb, 0xb8, 0x0e, 0x43, 0x61, 0x4a, 0x30, 0x55, 0x0b, 0xa6, 0xb1, 0x81,
	0xd6, 0x3b, 0x6e, 0xb8, 0x3a, 0x11, 0xbc, 0x53, 0x10, 0x49, 0xbd, 0x7b, 0x86, 0x5d, 0xa8, 0x45,
	0x64, 0xcb, 0xc8, 0x7d, 0x1d, 0xac, 0x4c, 0x1e, 0xb0, 0x63, 0xbf, 0x7d, 0x66, 0x3a, 0x36, 0x71,
	0xc8, 0xac, 0x7f, 0x17, 0xcc, 0xa6, 0x29, 0xa5, 0x90, 0x59, 0xf4, 0x37, 0x7a, 0x01, 0x46, 0xc3,
	0x5b, 0xee, 0xd7, 0xf1, 0x3a, 0xd9, 0xd2, 0x69, 0x2b, 0x4a, 0x15, 0x7b, 0x2b, 0xb6, 0x4e, 0x0f,
	0xd5, 0x0f, 0x9c, 0x92, 0xb6, 0x64, 0xfb, 0x24, 0x41, 0x98, 0x3a, 0xb6, 0xd1, 0x28, 0x1f, 0x09,
	0x2e, 0xd7, 0x5e, 0xc2, 0xeb, 0xb4, 0xf8, 0x49, 0x4a, 0x46, 0x3e, 0xa2, 0xb5, 0xff, 0xb0, 0xe5,
	0x32, 0x91, 0xbf, 0x0d, 0xcb, 0xc4, 0x3f, 0xf4, 0x43, 0x79, 0x9b, 0x74, 0xc9, 0x77, 0x66, 0x9a,
	0x3b, 0x33, 0xcd, 0x9d, 0x99, 0xe6, 0xd7, 0x6d, 0xa6, 0x91, 0x7e, 0x28, 0x40, 0xbf, 0x7f, 0xa7,
	0x38, 0x9d, 0x11, 0x6c, 0x02, 0xf0, 0x3b, 0xd1, 0xc1, 0xf0, 0x7d, 0x92, 0x66, 0xc3, 0x66, 0xa5,
	0x94, 0xd1, 0x63, 0x3b, 0x60, 0x14, 0xe0, 0xcb, 0x79, 0x9f, 0xc1, 0xac, 0x2e, 0xfd, 0x42, 0x80,
	0x42, 0x24, 0xf3, 0xc0, 0x3e, 0xac, 0x62, 0xdb, 0x23, 0x35, 0xff, 0x21, 0xc0, 0x40, 0x3c, 0x05,
	0xc2, 0x7e, 0xac, 0xb9, 0x08, 0xfd, 0x3c, 0x33, 0x04, 0x8b, 0x54, 0xf2, 0x9f, 0xd2, 0xeb, 0x19,
	0x28, 0xc5, 0xf2, 0x31, 0xec, 0xc7, 0xea, 0x5f, 0x81, 0x02, 0x9b, 0x9b, 0x14, 0xcf, 0xf0, 0xfb,
	0x7f, 0xa0, 0x35, 0xd9, 0x49, 0x6c, 0xa6, 0xf0, 0xe9, 0xb0, 0x99, 0x67, 0xd1, 0xa8, 0x62, 0x19,
	0xd4, 0xe0, 0x6f, 0x34, 0x0e, 0x45, 0x62, 0x6b, 0x60, 0x55, 0x5b, 0xa1, 0x19, 0x89, 0xd9, 0x65,
	0x4e, 0x58, 0xb6, 0x9d, 0x19, 0x55, 0x5b, 0x91, 0xed, 0x35, 0xc9, 0x83, 0x62, 0x34, 0xeb, 0x04,
	0x3a, 0x13, 0xb9, 0x22, 0xbe, 0xdd, 0xe4, 0x18, 0x45, 0x8c, 0x9c, 0xa9, 0xbb, 0x1b, 0x8a, 0x91,
	0xc4, 0xbd, 0x2c, 0x6a, 0x92, 0x97, 0x0b, 0x61, 0xd2, 0x5d, 0x57, 0xfa, 0x4a, 0xd8, 0x9b, 0x7e,
	0x16, 0x8b, 0x7d, 0xd8, 0x9b, 0xe7, 0xa0, 0xcf, 0xcf, 0x00, 0xd2, 0x43, 0xe3, 0x18, 0x13, 0xdd,
	0x25, 0x00, 0x91, 0x7d, 0x6c, 0xe9, 0xdb, 0x19, 0x18, 0x6e, 0x49, 0xd2, 0xb1, 0x1f, 0x1b, 0xec,
	0x1d, 0x70, 0xd0, 0xc2, 0x6b, 0x91, 0x2c, 0x26, 0x0a, 0x7d, 0x59, 0xca, 0x9f, 0x07, 0x91, 0x85,
	0xd7, 0xc2, 0xfa, 0xd3, 0x9c, 0x5f, 0x04, 0xc3, 0x36, 0xf5, 0x56, 0x8c, 0x2c, 0xc3, 0xb0, 0x4d,
	0xbd, 0x09, 0x83, 0xcc, 0xa3, 0x85, 0x48, 0xea, 0x91, 0xfd, 0xd8, 0x8c, 0xc7, 0x20, 0xbf, 0xb6,
	0x82, 0xad, 0x30, 0xf4, 0x9a, 0x97, 0x73, 0xa4, 0x80, 0xba, 0x15, 0x3e, 0xd1, 0x03, 0x23, 0x6d,
	0xb2, 0xa0, 0xec, 0xc7, 0x76, 0xf8, 0x10, 0xf4, 0x2f, 0xd7, 0x2d, 0x2d, 0x3c, 0x22, 0x41, 0x03,
	0xc4, 0xa4, 0xd6, 0xbb, 0x0e, 0x10, 0x13, 0xba, 0xac, 0xa5, 0x29, 0x07, 0xd5, 0xa9, 0xb0, 0x60,
	0x65, 0x9e, 0xbd, 0x33, 0x76, 0xc6, 0xa9, 0xb8, 0xc1, 0x47, 0x9a, 0xb8, 0xaa, 0x97, 0x75, 0x03,
	0x29, 0x98, 0xb2, 0xf5, 0x75, 0xe9, 0x57, 0xfd, 0x81, 0x1a, 0xa6, 0x77, 0x46, 0x2f, 0xdd, 0xe6,
	0xff, 0x70, 0xe7, 0x58, 0xb6, 0xbc, 0xd7, 0xb1, 0x6c, 0x51, 0x68, 0x8d, 0x66, 0x9b, 0x30, 0x10,
	0xe3, 0xef, 0x8a, 0x7d, 0x74, 0x1a, 0x7e, 0xa2, 0xab, 0x5c, 0x3d, 0x13, 0x9c, 0x64, 0x18, 0x5d,
	0xce, 0xde, 0x6c, 0x94, 0x0f, 0xc8, 0xa5, 0x28, 0x3f, 0xb7, 0xf5, 0xac, 0x40, 0xf6, 0x56, 0x9f,
	0x15, 0x68, 0x17, 0xad, 0xef, 0x4d, 0x25, 0x5a, 0x3f, 0xfa, 0xa7, 0x19, 0x18, 0x6e, 0x69, 0x17,
	0xb4, 0x00, 0x99, 0x40, 0x7b, 0xcf, 0x6e, 0x34, 0xca, 0x99, 0xdd, 0x2a, 0x6e, 0xc6, 0x68, 0xde,
	0xa4, 0x67, 0x6e, 0xed, 0x26, 0x3d, 0x1a, 0x57, 0xef, 0xb9, 0x55, 0x71, 0x75, 0xe9, 0x53, 0x19,
	0xc8, 0xf1, 0x74, 0x6c, 0xf4, 0x55, 0x17, 0xa6, 0x32, 0xd1, 0x53, 0x2c, 0x4c, 0x5b, 0x76, 0x39,
	0x49, 0x79, 0x54, 0x51, 0x88, 0x66, 0xaa, 0x8e, 0xa3, 0xae, 0x73, 0xd5, 0xf4, 0x07, 0x3e, 0xd5,
	0xcc, 0x33, 0xe4, 0xc3, 0x5e, 0x30, 0x2b, 0xa8, 0x01, 0x25, 0x1d, 0xdd, 0xc7, 0x4e, 0x4c, 0xd4,
	0x4d, 0xcf, 0xe0, 0xef, 0x74, 0x30, 0x6b, 0xbe, 0x64, 0xb8, 0x4f, 0x92, 0x52, 0x96, 0xe6, 0x56,
	0xba, 0x29, 0x40, 0x3e, 0xc8, 0xdd, 0x99, 0x42, 0x4b, 0xb4, 0x49, 0xed, 0x90, 0xd9, 0x9b, 0xd4,
	0x0e, 0xd2, 0x9b, 0x02, 0x94, 0x62, 0x09, 0xf7, 0xf6, 0x63, 0xc7, 0x4a, 0xdf, 0x15, 0xa0, 0x8f,
	0x5d, 0x5b, 0x4a, 0xed, 0x1a, 0x59, 0x82, 0x03, 0x3a, 0xec, 0x88, 0x6e, 0xad, 0xbe, 0x64, 0x1a,
	0x9a, 0x7f, 0x34, 0x27, 0x67, 0xb8, 0xf3, 0xf4, 0x77, 0x53, 0xe6, 0x8b, 0x62, 0x53, 0xe6, 0x0b,
	0xe9, 0x06, 0xe4, 0xf8, 0x95, 0x31, 0x64, 0x42, 0x21, 0x7a, 0x55, 0x2d, 0x72, 0x4e, 0x74, 0xaf,
	0x2e, 0xa9, 0x81, 0x1e, 0x5e, 0x4f, 0xfb, 0xe7, 0x0c, 0xe4, 0x83, 0x0c, 0xe0, 0xe9, 0xf2, 0x4e,
	0xeb, 0x4a, 0x1a, 0x72, 0xa0, 0xa4, 0x07, 0x77, 0xdb, 0xc3, 0x49, 0xf5, 0x49, 0x9a, 0x95, 0x39,
	0xf8, 0xb0, 0x5b, 0x7e, 0xc5, 0x90, 0x47, 0xc4, 0x79, 0x92, 0x8d, 0x38, 0x4f, 0xbe, 0x20, 0x40,
	0x2f, 0x3b, 0x0b, 0xdc, 0x22, 0x91, 0x70, 0xeb, 0x25, 0x3a, 0xc8, 0x93, 0xb0, 0xb3, 0xb3, 0xcb,
	0xec, 0x87, 0xf4, 0x63, 0x01, 0x06, 0xe2, 0x59, 0xcd, 0x6f, 0x8b, 0x70, 0xc7, 0x20, 0x4f, 0x93,
	0xb2, 0xd3, 0x36, 0x63, 0x02, 0xe6, 0x48, 0x01, 0xf5, 0xad, 0x8d, 0x01, 0x44, 0x92, 0xb5, 0x93,
	0xce, 0xcb, 0xca, 0x91, 0x12, 0xf4, 0x20, 0x0c, 0xd3, 0xac, 0x7a, 0x15, 0x47, 0xb5, 0x3c, 0x9e,
	0x5f, 0x29, 0x4b, 0xc1, 0x06, 0xc9, 0x87, 0xf3, 0xa4, 0x9c, 0x9d, 0x16, 0x97, 0x7e, 0x20, 0xc0,
	0xc1, 0x76, 0xaf, 0xe6, 0x12, 0xd3, 0x97, 0xbd, 0xc4, 0x1b, 0x37, 0x7d, 0x29, 0xd8, 0xae, 0x4d,
	0x5f, 0x4a, 0x79, 0x56, 0x47, 0xd3, 0x50, 0x88, 0x26, 0xf2, 0x66, 0xd3, 0xfe, 0x3d, 0x91, 0x69,
	0xdf, 0x7f, 0xe1, 0x9a, 0xbd, 0x69, 0x3d, 0x11, 0x8a, 0x27, 0xc3, 0xf3, 0xa1, 0xa8, 0x47, 0xa0,
	0xdf, 0xc5, 0xcf, 0xd1, 0x3c, 0x50, 0x54, 0x93, 0xe5, 0x3e, 0x17, 0x3f, 0x77, 0xb9, 0x5e, 0x95,
	0x9e, 0x87, 0x91, 0x36, 0x8f, 0x70, 0xa5, 0x73, 0x43, 0xe2, 0xa3, 0x02, 0x8c, 0x76, 0x7e, 0x77,
	0x2b, 0x1d, 0x19, 0xfe, 0x35, 0x03, 0xc7, 0xb7, 0x7a, 0x61, 0x2b, 0x9d, 0xfd, 0xcd, 0x47, 0x68,
	0x8c, 0x85, 0xe6, 0xeb, 0x0f, 0x93, 0x7a, 0xc7, 0x2f, 0x1d, 0x33, 0x71, 0xb8, 0xf5, 0xb5, 0xeb,
	0x4b, 0xc7, 0x4e, 0x9c, 0x1c, 0x99, 0x59, 0x0b, 0xbe, 0x04, 0xa1, 0x07, 0x77, 0x57, 0x37, 0x56,
	0x99, 0xc0, 0x64, 0xe0, 0xc8, 0xe0, 0x04, 0x7f, 0x93, 0x19, 0x6d, 0xb4, 0xf3, 0x5b, 0x5c, 0xe9,
	0x34, 0xf7, 0x00, 0x64, 0x54, 0xd7, 0x9f, 0x33, 0x32, 0xaa, 0x2b, 0xbd, 0x94, 0x81, 0x07, 0x12,
	0xbf, 0x0f, 0xb6, 0xcf, 0x83, 0x8b, 0xd2, 0xd7, 0x33, 0x30, 0xdc, 0xf2, 0x90, 0xcf, 0x7e, 0xca,
	0xaf, 0xa3, 0x42, 0x31, 0xf6, 0xbc, 0x51, 0x4f, 0xdb, 0x7c, 0xc3, 0xf1, 0x7c, 0x37, 0xd1, 0xb6,
	0x08, 0x17, 0xb4, 0xe8, 0x11, 0x98, 0x28, 0x49, 0xe9, 0xd5, 0x0c, 0x44, 0x5f, 0xad, 0x4d, 0xa7,
	0xf5, 0xae, 0x35, 0xbf, 0xb8, 0x9b, 0x69, 0xfb, 0x14, 0x66, 0xbc, 0x62, 0xd1, 0xc7, 0x76, 0xc3,
	0xda, 0xc4, 0x5e, 0xd4, 0x5d, 0x84, 0x9c, 0xe7, 0x99, 0x3b, 0xbf, 0x0f, 0x51, 0xa0, 0x55, 0x5d,
	0x9c, 0x23, 0x45, 0x72, 0xbf, 0xe7, 0x99, 0xd4, 0x9d, 0xf7, 0x13, 0x81, 0x67, 0xfd, 0x4b, 0xf5,
	0x6e, 0x79, 0x4a, 0x17, 0x49, 0xda, 0x05, 0xc2, 0xfe, 0x45, 0x80, 0x7c, 0xf8, 0xa2, 0xd0, 0x3e,
	0x1a, 0x50, 0xed, 0x2a, 0xfb, 0xb9, 0x0c, 0x8c, 0x76, 0x7e, 0xbf, 0x69, 0xbf, 0x1f, 0xd0, 0x68,
	0x67, 0xca, 0xbf, 0x22, 0x40, 0x31, 0xfa, 0xaa, 0x76, 0x3a, 0x6d, 0x20, 0xb2, 0x34, 0x11, 0xd8,
	0xf2, 0xfc, 0xf5, 0x8e, 0xff, 0x94, 0x3e, 0x23, 0x40, 0x21, 0x92, 0x82, 0x3f, 0x85, 0x6d, 0x7f,
	0x67, 0x59, 0xfe, 0xbf, 0x00, 0x83, 0x4d, 0x4f, 0xee, 0xa4, 0xbc, 0xb1, 0xec, 0x2c, 0xdb, 0x17,
	0x04, 0x28, 0xc5, 0x9e, 0x8b, 0x49, 0xcd, 0x83, 0xd0, 0x59, 0xa6, 0x9f, 0x0b, 0x50, 0x8c, 0xbe,
	0x6f, 0xb7, 0x9f, 0x66, 0x93, 0x48, 0xad, 0x7b, 0xe2, 0xb5, 0xfe, 0xf7, 0x0c, 0x94, 0x62, 0x6f,
	0x58, 0xee, 0xb7, 0x55, 0xa3, 0x63, 0xd5, 0xdb, 0x67, 0xf4, 0xcd, 0xa6, 0x9a, 0xd1, 0x97, 0x6c,
	0x95, 0x4a, 0xb1, 0x27, 0x3d, 0xf7, 0x5b, 0xf3, 0x6f, 0x75, 0xd2, 0xb1, 0xe7, 0x36, 0x9c, 0x74,
	0x7c, 0x39, 0x03, 0xc3, 0x2d, 0x0f, 0x07, 0xee, 0xf7, 0xa5, 0xb3, 0xf3, 0xf0, 0xff, 0x74, 0x06,
	0x0e, 0xb6, 0x7b, 0x9d, 0x2e, 0xe5, 0x95, 0xe2, 0xf6, 0xef, 0xd5, 0xa5, 0x57, 0x05, 0x18, 0x69,
	0xf3, 0x40, 0x5e, 0xca, 0x0d, 0x11, 0xcb, 0x26, 0x94, 0x69, 0xca, 0x26, 0xf4, 0xcd, 0x5e, 0x28,
	0x44, 0xde, 0x3f, 0xdd, 0x4f, 0x0b, 0x54, 0x7a, 0x19, 0xbd, 0xef, 0x83, 0x41, 0xdb, 0xd1, 0x0d,
	0x4b, 0x35, 0x15, 0xc3, 0x52, 0xae, 0x1b, 0x3c, 0xd7, 0x97, 0x5c, 0xf2, 0x8b, 0x67, 0xad, 0x4b,
	0x86, 0xa5, 0xa3, 0x73, 0x90, 0xa5, 0x1f, 0x59, 0xf2, 0xe1, 0x53, 0x5d, 0xbd, 0x4c, 0x3b, 0x41,
	0x28, 0xc8, 0x14, 0x1f, 0xcd, 0x43, 0x5e, 0x37, 0x1c, 0x1c, 0x3d, 0xd1, 0x7a, 0x6a, 0xcb, 0xdd,
	0x63, 0x94, 0xce, 0x34, 0xc7, 0x94, 0x43, 0x22, 0x68, 0x14, 0x72, 0x46, 0x95, 0x65, 0x79, 0xf5,
	0x93, 0x77, 0x07, 0xbf, 0xd1, 0x1a, 0x94, 0x78, 0x1e, 0x5b, 0x56, 0xb7, 0xdc, 0xae, 0x73, 0xef,
	0xf3, 0x0c, 0xb8, 0x11, 0xb9, 0x68, 0xf5, 0x8a, 0x9c, 0x11, 0xf9, 0x25, 0x3d, 0x04, 0x59, 0xda,
	0x6c, 0xfd, 0xd0, 0x73, 0x69, 0xe6, 0xe9, 0xa1, 0x03, 0x68, 0x00, 0xe0, 0xd2, 0xcc, 0xd3, 0xca,
	0xc2, 0xd5, 0x73, 0xe7, 0x66, 0x3f, 0x30, 0x24, 0x20, 0x80, 0xbe, 0x85, 0xc5, 0x2b, 0xf2, 0xcc,
	0xf4, 0x50, 0x46, 0x7a, 0x43, 0x80, 0x52, 0xec, 0xbd, 0xbc, 0x14, 0x0c, 0xe5, 0x47, 0xe0, 0x48,
	0x6d, 0x65, 0xdd, 0x35, 0x34, 0xd5, 0x54, 0x1c, 0x4c, 0x36, 0xd2, 0xd8, 0xf2, 0xd8, 0x3a, 0x44,
	0xd4, 0xba, 0x28, 0x1f, 0xe6, 0x9f, 0xe5, 0xd8, 0x57, 0xf4, 0x2e, 0x38, 0x6c, 0xda, 0x95, 0x76,
	0x78, 0x6c, 0x2e, 0x3d, 0xe4, 0x7f, 0x8d, 0xa3, 0x49, 0xbf, 0x2f, 0xc0, 0xa1, 0xb6, 0x8f, 0xe0,
	0xa1, 0x17, 0x60, 0xb8, 0xe9, 0x81, 0xbd, 0xa0, 0xd6, 0xf4, 0x5a, 0x7f, 0x0c, 0x6b, 0xb7, 0xd5,
	0x1f, 0x8c, 0xbd, 0xa9, 0x17, 0xd9, 0x46, 0x65, 0x22, 0xdb, 0xa8, 0x9f, 0xb6, 0x93, 0x95, 0xc6,
	0x2d, 0x6f, 0xaf, 0xac, 0xb7, 0x30, 0x44, 0xfb, 0x86, 0x00, 0xa8, 0xf5, 0x5d, 0xce, 0x94, 0x67,
	0xfb, 0x5b, 0x1c, 0x87, 0x78, 0x5d, 0x80, 0x41, 0xba, 0x18, 0xc4, 0xe3, 0x2b, 0xb7, 0x7e, 0xcd,
	0xb8, 0xc5, 0xf5, 0xfa, 0xa3, 0x1e, 0x18, 0xa4, 0xb3, 0x51, 0xda, 0xf5, 0x4a, 0x67, 0x2d, 0xfc,
	0xaf, 0xd0, 0xef, 0xd6, 0x97, 0x48, 0x43, 0xf8, 0x57, 0x08, 0xc7, 0x3b, 0xb6, 0xdc, 0x02, 0x83,
	0xf3, 0x0f, 0x21, 0x71, 0x34, 0x74, 0x05, 0x4a, 0xfe, 0x9f, 0x8a, 0x5b, 0x53, 0x2d, 0x76, 0x12,
	0x28, 0x9e, 0xca, 0xb9, 0x2d, 0x9d, 0x85, 0x9a, 0x6a, 0xf9, 0xb4, 0x8a, 0x6e, 0x58, 0xe4, 0x46,
	0xbb, 0xa2, 0x2f, 0xda, 0x15, 0x68, 0x0c, 0x0a, 0xb6, 0xa9, 0x2b, 0x86, 0x7e, 0x43, 0x71, 0xf0,
	0x32, 0x5d, 0x8e, 0x7a, 0xe5, 0xbc, 0x6d, 0xea, 0xb3, 0xfa, 0x0d, 0x19, 0x2f, 0xb3, 0x34, 0xd0,
	0xd2, 0xf7, 0x7a, 0x60, 0x24, 0xf0, 0xf6, 0xee, 0xcf, 0x4e, 0xbb, 0x17, 0x06, 0x02, 0x6f, 0x75,
	0x34, 0x17, 0x64, 0x29, 0x28, 0xa5, 0x73, 0xff, 0x3e, 0xea, 0x5b, 0xe9, 0x05, 0x88, 0x3d, 0xa6,
	0x9c, 0xf2, 0x89, 0x89, 0x86, 0x00, 0x79, 0xaa, 0x28, 0x94, 0x77, 0x4a, 0x27, 0x26, 0x0b, 0xad,
	0xd9, 0x8b, 0x6f, 0x59, 0x05, 0xff, 0x9e, 0xbb, 0xb6, 0xd3, 0xab, 0x60, 0x2a, 0x43, 0x45, 0xba,
	0x01, 0xc3, 0x54, 0xec, 0xd4, 0x63, 0x61, 0x01, 0x67, 0xe6, 0x54, 0x9c, 0xb3, 0xb5, 0xeb, 0x69,
	0x25, 0x2e, 0x7c, 0x5d, 0x80, 0xfc, 0xdc, 0xb4, 0x7c, 0xd1, 0x5e, 0x9a, 0x9d, 0x4e, 0xe9, 0x7c,
	0xaf, 0x06, 0xfd, 0xcf, 0xda, 0x4b, 0xc1, 0x41, 0xc9, 0x9e, 0xa9, 0x8b, 0xc4, 0xa4, 0x66, 0x12,
	0x74, 0x75, 0xb2, 0x37, 0xbe, 0x1d, 0xa0, 0x04, 0xe4, 0xbe, 0x67, 0xed, 0xa5, 0x59, 0xdd, 0x95,
	0xfe, 0x24, 0x0b, 0x39, 0x7e, 0x72, 0x9c, 0x8c, 0x8f, 0x48, 0x5a, 0xca, 0xe8, 0x04, 0x10, 0x66,
	0xa4, 0xdc, 0xe5, 0xf8, 0x58, 0x0e, 0x92, 0x51, 0x22, 0x19, 0xfa, 0x6a, 0xaa, 0xa3, 0x56, 0x59,
	0xf5, 0xba, 0x7a, 0x99, 0x79, 0x62, 0x9e, 0x20, 0x62, 0x0f, 0x3b, 0xfe, 0x8c, 0xe8, 0x53, 0x42,
	0x77, 0x01, 0x38, 0xd8, 0xab, 0x3b, 0x96, 0xe2, 0x62, 0xcf, 0x3f, 0xa6, 0x98, 0x67, 0x25, 0x0b,
	0xd8, 0x43, 0x97, 0xa1, 0xe0, 0x7f, 0xa6, 0xb7, 0x62, 0xba, 0x7c, 0x09, 0x8a, 0xb1, 0xf2, 0x19,
	0x2c, 0xfa, 0x77, 0x63, 0x0c, 0x57, 0xa9, 0x39, 0xb6, 0x86, 0xf5, 0xba, 0xe3, 0xbf, 0x01, 0x25,
	0x17, 0x0c, 0x77, 0x9e, 0x17, 0x8d, 0xfe, 0xad, 0x00, 0xf9, 0x40, 0xda, 0xc0, 0x78, 0x17, 0x42,
	0xe3, 0x1d, 0x5d, 0x82, 0x5e, 0xcd, 0x54, 0x5d, 0xd7, 0x37, 0xb3, 0x26, 0xb7, 0xdc, 0x5c, 0xf2,
	0x16, 0xa0, 0x24, 0xcf, 0x12, 0x34, 0x5f, 0x2c, 0x46, 0x23, 0xb8, 0xf0, 0xd3, 0xb3, 0x93, 0xaa,
	0x05, 0x17, 0x7e, 0x74, 0x96, 0x1c, 0x30, 0x4c, 0x83, 0x90, 0x97, 0x0b, 0x7a, 0x98, 0x30, 0x50,
	0xfa, 0xbc, 0x00, 0xc5, 0xe8, 0xd3, 0xdc, 0x29, 0x6b, 0x4e, 0xbb, 0x2d, 0xd0, 0x3f, 0x0a, 0x80,
	0x5a, 0x1f, 0xee, 0x4e, 0x59, 0xb0, 0xab, 0x00, 0x91, 0x17, 0xc7, 0xbb, 0xe9, 0xcf, 0xc8, 0x5b,
	0xe3, 0xbe, 0x9a, 0x85, 0x84, 0xa4, 0x57, 0x05, 0x18, 0x6e, 0x79, 0x13, 0x3c, 0xe5, 0xaa, 0xdd,
	0x05, 0x10, 0x79, 0xcb, 0x9c, 0xa5, 0x4e, 0xcd, 0x9b, 0x5c, 0x18, 0xe9, 0x97, 0x02, 0x1c, 0xed,
	0xf8, 0x5a, 0x78, 0xca, 0xa2, 0x9a, 0x30, 0xd2, 0xee, 0xd9, 0x73, 0xf6, 0xf2, 0xd9, 0xbb, 0x13,
	0x75, 0x47, 0xeb, 0x83, 0xe7, 0xac, 0x57, 0x86, 0xad, 0xe6, 0x0f, 0xd2, 0x9f, 0x41, 0x38, 0x16,
	0xe8, 0xbb, 0xe3, 0xa9, 0x8f, 0x05, 0x7a, 0x25, 0xc5, 0x1f, 0x0b, 0xe4, 0x6f, 0x74, 0x1e, 0xb2,
	0xa6, 0x1a, 0x1c, 0xe2, 0x78, 0x7b, 0xa2, 0x1a, 0xcf, 0xa9, 0x56, 0xa5, 0xae, 0x56, 0xb8, 0xb9,
	0x4a, 0x09, 0x20, 0x1d, 0x0a, 0xec, 0x1a, 0x04, 0x59, 0x92, 0x78, 0x02, 0xbf, 0xc7, 0xbb, 0x7b,
	0xae, 0x7d, 0x82, 0xae, 0x8a, 0xcd, 0xf7, 0x2d, 0x80, 0xde, 0x7d, 0xa0, 0x64, 0x91, 0x0a, 0xf4,
	0x97, 0xb2, 0x6a, 0xe0, 0x35, 0x6e, 0x0e, 0x3f, 0xd6, 0x25, 0x93, 0x6b, 0x06, 0x5e, 0x6b, 0xe6,
	0x91, 0x27, 0x54, 0xc9, 0x87, 0x0e, 0x2f, 0xb1, 0xf6, 0xa5, 0xf5, 0x12, 0x6b, 0xcb, 0x6d, 0x92,
	0xfe, 0xb4, 0x32, 0x4f, 0xc6, 0xb2, 0x4c, 0xe7, 0x52, 0xca, 0x32, 0x3d, 0x7a, 0x33, 0x03, 0x03,
	0xf1, 0x5e, 0x4f, 0xc7, 0x62, 0xda, 0x7f, 0xb7, 0x4b, 0x46, 0x1b, 0x02, 0x94, 0x62, 0xba, 0x9d,
	0x42, 0xa2, 0xd4, 0x34, 0x9b, 0x51, 0xfa, 0x1b, 0x01, 0x86, 0xb8, 0xee, 0xf0, 0x8c, 0xe0, 0x29,
	0x4f, 0xa1, 0x57, 0x20, 0xe7, 0xfa, 0x9c, 0xfd, 0x35, 0x3b, 0xd9, 0x94, 0xc9, 0xc5, 0xf5, 0xa7,
	0x9b, 0x80, 0x88, 0x64, 0xc0, 0x91, 0x0e, 0xaf, 0x67, 0xa2, 0xfb, 0x60, 0xc8, 0xb0, 0x94, 0x53,
	0xa7, 0x95, 0x77, 0x2a, 0xb6, 0xa3, 0x98, 0xaa, 0x87, 0xd9, 0x5b, 0xd7, 0x39, 0xb9, 0x68, 0x58,
	0xa7, 0x4e, 0xbf, 0xf3, 0x8a, 0x33, 0x47, 0xca, 0x38, 0xdc, 0xc3, 0xca, 0xe9, 0x10, 0x2e, 0x13,
	0xc0, 0x3d, 0x7c, 0xda, 0x87, 0x9b, 0x52, 0x6f, 0xbe, 0x31, 0x76, 0xe0, 0xf7, 0x36, 0xc6, 0x84,
	0x9b, 0x1b, 0x63, 0xc2, 0x6b, 0x1b, 0x63, 0xc2, 0xf7, 0x37, 0xc6, 0x84, 0x7f, 0xda, 0x18, 0x13,
	0x3e, 0xff, 0xe6, 0xd8, 0x81, 0xd7, 0xde, 0x1c, 0x3b, 0xf0, 0xfd, 0x37, 0xc7, 0x0e, 0x3c, 0xd3,
	0x45, 0x67, 0x45, 0xe7, 0xd9, 0x49, 0x32, 0xcf, 0x2e, 0xf5, 0xd5, 0x1c, 0xdb, 0xb3, 0x4f, 0xff,
	0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4, 0xe6, 0x16, 0x73, 0x9f, 0xa9, 0x00, 0x00,
}

func (this *ElementProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto)
	if !ok {
		that2, ok := that.(ElementProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ElementOneOf == nil {
		if this.ElementOneOf != nil {
			return false
		}
	} else if this.ElementOneOf == nil {
		return false
	} else if !this.ElementOneOf.Equal(that1.ElementOneOf) {
		return false
	}
	return true
}
func (this *ElementProto_Database) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Database)
	if !ok {
		that2, ok := that.(ElementProto_Database)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Database.Equal(that1.Database) {
		return false
	}
	return true
}
func (this *ElementProto_Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Schema)
	if !ok {
		that2, ok := that.(ElementProto_Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Schema.Equal(that1.Schema) {
		return false
	}
	return true
}
func (this *ElementProto_View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_View)
	if !ok {
		that2, ok := that.(ElementProto_View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.View.Equal(that1.View) {
		return false
	}
	return true
}
func (this *ElementProto_Sequence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Sequence)
	if !ok {
		that2, ok := that.(ElementProto_Sequence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sequence.Equal(that1.Sequence) {
		return false
	}
	return true
}
func (this *ElementProto_Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Table)
	if !ok {
		that2, ok := that.(ElementProto_Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Table.Equal(that1.Table) {
		return false
	}
	return true
}
func (this *ElementProto_EnumType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_EnumType)
	if !ok {
		that2, ok := that.(ElementProto_EnumType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnumType.Equal(that1.EnumType) {
		return false
	}
	return true
}
func (this *ElementProto_AliasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_AliasType)
	if !ok {
		that2, ok := that.(ElementProto_AliasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AliasType.Equal(that1.AliasType) {
		return false
	}
	return true
}
func (this *ElementProto_CompositeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CompositeType)
	if !ok {
		that2, ok := that.(ElementProto_CompositeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CompositeType.Equal(that1.CompositeType) {
		return false
	}
	return true
}
func (this *ElementProto_Function) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Function)
	if !ok {
		that2, ok := that.(ElementProto_Function)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Function.Equal(that1.Function) {
		return false
	}
	return true
}
func (this *ElementProto_NamedRangeZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_NamedRangeZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_NamedRangeZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NamedRangeZoneConfig.Equal(that1.NamedRangeZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnFamily) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnFamily)
	if !ok {
		that2, ok := that.(ElementProto_ColumnFamily)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnFamily.Equal(that1.ColumnFamily) {
		return false
	}
	return true
}
func (this *ElementProto_Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Column)
	if !ok {
		that2, ok := that.(ElementProto_Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	return true
}
func (this *ElementProto_PrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PrimaryIndex)
	if !ok {
		that2, ok := that.(ElementProto_PrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrimaryIndex.Equal(that1.PrimaryIndex) {
		return false
	}
	return true
}
func (this *ElementProto_SecondaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SecondaryIndex)
	if !ok {
		that2, ok := that.(ElementProto_SecondaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecondaryIndex.Equal(that1.SecondaryIndex) {
		return false
	}
	return true
}
func (this *ElementProto_TemporaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TemporaryIndex)
	if !ok {
		that2, ok := that.(ElementProto_TemporaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TemporaryIndex.Equal(that1.TemporaryIndex) {
		return false
	}
	return true
}
func (this *ElementProto_UniqueWithoutIndexConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_UniqueWithoutIndexConstraint)
	if !ok {
		that2, ok := that.(ElementProto_UniqueWithoutIndexConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniqueWithoutIndexConstraint.Equal(that1.UniqueWithoutIndexConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_UniqueWithoutIndexConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_UniqueWithoutIndexConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ElementProto_UniqueWithoutIndexConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniqueWithoutIndexConstraintUnvalidated.Equal(that1.UniqueWithoutIndexConstraintUnvalidated) {
		return false
	}
	return true
}
func (this *ElementProto_CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CheckConstraint)
	if !ok {
		that2, ok := that.(ElementProto_CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckConstraint.Equal(that1.CheckConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_CheckConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CheckConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ElementProto_CheckConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckConstraintUnvalidated.Equal(that1.CheckConstraintUnvalidated) {
		return false
	}
	return true
}
func (this *ElementProto_ForeignKeyConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ForeignKeyConstraint)
	if !ok {
		that2, ok := that.(ElementProto_ForeignKeyConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForeignKeyConstraint.Equal(that1.ForeignKeyConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_ForeignKeyConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ForeignKeyConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ElementProto_ForeignKeyConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForeignKeyConstraintUnvalidated.Equal(that1.ForeignKeyConstraintUnvalidated) {
		return false
	}
	return true
}
func (this *ElementProto_TableComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableComment)
	if !ok {
		that2, ok := that.(ElementProto_TableComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableComment.Equal(that1.TableComment) {
		return false
	}
	return true
}
func (this *ElementProto_RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_RowLevelTTL)
	if !ok {
		that2, ok := that.(ElementProto_RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RowLevelTTL.Equal(that1.RowLevelTTL) {
		return false
	}
	return true
}
func (this *ElementProto_TableZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_TableZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableZoneConfig.Equal(that1.TableZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_IndexZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_IndexZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexZoneConfig.Equal(that1.IndexZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_TableData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableData)
	if !ok {
		that2, ok := that.(ElementProto_TableData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableData.Equal(that1.TableData) {
		return false
	}
	return true
}
func (this *ElementProto_TablePartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TablePartitioning)
	if !ok {
		that2, ok := that.(ElementProto_TablePartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TablePartitioning.Equal(that1.TablePartitioning) {
		return false
	}
	return true
}
func (this *ElementProto_TableSchemaLocked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableSchemaLocked)
	if !ok {
		that2, ok := that.(ElementProto_TableSchemaLocked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableSchemaLocked.Equal(that1.TableSchemaLocked) {
		return false
	}
	return true
}
func (this *ElementProto_LDRJobIDs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_LDRJobIDs)
	if !ok {
		that2, ok := that.(ElementProto_LDRJobIDs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LDRJobIDs.Equal(that1.LDRJobIDs) {
		return false
	}
	return true
}
func (this *ElementProto_PartitionZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PartitionZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_PartitionZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PartitionZoneConfig.Equal(that1.PartitionZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_Trigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Trigger)
	if !ok {
		that2, ok := that.(ElementProto_Trigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Trigger.Equal(that1.Trigger) {
		return false
	}
	return true
}
func (this *ElementProto_Policy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Policy)
	if !ok {
		that2, ok := that.(ElementProto_Policy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	return true
}
func (this *ElementProto_RowLevelSecurityEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_RowLevelSecurityEnabled)
	if !ok {
		that2, ok := that.(ElementProto_RowLevelSecurityEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RowLevelSecurityEnabled.Equal(that1.RowLevelSecurityEnabled) {
		return false
	}
	return true
}
func (this *ElementProto_RowLevelSecurityForced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_RowLevelSecurityForced)
	if !ok {
		that2, ok := that.(ElementProto_RowLevelSecurityForced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RowLevelSecurityForced.Equal(that1.RowLevelSecurityForced) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityGlobal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityGlobal)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityGlobal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityGlobal.Equal(that1.TableLocalityGlobal) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityPrimaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityPrimaryRegion)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityPrimaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityPrimaryRegion.Equal(that1.TableLocalityPrimaryRegion) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalitySecondaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalitySecondaryRegion)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalitySecondaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalitySecondaryRegion.Equal(that1.TableLocalitySecondaryRegion) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityRegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityRegionalByRow)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityRegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityRegionalByRow.Equal(that1.TableLocalityRegionalByRow) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityRegionalByRowUsingConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityRegionalByRowUsingConstraint)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityRegionalByRowUsingConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityRegionalByRowUsingConstraint.Equal(that1.TableLocalityRegionalByRowUsingConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnName)
	if !ok {
		that2, ok := that.(ElementProto_ColumnName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnName.Equal(that1.ColumnName) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnType)
	if !ok {
		that2, ok := that.(ElementProto_ColumnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnType.Equal(that1.ColumnType) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnDefaultExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnDefaultExpression)
	if !ok {
		that2, ok := that.(ElementProto_ColumnDefaultExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnDefaultExpression.Equal(that1.ColumnDefaultExpression) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnOnUpdateExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnOnUpdateExpression)
	if !ok {
		that2, ok := that.(ElementProto_ColumnOnUpdateExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnOnUpdateExpression.Equal(that1.ColumnOnUpdateExpression) {
		return false
	}
	return true
}
func (this *ElementProto_SequenceOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SequenceOwner)
	if !ok {
		that2, ok := that.(ElementProto_SequenceOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SequenceOwner.Equal(that1.SequenceOwner) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnComment)
	if !ok {
		that2, ok := that.(ElementProto_ColumnComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnComment.Equal(that1.ColumnComment) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnNotNull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnNotNull)
	if !ok {
		that2, ok := that.(ElementProto_ColumnNotNull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnNotNull.Equal(that1.ColumnNotNull) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnComputeExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnComputeExpression)
	if !ok {
		that2, ok := that.(ElementProto_ColumnComputeExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnComputeExpression.Equal(that1.ColumnComputeExpression) {
		return false
	}
	return true
}
func (this *ElementProto_SequenceOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SequenceOption)
	if !ok {
		that2, ok := that.(ElementProto_SequenceOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SequenceOption.Equal(that1.SequenceOption) {
		return false
	}
	return true
}
func (this *ElementProto_IndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexName)
	if !ok {
		that2, ok := that.(ElementProto_IndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexName.Equal(that1.IndexName) {
		return false
	}
	return true
}
func (this *ElementProto_IndexPartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexPartitioning)
	if !ok {
		that2, ok := that.(ElementProto_IndexPartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexPartitioning.Equal(that1.IndexPartitioning) {
		return false
	}
	return true
}
func (this *ElementProto_IndexComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexComment)
	if !ok {
		that2, ok := that.(ElementProto_IndexComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexComment.Equal(that1.IndexComment) {
		return false
	}
	return true
}
func (this *ElementProto_IndexColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexColumn)
	if !ok {
		that2, ok := that.(ElementProto_IndexColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexColumn.Equal(that1.IndexColumn) {
		return false
	}
	return true
}
func (this *ElementProto_IndexData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexData)
	if !ok {
		that2, ok := that.(ElementProto_IndexData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexData.Equal(that1.IndexData) {
		return false
	}
	return true
}
func (this *ElementProto_ConstraintWithoutIndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ConstraintWithoutIndexName)
	if !ok {
		that2, ok := that.(ElementProto_ConstraintWithoutIndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConstraintWithoutIndexName.Equal(that1.ConstraintWithoutIndexName) {
		return false
	}
	return true
}
func (this *ElementProto_ConstraintComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ConstraintComment)
	if !ok {
		that2, ok := that.(ElementProto_ConstraintComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConstraintComment.Equal(that1.ConstraintComment) {
		return false
	}
	return true
}
func (this *ElementProto_Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Namespace)
	if !ok {
		that2, ok := that.(ElementProto_Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Namespace.Equal(that1.Namespace) {
		return false
	}
	return true
}
func (this *ElementProto_Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Owner)
	if !ok {
		that2, ok := that.(ElementProto_Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Owner.Equal(that1.Owner) {
		return false
	}
	return true
}
func (this *ElementProto_UserPrivileges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_UserPrivileges)
	if !ok {
		that2, ok := that.(ElementProto_UserPrivileges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UserPrivileges.Equal(that1.UserPrivileges) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseRegionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseRegionConfig)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseRegionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseRegionConfig.Equal(that1.DatabaseRegionConfig) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseRoleSetting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseRoleSetting)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseRoleSetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseRoleSetting.Equal(that1.DatabaseRoleSetting) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseComment)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseComment.Equal(that1.DatabaseComment) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseData)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseData.Equal(that1.DatabaseData) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseZoneConfig.Equal(that1.DatabaseZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_SchemaParent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SchemaParent)
	if !ok {
		that2, ok := that.(ElementProto_SchemaParent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemaParent.Equal(that1.SchemaParent) {
		return false
	}
	return true
}
func (this *ElementProto_SchemaComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SchemaComment)
	if !ok {
		that2, ok := that.(ElementProto_SchemaComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemaComment.Equal(that1.SchemaComment) {
		return false
	}
	return true
}
func (this *ElementProto_SchemaChild) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SchemaChild)
	if !ok {
		that2, ok := that.(ElementProto_SchemaChild)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemaChild.Equal(that1.SchemaChild) {
		return false
	}
	return true
}
func (this *ElementProto_EnumTypeValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_EnumTypeValue)
	if !ok {
		that2, ok := that.(ElementProto_EnumTypeValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnumTypeValue.Equal(that1.EnumTypeValue) {
		return false
	}
	return true
}
func (this *ElementProto_CompositeTypeAttrType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CompositeTypeAttrType)
	if !ok {
		that2, ok := that.(ElementProto_CompositeTypeAttrType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CompositeTypeAttrType.Equal(that1.CompositeTypeAttrType) {
		return false
	}
	return true
}
func (this *ElementProto_CompositeTypeAttrName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CompositeTypeAttrName)
	if !ok {
		that2, ok := that.(ElementProto_CompositeTypeAttrName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CompositeTypeAttrName.Equal(that1.CompositeTypeAttrName) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionName)
	if !ok {
		that2, ok := that.(ElementProto_FunctionName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionName.Equal(that1.FunctionName) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionVolatility) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionVolatility)
	if !ok {
		that2, ok := that.(ElementProto_FunctionVolatility)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionVolatility.Equal(that1.FunctionVolatility) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionLeakProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionLeakProof)
	if !ok {
		that2, ok := that.(ElementProto_FunctionLeakProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionLeakProof.Equal(that1.FunctionLeakProof) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionNullInputBehavior) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionNullInputBehavior)
	if !ok {
		that2, ok := that.(ElementProto_FunctionNullInputBehavior)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionNullInputBehavior.Equal(that1.FunctionNullInputBehavior) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionBody) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionBody)
	if !ok {
		that2, ok := that.(ElementProto_FunctionBody)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionBody.Equal(that1.FunctionBody) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionSecurity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionSecurity)
	if !ok {
		that2, ok := that.(ElementProto_FunctionSecurity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionSecurity.Equal(that1.FunctionSecurity) {
		return false
	}
	return true
}
func (this *ElementProto_TypeComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TypeComment)
	if !ok {
		that2, ok := that.(ElementProto_TypeComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TypeComment.Equal(that1.TypeComment) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerName)
	if !ok {
		that2, ok := that.(ElementProto_TriggerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerName.Equal(that1.TriggerName) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerEnabled)
	if !ok {
		that2, ok := that.(ElementProto_TriggerEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerEnabled.Equal(that1.TriggerEnabled) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerTiming) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerTiming)
	if !ok {
		that2, ok := that.(ElementProto_TriggerTiming)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerTiming.Equal(that1.TriggerTiming) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerEvents) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerEvents)
	if !ok {
		that2, ok := that.(ElementProto_TriggerEvents)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerEvents.Equal(that1.TriggerEvents) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerTransition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerTransition)
	if !ok {
		that2, ok := that.(ElementProto_TriggerTransition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerTransition.Equal(that1.TriggerTransition) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerWhen) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerWhen)
	if !ok {
		that2, ok := that.(ElementProto_TriggerWhen)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerWhen.Equal(that1.TriggerWhen) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerFunctionCall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerFunctionCall)
	if !ok {
		that2, ok := that.(ElementProto_TriggerFunctionCall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerFunctionCall.Equal(that1.TriggerFunctionCall) {
		return false
	}
	return true
}
func (this *ElementProto_TriggerDeps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TriggerDeps)
	if !ok {
		that2, ok := that.(ElementProto_TriggerDeps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerDeps.Equal(that1.TriggerDeps) {
		return false
	}
	return true
}
func (this *ElementProto_PolicyName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PolicyName)
	if !ok {
		that2, ok := that.(ElementProto_PolicyName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PolicyName.Equal(that1.PolicyName) {
		return false
	}
	return true
}
func (this *ElementProto_PolicyRole) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PolicyRole)
	if !ok {
		that2, ok := that.(ElementProto_PolicyRole)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PolicyRole.Equal(that1.PolicyRole) {
		return false
	}
	return true
}
func (this *ElementProto_PolicyUsingExpr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PolicyUsingExpr)
	if !ok {
		that2, ok := that.(ElementProto_PolicyUsingExpr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PolicyUsingExpr.Equal(that1.PolicyUsingExpr) {
		return false
	}
	return true
}
func (this *ElementProto_PolicyWithCheckExpr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PolicyWithCheckExpr)
	if !ok {
		that2, ok := that.(ElementProto_PolicyWithCheckExpr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PolicyWithCheckExpr.Equal(that1.PolicyWithCheckExpr) {
		return false
	}
	return true
}
func (this *ElementProto_PolicyDeps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PolicyDeps)
	if !ok {
		that2, ok := that.(ElementProto_PolicyDeps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PolicyDeps.Equal(that1.PolicyDeps) {
		return false
	}
	return true
}
func (this *TypeT) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeT)
	if !ok {
		that2, ok := that.(TypeT)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if len(this.ClosedTypeIDs) != len(that1.ClosedTypeIDs) {
		return false
	}
	for i := range this.ClosedTypeIDs {
		if this.ClosedTypeIDs[i] != that1.ClosedTypeIDs[i] {
			return false
		}
	}
	if this.TypeName != that1.TypeName {
		return false
	}
	return true
}
func (this *Expression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression)
	if !ok {
		that2, ok := that.(Expression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if len(this.UsesFunctionIDs) != len(that1.UsesFunctionIDs) {
		return false
	}
	for i := range this.UsesFunctionIDs {
		if this.UsesFunctionIDs[i] != that1.UsesFunctionIDs[i] {
			return false
		}
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	if this.IsInaccessible != that1.IsInaccessible {
		return false
	}
	if this.GeneratedAsIdentityType != that1.GeneratedAsIdentityType {
		return false
	}
	if this.GeneratedAsIdentitySequenceOption != that1.GeneratedAsIdentitySequenceOption {
		return false
	}
	if this.PgAttributeNum != that1.PgAttributeNum {
		return false
	}
	if this.IsSystemColumn != that1.IsSystemColumn {
		return false
	}
	return true
}
func (this *ColumnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnType)
	if !ok {
		that2, ok := that.(ColumnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	if this.IsNullable != that1.IsNullable {
		return false
	}
	if !this.ComputeExpr.Equal(that1.ComputeExpr) {
		return false
	}
	if this.IsVirtual != that1.IsVirtual {
		return false
	}
	if !this.ElementCreationMetadata.Equal(that1.ElementCreationMetadata) {
		return false
	}
	if this.ColumnFamilyOrderFollowsColumnID != that1.ColumnFamilyOrderFollowsColumnID {
		return false
	}
	return true
}
func (this *ColumnComputeExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnComputeExpression)
	if !ok {
		that2, ok := that.(ColumnComputeExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	if this.Usage != that1.Usage {
		return false
	}
	return true
}
func (this *ColumnFamily) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnFamily)
	if !ok {
		that2, ok := that.(ColumnFamily)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Index) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Index)
	if !ok {
		that2, ok := that.(Index)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.IsUnique != that1.IsUnique {
		return false
	}
	if this.IsInverted != that1.IsInverted {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Sharding.Equal(that1.Sharding) {
		return false
	}
	if this.IsCreatedExplicitly != that1.IsCreatedExplicitly {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.IsConcurrently != that1.IsConcurrently {
		return false
	}
	if this.SourceIndexID != that1.SourceIndexID {
		return false
	}
	if this.TemporaryIndexID != that1.TemporaryIndexID {
		return false
	}
	if !this.GeoConfig.Equal(that1.GeoConfig) {
		return false
	}
	if this.IsNotVisible != that1.IsNotVisible {
		return false
	}
	if this.Invisibility != that1.Invisibility {
		return false
	}
	if !this.VecConfig.Equal(that1.VecConfig) {
		return false
	}
	return true
}
func (this *PrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrimaryIndex)
	if !ok {
		that2, ok := that.(PrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	return true
}
func (this *SecondaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecondaryIndex)
	if !ok {
		that2, ok := that.(SecondaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if !this.EmbeddedExpr.Equal(that1.EmbeddedExpr) {
		return false
	}
	if this.RecreateSourceIndexID != that1.RecreateSourceIndexID {
		return false
	}
	if this.RecreateTargetIndexID != that1.RecreateTargetIndexID {
		return false
	}
	if this.HideForPrimaryKeyRecreated != that1.HideForPrimaryKeyRecreated {
		return false
	}
	return true
}
func (this *TemporaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemporaryIndex)
	if !ok {
		that2, ok := that.(TemporaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if this.IsUsingSecondaryEncoding != that1.IsUsingSecondaryEncoding {
		return false
	}
	if !this.Expr.Equal(that1.Expr) {
		return false
	}
	return true
}
func (this *SchemaParent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaParent)
	if !ok {
		that2, ok := that.(SchemaParent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.ParentDatabaseID != that1.ParentDatabaseID {
		return false
	}
	return true
}
func (this *SchemaChild) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaChild)
	if !ok {
		that2, ok := that.(SchemaChild)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChildObjectID != that1.ChildObjectID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	return true
}
func (this *Policy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Policy)
	if !ok {
		that2, ok := that.(Policy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.PolicyID != that1.PolicyID {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Command != that1.Command {
		return false
	}
	return true
}
func (this *PolicyName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyName)
	if !ok {
		that2, ok := that.(PolicyName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.PolicyID != that1.PolicyID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *PolicyRole) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyRole)
	if !ok {
		that2, ok := that.(PolicyRole)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.PolicyID != that1.PolicyID {
		return false
	}
	if this.RoleName != that1.RoleName {
		return false
	}
	return true
}
func (this *PolicyUsingExpr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyUsingExpr)
	if !ok {
		that2, ok := that.(PolicyUsingExpr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.PolicyID != that1.PolicyID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *PolicyWithCheckExpr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyWithCheckExpr)
	if !ok {
		that2, ok := that.(PolicyWithCheckExpr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.PolicyID != that1.PolicyID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *PolicyDeps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyDeps)
	if !ok {
		that2, ok := that.(PolicyDeps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.PolicyID != that1.PolicyID {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesRelationIDs) != len(that1.UsesRelationIDs) {
		return false
	}
	for i := range this.UsesRelationIDs {
		if this.UsesRelationIDs[i] != that1.UsesRelationIDs[i] {
			return false
		}
	}
	if len(this.UsesFunctionIDs) != len(that1.UsesFunctionIDs) {
		return false
	}
	for i := range this.UsesFunctionIDs {
		if this.UsesFunctionIDs[i] != that1.UsesFunctionIDs[i] {
			return false
		}
	}
	return true
}
func (this *RowLevelSecurityEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelSecurityEnabled)
	if !ok {
		that2, ok := that.(RowLevelSecurityEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *RowLevelSecurityForced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelSecurityForced)
	if !ok {
		that2, ok := that.(RowLevelSecurityForced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IsForced != that1.IsForced {
		return false
	}
	return true
}
func (this *Sequence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sequence)
	if !ok {
		that2, ok := that.(Sequence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.RestartWith != that1.RestartWith {
		return false
	}
	if this.UseRestartWith != that1.UseRestartWith {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	return true
}
func (this *SequenceOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceOption)
	if !ok {
		that2, ok := that.(SequenceOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *SequenceOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceOwner)
	if !ok {
		that2, ok := that.(SequenceOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *ColumnDefaultExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnDefaultExpression)
	if !ok {
		that2, ok := that.(ColumnDefaultExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *ColumnOnUpdateExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOnUpdateExpression)
	if !ok {
		that2, ok := that.(ColumnOnUpdateExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*View)
	if !ok {
		that2, ok := that.(View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ViewID != that1.ViewID {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesRelationIDs) != len(that1.UsesRelationIDs) {
		return false
	}
	for i := range this.UsesRelationIDs {
		if this.UsesRelationIDs[i] != that1.UsesRelationIDs[i] {
			return false
		}
	}
	if len(this.UsesRoutineIDs) != len(that1.UsesRoutineIDs) {
		return false
	}
	for i := range this.UsesRoutineIDs {
		if this.UsesRoutineIDs[i] != that1.UsesRoutineIDs[i] {
			return false
		}
	}
	if len(this.ForwardReferences) != len(that1.ForwardReferences) {
		return false
	}
	for i := range this.ForwardReferences {
		if !this.ForwardReferences[i].Equal(that1.ForwardReferences[i]) {
			return false
		}
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	if this.IsMaterialized != that1.IsMaterialized {
		return false
	}
	return true
}
func (this *View_Reference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*View_Reference)
	if !ok {
		that2, ok := that.(View_Reference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ToID != that1.ToID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Table)
	if !ok {
		that2, ok := that.(Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	return true
}
func (this *UniqueWithoutIndexConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueWithoutIndexConstraint)
	if !ok {
		that2, ok := that.(UniqueWithoutIndexConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Predicate.Equal(that1.Predicate) {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *UniqueWithoutIndexConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueWithoutIndexConstraintUnvalidated)
	if !ok {
		that2, ok := that.(UniqueWithoutIndexConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Predicate.Equal(that1.Predicate) {
		return false
	}
	return true
}
func (this *CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraint)
	if !ok {
		that2, ok := that.(CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	if this.FromHashShardedColumn != that1.FromHashShardedColumn {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *CheckConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraintUnvalidated)
	if !ok {
		that2, ok := that.(CheckConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *ForeignKeyConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyConstraint)
	if !ok {
		that2, ok := that.(ForeignKeyConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.ReferencedTableID != that1.ReferencedTableID {
		return false
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if this.OnUpdateAction != that1.OnUpdateAction {
		return false
	}
	if this.OnDeleteAction != that1.OnDeleteAction {
		return false
	}
	if this.CompositeKeyMatchMethod != that1.CompositeKeyMatchMethod {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *ForeignKeyConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ForeignKeyConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.ReferencedTableID != that1.ReferencedTableID {
		return false
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if this.OnUpdateAction != that1.OnUpdateAction {
		return false
	}
	if this.OnDeleteAction != that1.OnDeleteAction {
		return false
	}
	if this.CompositeKeyMatchMethod != that1.CompositeKeyMatchMethod {
		return false
	}
	return true
}
func (this *Trigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Trigger)
	if !ok {
		that2, ok := that.(Trigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	return true
}
func (this *TriggerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerName)
	if !ok {
		that2, ok := that.(TriggerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *TriggerEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerEnabled)
	if !ok {
		that2, ok := that.(TriggerEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *TriggerTiming) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerTiming)
	if !ok {
		that2, ok := that.(TriggerTiming)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if this.ActionTime != that1.ActionTime {
		return false
	}
	if this.ForEachRow != that1.ForEachRow {
		return false
	}
	return true
}
func (this *TriggerEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerEvent)
	if !ok {
		that2, ok := that.(TriggerEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	return true
}
func (this *TriggerEvents) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerEvents)
	if !ok {
		that2, ok := that.(TriggerEvents)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	return true
}
func (this *TriggerTransition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerTransition)
	if !ok {
		that2, ok := that.(TriggerTransition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if this.NewTransitionAlias != that1.NewTransitionAlias {
		return false
	}
	if this.OldTransitionAlias != that1.OldTransitionAlias {
		return false
	}
	return true
}
func (this *TriggerWhen) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerWhen)
	if !ok {
		that2, ok := that.(TriggerWhen)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if this.WhenExpr != that1.WhenExpr {
		return false
	}
	return true
}
func (this *TriggerFunctionCall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerFunctionCall)
	if !ok {
		that2, ok := that.(TriggerFunctionCall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if this.FuncID != that1.FuncID {
		return false
	}
	if len(this.FuncArgs) != len(that1.FuncArgs) {
		return false
	}
	for i := range this.FuncArgs {
		if this.FuncArgs[i] != that1.FuncArgs[i] {
			return false
		}
	}
	if this.FuncBody != that1.FuncBody {
		return false
	}
	return true
}
func (this *TriggerDeps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerDeps)
	if !ok {
		that2, ok := that.(TriggerDeps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TriggerID != that1.TriggerID {
		return false
	}
	if len(this.UsesRelationIDs) != len(that1.UsesRelationIDs) {
		return false
	}
	for i := range this.UsesRelationIDs {
		if this.UsesRelationIDs[i] != that1.UsesRelationIDs[i] {
			return false
		}
	}
	if len(this.UsesRelations) != len(that1.UsesRelations) {
		return false
	}
	for i := range this.UsesRelations {
		if !this.UsesRelations[i].Equal(&that1.UsesRelations[i]) {
			return false
		}
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesRoutineIDs) != len(that1.UsesRoutineIDs) {
		return false
	}
	for i := range this.UsesRoutineIDs {
		if this.UsesRoutineIDs[i] != that1.UsesRoutineIDs[i] {
			return false
		}
	}
	return true
}
func (this *TriggerDeps_RelationReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerDeps_RelationReference)
	if !ok {
		that2, ok := that.(TriggerDeps_RelationReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	return true
}
func (this *EnumType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnumType)
	if !ok {
		that2, ok := that.(EnumType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.ArrayTypeID != that1.ArrayTypeID {
		return false
	}
	if this.IsMultiRegion != that1.IsMultiRegion {
		return false
	}
	return true
}
func (this *AliasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasType)
	if !ok {
		that2, ok := that.(AliasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	return true
}
func (this *CompositeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompositeType)
	if !ok {
		that2, ok := that.(CompositeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.ArrayTypeID != that1.ArrayTypeID {
		return false
	}
	return true
}
func (this *Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema)
	if !ok {
		that2, ok := that.(Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	if this.IsPublic != that1.IsPublic {
		return false
	}
	if this.IsVirtual != that1.IsVirtual {
		return false
	}
	return true
}
func (this *Database) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Database)
	if !ok {
		that2, ok := that.(Database)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Namespace)
	if !ok {
		that2, ok := that.(Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Owner)
	if !ok {
		that2, ok := that.(Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	return true
}
func (this *UserPrivileges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserPrivileges)
	if !ok {
		that2, ok := that.(UserPrivileges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if this.Privileges != that1.Privileges {
		return false
	}
	if this.WithGrantOption != that1.WithGrantOption {
		return false
	}
	return true
}
func (this *NamedRangeZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedRangeZoneConfig)
	if !ok {
		that2, ok := that.(NamedRangeZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RangeID != that1.RangeID {
		return false
	}
	if !this.ZoneConfig.Equal(that1.ZoneConfig) {
		return false
	}
	if this.SeqNum != that1.SeqNum {
		return false
	}
	return true
}
func (this *TableLocalityGlobal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityGlobal)
	if !ok {
		that2, ok := that.(TableLocalityGlobal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableLocalityPrimaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityPrimaryRegion)
	if !ok {
		that2, ok := that.(TableLocalityPrimaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableLocalitySecondaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalitySecondaryRegion)
	if !ok {
		that2, ok := that.(TableLocalitySecondaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.RegionEnumTypeID != that1.RegionEnumTypeID {
		return false
	}
	if this.RegionName != that1.RegionName {
		return false
	}
	return true
}
func (this *TableLocalityRegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityRegionalByRow)
	if !ok {
		that2, ok := that.(TableLocalityRegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.As != that1.As {
		return false
	}
	return true
}
func (this *TableLocalityRegionalByRowUsingConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityRegionalByRowUsingConstraint)
	if !ok {
		that2, ok := that.(TableLocalityRegionalByRowUsingConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	return true
}
func (this *IndexPartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexPartitioning)
	if !ok {
		that2, ok := that.(IndexPartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.PartitioningDescriptor.Equal(&that1.PartitioningDescriptor) {
		return false
	}
	return true
}
func (this *RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelTTL)
	if !ok {
		that2, ok := that.(RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.RowLevelTTL.Equal(&that1.RowLevelTTL) {
		return false
	}
	if !this.TTLExpr.Equal(that1.TTLExpr) {
		return false
	}
	return true
}
func (this *ColumnName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnName)
	if !ok {
		that2, ok := that.(ColumnName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *IndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexName)
	if !ok {
		that2, ok := that.(IndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ConstraintWithoutIndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintWithoutIndexName)
	if !ok {
		that2, ok := that.(ConstraintWithoutIndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *TableComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableComment)
	if !ok {
		that2, ok := that.(TableComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *TypeComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeComment)
	if !ok {
		that2, ok := that.(TypeComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseComment)
	if !ok {
		that2, ok := that.(DatabaseComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *SchemaComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaComment)
	if !ok {
		that2, ok := that.(SchemaComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *IndexComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexComment)
	if !ok {
		that2, ok := that.(IndexComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *ColumnComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnComment)
	if !ok {
		that2, ok := that.(ColumnComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.PgAttributeNum != that1.PgAttributeNum {
		return false
	}
	return true
}
func (this *ColumnNotNull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnNotNull)
	if !ok {
		that2, ok := that.(ColumnNotNull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *ConstraintComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintComment)
	if !ok {
		that2, ok := that.(ConstraintComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseRegionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRegionConfig)
	if !ok {
		that2, ok := that.(DatabaseRegionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RegionEnumTypeID != that1.RegionEnumTypeID {
		return false
	}
	return true
}
func (this *DatabaseRoleSetting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRoleSetting)
	if !ok {
		that2, ok := that.(DatabaseRoleSetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RoleName != that1.RoleName {
		return false
	}
	return true
}
func (this *IndexColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexColumn)
	if !ok {
		that2, ok := that.(IndexColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.OrdinalInKind != that1.OrdinalInKind {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.Implicit != that1.Implicit {
		return false
	}
	if this.InvertedKind != that1.InvertedKind {
		return false
	}
	return true
}
func (this *EnumTypeValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnumTypeValue)
	if !ok {
		that2, ok := that.(EnumTypeValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if !bytes.Equal(this.PhysicalRepresentation, that1.PhysicalRepresentation) {
		return false
	}
	if this.LogicalRepresentation != that1.LogicalRepresentation {
		return false
	}
	return true
}
func (this *CompositeTypeAttrName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompositeTypeAttrName)
	if !ok {
		that2, ok := that.(CompositeTypeAttrName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CompositeTypeID != that1.CompositeTypeID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *CompositeTypeAttrType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompositeTypeAttrType)
	if !ok {
		that2, ok := that.(CompositeTypeAttrType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CompositeTypeID != that1.CompositeTypeID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	return true
}
func (this *DatabaseZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseZoneConfig)
	if !ok {
		that2, ok := that.(DatabaseZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if !this.ZoneConfig.Equal(that1.ZoneConfig) {
		return false
	}
	if this.SeqNum != that1.SeqNum {
		return false
	}
	return true
}
func (this *TableZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableZoneConfig)
	if !ok {
		that2, ok := that.(TableZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.ZoneConfig.Equal(that1.ZoneConfig) {
		return false
	}
	if this.SeqNum != that1.SeqNum {
		return false
	}
	return true
}
func (this *IndexZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexZoneConfig)
	if !ok {
		that2, ok := that.(IndexZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.Subzone.Equal(&that1.Subzone) {
		return false
	}
	if len(this.SubzoneSpans) != len(that1.SubzoneSpans) {
		return false
	}
	for i := range this.SubzoneSpans {
		if !this.SubzoneSpans[i].Equal(&that1.SubzoneSpans[i]) {
			return false
		}
	}
	if this.SeqNum != that1.SeqNum {
		return false
	}
	if this.OldIdxRef != that1.OldIdxRef {
		return false
	}
	return true
}
func (this *PartitionZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitionZoneConfig)
	if !ok {
		that2, ok := that.(PartitionZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.PartitionName != that1.PartitionName {
		return false
	}
	if !this.Subzone.Equal(&that1.Subzone) {
		return false
	}
	if len(this.SubzoneSpans) != len(that1.SubzoneSpans) {
		return false
	}
	for i := range this.SubzoneSpans {
		if !this.SubzoneSpans[i].Equal(&that1.SubzoneSpans[i]) {
			return false
		}
	}
	if this.SeqNum != that1.SeqNum {
		return false
	}
	if this.OldIdxRef != that1.OldIdxRef {
		return false
	}
	return true
}
func (this *DatabaseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseData)
	if !ok {
		that2, ok := that.(DatabaseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *TableData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableData)
	if !ok {
		that2, ok := that.(TableData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *IndexData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexData)
	if !ok {
		that2, ok := that.(IndexData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	return true
}
func (this *TablePartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TablePartitioning)
	if !ok {
		that2, ok := that.(TablePartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableSchemaLocked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableSchemaLocked)
	if !ok {
		that2, ok := that.(TableSchemaLocked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *LDRJobIDs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LDRJobIDs)
	if !ok {
		that2, ok := that.(LDRJobIDs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if len(this.JobIDs) != len(that1.JobIDs) {
		return false
	}
	for i := range this.JobIDs {
		if this.JobIDs[i] != that1.JobIDs[i] {
			return false
		}
	}
	return true
}
func (this *Function) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Function)
	if !ok {
		that2, ok := that.(Function)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(&that1.Params[i]) {
			return false
		}
	}
	if this.ReturnSet != that1.ReturnSet {
		return false
	}
	if !this.ReturnType.Equal(&that1.ReturnType) {
		return false
	}
	if this.IsProcedure != that1.IsProcedure {
		return false
	}
	return true
}
func (this *Function_Parameter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Function_Parameter)
	if !ok {
		that2, ok := that.(Function_Parameter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Class.Equal(&that1.Class) {
		return false
	}
	if !this.Type.Equal(&that1.Type) {
		return false
	}
	if this.DefaultExpr != that1.DefaultExpr {
		return false
	}
	return true
}
func (this *FunctionName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionName)
	if !ok {
		that2, ok := that.(FunctionName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *FunctionVolatility) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionVolatility)
	if !ok {
		that2, ok := that.(FunctionVolatility)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if !this.Volatility.Equal(&that1.Volatility) {
		return false
	}
	return true
}
func (this *FunctionLeakProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionLeakProof)
	if !ok {
		that2, ok := that.(FunctionLeakProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if this.LeakProof != that1.LeakProof {
		return false
	}
	return true
}
func (this *FunctionNullInputBehavior) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionNullInputBehavior)
	if !ok {
		that2, ok := that.(FunctionNullInputBehavior)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if !this.NullInputBehavior.Equal(&that1.NullInputBehavior) {
		return false
	}
	return true
}
func (this *FunctionBody) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionBody)
	if !ok {
		that2, ok := that.(FunctionBody)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	if !this.Lang.Equal(&that1.Lang) {
		return false
	}
	if len(this.UsesTables) != len(that1.UsesTables) {
		return false
	}
	for i := range this.UsesTables {
		if !this.UsesTables[i].Equal(&that1.UsesTables[i]) {
			return false
		}
	}
	if len(this.UsesViews) != len(that1.UsesViews) {
		return false
	}
	for i := range this.UsesViews {
		if !this.UsesViews[i].Equal(&that1.UsesViews[i]) {
			return false
		}
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesFunctionIDs) != len(that1.UsesFunctionIDs) {
		return false
	}
	for i := range this.UsesFunctionIDs {
		if this.UsesFunctionIDs[i] != that1.UsesFunctionIDs[i] {
			return false
		}
	}
	return true
}
func (this *FunctionBody_TableReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionBody_TableReference)
	if !ok {
		that2, ok := that.(FunctionBody_TableReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	return true
}
func (this *FunctionBody_ViewReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionBody_ViewReference)
	if !ok {
		that2, ok := that.(FunctionBody_ViewReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ViewID != that1.ViewID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *FunctionSecurity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionSecurity)
	if !ok {
		that2, ok := that.(FunctionSecurity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if !this.Security.Equal(&that1.Security) {
		return false
	}
	return true
}
func (this *ElementCreationMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementCreationMetadata)
	if !ok {
		that2, ok := that.(ElementCreationMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.In_23_1OrLater != that1.In_23_1OrLater {
		return false
	}
	if this.In_24_3OrLater != that1.In_24_3OrLater {
		return false
	}
	return true
}
func (m *ElementProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElementProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ElementOneOf != nil {
		{
			size := m.ElementOneOf.Size()
			i -= size
			if _, err := m.ElementOneOf.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ElementProto_Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.View != nil {
		{
			size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sequence != nil {
		{
			size, err := m.Sequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_EnumType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_EnumType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnumType != nil {
		{
			size, err := m.EnumType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_AliasType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_AliasType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AliasType != nil {
		{
			size, err := m.AliasType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CompositeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CompositeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeType != nil {
		{
			size, err := m.CompositeType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Function != nil {
		{
			size, err := m.Function.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnFamily) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnFamily) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnFamily != nil {
		{
			size, err := m.ColumnFamily.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PrimaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrimaryIndex != nil {
		{
			size, err := m.PrimaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SecondaryIndex != nil {
		{
			size, err := m.SecondaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TemporaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TemporaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TemporaryIndex != nil {
		{
			size, err := m.TemporaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_UniqueWithoutIndexConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_UniqueWithoutIndexConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniqueWithoutIndexConstraint != nil {
		{
			size, err := m.UniqueWithoutIndexConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CheckConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConstraint != nil {
		{
			size, err := m.CheckConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ForeignKeyConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ForeignKeyConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForeignKeyConstraint != nil {
		{
			size, err := m.ForeignKeyConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableComment != nil {
		{
			size, err := m.TableComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RowLevelTTL != nil {
		{
			size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnName != nil {
		{
			size, err := m.ColumnName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnType != nil {
		{
			size, err := m.ColumnType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnDefaultExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnDefaultExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnDefaultExpression != nil {
		{
			size, err := m.ColumnDefaultExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnOnUpdateExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnOnUpdateExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnOnUpdateExpression != nil {
		{
			size, err := m.ColumnOnUpdateExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SequenceOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SequenceOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SequenceOwner != nil {
		{
			size, err := m.SequenceOwner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnComment != nil {
		{
			size, err := m.ColumnComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnNotNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnNotNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnNotNull != nil {
		{
			size, err := m.ColumnNotNull.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SequenceOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SequenceOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SequenceOption != nil {
		{
			size, err := m.SequenceOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexName != nil {
		{
			size, err := m.IndexName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexPartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexPartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexPartitioning != nil {
		{
			size, err := m.IndexPartitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexComment != nil {
		{
			size, err := m.IndexComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexColumn != nil {
		{
			size, err := m.IndexColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexData != nil {
		{
			size, err := m.IndexData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ConstraintWithoutIndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ConstraintWithoutIndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConstraintWithoutIndexName != nil {
		{
			size, err := m.ConstraintWithoutIndexName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ConstraintComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ConstraintComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConstraintComment != nil {
		{
			size, err := m.ConstraintComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Namespace != nil {
		{
			size, err := m.Namespace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_UserPrivileges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_UserPrivileges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserPrivileges != nil {
		{
			size, err := m.UserPrivileges.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseRegionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseRegionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseRegionConfig != nil {
		{
			size, err := m.DatabaseRegionConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseRoleSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseRoleSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseRoleSetting != nil {
		{
			size, err := m.DatabaseRoleSetting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseComment != nil {
		{
			size, err := m.DatabaseComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseData != nil {
		{
			size, err := m.DatabaseData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseZoneConfig != nil {
		{
			size, err := m.DatabaseZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SchemaParent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SchemaParent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemaParent != nil {
		{
			size, err := m.SchemaParent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SchemaComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SchemaComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemaComment != nil {
		{
			size, err := m.SchemaComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SchemaChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SchemaChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemaChild != nil {
		{
			size, err := m.SchemaChild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityGlobal != nil {
		{
			size, err := m.TableLocalityGlobal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityPrimaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityPrimaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityPrimaryRegion != nil {
		{
			size, err := m.TableLocalityPrimaryRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalitySecondaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalitySecondaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalitySecondaryRegion != nil {
		{
			size, err := m.TableLocalitySecondaryRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityRegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityRegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityRegionalByRow != nil {
		{
			size, err := m.TableLocalityRegionalByRow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityRegionalByRowUsingConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityRegionalByRowUsingConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityRegionalByRowUsingConstraint != nil {
		{
			size, err := m.TableLocalityRegionalByRowUsingConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_EnumTypeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_EnumTypeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnumTypeValue != nil {
		{
			size, err := m.EnumTypeValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableZoneConfig != nil {
		{
			size, err := m.TableZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexZoneConfig != nil {
		{
			size, err := m.IndexZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableData != nil {
		{
			size, err := m.TableData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TablePartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TablePartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TablePartitioning != nil {
		{
			size, err := m.TablePartitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableSchemaLocked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableSchemaLocked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableSchemaLocked != nil {
		{
			size, err := m.TableSchemaLocked.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_LDRJobIDs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_LDRJobIDs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LDRJobIDs != nil {
		{
			size, err := m.LDRJobIDs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PartitionZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PartitionZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PartitionZoneConfig != nil {
		{
			size, err := m.PartitionZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Trigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Trigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_RowLevelSecurityEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_RowLevelSecurityEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RowLevelSecurityEnabled != nil {
		{
			size, err := m.RowLevelSecurityEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_RowLevelSecurityForced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_RowLevelSecurityForced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RowLevelSecurityForced != nil {
		{
			size, err := m.RowLevelSecurityForced.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CompositeTypeAttrType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CompositeTypeAttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeTypeAttrType != nil {
		{
			size, err := m.CompositeTypeAttrType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CompositeTypeAttrName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CompositeTypeAttrName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeTypeAttrName != nil {
		{
			size, err := m.CompositeTypeAttrName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionName != nil {
		{
			size, err := m.FunctionName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionVolatility) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionVolatility) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionVolatility != nil {
		{
			size, err := m.FunctionVolatility.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionLeakProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionLeakProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionLeakProof != nil {
		{
			size, err := m.FunctionLeakProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionNullInputBehavior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionNullInputBehavior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionNullInputBehavior != nil {
		{
			size, err := m.FunctionNullInputBehavior.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionBody != nil {
		{
			size, err := m.FunctionBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionSecurity != nil {
		{
			size, err := m.FunctionSecurity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CheckConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CheckConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConstraintUnvalidated != nil {
		{
			size, err := m.CheckConstraintUnvalidated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_UniqueWithoutIndexConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_UniqueWithoutIndexConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniqueWithoutIndexConstraintUnvalidated != nil {
		{
			size, err := m.UniqueWithoutIndexConstraintUnvalidated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ForeignKeyConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ForeignKeyConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForeignKeyConstraintUnvalidated != nil {
		{
			size, err := m.ForeignKeyConstraintUnvalidated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TypeComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TypeComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TypeComment != nil {
		{
			size, err := m.TypeComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnComputeExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnComputeExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnComputeExpression != nil {
		{
			size, err := m.ColumnComputeExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xb
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerName != nil {
		{
			size, err := m.TriggerName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerEnabled != nil {
		{
			size, err := m.TriggerEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerTiming) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerTiming) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerTiming != nil {
		{
			size, err := m.TriggerTiming.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerEvents != nil {
		{
			size, err := m.TriggerEvents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerTransition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerTransition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerTransition != nil {
		{
			size, err := m.TriggerTransition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerWhen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerWhen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerWhen != nil {
		{
			size, err := m.TriggerWhen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerFunctionCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerFunctionCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerFunctionCall != nil {
		{
			size, err := m.TriggerFunctionCall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TriggerDeps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TriggerDeps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TriggerDeps != nil {
		{
			size, err := m.TriggerDeps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_NamedRangeZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_NamedRangeZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NamedRangeZoneConfig != nil {
		{
			size, err := m.NamedRangeZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PolicyName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PolicyName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PolicyName != nil {
		{
			size, err := m.PolicyName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PolicyRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PolicyRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PolicyRole != nil {
		{
			size, err := m.PolicyRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PolicyUsingExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PolicyUsingExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PolicyUsingExpr != nil {
		{
			size, err := m.PolicyUsingExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PolicyWithCheckExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PolicyWithCheckExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PolicyWithCheckExpr != nil {
		{
			size, err := m.PolicyWithCheckExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PolicyDeps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PolicyDeps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PolicyDeps != nil {
		{
			size, err := m.PolicyDeps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *TypeT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClosedTypeIDs) > 0 {
		l := 0
		for _, e := range m.ClosedTypeIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ClosedTypeIDs) {
			dest := dAtA[i : i+len(m.ClosedTypeIDs)]
			for k, num := range m.ClosedTypeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j90 := i
			for _, num := range m.ClosedTypeIDs {
				for num >= 1<<7 {
					dAtA[j90] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j90++
				}
				dAtA[j90] = uint8(num)
				j90++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesFunctionIDs) > 0 {
		l := 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesFunctionIDs) {
			dest := dAtA[i : i+len(m.UsesFunctionIDs)]
			for k, num := range m.UsesFunctionIDs {
				dest[k] = uint8(num)
			}
		} else {
			j92 := i
			for _, num := range m.UsesFunctionIDs {
				for num >= 1<<7 {
					dAtA[j92] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j92++
				}
				dAtA[j92] = uint8(num)
				j92++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l := 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ReferencedColumnIDs) {
			dest := dAtA[i : i+len(m.ReferencedColumnIDs)]
			for k, num := range m.ReferencedColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j93 := i
			for _, num := range m.ReferencedColumnIDs {
				for num >= 1<<7 {
					dAtA[j93] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j93++
				}
				dAtA[j93] = uint8(num)
				j93++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UsesSequenceIDs) > 0 {
		l := 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesSequenceIDs) {
			dest := dAtA[i : i+len(m.UsesSequenceIDs)]
			for k, num := range m.UsesSequenceIDs {
				dest[k] = uint8(num)
			}
		} else {
			j94 := i
			for _, num := range m.UsesSequenceIDs {
				for num >= 1<<7 {
					dAtA[j94] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j94++
				}
				dAtA[j94] = uint8(num)
				j94++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsesTypeIDs) > 0 {
		l := 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesTypeIDs) {
			dest := dAtA[i : i+len(m.UsesTypeIDs)]
			for k, num := range m.UsesTypeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j95 := i
			for _, num := range m.UsesTypeIDs {
				for num >= 1<<7 {
					dAtA[j95] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j95++
				}
				dAtA[j95] = uint8(num)
				j95++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Expr) > 0 {
		i -= len(m.Expr)
		copy(dAtA[i:], m.Expr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Expr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSystemColumn {
		i--
		if m.IsSystemColumn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PgAttributeNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PgAttributeNum))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GeneratedAsIdentitySequenceOption) > 0 {
		i -= len(m.GeneratedAsIdentitySequenceOption)
		copy(dAtA[i:], m.GeneratedAsIdentitySequenceOption)
		i = encodeVarintElements(dAtA, i, uint64(len(m.GeneratedAsIdentitySequenceOption)))
		i--
		dAtA[i] = 0x32
	}
	if m.GeneratedAsIdentityType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.GeneratedAsIdentityType))
		i--
		dAtA[i] = 0x28
	}
	if m.IsInaccessible {
		i--
		if m.IsInaccessible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnFamilyOrderFollowsColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnFamilyOrderFollowsColumnID))
		i--
		dAtA[i] = 0x60
	}
	if m.ElementCreationMetadata != nil {
		{
			size, err := m.ElementCreationMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.IsVirtual {
		i--
		if m.IsVirtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ComputeExpr != nil {
		{
			size, err := m.ComputeExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsNullable {
		i--
		if m.IsNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnComputeExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnComputeExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnComputeExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Usage != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Usage))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnFamily) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnFamily) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnFamily) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VecConfig != nil {
		{
			size, err := m.VecConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.Type != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Invisibility != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Invisibility))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc9
	}
	if m.GeoConfig != nil {
		{
			size, err := m.GeoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.IsNotVisible {
		i--
		if m.IsNotVisible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.TemporaryIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TemporaryIndexID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SourceIndexID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.IsConcurrently {
		i--
		if m.IsConcurrently {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x70
	}
	if m.IsCreatedExplicitly {
		i--
		if m.IsCreatedExplicitly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.IsInverted {
		i--
		if m.IsInverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SecondaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HideForPrimaryKeyRecreated {
		i--
		if m.HideForPrimaryKeyRecreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.RecreateTargetIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RecreateTargetIndexID))
		i--
		dAtA[i] = 0x28
	}
	if m.RecreateSourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RecreateSourceIndexID))
		i--
		dAtA[i] = 0x20
	}
	if m.EmbeddedExpr != nil {
		{
			size, err := m.EmbeddedExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TemporaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemporaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemporaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsUsingSecondaryEncoding {
		i--
		if m.IsUsingSecondaryEncoding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SchemaParent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaParent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaParent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParentDatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ParentDatabaseID))
		i--
		dAtA[i] = 0x10
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ChildObjectID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ChildObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Command != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.PolicyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PolicyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicyName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PolicyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PolicyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicyRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleName) > 0 {
		i -= len(m.RoleName)
		copy(dAtA[i:], m.RoleName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RoleName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PolicyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PolicyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicyUsingExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyUsingExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyUsingExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PolicyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PolicyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicyWithCheckExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyWithCheckExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyWithCheckExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PolicyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PolicyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicyDeps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyDeps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyDeps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesFunctionIDs) > 0 {
		l := 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesFunctionIDs) {
			dest := dAtA[i : i+len(m.UsesFunctionIDs)]
			for k, num := range m.UsesFunctionIDs {
				dest[k] = uint8(num)
			}
		} else {
			j110 := i
			for _, num := range m.UsesFunctionIDs {
				for num >= 1<<7 {
					dAtA[j110] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j110++
				}
				dAtA[j110] = uint8(num)
				j110++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UsesRelationIDs) > 0 {
		l := 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesRelationIDs) {
			dest := dAtA[i : i+len(m.UsesRelationIDs)]
			for k, num := range m.UsesRelationIDs {
				dest[k] = uint8(num)
			}
		} else {
			j111 := i
			for _, num := range m.UsesRelationIDs {
				for num >= 1<<7 {
					dAtA[j111] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j111++
				}
				dAtA[j111] = uint8(num)
				j111++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UsesTypeIDs) > 0 {
		l := 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesTypeIDs) {
			dest := dAtA[i : i+len(m.UsesTypeIDs)]
			for k, num := range m.UsesTypeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j112 := i
			for _, num := range m.UsesTypeIDs {
				for num >= 1<<7 {
					dAtA[j112] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j112++
				}
				dAtA[j112] = uint8(num)
				j112++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PolicyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PolicyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowLevelSecurityEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelSecurityEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelSecurityEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowLevelSecurityForced) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelSecurityForced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelSecurityForced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsForced {
		i--
		if m.IsForced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UseRestartWith {
		i--
		if m.UseRestartWith {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RestartWith != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RestartWith))
		i--
		dAtA[i] = 0x10
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x10
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnDefaultExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnDefaultExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnDefaultExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOnUpdateExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOnUpdateExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOnUpdateExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesRoutineIDs) > 0 {
		l := 0
		for _, e := range m.UsesRoutineIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesRoutineIDs) {
			dest := dAtA[i : i+len(m.UsesRoutineIDs)]
			for k, num := range m.UsesRoutineIDs {
				dest[k] = uint8(num)
			}
		} else {
			j115 := i
			for _, num := range m.UsesRoutineIDs {
				for num >= 1<<7 {
					dAtA[j115] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j115++
				}
				dAtA[j115] = uint8(num)
				j115++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x62
	}
	if m.IsMaterialized {
		i--
		if m.IsMaterialized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.ForwardReferences) > 0 {
		for iNdEx := len(m.ForwardReferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForwardReferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UsesRelationIDs) > 0 {
		l := 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesRelationIDs) {
			dest := dAtA[i : i+len(m.UsesRelationIDs)]
			for k, num := range m.UsesRelationIDs {
				dest[k] = uint8(num)
			}
		} else {
			j116 := i
			for _, num := range m.UsesRelationIDs {
				for num >= 1<<7 {
					dAtA[j116] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j116++
				}
				dAtA[j116] = uint8(num)
				j116++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsesTypeIDs) > 0 {
		l := 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesTypeIDs) {
			dest := dAtA[i : i+len(m.UsesTypeIDs)]
			for k, num := range m.UsesTypeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j117 := i
			for _, num := range m.UsesTypeIDs {
				for num >= 1<<7 {
					dAtA[j117] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j117++
				}
				dAtA[j117] = uint8(num)
				j117++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.ViewID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ViewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View_Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View_Reference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View_Reference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j118 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j118] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j118++
				}
				dAtA[j118] = uint8(num)
				j118++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.ToID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ToID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UniqueWithoutIndexConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueWithoutIndexConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueWithoutIndexConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x28
	}
	if m.Predicate != nil {
		{
			size, err := m.Predicate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j120 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j120] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j120++
				}
				dAtA[j120] = uint8(num)
				j120++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UniqueWithoutIndexConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueWithoutIndexConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueWithoutIndexConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Predicate != nil {
		{
			size, err := m.Predicate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j122 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j122] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j122++
				}
				dAtA[j122] = uint8(num)
				j122++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x30
	}
	if m.FromHashShardedColumn {
		i--
		if m.FromHashShardedColumn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j124 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j124] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j124++
				}
				dAtA[j124] = uint8(num)
				j124++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j126 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j126] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j126++
				}
				dAtA[j126] = uint8(num)
				j126++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x48
	}
	if m.CompositeKeyMatchMethod != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeKeyMatchMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.OnDeleteAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnDeleteAction))
		i--
		dAtA[i] = 0x38
	}
	if m.OnUpdateAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnUpdateAction))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l := 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ReferencedColumnIDs) {
			dest := dAtA[i : i+len(m.ReferencedColumnIDs)]
			for k, num := range m.ReferencedColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j127 := i
			for _, num := range m.ReferencedColumnIDs {
				for num >= 1<<7 {
					dAtA[j127] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j127++
				}
				dAtA[j127] = uint8(num)
				j127++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferencedTableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferencedTableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j128 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j128] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j128++
				}
				dAtA[j128] = uint8(num)
				j128++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompositeKeyMatchMethod != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeKeyMatchMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.OnDeleteAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnDeleteAction))
		i--
		dAtA[i] = 0x38
	}
	if m.OnUpdateAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnUpdateAction))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l := 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ReferencedColumnIDs) {
			dest := dAtA[i : i+len(m.ReferencedColumnIDs)]
			for k, num := range m.ReferencedColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j129 := i
			for _, num := range m.ReferencedColumnIDs {
				for num >= 1<<7 {
					dAtA[j129] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j129++
				}
				dAtA[j129] = uint8(num)
				j129++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferencedTableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferencedTableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j130 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j130] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j130++
				}
				dAtA[j130] = uint8(num)
				j130++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Trigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerTiming) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerTiming) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerTiming) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForEachRow {
		i--
		if m.ForEachRow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ActionTime != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ActionTime))
		i--
		dAtA[i] = 0x18
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintElements(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerTransition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerTransition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerTransition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OldTransitionAlias) > 0 {
		i -= len(m.OldTransitionAlias)
		copy(dAtA[i:], m.OldTransitionAlias)
		i = encodeVarintElements(dAtA, i, uint64(len(m.OldTransitionAlias)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NewTransitionAlias) > 0 {
		i -= len(m.NewTransitionAlias)
		copy(dAtA[i:], m.NewTransitionAlias)
		i = encodeVarintElements(dAtA, i, uint64(len(m.NewTransitionAlias)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerWhen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerWhen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerWhen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WhenExpr) > 0 {
		i -= len(m.WhenExpr)
		copy(dAtA[i:], m.WhenExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.WhenExpr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerFunctionCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerFunctionCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerFunctionCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FuncBody) > 0 {
		i -= len(m.FuncBody)
		copy(dAtA[i:], m.FuncBody)
		i = encodeVarintElements(dAtA, i, uint64(len(m.FuncBody)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FuncArgs) > 0 {
		for iNdEx := len(m.FuncArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FuncArgs[iNdEx])
			copy(dAtA[i:], m.FuncArgs[iNdEx])
			i = encodeVarintElements(dAtA, i, uint64(len(m.FuncArgs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.FuncID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FuncID))
		i--
		dAtA[i] = 0x18
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerDeps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerDeps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerDeps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesRelations) > 0 {
		for iNdEx := len(m.UsesRelations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsesRelations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.UsesRoutineIDs) > 0 {
		l := 0
		for _, e := range m.UsesRoutineIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesRoutineIDs) {
			dest := dAtA[i : i+len(m.UsesRoutineIDs)]
			for k, num := range m.UsesRoutineIDs {
				dest[k] = uint8(num)
			}
		} else {
			j131 := i
			for _, num := range m.UsesRoutineIDs {
				for num >= 1<<7 {
					dAtA[j131] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j131++
				}
				dAtA[j131] = uint8(num)
				j131++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UsesTypeIDs) > 0 {
		l := 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesTypeIDs) {
			dest := dAtA[i : i+len(m.UsesTypeIDs)]
			for k, num := range m.UsesTypeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j132 := i
			for _, num := range m.UsesTypeIDs {
				for num >= 1<<7 {
					dAtA[j132] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j132++
				}
				dAtA[j132] = uint8(num)
				j132++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UsesRelationIDs) > 0 {
		l := 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesRelationIDs) {
			dest := dAtA[i : i+len(m.UsesRelationIDs)]
			for k, num := range m.UsesRelationIDs {
				dest[k] = uint8(num)
			}
		} else {
			j133 := i
			for _, num := range m.UsesRelationIDs {
				for num >= 1<<7 {
					dAtA[j133] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j133++
				}
				dAtA[j133] = uint8(num)
				j133++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TriggerID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TriggerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerDeps_RelationReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerDeps_RelationReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerDeps_RelationReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j134 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j134] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j134++
				}
				dAtA[j134] = uint8(num)
				j134++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnumType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMultiRegion {
		i--
		if m.IsMultiRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ArrayTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ArrayTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AliasType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ArrayTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ArrayTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsVirtual {
		i--
		if m.IsVirtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsPublic {
		i--
		if m.IsPublic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Owner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPrivileges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPrivileges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPrivileges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithGrantOption != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.WithGrantOption))
		i--
		dAtA[i] = 0x20
	}
	if m.Privileges != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Privileges))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NamedRangeZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedRangeZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamedRangeZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x18
	}
	if m.ZoneConfig != nil {
		{
			size, err := m.ZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityGlobal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityPrimaryRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityPrimaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityPrimaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalitySecondaryRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalitySecondaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalitySecondaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegionName) > 0 {
		i -= len(m.RegionName)
		copy(dAtA[i:], m.RegionName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RegionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionEnumTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RegionEnumTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityRegionalByRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityRegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityRegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.As) > 0 {
		i -= len(m.As)
		copy(dAtA[i:], m.As)
		i = encodeVarintElements(dAtA, i, uint64(len(m.As)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityRegionalByRowUsingConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityRegionalByRowUsingConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityRegionalByRowUsingConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexPartitioning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexPartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexPartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PartitioningDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowLevelTTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTLExpr != nil {
		{
			size, err := m.TTLExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintWithoutIndexName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintWithoutIndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintWithoutIndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TypeComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgAttributeNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PgAttributeNum))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnNotNull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnNotNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnNotNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRegionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRegionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRegionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegionEnumTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RegionEnumTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRoleSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRoleSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRoleSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleName) > 0 {
		i -= len(m.RoleName)
		copy(dAtA[i:], m.RoleName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RoleName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertedKind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.InvertedKind))
		i--
		dAtA[i] = 0x40
	}
	if m.Implicit {
		i--
		if m.Implicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Direction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x30
	}
	if m.Kind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x28
	}
	if m.OrdinalInKind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OrdinalInKind))
		i--
		dAtA[i] = 0x20
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumTypeValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumTypeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnumTypeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogicalRepresentation) > 0 {
		i -= len(m.LogicalRepresentation)
		copy(dAtA[i:], m.LogicalRepresentation)
		i = encodeVarintElements(dAtA, i, uint64(len(m.LogicalRepresentation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PhysicalRepresentation) > 0 {
		i -= len(m.PhysicalRepresentation)
		copy(dAtA[i:], m.PhysicalRepresentation)
		i = encodeVarintElements(dAtA, i, uint64(len(m.PhysicalRepresentation)))
		i--
		dAtA[i] = 0x12
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositeTypeAttrName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeTypeAttrName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeTypeAttrName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CompositeTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeTypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositeTypeAttrType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeTypeAttrType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeTypeAttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.CompositeTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeTypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x18
	}
	if m.ZoneConfig != nil {
		{
			size, err := m.ZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x18
	}
	if m.ZoneConfig != nil {
		{
			size, err := m.ZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OldIdxRef != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OldIdxRef))
		i--
		dAtA[i] = 0x38
	}
	if m.SeqNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SubzoneSpans) > 0 {
		for iNdEx := len(m.SubzoneSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubzoneSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.Subzone.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OldIdxRef != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OldIdxRef))
		i--
		dAtA[i] = 0x38
	}
	if m.SeqNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SubzoneSpans) > 0 {
		for iNdEx := len(m.SubzoneSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubzoneSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.Subzone.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TablePartitioning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TablePartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TablePartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableSchemaLocked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableSchemaLocked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableSchemaLocked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LDRJobIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LDRJobIDs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LDRJobIDs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobIDs) > 0 {
		l := 0
		for _, e := range m.JobIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.JobIDs) {
			dest := dAtA[i : i+len(m.JobIDs)]
			for k, num := range m.JobIDs {
				dest[k] = uint8(num)
			}
		} else {
			j145 := i
			for _, num1 := range m.JobIDs {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j145] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j145++
				}
				dAtA[j145] = uint8(num)
				j145++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsProcedure {
		i--
		if m.IsProcedure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.ReturnType.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ReturnSet {
		i--
		if m.ReturnSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function_Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function_Parameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function_Parameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DefaultExpr) > 0 {
		i -= len(m.DefaultExpr)
		copy(dAtA[i:], m.DefaultExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.DefaultExpr)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Class.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FunctionName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionVolatility) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionVolatility) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionVolatility) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Volatility.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionLeakProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionLeakProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionLeakProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeakProof {
		i--
		if m.LeakProof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionNullInputBehavior) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionNullInputBehavior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionNullInputBehavior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NullInputBehavior.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesFunctionIDs) > 0 {
		l := 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesFunctionIDs) {
			dest := dAtA[i : i+len(m.UsesFunctionIDs)]
			for k, num := range m.UsesFunctionIDs {
				dest[k] = uint8(num)
			}
		} else {
			j151 := i
			for _, num := range m.UsesFunctionIDs {
				for num >= 1<<7 {
					dAtA[j151] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j151++
				}
				dAtA[j151] = uint8(num)
				j151++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UsesTypeIDs) > 0 {
		l := 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesTypeIDs) {
			dest := dAtA[i : i+len(m.UsesTypeIDs)]
			for k, num := range m.UsesTypeIDs {
				dest[k] = uint8(num)
			}
		} else {
			j152 := i
			for _, num := range m.UsesTypeIDs {
				for num >= 1<<7 {
					dAtA[j152] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j152++
				}
				dAtA[j152] = uint8(num)
				j152++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UsesSequenceIDs) > 0 {
		l := 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.UsesSequenceIDs) {
			dest := dAtA[i : i+len(m.UsesSequenceIDs)]
			for k, num := range m.UsesSequenceIDs {
				dest[k] = uint8(num)
			}
		} else {
			j153 := i
			for _, num := range m.UsesSequenceIDs {
				for num >= 1<<7 {
					dAtA[j153] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j153++
				}
				dAtA[j153] = uint8(num)
				j153++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UsesViews) > 0 {
		for iNdEx := len(m.UsesViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsesViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UsesTables) > 0 {
		for iNdEx := len(m.UsesTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsesTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Lang.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x12
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionBody_TableReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionBody_TableReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionBody_TableReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j155 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j155] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j155++
				}
				dAtA[j155] = uint8(num)
				j155++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionBody_ViewReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionBody_ViewReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionBody_ViewReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		l := 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		i -= l
		if l == len(m.ColumnIDs) {
			dest := dAtA[i : i+len(m.ColumnIDs)]
			for k, num := range m.ColumnIDs {
				dest[k] = uint8(num)
			}
		} else {
			j156 := i
			for _, num := range m.ColumnIDs {
				for num >= 1<<7 {
					dAtA[j156] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j156++
				}
				dAtA[j156] = uint8(num)
				j156++
			}
		}
		i = encodeVarintElements(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x12
	}
	if m.ViewID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ViewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Security.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ElementCreationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElementCreationMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementCreationMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.In_24_3OrLater {
		i--
		if m.In_24_3OrLater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.In_23_1OrLater {
		i--
		if m.In_23_1OrLater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintElements(dAtA []byte, offset int, v uint64) int {
	offset -= sovElements(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ElementProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElementOneOf != nil {
		n += m.ElementOneOf.Size()
	}
	return n
}

func (m *ElementProto_Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != nil {
		l = m.View.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != nil {
		l = m.Sequence.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_EnumType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnumType != nil {
		l = m.EnumType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_AliasType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AliasType != nil {
		l = m.AliasType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CompositeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeType != nil {
		l = m.CompositeType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnFamily) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnFamily != nil {
		l = m.ColumnFamily.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimaryIndex != nil {
		l = m.PrimaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SecondaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecondaryIndex != nil {
		l = m.SecondaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TemporaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TemporaryIndex != nil {
		l = m.TemporaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_UniqueWithoutIndexConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniqueWithoutIndexConstraint != nil {
		l = m.UniqueWithoutIndexConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConstraint != nil {
		l = m.CheckConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ForeignKeyConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForeignKeyConstraint != nil {
		l = m.ForeignKeyConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableComment != nil {
		l = m.TableComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowLevelTTL != nil {
		l = m.RowLevelTTL.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnName != nil {
		l = m.ColumnName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnType != nil {
		l = m.ColumnType.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnDefaultExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnDefaultExpression != nil {
		l = m.ColumnDefaultExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnOnUpdateExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnOnUpdateExpression != nil {
		l = m.ColumnOnUpdateExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SequenceOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceOwner != nil {
		l = m.SequenceOwner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnComment != nil {
		l = m.ColumnComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnNotNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnNotNull != nil {
		l = m.ColumnNotNull.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SequenceOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceOption != nil {
		l = m.SequenceOption.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexName != nil {
		l = m.IndexName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexPartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexPartitioning != nil {
		l = m.IndexPartitioning.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexComment != nil {
		l = m.IndexComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexColumn != nil {
		l = m.IndexColumn.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexData != nil {
		l = m.IndexData.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ConstraintWithoutIndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstraintWithoutIndexName != nil {
		l = m.ConstraintWithoutIndexName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ConstraintComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstraintComment != nil {
		l = m.ConstraintComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Namespace != nil {
		l = m.Namespace.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_UserPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserPrivileges != nil {
		l = m.UserPrivileges.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseRegionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseRegionConfig != nil {
		l = m.DatabaseRegionConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseRoleSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseRoleSetting != nil {
		l = m.DatabaseRoleSetting.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseComment != nil {
		l = m.DatabaseComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseData != nil {
		l = m.DatabaseData.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseZoneConfig != nil {
		l = m.DatabaseZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SchemaParent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaParent != nil {
		l = m.SchemaParent.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SchemaComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaComment != nil {
		l = m.SchemaComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SchemaChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChild != nil {
		l = m.SchemaChild.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityGlobal != nil {
		l = m.TableLocalityGlobal.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityPrimaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityPrimaryRegion != nil {
		l = m.TableLocalityPrimaryRegion.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalitySecondaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalitySecondaryRegion != nil {
		l = m.TableLocalitySecondaryRegion.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityRegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityRegionalByRow != nil {
		l = m.TableLocalityRegionalByRow.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityRegionalByRowUsingConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityRegionalByRowUsingConstraint != nil {
		l = m.TableLocalityRegionalByRowUsingConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_EnumTypeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnumTypeValue != nil {
		l = m.EnumTypeValue.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableZoneConfig != nil {
		l = m.TableZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexZoneConfig != nil {
		l = m.IndexZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableData != nil {
		l = m.TableData.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TablePartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TablePartitioning != nil {
		l = m.TablePartitioning.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableSchemaLocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableSchemaLocked != nil {
		l = m.TableSchemaLocked.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_LDRJobIDs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LDRJobIDs != nil {
		l = m.LDRJobIDs.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PartitionZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionZoneConfig != nil {
		l = m.PartitionZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Trigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_RowLevelSecurityEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowLevelSecurityEnabled != nil {
		l = m.RowLevelSecurityEnabled.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_RowLevelSecurityForced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowLevelSecurityForced != nil {
		l = m.RowLevelSecurityForced.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CompositeTypeAttrType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeAttrType != nil {
		l = m.CompositeTypeAttrType.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CompositeTypeAttrName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeAttrName != nil {
		l = m.CompositeTypeAttrName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionName != nil {
		l = m.FunctionName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionVolatility) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionVolatility != nil {
		l = m.FunctionVolatility.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionLeakProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionLeakProof != nil {
		l = m.FunctionLeakProof.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionNullInputBehavior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionNullInputBehavior != nil {
		l = m.FunctionNullInputBehavior.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionBody != nil {
		l = m.FunctionBody.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionSecurity != nil {
		l = m.FunctionSecurity.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CheckConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConstraintUnvalidated != nil {
		l = m.CheckConstraintUnvalidated.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_UniqueWithoutIndexConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniqueWithoutIndexConstraintUnvalidated != nil {
		l = m.UniqueWithoutIndexConstraintUnvalidated.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ForeignKeyConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForeignKeyConstraintUnvalidated != nil {
		l = m.ForeignKeyConstraintUnvalidated.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TypeComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeComment != nil {
		l = m.TypeComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnComputeExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnComputeExpression != nil {
		l = m.ColumnComputeExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerName != nil {
		l = m.TriggerName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerEnabled != nil {
		l = m.TriggerEnabled.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerTiming) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerTiming != nil {
		l = m.TriggerTiming.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerEvents != nil {
		l = m.TriggerEvents.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerTransition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerTransition != nil {
		l = m.TriggerTransition.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerWhen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerWhen != nil {
		l = m.TriggerWhen.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerFunctionCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerFunctionCall != nil {
		l = m.TriggerFunctionCall.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TriggerDeps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerDeps != nil {
		l = m.TriggerDeps.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_NamedRangeZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamedRangeZoneConfig != nil {
		l = m.NamedRangeZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PolicyName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyName != nil {
		l = m.PolicyName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PolicyRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyRole != nil {
		l = m.PolicyRole.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PolicyUsingExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyUsingExpr != nil {
		l = m.PolicyUsingExpr.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PolicyWithCheckExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyWithCheckExpr != nil {
		l = m.PolicyWithCheckExpr.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PolicyDeps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyDeps != nil {
		l = m.PolicyDeps.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *TypeT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.ClosedTypeIDs) > 0 {
		l = 0
		for _, e := range m.ClosedTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesFunctionIDs) > 0 {
		l = 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.IsHidden {
		n += 2
	}
	if m.IsInaccessible {
		n += 2
	}
	if m.GeneratedAsIdentityType != 0 {
		n += 1 + sovElements(uint64(m.GeneratedAsIdentityType))
	}
	l = len(m.GeneratedAsIdentitySequenceOption)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PgAttributeNum != 0 {
		n += 1 + sovElements(uint64(m.PgAttributeNum))
	}
	if m.IsSystemColumn {
		n += 2
	}
	return n
}

func (m *ColumnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsNullable {
		n += 2
	}
	if m.ComputeExpr != nil {
		l = m.ComputeExpr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IsVirtual {
		n += 2
	}
	if m.ElementCreationMetadata != nil {
		l = m.ElementCreationMetadata.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.ColumnFamilyOrderFollowsColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnFamilyOrderFollowsColumnID))
	}
	return n
}

func (m *ColumnComputeExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.Usage != 0 {
		n += 1 + sovElements(uint64(m.Usage))
	}
	return n
}

func (m *ColumnFamily) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.IsUnique {
		n += 2
	}
	if m.IsInverted {
		n += 2
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IsCreatedExplicitly {
		n += 2
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if m.IsConcurrently {
		n += 3
	}
	if m.SourceIndexID != 0 {
		n += 2 + sovElements(uint64(m.SourceIndexID))
	}
	if m.TemporaryIndexID != 0 {
		n += 2 + sovElements(uint64(m.TemporaryIndexID))
	}
	if m.IsNotVisible {
		n += 3
	}
	if m.GeoConfig != nil {
		l = m.GeoConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Invisibility != 0 {
		n += 10
	}
	if m.Type != 0 {
		n += 2 + sovElements(uint64(m.Type))
	}
	if m.VecConfig != nil {
		l = m.VecConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}

func (m *PrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *SecondaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.EmbeddedExpr != nil {
		l = m.EmbeddedExpr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.RecreateSourceIndexID != 0 {
		n += 1 + sovElements(uint64(m.RecreateSourceIndexID))
	}
	if m.RecreateTargetIndexID != 0 {
		n += 1 + sovElements(uint64(m.RecreateTargetIndexID))
	}
	if m.HideForPrimaryKeyRecreated {
		n += 2
	}
	return n
}

func (m *TemporaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsUsingSecondaryEncoding {
		n += 2
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SchemaParent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.ParentDatabaseID != 0 {
		n += 1 + sovElements(uint64(m.ParentDatabaseID))
	}
	return n
}

func (m *SchemaChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChildObjectID != 0 {
		n += 1 + sovElements(uint64(m.ChildObjectID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	return n
}

func (m *Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.PolicyID != 0 {
		n += 1 + sovElements(uint64(m.PolicyID))
	}
	if m.Type != 0 {
		n += 1 + sovElements(uint64(m.Type))
	}
	if m.Command != 0 {
		n += 1 + sovElements(uint64(m.Command))
	}
	return n
}

func (m *PolicyName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.PolicyID != 0 {
		n += 1 + sovElements(uint64(m.PolicyID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *PolicyRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.PolicyID != 0 {
		n += 1 + sovElements(uint64(m.PolicyID))
	}
	l = len(m.RoleName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *PolicyUsingExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.PolicyID != 0 {
		n += 1 + sovElements(uint64(m.PolicyID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *PolicyWithCheckExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.PolicyID != 0 {
		n += 1 + sovElements(uint64(m.PolicyID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *PolicyDeps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.PolicyID != 0 {
		n += 1 + sovElements(uint64(m.PolicyID))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesRelationIDs) > 0 {
		l = 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesFunctionIDs) > 0 {
		l = 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *RowLevelSecurityEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *RowLevelSecurityForced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IsForced {
		n += 2
	}
	return n
}

func (m *Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.RestartWith != 0 {
		n += 1 + sovElements(uint64(m.RestartWith))
	}
	if m.UseRestartWith {
		n += 2
	}
	if m.IsTemporary {
		n += 2
	}
	return n
}

func (m *SequenceOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SequenceOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	return n
}

func (m *ColumnDefaultExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ColumnOnUpdateExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ViewID != 0 {
		n += 1 + sovElements(uint64(m.ViewID))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesRelationIDs) > 0 {
		l = 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.ForwardReferences) > 0 {
		for _, e := range m.ForwardReferences {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if m.IsTemporary {
		n += 2
	}
	if m.IsMaterialized {
		n += 2
	}
	if len(m.UsesRoutineIDs) > 0 {
		l = 0
		for _, e := range m.UsesRoutineIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *View_Reference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToID != 0 {
		n += 1 + sovElements(uint64(m.ToID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IsTemporary {
		n += 2
	}
	return n
}

func (m *UniqueWithoutIndexConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Predicate != nil {
		l = m.Predicate.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *UniqueWithoutIndexConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Predicate != nil {
		l = m.Predicate.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.FromHashShardedColumn {
		n += 2
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *CheckConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ForeignKeyConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferencedTableID != 0 {
		n += 1 + sovElements(uint64(m.ReferencedTableID))
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.OnUpdateAction != 0 {
		n += 1 + sovElements(uint64(m.OnUpdateAction))
	}
	if m.OnDeleteAction != 0 {
		n += 1 + sovElements(uint64(m.OnDeleteAction))
	}
	if m.CompositeKeyMatchMethod != 0 {
		n += 1 + sovElements(uint64(m.CompositeKeyMatchMethod))
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *ForeignKeyConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferencedTableID != 0 {
		n += 1 + sovElements(uint64(m.ReferencedTableID))
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.OnUpdateAction != 0 {
		n += 1 + sovElements(uint64(m.OnUpdateAction))
	}
	if m.OnDeleteAction != 0 {
		n += 1 + sovElements(uint64(m.OnDeleteAction))
	}
	if m.CompositeKeyMatchMethod != 0 {
		n += 1 + sovElements(uint64(m.CompositeKeyMatchMethod))
	}
	return n
}

func (m *Trigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	return n
}

func (m *TriggerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TriggerEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *TriggerTiming) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	if m.ActionTime != 0 {
		n += 1 + sovElements(uint64(m.ActionTime))
	}
	if m.ForEachRow {
		n += 2
	}
	return n
}

func (m *TriggerEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovElements(uint64(m.Type))
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovElements(uint64(l))
		}
	}
	return n
}

func (m *TriggerEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	return n
}

func (m *TriggerTransition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	l = len(m.NewTransitionAlias)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.OldTransitionAlias)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TriggerWhen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	l = len(m.WhenExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TriggerFunctionCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	if m.FuncID != 0 {
		n += 1 + sovElements(uint64(m.FuncID))
	}
	if len(m.FuncArgs) > 0 {
		for _, s := range m.FuncArgs {
			l = len(s)
			n += 1 + l + sovElements(uint64(l))
		}
	}
	l = len(m.FuncBody)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TriggerDeps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TriggerID != 0 {
		n += 1 + sovElements(uint64(m.TriggerID))
	}
	if len(m.UsesRelationIDs) > 0 {
		l = 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesRoutineIDs) > 0 {
		l = 0
		for _, e := range m.UsesRoutineIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesRelations) > 0 {
		for _, e := range m.UsesRelations {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	return n
}

func (m *TriggerDeps_RelationReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovElements(uint64(m.ID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	return n
}

func (m *EnumType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	if m.ArrayTypeID != 0 {
		n += 1 + sovElements(uint64(m.ArrayTypeID))
	}
	if m.IsMultiRegion {
		n += 2
	}
	return n
}

func (m *AliasType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *CompositeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	if m.ArrayTypeID != 0 {
		n += 1 + sovElements(uint64(m.ArrayTypeID))
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.IsTemporary {
		n += 2
	}
	if m.IsPublic {
		n += 2
	}
	if m.IsVirtual {
		n += 2
	}
	return n
}

func (m *Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *UserPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Privileges != 0 {
		n += 1 + sovElements(uint64(m.Privileges))
	}
	if m.WithGrantOption != 0 {
		n += 1 + sovElements(uint64(m.WithGrantOption))
	}
	return n
}

func (m *NamedRangeZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovElements(uint64(m.RangeID))
	}
	if m.ZoneConfig != nil {
		l = m.ZoneConfig.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovElements(uint64(m.SeqNum))
	}
	return n
}

func (m *TableLocalityGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableLocalityPrimaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableLocalitySecondaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.RegionEnumTypeID != 0 {
		n += 1 + sovElements(uint64(m.RegionEnumTypeID))
	}
	l = len(m.RegionName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableLocalityRegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.As)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableLocalityRegionalByRowUsingConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	return n
}

func (m *IndexPartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = m.PartitioningDescriptor.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = m.RowLevelTTL.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.TTLExpr != nil {
		l = m.TTLExpr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ConstraintWithoutIndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TypeComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SchemaComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PgAttributeNum != 0 {
		n += 1 + sovElements(uint64(m.PgAttributeNum))
	}
	return n
}

func (m *ColumnNotNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *ConstraintComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseRegionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.RegionEnumTypeID != 0 {
		n += 1 + sovElements(uint64(m.RegionEnumTypeID))
	}
	return n
}

func (m *DatabaseRoleSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.RoleName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.OrdinalInKind != 0 {
		n += 1 + sovElements(uint64(m.OrdinalInKind))
	}
	if m.Kind != 0 {
		n += 1 + sovElements(uint64(m.Kind))
	}
	if m.Direction != 0 {
		n += 1 + sovElements(uint64(m.Direction))
	}
	if m.Implicit {
		n += 2
	}
	if m.InvertedKind != 0 {
		n += 1 + sovElements(uint64(m.InvertedKind))
	}
	return n
}

func (m *EnumTypeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	l = len(m.PhysicalRepresentation)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.LogicalRepresentation)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *CompositeTypeAttrName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeID != 0 {
		n += 1 + sovElements(uint64(m.CompositeTypeID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *CompositeTypeAttrType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeID != 0 {
		n += 1 + sovElements(uint64(m.CompositeTypeID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *DatabaseZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.ZoneConfig != nil {
		l = m.ZoneConfig.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovElements(uint64(m.SeqNum))
	}
	return n
}

func (m *TableZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ZoneConfig != nil {
		l = m.ZoneConfig.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovElements(uint64(m.SeqNum))
	}
	return n
}

func (m *IndexZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = m.Subzone.Size()
	n += 1 + l + sovElements(uint64(l))
	if len(m.SubzoneSpans) > 0 {
		for _, e := range m.SubzoneSpans {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if m.SeqNum != 0 {
		n += 1 + sovElements(uint64(m.SeqNum))
	}
	if m.OldIdxRef != 0 {
		n += 1 + sovElements(uint64(m.OldIdxRef))
	}
	return n
}

func (m *PartitionZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = m.Subzone.Size()
	n += 1 + l + sovElements(uint64(l))
	if len(m.SubzoneSpans) > 0 {
		for _, e := range m.SubzoneSpans {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if m.SeqNum != 0 {
		n += 1 + sovElements(uint64(m.SeqNum))
	}
	if m.OldIdxRef != 0 {
		n += 1 + sovElements(uint64(m.OldIdxRef))
	}
	return n
}

func (m *DatabaseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *TableData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *IndexData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	return n
}

func (m *TablePartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableSchemaLocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *LDRJobIDs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if len(m.JobIDs) > 0 {
		l = 0
		for _, e := range m.JobIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if m.ReturnSet {
		n += 2
	}
	l = m.ReturnType.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsProcedure {
		n += 2
	}
	return n
}

func (m *Function_Parameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = m.Class.Size()
	n += 1 + l + sovElements(uint64(l))
	l = m.Type.Size()
	n += 1 + l + sovElements(uint64(l))
	l = len(m.DefaultExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *FunctionName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *FunctionVolatility) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = m.Volatility.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *FunctionLeakProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	if m.LeakProof {
		n += 2
	}
	return n
}

func (m *FunctionNullInputBehavior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = m.NullInputBehavior.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *FunctionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = m.Lang.Size()
	n += 1 + l + sovElements(uint64(l))
	if len(m.UsesTables) > 0 {
		for _, e := range m.UsesTables {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if len(m.UsesViews) > 0 {
		for _, e := range m.UsesViews {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesFunctionIDs) > 0 {
		l = 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *FunctionBody_TableReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	return n
}

func (m *FunctionBody_ViewReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ViewID != 0 {
		n += 1 + sovElements(uint64(m.ViewID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *FunctionSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = m.Security.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ElementCreationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.In_23_1OrLater {
		n += 2
	}
	if m.In_24_3OrLater {
		n += 2
	}
	return n
}

func sovElements(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozElements(x uint64) (n int) {
	return sovElements(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ElementProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElementProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElementProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Database
				field Database
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Database = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Schema
				field Schema
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Schema = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_View
				field View
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.View = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Sequence
				field Sequence
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Sequence = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Table
				field Table
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Table = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_EnumType
				field EnumType
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.EnumType = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_AliasType
				field AliasType
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AliasType = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_CompositeType
				field CompositeType
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CompositeType = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Function
				field Function
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Function = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnFamily", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnFamily
				field ColumnFamily
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnFamily = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Column
				field Column
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Column = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PrimaryIndex
				field PrimaryIndex
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PrimaryIndex = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_SecondaryIndex
				field SecondaryIndex
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SecondaryIndex = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TemporaryIndex
				field TemporaryIndex
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TemporaryIndex = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueWithoutIndexConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_UniqueWithoutIndexConstraint
				field UniqueWithoutIndexConstraint
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.UniqueWithoutIndexConstraint = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_CheckConstraint
				field CheckConstraint
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CheckConstraint = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKeyConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ForeignKeyConstraint
				field ForeignKeyConstraint
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ForeignKeyConstraint = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableComment
				field TableComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_RowLevelTTL
				field RowLevelTTL
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RowLevelTTL = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnName
				field ColumnName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnType
				field ColumnType
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnType = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnDefaultExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnDefaultExpression
				field ColumnDefaultExpression
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnDefaultExpression = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOnUpdateExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnOnUpdateExpression
				field ColumnOnUpdateExpression
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnOnUpdateExpression = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOwner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_SequenceOwner
				field SequenceOwner
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SequenceOwner = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnComment
				field ColumnComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNotNull", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnNotNull
				field ColumnNotNull
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnNotNull = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_SequenceOption
				field SequenceOption
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SequenceOption = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_IndexName
				field IndexName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IndexName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_IndexPartitioning
				field IndexPartitioning
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IndexPartitioning = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_IndexComment
				field IndexComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IndexComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_IndexColumn
				field IndexColumn
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IndexColumn = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_IndexData
				field IndexData
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IndexData = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintWithoutIndexName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ConstraintWithoutIndexName
				field ConstraintWithoutIndexName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ConstraintWithoutIndexName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ConstraintComment
				field ConstraintComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ConstraintComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Namespace
				field Namespace
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Namespace = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Owner
				field Owner
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Owner = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPrivileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_UserPrivileges
				field UserPrivileges
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.UserPrivileges = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRegionConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_DatabaseRegionConfig
				field DatabaseRegionConfig
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DatabaseRegionConfig = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRoleSetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_DatabaseRoleSetting
				field DatabaseRoleSetting
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DatabaseRoleSetting = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_DatabaseComment
				field DatabaseComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DatabaseComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 83:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_DatabaseData
				field DatabaseData
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DatabaseData = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 84:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_DatabaseZoneConfig
				field DatabaseZoneConfig
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DatabaseZoneConfig = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaParent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_SchemaParent
				field SchemaParent
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SchemaParent = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_SchemaComment
				field SchemaComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SchemaComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_SchemaChild
				field SchemaChild
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SchemaChild = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityGlobal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableLocalityGlobal
				field TableLocalityGlobal
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableLocalityGlobal = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityPrimaryRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableLocalityPrimaryRegion
				field TableLocalityPrimaryRegion
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableLocalityPrimaryRegion = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalitySecondaryRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableLocalitySecondaryRegion
				field TableLocalitySecondaryRegion
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableLocalitySecondaryRegion = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityRegionalByRow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableLocalityRegionalByRow
				field TableLocalityRegionalByRow
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableLocalityRegionalByRow = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityRegionalByRowUsingConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableLocalityRegionalByRowUsingConstraint
				field TableLocalityRegionalByRowUsingConstraint
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableLocalityRegionalByRowUsingConstraint = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumTypeValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_EnumTypeValue
				field EnumTypeValue
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.EnumTypeValue = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 121:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableZoneConfig
				field TableZoneConfig
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableZoneConfig = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 122:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_IndexZoneConfig
				field IndexZoneConfig
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.IndexZoneConfig = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 131:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableData
				field TableData
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableData = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablePartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TablePartitioning
				field TablePartitioning
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TablePartitioning = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 133:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableSchemaLocked", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TableSchemaLocked
				field TableSchemaLocked
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TableSchemaLocked = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 134:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LDRJobIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_LDRJobIDs
				field LDRJobIDs
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.LDRJobIDs = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 135:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PartitionZoneConfig
				field PartitionZoneConfig
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PartitionZoneConfig = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 136:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Trigger
				field Trigger
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Trigger = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 137:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_Policy
				field Policy
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.Policy = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 138:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelSecurityEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_RowLevelSecurityEnabled
				field RowLevelSecurityEnabled
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RowLevelSecurityEnabled = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 139:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelSecurityForced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_RowLevelSecurityForced
				field RowLevelSecurityForced
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.RowLevelSecurityForced = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 140:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeAttrType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_CompositeTypeAttrType
				field CompositeTypeAttrType
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CompositeTypeAttrType = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeAttrName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_CompositeTypeAttrName
				field CompositeTypeAttrName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CompositeTypeAttrName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 160:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_FunctionName
				field FunctionName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FunctionName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 161:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionVolatility", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_FunctionVolatility
				field FunctionVolatility
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FunctionVolatility = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 162:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionLeakProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_FunctionLeakProof
				field FunctionLeakProof
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FunctionLeakProof = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 163:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionNullInputBehavior", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_FunctionNullInputBehavior
				field FunctionNullInputBehavior
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FunctionNullInputBehavior = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 164:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_FunctionBody
				field FunctionBody
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FunctionBody = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 165:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_FunctionSecurity
				field FunctionSecurity
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.FunctionSecurity = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 170:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_CheckConstraintUnvalidated
				field CheckConstraintUnvalidated
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.CheckConstraintUnvalidated = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 171:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueWithoutIndexConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_UniqueWithoutIndexConstraintUnvalidated
				field UniqueWithoutIndexConstraintUnvalidated
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.UniqueWithoutIndexConstraintUnvalidated = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 172:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKeyConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ForeignKeyConstraintUnvalidated
				field ForeignKeyConstraintUnvalidated
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ForeignKeyConstraintUnvalidated = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 180:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TypeComment
				field TypeComment
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TypeComment = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 190:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnComputeExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_ColumnComputeExpression
				field ColumnComputeExpression
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ColumnComputeExpression = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerName
				field TriggerName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerEnabled
				field TriggerEnabled
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerEnabled = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 202:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTiming", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerTiming
				field TriggerTiming
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerTiming = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 203:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerEvents
				field TriggerEvents
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerEvents = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 204:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTransition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerTransition
				field TriggerTransition
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerTransition = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 205:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerWhen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerWhen
				field TriggerWhen
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerWhen = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 206:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerFunctionCall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerFunctionCall
				field TriggerFunctionCall
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerFunctionCall = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 207:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerDeps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_TriggerDeps
				field TriggerDeps
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.TriggerDeps = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 220:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamedRangeZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_NamedRangeZoneConfig
				field NamedRangeZoneConfig
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.NamedRangeZoneConfig = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 240:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PolicyName
				field PolicyName
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PolicyName = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 241:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PolicyRole
				field PolicyRole
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PolicyRole = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 242:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyUsingExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PolicyUsingExpr
				field PolicyUsingExpr
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PolicyUsingExpr = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 243:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyWithCheckExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PolicyWithCheckExpr
				field PolicyWithCheckExpr
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PolicyWithCheckExpr = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		case 244:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyDeps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value ElementProto_PolicyDeps
				field PolicyDeps
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.PolicyDeps = &alloc.field
			m.ElementOneOf = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClosedTypeIDs = append(m.ClosedTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ClosedTypeIDs == nil {
						m.ClosedTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.ClosedTypeIDs = slices.Grow(m.ClosedTypeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClosedTypeIDs = append(m.ClosedTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTypeIDs", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.Expression(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesTypeIDs == nil {
						m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesTypeIDs = slices.Grow(m.UsesTypeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesSequenceIDs == nil {
						m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesSequenceIDs = slices.Grow(m.UsesSequenceIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ReferencedColumnIDs == nil {
						m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ReferencedColumnIDs = slices.Grow(m.ReferencedColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesFunctionIDs == nil {
						m.UsesFunctionIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesFunctionIDs = slices.Grow(m.UsesFunctionIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesFunctionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInaccessible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInaccessible = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentityType", wireType)
			}
			m.GeneratedAsIdentityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneratedAsIdentityType |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentitySequenceOption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedAsIdentitySequenceOption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgAttributeNum", wireType)
			}
			m.PgAttributeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgAttributeNum |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSystemColumn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSystemColumn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNullable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputeExpr == nil {
				m.ComputeExpr = &Expression{}
			}
			if err := m.ComputeExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtual = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementCreationMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ElementCreationMetadata == nil {
				m.ElementCreationMetadata = &ElementCreationMetadata{}
			}
			if err := m.ElementCreationMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnFamilyOrderFollowsColumnID", wireType)
			}
			m.ColumnFamilyOrderFollowsColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnFamilyOrderFollowsColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnComputeExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnComputeExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnComputeExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			m.Usage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usage |= ColumnComputeExpression_Usage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnFamily) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnFamily: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnFamily: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &catpb.ShardedDescriptor{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCreatedExplicitly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCreatedExplicitly = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConcurrently", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConcurrently = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndexID", wireType)
			}
			m.SourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndexID", wireType)
			}
			m.TemporaryIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemporaryIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNotVisible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNotVisible = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoConfig == nil {
				m.GeoConfig = &geopb.Config{}
			}
			if err := m.GeoConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invisibility", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Invisibility = float64(math.Float64frombits(v))
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= idxtype.T(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VecConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VecConfig == nil {
				m.VecConfig = &vecpb.Config{}
			}
			if err := m.VecConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbeddedExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmbeddedExpr == nil {
				m.EmbeddedExpr = &Expression{}
			}
			if err := m.EmbeddedExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecreateSourceIndexID", wireType)
			}
			m.RecreateSourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecreateSourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecreateTargetIndexID", wireType)
			}
			m.RecreateTargetIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecreateTargetIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideForPrimaryKeyRecreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideForPrimaryKeyRecreated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemporaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemporaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemporaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsingSecondaryEncoding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsingSecondaryEncoding = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expression{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaParent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaParent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaParent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentDatabaseID", wireType)
			}
			m.ParentDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentDatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildObjectID", wireType)
			}
			m.ChildObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildObjectID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			m.PolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.PolicyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.PolicyCommand(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			m.PolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			m.PolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyUsingExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyUsingExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyUsingExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			m.PolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyWithCheckExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyWithCheckExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyWithCheckExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			m.PolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyDeps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyDeps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyDeps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			m.PolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PolicyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesTypeIDs == nil {
						m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesTypeIDs = slices.Grow(m.UsesTypeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRelationIDs = append(m.UsesRelationIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesRelationIDs == nil {
						m.UsesRelationIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesRelationIDs = slices.Grow(m.UsesRelationIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRelationIDs = append(m.UsesRelationIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRelationIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesFunctionIDs == nil {
						m.UsesFunctionIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesFunctionIDs = slices.Grow(m.UsesFunctionIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesFunctionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelSecurityEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelSecurityEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelSecurityEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelSecurityForced) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelSecurityForced: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelSecurityForced: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsForced = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartWith", wireType)
			}
			m.RestartWith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartWith |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRestartWith", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRestartWith = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnDefaultExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnDefaultExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnDefaultExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOnUpdateExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOnUpdateExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOnUpdateExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewID", wireType)
			}
			m.ViewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesTypeIDs == nil {
						m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesTypeIDs = slices.Grow(m.UsesTypeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRelationIDs = append(m.UsesRelationIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesRelationIDs == nil {
						m.UsesRelationIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesRelationIDs = slices.Grow(m.UsesRelationIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRelationIDs = append(m.UsesRelationIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRelationIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardReferences = append(m.ForwardReferences, &View_Reference{})
			if err := m.ForwardReferences[len(m.ForwardReferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMaterialized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMaterialized = bool(v != 0)
		case 12:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRoutineIDs = append(m.UsesRoutineIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesRoutineIDs == nil {
						m.UsesRoutineIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesRoutineIDs = slices.Grow(m.UsesRoutineIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRoutineIDs = append(m.UsesRoutineIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRoutineIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View_Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToID", wireType)
			}
			m.ToID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueWithoutIndexConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predicate == nil {
				m.Predicate = &Expression{}
			}
			if err := m.Predicate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueWithoutIndexConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predicate == nil {
				m.Predicate = &Expression{}
			}
			if err := m.Predicate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromHashShardedColumn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromHashShardedColumn = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedTableID", wireType)
			}
			m.ReferencedTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencedTableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ReferencedColumnIDs == nil {
						m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ReferencedColumnIDs = slices.Grow(m.ReferencedColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateAction", wireType)
			}
			m.OnUpdateAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdateAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDeleteAction", wireType)
			}
			m.OnDeleteAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDeleteAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeKeyMatchMethod", wireType)
			}
			m.CompositeKeyMatchMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeKeyMatchMethod |= semenumpb.Match(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedTableID", wireType)
			}
			m.ReferencedTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencedTableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ReferencedColumnIDs == nil {
						m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ReferencedColumnIDs = slices.Grow(m.ReferencedColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateAction", wireType)
			}
			m.OnUpdateAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdateAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDeleteAction", wireType)
			}
			m.OnDeleteAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDeleteAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeKeyMatchMethod", wireType)
			}
			m.CompositeKeyMatchMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeKeyMatchMethod |= semenumpb.Match(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerTiming) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerTiming: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerTiming: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionTime", wireType)
			}
			m.ActionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionTime |= semenumpb.TriggerActionTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForEachRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForEachRow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= semenumpb.TriggerEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &TriggerEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerTransition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerTransition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerTransition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTransitionAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTransitionAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldTransitionAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldTransitionAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerWhen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerWhen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerWhen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhenExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhenExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerFunctionCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerFunctionCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerFunctionCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncID", wireType)
			}
			m.FuncID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FuncID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncArgs = append(m.FuncArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerDeps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerDeps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerDeps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerID", wireType)
			}
			m.TriggerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.TriggerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRelationIDs = append(m.UsesRelationIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesRelationIDs == nil {
						m.UsesRelationIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesRelationIDs = slices.Grow(m.UsesRelationIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRelationIDs = append(m.UsesRelationIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRelationIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesTypeIDs == nil {
						m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesTypeIDs = slices.Grow(m.UsesTypeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRoutineIDs = append(m.UsesRoutineIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesRoutineIDs == nil {
						m.UsesRoutineIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesRoutineIDs = slices.Grow(m.UsesRoutineIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRoutineIDs = append(m.UsesRoutineIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRoutineIDs", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRelations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsesRelations = append(m.UsesRelations, TriggerDeps_RelationReference{})
			if err := m.UsesRelations[len(m.UsesRelations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerDeps_RelationReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayTypeID", wireType)
			}
			m.ArrayTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrayTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultiRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultiRegion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayTypeID", wireType)
			}
			m.ArrayTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrayTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublic = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtual = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Owner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Owner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Owner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPrivileges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrivileges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrivileges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			m.Privileges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Privileges |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithGrantOption", wireType)
			}
			m.WithGrantOption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithGrantOption |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedRangeZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedRangeZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedRangeZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZoneConfig == nil {
				m.ZoneConfig = &zonepb.ZoneConfig{}
			}
			if err := m.ZoneConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityGlobal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityGlobal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityGlobal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityPrimaryRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityPrimaryRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityPrimaryRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalitySecondaryRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalitySecondaryRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalitySecondaryRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEnumTypeID", wireType)
			}
			m.RegionEnumTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionEnumTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionName = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityRegionalByRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityRegionalByRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityRegionalByRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.As = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityRegionalByRowUsingConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityRegionalByRowUsingConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityRegionalByRowUsingConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexPartitioning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexPartitioning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexPartitioning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitioningDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitioningDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelTTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelTTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelTTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowLevelTTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTLExpr == nil {
				m.TTLExpr = &Expression{}
			}
			if err := m.TTLExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintWithoutIndexName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintWithoutIndexName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintWithoutIndexName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgAttributeNum", wireType)
			}
			m.PgAttributeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgAttributeNum |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnNotNull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnNotNull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnNotNull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRegionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRegionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRegionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEnumTypeID", wireType)
			}
			m.RegionEnumTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionEnumTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRoleSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRoleSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRoleSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrdinalInKind", wireType)
			}
			m.OrdinalInKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrdinalInKind |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= IndexColumn_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= catenumpb.IndexColumn_Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implicit = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedKind", wireType)
			}
			m.InvertedKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedKind |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.InvertedIndexColumnKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumTypeValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumTypeValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumTypeValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRepresentation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRepresentation = append(m.PhysicalRepresentation[:0], dAtA[iNdEx:postIndex]...)
			if m.PhysicalRepresentation == nil {
				m.PhysicalRepresentation = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalRepresentation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalRepresentation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeTypeAttrName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeTypeAttrName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeTypeAttrName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeID", wireType)
			}
			m.CompositeTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeTypeAttrType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeTypeAttrType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeTypeAttrType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeID", wireType)
			}
			m.CompositeTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZoneConfig == nil {
				m.ZoneConfig = &zonepb.ZoneConfig{}
			}
			if err := m.ZoneConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZoneConfig == nil {
				m.ZoneConfig = &zonepb.ZoneConfig{}
			}
			if err := m.ZoneConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subzone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subzone.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubzoneSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubzoneSpans = append(m.SubzoneSpans, zonepb.SubzoneSpan{})
			if err := m.SubzoneSpans[len(m.SubzoneSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldIdxRef", wireType)
			}
			m.OldIdxRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldIdxRef |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subzone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subzone.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubzoneSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubzoneSpans = append(m.SubzoneSpans, zonepb.SubzoneSpan{})
			if err := m.SubzoneSpans[len(m.SubzoneSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldIdxRef", wireType)
			}
			m.OldIdxRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldIdxRef |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TablePartitioning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TablePartitioning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TablePartitioning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableSchemaLocked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableSchemaLocked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableSchemaLocked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LDRJobIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LDRJobIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LDRJobIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.JobIDs = append(m.JobIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.JobIDs == nil {
						m.JobIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID, 0, elementCount)
					} else {
						m.JobIDs = slices.Grow(m.JobIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.JobIDs = append(m.JobIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, Function_Parameter{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnSet = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReturnType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProcedure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProcedure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function_Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Class.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionVolatility) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionVolatility: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionVolatility: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volatility", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Volatility.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionLeakProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionLeakProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionLeakProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakProof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeakProof = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionNullInputBehavior) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionNullInputBehavior: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionNullInputBehavior: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullInputBehavior", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NullInputBehavior.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lang.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsesTables = append(m.UsesTables, FunctionBody_TableReference{})
			if err := m.UsesTables[len(m.UsesTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsesViews = append(m.UsesViews, FunctionBody_ViewReference{})
			if err := m.UsesViews[len(m.UsesViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesSequenceIDs == nil {
						m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesSequenceIDs = slices.Grow(m.UsesSequenceIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesTypeIDs == nil {
						m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesTypeIDs = slices.Grow(m.UsesTypeIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.UsesFunctionIDs == nil {
						m.UsesFunctionIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
					} else {
						m.UsesFunctionIDs = slices.Grow(m.UsesFunctionIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesFunctionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionBody_TableReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionBody_ViewReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewID", wireType)
			}
			m.ViewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 {
					if m.ColumnIDs == nil {
						m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
					} else {
						m.ColumnIDs = slices.Grow(m.ColumnIDs, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElementCreationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElementCreationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElementCreationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field In_23_1OrLater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.In_23_1OrLater = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field In_24_3OrLater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.In_24_3OrLater = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipElements(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowElements
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthElements
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupElements
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthElements
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthElements        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowElements          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupElements = fmt.Errorf("proto: unexpected end of group")
)

