// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/main/protobuf/invocation_policy.proto

package blaze_invocation_policy

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SetValue_Behavior int32

const (
	SetValue_UNDEFINED SetValue_Behavior = 0
	// Change the flag value but allow it to be overridden by explicit settings
	// from command line/config expansion/rc files.
	// Matching old flag values: append = false, overridable = true.
	SetValue_ALLOW_OVERRIDES SetValue_Behavior = 1
	// Append a new value for a repeatable flag, leave old values and allow
	// further overrides.
	// Matching old flag values: append = true, overridable = false.
	SetValue_APPEND SetValue_Behavior = 2
	// Set a final value of the flag. Any overrides provided by the user for
	// this flag will be ignored.
	// Matching old flag values: append = false, overridable = false.
	SetValue_FINAL_VALUE_IGNORE_OVERRIDES SetValue_Behavior = 3
)

var SetValue_Behavior_name = map[int32]string{
	0: "UNDEFINED",
	1: "ALLOW_OVERRIDES",
	2: "APPEND",
	3: "FINAL_VALUE_IGNORE_OVERRIDES",
}

var SetValue_Behavior_value = map[string]int32{
	"UNDEFINED":                    0,
	"ALLOW_OVERRIDES":              1,
	"APPEND":                       2,
	"FINAL_VALUE_IGNORE_OVERRIDES": 3,
}

func (x SetValue_Behavior) Enum() *SetValue_Behavior {
	p := new(SetValue_Behavior)
	*p = x
	return p
}

func (x SetValue_Behavior) String() string {
	return proto.EnumName(SetValue_Behavior_name, int32(x))
}

func (x *SetValue_Behavior) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SetValue_Behavior_value, data, "SetValue_Behavior")
	if err != nil {
		return err
	}
	*x = SetValue_Behavior(value)
	return nil
}

func (SetValue_Behavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{2, 0}
}

// The --invocation_policy flag takes a base64-encoded binary-serialized or text
// formatted InvocationPolicy message.
type InvocationPolicy struct {
	// Order matters.
	// After expanding policies on expansion flags or flags with implicit
	// requirements, only the final policy on a specific flag will be enforced
	// onto the user's command line.
	FlagPolicies []*FlagPolicy `protobuf:"bytes,1,rep,name=flag_policies,json=flagPolicies" json:"flag_policies,omitempty"`
}

func (m *InvocationPolicy) Reset()         { *m = InvocationPolicy{} }
func (m *InvocationPolicy) String() string { return proto.CompactTextString(m) }
func (*InvocationPolicy) ProtoMessage()    {}
func (*InvocationPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{0}
}
func (m *InvocationPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvocationPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InvocationPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvocationPolicy.Merge(m, src)
}
func (m *InvocationPolicy) XXX_Size() int {
	return m.Size()
}
func (m *InvocationPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_InvocationPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_InvocationPolicy proto.InternalMessageInfo

// A policy for controlling the value of a flag.
type FlagPolicy struct {
	// The name of the flag to enforce this policy on.
	//
	// Note that this should be the full name of the flag, not the abbreviated
	// name of the flag. If the user specifies the abbreviated name of a flag,
	// that flag will be matched using its full name.
	//
	// The "no" prefix will not be parsed, so for boolean flags, use
	// the flag's full name and explicitly set it to true or false.
	FlagName *string `protobuf:"bytes,1,opt,name=flag_name,json=flagName" json:"flag_name,omitempty"`
	// If set, this flag policy is applied only if one of the given commands or a
	// command that inherits from one of the given commands is being run. For
	// instance, if "build" is one of the commands here, then this policy will
	// apply to any command that inherits from build, such as info, coverage, or
	// test. If empty, this flag policy is applied for all commands. This allows
	// the policy setter to add all policies to the proto without having to
	// determine which Bazel command the user is actually running. Additionally,
	// Bazel allows multiple flags to be defined by the same name, and the
	// specific flag definition is determined by the command.
	Commands []string `protobuf:"bytes,2,rep,name=commands" json:"commands,omitempty"`
	// Types that are valid to be assigned to Operation:
	//
	//	*FlagPolicy_SetValue
	//	*FlagPolicy_UseDefault
	//	*FlagPolicy_DisallowValues
	//	*FlagPolicy_AllowValues
	Operation isFlagPolicy_Operation `protobuf_oneof:"operation"`
}

func (m *FlagPolicy) Reset()         { *m = FlagPolicy{} }
func (m *FlagPolicy) String() string { return proto.CompactTextString(m) }
func (*FlagPolicy) ProtoMessage()    {}
func (*FlagPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{1}
}
func (m *FlagPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlagPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlagPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlagPolicy.Merge(m, src)
}
func (m *FlagPolicy) XXX_Size() int {
	return m.Size()
}
func (m *FlagPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_FlagPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_FlagPolicy proto.InternalMessageInfo

type isFlagPolicy_Operation interface {
	isFlagPolicy_Operation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlagPolicy_SetValue struct {
	SetValue *SetValue `protobuf:"bytes,3,opt,name=set_value,json=setValue,oneof" json:"set_value,omitempty"`
}
type FlagPolicy_UseDefault struct {
	UseDefault *UseDefault `protobuf:"bytes,4,opt,name=use_default,json=useDefault,oneof" json:"use_default,omitempty"`
}
type FlagPolicy_DisallowValues struct {
	DisallowValues *DisallowValues `protobuf:"bytes,5,opt,name=disallow_values,json=disallowValues,oneof" json:"disallow_values,omitempty"`
}
type FlagPolicy_AllowValues struct {
	AllowValues *AllowValues `protobuf:"bytes,6,opt,name=allow_values,json=allowValues,oneof" json:"allow_values,omitempty"`
}

func (*FlagPolicy_SetValue) isFlagPolicy_Operation()       {}
func (*FlagPolicy_UseDefault) isFlagPolicy_Operation()     {}
func (*FlagPolicy_DisallowValues) isFlagPolicy_Operation() {}
func (*FlagPolicy_AllowValues) isFlagPolicy_Operation()    {}

func (m *FlagPolicy) GetOperation() isFlagPolicy_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *FlagPolicy) GetSetValue() *SetValue {
	if x, ok := m.GetOperation().(*FlagPolicy_SetValue); ok {
		return x.SetValue
	}
	return nil
}

func (m *FlagPolicy) GetUseDefault() *UseDefault {
	if x, ok := m.GetOperation().(*FlagPolicy_UseDefault); ok {
		return x.UseDefault
	}
	return nil
}

func (m *FlagPolicy) GetDisallowValues() *DisallowValues {
	if x, ok := m.GetOperation().(*FlagPolicy_DisallowValues); ok {
		return x.DisallowValues
	}
	return nil
}

func (m *FlagPolicy) GetAllowValues() *AllowValues {
	if x, ok := m.GetOperation().(*FlagPolicy_AllowValues); ok {
		return x.AllowValues
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FlagPolicy) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FlagPolicy_SetValue)(nil),
		(*FlagPolicy_UseDefault)(nil),
		(*FlagPolicy_DisallowValues)(nil),
		(*FlagPolicy_AllowValues)(nil),
	}
}

type SetValue struct {
	// Use this value for the specified flag, overriding any default or user-set
	// value (unless behavior = APPEND for repeatable flags).
	//
	// This field is repeated for repeatable flags. It is an error to set
	// multiple values for a flag that is not actually a repeatable flag.
	// This requires at least 1 value, if even the empty string.
	//
	// If the flag allows multiple values, all of its values are replaced with the
	// value or values from the policy (i.e., no diffing or merging is performed),
	// unless behavior = APPEND (see below).
	//
	// Note that some flags are tricky. For example, some flags look like boolean
	// flags, but are actually Void expansion flags that expand into other flags.
	// The Bazel flag parser will accept "--void_flag=false", but because
	// the flag is Void, the "=false" is ignored. It can get even trickier, like
	// "--novoid_flag" which is also an expansion flag with the type Void whose
	// name is explicitly "novoid_flag" and which expands into other flags that
	// are the opposite of "--void_flag". For expansion flags, it's best to
	// explicitly override the flags they expand into.
	//
	// Other flags may be differently tricky: A flag could have a converter that
	// converts some string to a list of values, but that flag may not itself have
	// allowMultiple set to true.
	//
	// An example is "--test_tag_filters": this flag sets its converter to
	// CommaSeparatedOptionListConverter, but does not set allowMultiple to true.
	// So "--test_tag_filters=foo,bar" results in ["foo", "bar"], however
	// "--test_tag_filters=foo --test_tag_filters=bar" results in just ["bar"]
	// since the 2nd value overrides the 1st.
	//
	// Similarly, "--test_tag_filters=foo,bar --test_tag_filters=baz,qux" results
	// in ["baz", "qux"]. For flags like these, the policy should specify
	// "foo,bar" instead of separately specifying "foo" and "bar" so that the
	// converter is appropriately invoked.
	//
	// Note that the opposite is not necessarily
	// true: for a flag that specifies allowMultiple=true, "--flag=foo,bar"
	// may fail to parse or result in an unexpected value.
	FlagValue []string `protobuf:"bytes,1,rep,name=flag_value,json=flagValue" json:"flag_value,omitempty"`
	// Defines how invocation policy should interact with user settings for the
	// same flag.
	Behavior *SetValue_Behavior `protobuf:"varint,4,opt,name=behavior,enum=blaze.invocation_policy.SetValue_Behavior" json:"behavior,omitempty"`
}

func (m *SetValue) Reset()         { *m = SetValue{} }
func (m *SetValue) String() string { return proto.CompactTextString(m) }
func (*SetValue) ProtoMessage()    {}
func (*SetValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{2}
}
func (m *SetValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SetValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetValue.Merge(m, src)
}
func (m *SetValue) XXX_Size() int {
	return m.Size()
}
func (m *SetValue) XXX_DiscardUnknown() {
	xxx_messageInfo_SetValue.DiscardUnknown(m)
}

var xxx_messageInfo_SetValue proto.InternalMessageInfo

type UseDefault struct {
}

func (m *UseDefault) Reset()         { *m = UseDefault{} }
func (m *UseDefault) String() string { return proto.CompactTextString(m) }
func (*UseDefault) ProtoMessage()    {}
func (*UseDefault) Descriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{3}
}
func (m *UseDefault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UseDefault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UseDefault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UseDefault.Merge(m, src)
}
func (m *UseDefault) XXX_Size() int {
	return m.Size()
}
func (m *UseDefault) XXX_DiscardUnknown() {
	xxx_messageInfo_UseDefault.DiscardUnknown(m)
}

var xxx_messageInfo_UseDefault proto.InternalMessageInfo

type DisallowValues struct {
	// It is an error for the user to use any of these values (that is, the Bazel
	// command will fail), unless new_value or use_default is set.
	//
	// For repeatable flags, if any one of the values in the flag matches a value
	// in the list of disallowed values, an error is thrown.
	//
	// Care must be taken for flags with complicated converters. For example,
	// it's possible for a repeated flag to be of type List<List<T>>, so that
	// "--foo=a,b --foo=c,d" results in foo=[["a","b"], ["c", "d"]]. In this case,
	// it is not possible to disallow just "b", nor will ["b", "a"] match, nor
	// will ["b", "c"] (but ["a", "b"] will still match).
	DisallowedValues []string `protobuf:"bytes,1,rep,name=disallowed_values,json=disallowedValues" json:"disallowed_values,omitempty"`
	// Types that are valid to be assigned to ReplacementValue:
	//
	//	*DisallowValues_NewValue
	//	*DisallowValues_UseDefault
	ReplacementValue isDisallowValues_ReplacementValue `protobuf_oneof:"replacement_value"`
}

func (m *DisallowValues) Reset()         { *m = DisallowValues{} }
func (m *DisallowValues) String() string { return proto.CompactTextString(m) }
func (*DisallowValues) ProtoMessage()    {}
func (*DisallowValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{4}
}
func (m *DisallowValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisallowValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DisallowValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisallowValues.Merge(m, src)
}
func (m *DisallowValues) XXX_Size() int {
	return m.Size()
}
func (m *DisallowValues) XXX_DiscardUnknown() {
	xxx_messageInfo_DisallowValues.DiscardUnknown(m)
}

var xxx_messageInfo_DisallowValues proto.InternalMessageInfo

type isDisallowValues_ReplacementValue interface {
	isDisallowValues_ReplacementValue()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DisallowValues_NewValue struct {
	NewValue string `protobuf:"bytes,3,opt,name=new_value,json=newValue,oneof" json:"new_value,omitempty"`
}
type DisallowValues_UseDefault struct {
	UseDefault *UseDefault `protobuf:"bytes,4,opt,name=use_default,json=useDefault,oneof" json:"use_default,omitempty"`
}

func (*DisallowValues_NewValue) isDisallowValues_ReplacementValue()   {}
func (*DisallowValues_UseDefault) isDisallowValues_ReplacementValue() {}

func (m *DisallowValues) GetReplacementValue() isDisallowValues_ReplacementValue {
	if m != nil {
		return m.ReplacementValue
	}
	return nil
}

func (m *DisallowValues) GetNewValue() string {
	if x, ok := m.GetReplacementValue().(*DisallowValues_NewValue); ok {
		return x.NewValue
	}
	return ""
}

func (m *DisallowValues) GetUseDefault() *UseDefault {
	if x, ok := m.GetReplacementValue().(*DisallowValues_UseDefault); ok {
		return x.UseDefault
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DisallowValues) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DisallowValues_NewValue)(nil),
		(*DisallowValues_UseDefault)(nil),
	}
}

type AllowValues struct {
	// It is an error for the user to use any value not in this list, unless
	// new_value or use_default is set.
	AllowedValues []string `protobuf:"bytes,1,rep,name=allowed_values,json=allowedValues" json:"allowed_values,omitempty"`
	// Types that are valid to be assigned to ReplacementValue:
	//
	//	*AllowValues_NewValue
	//	*AllowValues_UseDefault
	ReplacementValue isAllowValues_ReplacementValue `protobuf_oneof:"replacement_value"`
}

func (m *AllowValues) Reset()         { *m = AllowValues{} }
func (m *AllowValues) String() string { return proto.CompactTextString(m) }
func (*AllowValues) ProtoMessage()    {}
func (*AllowValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_e130ca0062eb2b66, []int{5}
}
func (m *AllowValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllowValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowValues.Merge(m, src)
}
func (m *AllowValues) XXX_Size() int {
	return m.Size()
}
func (m *AllowValues) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowValues.DiscardUnknown(m)
}

var xxx_messageInfo_AllowValues proto.InternalMessageInfo

type isAllowValues_ReplacementValue interface {
	isAllowValues_ReplacementValue()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AllowValues_NewValue struct {
	NewValue string `protobuf:"bytes,3,opt,name=new_value,json=newValue,oneof" json:"new_value,omitempty"`
}
type AllowValues_UseDefault struct {
	UseDefault *UseDefault `protobuf:"bytes,4,opt,name=use_default,json=useDefault,oneof" json:"use_default,omitempty"`
}

func (*AllowValues_NewValue) isAllowValues_ReplacementValue()   {}
func (*AllowValues_UseDefault) isAllowValues_ReplacementValue() {}

func (m *AllowValues) GetReplacementValue() isAllowValues_ReplacementValue {
	if m != nil {
		return m.ReplacementValue
	}
	return nil
}

func (m *AllowValues) GetNewValue() string {
	if x, ok := m.GetReplacementValue().(*AllowValues_NewValue); ok {
		return x.NewValue
	}
	return ""
}

func (m *AllowValues) GetUseDefault() *UseDefault {
	if x, ok := m.GetReplacementValue().(*AllowValues_UseDefault); ok {
		return x.UseDefault
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AllowValues) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AllowValues_NewValue)(nil),
		(*AllowValues_UseDefault)(nil),
	}
}

func init() {
	proto.RegisterEnum("blaze.invocation_policy.SetValue_Behavior", SetValue_Behavior_name, SetValue_Behavior_value)
	proto.RegisterType((*InvocationPolicy)(nil), "blaze.invocation_policy.InvocationPolicy")
	proto.RegisterType((*FlagPolicy)(nil), "blaze.invocation_policy.FlagPolicy")
	proto.RegisterType((*SetValue)(nil), "blaze.invocation_policy.SetValue")
	proto.RegisterType((*UseDefault)(nil), "blaze.invocation_policy.UseDefault")
	proto.RegisterType((*DisallowValues)(nil), "blaze.invocation_policy.DisallowValues")
	proto.RegisterType((*AllowValues)(nil), "blaze.invocation_policy.AllowValues")
}

func init() {
	proto.RegisterFile("src/main/protobuf/invocation_policy.proto", fileDescriptor_e130ca0062eb2b66)
}

var fileDescriptor_e130ca0062eb2b66 = []byte{
	// 577 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x94, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xbd, 0x49, 0xbf, 0xca, 0x9e, 0xb4, 0x69, 0xba, 0x3d, 0x7c, 0x11, 0x50, 0x2b, 0x18,
	0x10, 0x85, 0x4a, 0xae, 0xd4, 0x27, 0x20, 0x91, 0x1d, 0x62, 0x14, 0xdc, 0xca, 0x55, 0xcb, 0xa5,
	0x92, 0xb5, 0xb1, 0x37, 0xc1, 0xd2, 0xda, 0x1b, 0x79, 0xed, 0x54, 0xf0, 0x14, 0x3c, 0x0d, 0x57,
	0xae, 0x3d, 0xf6, 0x58, 0x89, 0x0b, 0xa4, 0x8f, 0xc1, 0x05, 0x65, 0x1d, 0x37, 0x89, 0x20, 0xe2,
	0xc2, 0x81, 0x8b, 0xb5, 0x3b, 0xf3, 0xdf, 0xbf, 0x66, 0x7e, 0x33, 0x32, 0xbc, 0x10, 0x69, 0x70,
	0x14, 0x93, 0x28, 0x39, 0x1a, 0xa7, 0x3c, 0xe3, 0x83, 0x7c, 0x78, 0x14, 0x25, 0x13, 0x1e, 0x90,
	0x2c, 0xe2, 0x89, 0x3f, 0xe6, 0x2c, 0x0a, 0x3e, 0x98, 0x32, 0x85, 0xff, 0x1f, 0x30, 0xf2, 0x91,
	0x9a, 0xbf, 0xa4, 0x8d, 0x4b, 0x68, 0x38, 0xf7, 0xc1, 0x53, 0x19, 0xc3, 0x3d, 0xd8, 0x1e, 0x32,
	0x32, 0x2a, 0x24, 0x11, 0x15, 0x4d, 0xd4, 0xaa, 0x1e, 0xd4, 0x8e, 0x9f, 0x98, 0x6b, 0x4c, 0xcc,
	0x2e, 0x23, 0xa3, 0xe2, 0xad, 0xb7, 0x35, 0x2c, 0xcf, 0x11, 0x15, 0xc6, 0x8f, 0x0a, 0xc0, 0x22,
	0x89, 0x1f, 0x82, 0x26, 0x8d, 0x13, 0x12, 0xd3, 0x26, 0x6a, 0xa1, 0x03, 0xcd, 0x53, 0x67, 0x01,
	0x97, 0xc4, 0x14, 0x3f, 0x00, 0x35, 0xe0, 0x71, 0x4c, 0x92, 0x50, 0x34, 0x2b, 0xad, 0xea, 0x2c,
	0x57, 0xde, 0xf1, 0x2b, 0xd0, 0x04, 0xcd, 0xfc, 0x09, 0x61, 0x39, 0x6d, 0x56, 0x5b, 0xe8, 0xa0,
	0x76, 0xfc, 0x78, 0x6d, 0x35, 0x67, 0x34, 0xbb, 0x98, 0x09, 0x7b, 0x8a, 0xa7, 0x8a, 0xf9, 0x19,
	0x77, 0xa1, 0x96, 0x0b, 0xea, 0x87, 0x74, 0x48, 0x72, 0x96, 0x35, 0x37, 0xa4, 0xc7, 0xfa, 0x8e,
	0xce, 0x05, 0xb5, 0x0a, 0x69, 0x4f, 0xf1, 0x20, 0xbf, 0xbf, 0x61, 0x0f, 0x76, 0xc2, 0x48, 0x10,
	0xc6, 0xf8, 0x55, 0x51, 0x8e, 0x68, 0xfe, 0x27, 0xbd, 0x9e, 0xaf, 0xf5, 0xb2, 0xe6, 0x7a, 0x59,
	0x88, 0xe8, 0x29, 0x5e, 0x3d, 0x5c, 0x89, 0x60, 0x07, 0xb6, 0x56, 0x0c, 0x37, 0xa5, 0xe1, 0xd3,
	0xb5, 0x86, 0xed, 0x15, 0xb7, 0xda, 0x92, 0x55, 0xa7, 0x06, 0x1a, 0x1f, 0xd3, 0x54, 0xca, 0x8d,
	0xaf, 0x08, 0xd4, 0x12, 0x06, 0xde, 0x07, 0x90, 0xec, 0x0b, 0x86, 0x48, 0x02, 0x96, 0xd3, 0x28,
	0xf9, 0xa8, 0x03, 0xfa, 0x9e, 0x4c, 0x22, 0x9e, 0x4a, 0x38, 0xf5, 0xe3, 0x97, 0x7f, 0x04, 0x6c,
	0x76, 0xe6, 0x2f, 0xbc, 0xfb, 0xb7, 0xc6, 0x25, 0xa8, 0x65, 0x14, 0x6f, 0x83, 0x76, 0xee, 0x5a,
	0x76, 0xd7, 0x71, 0x6d, 0xab, 0xa1, 0xe0, 0x3d, 0xd8, 0x69, 0xf7, 0xfb, 0x27, 0xef, 0xfc, 0x93,
	0x0b, 0xdb, 0xf3, 0x1c, 0xcb, 0x3e, 0x6b, 0x20, 0x0c, 0xb0, 0xd9, 0x3e, 0x3d, 0xb5, 0x5d, 0xab,
	0x51, 0xc1, 0x2d, 0x78, 0xd4, 0x75, 0xdc, 0x76, 0xdf, 0xbf, 0x68, 0xf7, 0xcf, 0x6d, 0xdf, 0x79,
	0xed, 0x9e, 0x78, 0xf6, 0x92, 0xba, 0xfa, 0x66, 0x43, 0xad, 0xc8, 0x6f, 0xb5, 0xb1, 0x61, 0x6c,
	0x01, 0x2c, 0xa6, 0x64, 0x7c, 0x41, 0x50, 0x5f, 0x05, 0x8d, 0x0f, 0x61, 0xb7, 0x04, 0x4d, 0xc3,
	0x92, 0x6d, 0xd1, 0x78, 0x63, 0x91, 0x98, 0x8b, 0xf7, 0x41, 0x4b, 0xe8, 0xd5, 0xd2, 0x86, 0x69,
	0xb3, 0xf5, 0x49, 0xe8, 0xd5, 0x5f, 0x5d, 0x9f, 0xce, 0x1e, 0xec, 0xa6, 0x74, 0xcc, 0x48, 0x40,
	0x63, 0x9a, 0xcc, 0x17, 0xba, 0xe8, 0xca, 0xf8, 0x8c, 0xa0, 0xb6, 0x34, 0x59, 0xfc, 0x0c, 0xea,
	0xbf, 0xad, 0x7d, 0xfb, 0x1f, 0x2b, 0xbc, 0xf3, 0xf6, 0xfa, 0xbb, 0xae, 0x5c, 0x4f, 0x75, 0x74,
	0x33, 0xd5, 0xd1, 0xed, 0x54, 0x47, 0xdf, 0xa6, 0x3a, 0xfa, 0x74, 0xa7, 0x2b, 0x37, 0x77, 0xba,
	0x72, 0x7b, 0xa7, 0x2b, 0x70, 0x18, 0xf0, 0xd8, 0x1c, 0x71, 0x3e, 0x62, 0xd4, 0x0c, 0xe9, 0x24,
	0xe3, 0x9c, 0x09, 0x73, 0x90, 0x47, 0x2c, 0x34, 0x59, 0x34, 0x30, 0xd3, 0x3c, 0xc9, 0xa2, 0x98,
	0x16, 0xbf, 0xaa, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x3e, 0x98, 0x19, 0xe5, 0xd6, 0x04, 0x00,
	0x00,
}

func (m *InvocationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvocationPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvocationPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FlagPolicies) > 0 {
		for iNdEx := len(m.FlagPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlagPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlagPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlagPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commands[iNdEx])
			copy(dAtA[i:], m.Commands[iNdEx])
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(m.Commands[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FlagName != nil {
		i -= len(*m.FlagName)
		copy(dAtA[i:], *m.FlagName)
		i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(*m.FlagName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlagPolicy_SetValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagPolicy_SetValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetValue != nil {
		{
			size, err := m.SetValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *FlagPolicy_UseDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagPolicy_UseDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefault != nil {
		{
			size, err := m.UseDefault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *FlagPolicy_DisallowValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagPolicy_DisallowValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisallowValues != nil {
		{
			size, err := m.DisallowValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *FlagPolicy_AllowValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagPolicy_AllowValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowValues != nil {
		{
			size, err := m.AllowValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SetValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Behavior != nil {
		i = encodeVarintInvocationPolicy(dAtA, i, uint64(*m.Behavior))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FlagValue) > 0 {
		for iNdEx := len(m.FlagValue) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FlagValue[iNdEx])
			copy(dAtA[i:], m.FlagValue[iNdEx])
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(m.FlagValue[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UseDefault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UseDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DisallowValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisallowValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisallowValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplacementValue != nil {
		{
			size := m.ReplacementValue.Size()
			i -= size
			if _, err := m.ReplacementValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DisallowedValues) > 0 {
		for iNdEx := len(m.DisallowedValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DisallowedValues[iNdEx])
			copy(dAtA[i:], m.DisallowedValues[iNdEx])
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(m.DisallowedValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DisallowValues_NewValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisallowValues_NewValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NewValue)
	copy(dAtA[i:], m.NewValue)
	i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(m.NewValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *DisallowValues_UseDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisallowValues_UseDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefault != nil {
		{
			size, err := m.UseDefault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AllowValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplacementValue != nil {
		{
			size := m.ReplacementValue.Size()
			i -= size
			if _, err := m.ReplacementValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AllowedValues) > 0 {
		for iNdEx := len(m.AllowedValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedValues[iNdEx])
			copy(dAtA[i:], m.AllowedValues[iNdEx])
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(m.AllowedValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AllowValues_NewValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowValues_NewValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NewValue)
	copy(dAtA[i:], m.NewValue)
	i = encodeVarintInvocationPolicy(dAtA, i, uint64(len(m.NewValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *AllowValues_UseDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowValues_UseDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefault != nil {
		{
			size, err := m.UseDefault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvocationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintInvocationPolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovInvocationPolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InvocationPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FlagPolicies) > 0 {
		for _, e := range m.FlagPolicies {
			l = e.Size()
			n += 1 + l + sovInvocationPolicy(uint64(l))
		}
	}
	return n
}

func (m *FlagPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlagName != nil {
		l = len(*m.FlagName)
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	if len(m.Commands) > 0 {
		for _, s := range m.Commands {
			l = len(s)
			n += 1 + l + sovInvocationPolicy(uint64(l))
		}
	}
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *FlagPolicy_SetValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetValue != nil {
		l = m.SetValue.Size()
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	return n
}
func (m *FlagPolicy_UseDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefault != nil {
		l = m.UseDefault.Size()
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	return n
}
func (m *FlagPolicy_DisallowValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisallowValues != nil {
		l = m.DisallowValues.Size()
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	return n
}
func (m *FlagPolicy_AllowValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowValues != nil {
		l = m.AllowValues.Size()
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	return n
}
func (m *SetValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FlagValue) > 0 {
		for _, s := range m.FlagValue {
			l = len(s)
			n += 1 + l + sovInvocationPolicy(uint64(l))
		}
	}
	if m.Behavior != nil {
		n += 1 + sovInvocationPolicy(uint64(*m.Behavior))
	}
	return n
}

func (m *UseDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DisallowValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DisallowedValues) > 0 {
		for _, s := range m.DisallowedValues {
			l = len(s)
			n += 1 + l + sovInvocationPolicy(uint64(l))
		}
	}
	if m.ReplacementValue != nil {
		n += m.ReplacementValue.Size()
	}
	return n
}

func (m *DisallowValues_NewValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewValue)
	n += 1 + l + sovInvocationPolicy(uint64(l))
	return n
}
func (m *DisallowValues_UseDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefault != nil {
		l = m.UseDefault.Size()
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	return n
}
func (m *AllowValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedValues) > 0 {
		for _, s := range m.AllowedValues {
			l = len(s)
			n += 1 + l + sovInvocationPolicy(uint64(l))
		}
	}
	if m.ReplacementValue != nil {
		n += m.ReplacementValue.Size()
	}
	return n
}

func (m *AllowValues_NewValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewValue)
	n += 1 + l + sovInvocationPolicy(uint64(l))
	return n
}
func (m *AllowValues_UseDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefault != nil {
		l = m.UseDefault.Size()
		n += 1 + l + sovInvocationPolicy(uint64(l))
	}
	return n
}

func sovInvocationPolicy(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozInvocationPolicy(x uint64) (n int) {
	return sovInvocationPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InvocationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvocationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvocationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlagPolicies = append(m.FlagPolicies, &FlagPolicy{})
			if err := m.FlagPolicies[len(m.FlagPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvocationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlagPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlagPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlagPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FlagName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value FlagPolicy_SetValue
				field SetValue
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.SetValue = &alloc.field
			m.Operation = &alloc.value
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value FlagPolicy_UseDefault
				field UseDefault
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.UseDefault = &alloc.field
			m.Operation = &alloc.value
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value FlagPolicy_DisallowValues
				field DisallowValues
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.DisallowValues = &alloc.field
			m.Operation = &alloc.value
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value FlagPolicy_AllowValues
				field AllowValues
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.AllowValues = &alloc.field
			m.Operation = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvocationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlagValue = append(m.FlagValue, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Behavior", wireType)
			}
			var v SetValue_Behavior
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SetValue_Behavior(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Behavior = &v
		default:
			iNdEx = preIndex
			skippy, err := skipInvocationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseDefault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseDefault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseDefault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvocationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisallowValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisallowValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisallowValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowedValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisallowedValues = append(m.DisallowedValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplacementValue = &DisallowValues_NewValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value DisallowValues_UseDefault
				field UseDefault
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.UseDefault = &alloc.field
			m.ReplacementValue = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvocationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedValues = append(m.AllowedValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplacementValue = &AllowValues_NewValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value AllowValues_UseDefault
				field UseDefault
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.UseDefault = &alloc.field
			m.ReplacementValue = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvocationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInvocationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInvocationPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInvocationPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInvocationPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInvocationPolicy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInvocationPolicy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInvocationPolicy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInvocationPolicy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInvocationPolicy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInvocationPolicy = fmt.Errorf("proto: unexpected end of group")
)

