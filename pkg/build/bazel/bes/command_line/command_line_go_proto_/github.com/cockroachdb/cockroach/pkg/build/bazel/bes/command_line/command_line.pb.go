// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/main/protobuf/command_line.proto

package command_line

import (
	fmt "fmt"
	option_filters "github.com/cockroachdb/cockroach/pkg/build/bazel/bes/option_filters"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	slices "slices"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Representation of a Bazel command line.
type CommandLine struct {
	// A title for this command line value, to differentiate it from others.
	// In particular, a single invocation may wish to report both the literal and
	// canonical command lines, and this label would be used to differentiate
	// between both versions. This is a string for flexibility.
	CommandLineLabel string `protobuf:"bytes,1,opt,name=command_line_label,json=commandLineLabel,proto3" json:"command_line_label,omitempty"`
	// A Bazel command line is made of distinct parts. For example,
	//
	//	`bazel --nomaster_bazelrc test --nocache_test_results //foo:aTest`
	//
	// has the executable "bazel", a startup flag, a command "test", a command
	// flag, and a test target. There could be many more flags and targets, or
	// none (`bazel info` for example), but the basic structure is there. The
	// command line should be broken down into these logical sections here.
	Sections []*CommandLineSection `protobuf:"bytes,2,rep,name=sections,proto3" json:"sections,omitempty"`
}

func (m *CommandLine) Reset()         { *m = CommandLine{} }
func (m *CommandLine) String() string { return proto.CompactTextString(m) }
func (*CommandLine) ProtoMessage()    {}
func (*CommandLine) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6c030aeb09bb06d, []int{0}
}
func (m *CommandLine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CommandLine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLine.Merge(m, src)
}
func (m *CommandLine) XXX_Size() int {
	return m.Size()
}
func (m *CommandLine) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLine.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLine proto.InternalMessageInfo

// A section of the Bazel command line.
type CommandLineSection struct {
	// The name of this section, such as "startup_option" or "command".
	SectionLabel string `protobuf:"bytes,1,opt,name=section_label,json=sectionLabel,proto3" json:"section_label,omitempty"`
	// Types that are valid to be assigned to SectionType:
	//
	//	*CommandLineSection_ChunkList
	//	*CommandLineSection_OptionList
	SectionType isCommandLineSection_SectionType `protobuf_oneof:"section_type"`
}

func (m *CommandLineSection) Reset()         { *m = CommandLineSection{} }
func (m *CommandLineSection) String() string { return proto.CompactTextString(m) }
func (*CommandLineSection) ProtoMessage()    {}
func (*CommandLineSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6c030aeb09bb06d, []int{1}
}
func (m *CommandLineSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLineSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CommandLineSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLineSection.Merge(m, src)
}
func (m *CommandLineSection) XXX_Size() int {
	return m.Size()
}
func (m *CommandLineSection) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLineSection.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLineSection proto.InternalMessageInfo

type isCommandLineSection_SectionType interface {
	isCommandLineSection_SectionType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandLineSection_ChunkList struct {
	ChunkList *ChunkList `protobuf:"bytes,2,opt,name=chunk_list,json=chunkList,proto3,oneof" json:"chunk_list,omitempty"`
}
type CommandLineSection_OptionList struct {
	OptionList *OptionList `protobuf:"bytes,3,opt,name=option_list,json=optionList,proto3,oneof" json:"option_list,omitempty"`
}

func (*CommandLineSection_ChunkList) isCommandLineSection_SectionType()  {}
func (*CommandLineSection_OptionList) isCommandLineSection_SectionType() {}

func (m *CommandLineSection) GetSectionType() isCommandLineSection_SectionType {
	if m != nil {
		return m.SectionType
	}
	return nil
}

func (m *CommandLineSection) GetChunkList() *ChunkList {
	if x, ok := m.GetSectionType().(*CommandLineSection_ChunkList); ok {
		return x.ChunkList
	}
	return nil
}

func (m *CommandLineSection) GetOptionList() *OptionList {
	if x, ok := m.GetSectionType().(*CommandLineSection_OptionList); ok {
		return x.OptionList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CommandLineSection) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CommandLineSection_ChunkList)(nil),
		(*CommandLineSection_OptionList)(nil),
	}
}

// Wrapper to allow a list of strings in the "oneof" section_type.
type ChunkList struct {
	Chunk []string `protobuf:"bytes,1,rep,name=chunk,proto3" json:"chunk,omitempty"`
}

func (m *ChunkList) Reset()         { *m = ChunkList{} }
func (m *ChunkList) String() string { return proto.CompactTextString(m) }
func (*ChunkList) ProtoMessage()    {}
func (*ChunkList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6c030aeb09bb06d, []int{2}
}
func (m *ChunkList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChunkList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChunkList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChunkList.Merge(m, src)
}
func (m *ChunkList) XXX_Size() int {
	return m.Size()
}
func (m *ChunkList) XXX_DiscardUnknown() {
	xxx_messageInfo_ChunkList.DiscardUnknown(m)
}

var xxx_messageInfo_ChunkList proto.InternalMessageInfo

// Wrapper to allow a list of options in the "oneof" section_type.
type OptionList struct {
	Option []*Option `protobuf:"bytes,1,rep,name=option,proto3" json:"option,omitempty"`
}

func (m *OptionList) Reset()         { *m = OptionList{} }
func (m *OptionList) String() string { return proto.CompactTextString(m) }
func (*OptionList) ProtoMessage()    {}
func (*OptionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6c030aeb09bb06d, []int{3}
}
func (m *OptionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OptionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionList.Merge(m, src)
}
func (m *OptionList) XXX_Size() int {
	return m.Size()
}
func (m *OptionList) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionList.DiscardUnknown(m)
}

var xxx_messageInfo_OptionList proto.InternalMessageInfo

// A single command line option.
//
// This represents the option itself, but does not take into account the type of
// option or how the parser interpreted it. If this option is part of a command
// line that represents the actual input that Bazel received, it would, for
// example, include expansion flags as they are. However, if this option
// represents the canonical form of the command line, with the values as Bazel
// understands them, then the expansion flag, which has no value, would not
// appear, and the flags it expands to would.
type Option struct {
	// How the option looks with the option and its value combined. Depending on
	// the purpose of this command line report, this could be the canonical
	// form, or the way that the flag was set.
	//
	// Some examples: this might be `--foo=bar` form, or `--foo bar` with a space;
	// for boolean flags, `--nobaz` is accepted on top of `--baz=false` and other
	// negating values, or for a positive value, the unqualified `--baz` form
	// is also accepted. This could also be a short `-b`, if the flag has an
	// abbreviated form.
	CombinedForm string `protobuf:"bytes,1,opt,name=combined_form,json=combinedForm,proto3" json:"combined_form,omitempty"`
	// The canonical name of the option, without the preceding dashes.
	OptionName string `protobuf:"bytes,2,opt,name=option_name,json=optionName,proto3" json:"option_name,omitempty"`
	// The value of the flag, or unset for flags that do not take values.
	// Especially for boolean flags, this should be in canonical form, the
	// combined_form field above gives room for showing the flag as it was set
	// if that is preferred.
	OptionValue string `protobuf:"bytes,3,opt,name=option_value,json=optionValue,proto3" json:"option_value,omitempty"`
	// This flag's tagged effects. See OptionEffectTag's java documentation for
	// details.
	EffectTags []option_filters.OptionEffectTag `protobuf:"varint,4,rep,packed,name=effect_tags,json=effectTags,proto3,enum=options.OptionEffectTag" json:"effect_tags,omitempty"`
	// Metadata about the flag. See OptionMetadataTag's java documentation for
	// details.
	MetadataTags []option_filters.OptionMetadataTag `protobuf:"varint,5,rep,packed,name=metadata_tags,json=metadataTags,proto3,enum=options.OptionMetadataTag" json:"metadata_tags,omitempty"`
}

func (m *Option) Reset()         { *m = Option{} }
func (m *Option) String() string { return proto.CompactTextString(m) }
func (*Option) ProtoMessage()    {}
func (*Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6c030aeb09bb06d, []int{4}
}
func (m *Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Option.Merge(m, src)
}
func (m *Option) XXX_Size() int {
	return m.Size()
}
func (m *Option) XXX_DiscardUnknown() {
	xxx_messageInfo_Option.DiscardUnknown(m)
}

var xxx_messageInfo_Option proto.InternalMessageInfo

func init() {
	proto.RegisterType((*CommandLine)(nil), "command_line.CommandLine")
	proto.RegisterType((*CommandLineSection)(nil), "command_line.CommandLineSection")
	proto.RegisterType((*ChunkList)(nil), "command_line.ChunkList")
	proto.RegisterType((*OptionList)(nil), "command_line.OptionList")
	proto.RegisterType((*Option)(nil), "command_line.Option")
}

func init() {
	proto.RegisterFile("src/main/protobuf/command_line.proto", fileDescriptor_a6c030aeb09bb06d)
}

var fileDescriptor_a6c030aeb09bb06d = []byte{
	// 472 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0xcf, 0x6b, 0xd4, 0x40,
	0x14, 0xc7, 0x77, 0xba, 0x76, 0x31, 0x2f, 0xdb, 0x22, 0x43, 0xc1, 0xd0, 0x43, 0x4c, 0xa3, 0x48,
	0xc0, 0x92, 0x85, 0xf5, 0xe2, 0x2f, 0x10, 0x2a, 0x8a, 0x87, 0xad, 0x42, 0x14, 0xaf, 0x61, 0x92,
	0x4c, 0xd6, 0xc1, 0x99, 0xcc, 0x92, 0x99, 0x14, 0xfa, 0x5f, 0xf8, 0x27, 0x79, 0xec, 0xb1, 0xc7,
	0x1e, 0x75, 0xf7, 0xec, 0xff, 0x20, 0x99, 0x4c, 0xf6, 0x47, 0xeb, 0x29, 0x79, 0xdf, 0x7c, 0x3f,
	0xef, 0xfb, 0xde, 0x83, 0xc0, 0x13, 0x55, 0xe7, 0x13, 0x41, 0x58, 0x35, 0x59, 0xd4, 0x52, 0xcb,
	0xac, 0x29, 0x27, 0xb9, 0x14, 0x82, 0x54, 0x45, 0xca, 0x59, 0x45, 0x63, 0xa3, 0xe2, 0xf1, 0xb6,
	0x76, 0xfc, 0xf4, 0x2e, 0x23, 0x17, 0x9a, 0xc9, 0x2a, 0x2d, 0x19, 0xd7, 0xb4, 0x56, 0x1d, 0x15,
	0x5e, 0x82, 0xfb, 0xae, 0xe3, 0x66, 0xac, 0xa2, 0xf8, 0x14, 0xf0, 0x76, 0x9b, 0x94, 0x93, 0x8c,
	0x72, 0x0f, 0x05, 0x28, 0x72, 0x92, 0x07, 0xf9, 0xc6, 0x38, 0x6b, 0x75, 0xfc, 0x06, 0xee, 0x2b,
	0x9a, 0xb7, 0x5d, 0x95, 0xb7, 0x17, 0x0c, 0x23, 0x77, 0x1a, 0xc4, 0x3b, 0x93, 0x6d, 0xb5, 0xfe,
	0xd2, 0x19, 0x93, 0x35, 0x11, 0xfe, 0x42, 0x80, 0xef, 0x1a, 0xf0, 0x63, 0x38, 0xb0, 0x96, 0x9d,
	0xf4, 0xb1, 0x15, 0xbb, 0xe4, 0x17, 0x00, 0xf9, 0xf7, 0xa6, 0xfa, 0x91, 0x72, 0xa6, 0xb4, 0xb7,
	0x17, 0xa0, 0xc8, 0x9d, 0x3e, 0xbc, 0x95, 0xdd, 0x7e, 0x9f, 0x31, 0xa5, 0x3f, 0x0e, 0x12, 0x27,
	0xef, 0x0b, 0xfc, 0x1a, 0x5c, 0x7b, 0x08, 0x83, 0x0e, 0x0d, 0xea, 0xed, 0xa2, 0x9f, 0x8d, 0xc1,
	0xb2, 0x20, 0xd7, 0xd5, 0xd9, 0x21, 0xf4, 0x63, 0xa4, 0xfa, 0x72, 0x41, 0xc3, 0x13, 0x70, 0xd6,
	0x31, 0xf8, 0x08, 0xf6, 0x4d, 0x8c, 0x87, 0x82, 0x61, 0xe4, 0x24, 0x5d, 0x11, 0xbe, 0x02, 0xd8,
	0xb4, 0xc3, 0xa7, 0x30, 0xea, 0xda, 0x19, 0x93, 0x3b, 0x3d, 0xfa, 0x5f, 0x70, 0x62, 0x3d, 0xe1,
	0x5f, 0x04, 0xa3, 0x4e, 0x6a, 0xaf, 0x92, 0x4b, 0x91, 0xb1, 0x8a, 0x16, 0x69, 0x29, 0x6b, 0xd1,
	0x5f, 0xa5, 0x17, 0x3f, 0xc8, 0x5a, 0xe0, 0x47, 0xeb, 0xdd, 0x2a, 0x22, 0xa8, 0x39, 0x8b, 0xd3,
	0xcf, 0xff, 0x89, 0x08, 0x8a, 0x4f, 0x60, 0x6c, 0x0d, 0x17, 0x84, 0x37, 0xd4, 0x6c, 0xef, 0x24,
	0x16, 0xfa, 0xd6, 0x4a, 0xf8, 0x25, 0xb8, 0xb4, 0x2c, 0x69, 0xae, 0x53, 0x4d, 0xe6, 0xca, 0xbb,
	0x17, 0x0c, 0xa3, 0xc3, 0xa9, 0x17, 0x77, 0x16, 0x65, 0x27, 0x7c, 0x6f, 0x1c, 0x5f, 0xc9, 0x3c,
	0x01, 0xda, 0xbf, 0x2a, 0xfc, 0x16, 0x0e, 0x04, 0xd5, 0xa4, 0x20, 0x9a, 0x74, 0xf0, 0xbe, 0x81,
	0x8f, 0x6f, 0xc1, 0xe7, 0xd6, 0xd3, 0xe2, 0x63, 0xb1, 0x29, 0xd4, 0xd9, 0xf9, 0xd5, 0x1f, 0x7f,
	0x70, 0xb5, 0xf4, 0xd1, 0xf5, 0xd2, 0x47, 0x37, 0x4b, 0x1f, 0xfd, 0x5e, 0xfa, 0xe8, 0xe7, 0xca,
	0x1f, 0x5c, 0xaf, 0xfc, 0xc1, 0xcd, 0xca, 0x1f, 0xc0, 0xb3, 0x5c, 0x8a, 0x78, 0x2e, 0xe5, 0x9c,
	0xd3, 0xb8, 0xa0, 0x17, 0x5a, 0x4a, 0xae, 0xe2, 0xac, 0x61, 0xbc, 0x88, 0x39, 0xcb, 0xe2, 0xba,
	0xa9, 0x34, 0x13, 0xf6, 0x8f, 0xc8, 0x46, 0xe6, 0xf1, 0xfc, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x8f, 0x6d, 0xb2, 0xd1, 0x40, 0x03, 0x00, 0x00,
}

func (m *CommandLine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for iNdEx := len(m.Sections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommandLine(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CommandLineLabel) > 0 {
		i -= len(m.CommandLineLabel)
		copy(dAtA[i:], m.CommandLineLabel)
		i = encodeVarintCommandLine(dAtA, i, uint64(len(m.CommandLineLabel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandLineSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLineSection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLineSection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SectionType != nil {
		{
			size := m.SectionType.Size()
			i -= size
			if _, err := m.SectionType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SectionLabel) > 0 {
		i -= len(m.SectionLabel)
		copy(dAtA[i:], m.SectionLabel)
		i = encodeVarintCommandLine(dAtA, i, uint64(len(m.SectionLabel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandLineSection_ChunkList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLineSection_ChunkList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChunkList != nil {
		{
			size, err := m.ChunkList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommandLine(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CommandLineSection_OptionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLineSection_OptionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OptionList != nil {
		{
			size, err := m.OptionList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommandLine(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ChunkList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChunkList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunk) > 0 {
		for iNdEx := len(m.Chunk) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Chunk[iNdEx])
			copy(dAtA[i:], m.Chunk[iNdEx])
			i = encodeVarintCommandLine(dAtA, i, uint64(len(m.Chunk[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OptionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Option) > 0 {
		for iNdEx := len(m.Option) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Option[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommandLine(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Option) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Option) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataTags) > 0 {
		l := 0
		for _, e := range m.MetadataTags {
			l += sovCommandLine(uint64(e))
		}
		i -= l
		if l == len(m.MetadataTags) {
			dest := dAtA[i : i+len(m.MetadataTags)]
			for k, num := range m.MetadataTags {
				dest[k] = uint8(num)
			}
		} else {
			j3 := i
			for _, num := range m.MetadataTags {
				for num >= 1<<7 {
					dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j3++
				}
				dAtA[j3] = uint8(num)
				j3++
			}
		}
		i = encodeVarintCommandLine(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EffectTags) > 0 {
		l := 0
		for _, e := range m.EffectTags {
			l += sovCommandLine(uint64(e))
		}
		i -= l
		if l == len(m.EffectTags) {
			dest := dAtA[i : i+len(m.EffectTags)]
			for k, num := range m.EffectTags {
				dest[k] = uint8(num)
			}
		} else {
			j4 := i
			for _, num := range m.EffectTags {
				for num >= 1<<7 {
					dAtA[j4] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j4++
				}
				dAtA[j4] = uint8(num)
				j4++
			}
		}
		i = encodeVarintCommandLine(dAtA, i, uint64(uint64(l)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OptionValue) > 0 {
		i -= len(m.OptionValue)
		copy(dAtA[i:], m.OptionValue)
		i = encodeVarintCommandLine(dAtA, i, uint64(len(m.OptionValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OptionName) > 0 {
		i -= len(m.OptionName)
		copy(dAtA[i:], m.OptionName)
		i = encodeVarintCommandLine(dAtA, i, uint64(len(m.OptionName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CombinedForm) > 0 {
		i -= len(m.CombinedForm)
		copy(dAtA[i:], m.CombinedForm)
		i = encodeVarintCommandLine(dAtA, i, uint64(len(m.CombinedForm)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommandLine(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommandLine(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CommandLine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommandLineLabel)
	if l > 0 {
		n += 1 + l + sovCommandLine(uint64(l))
	}
	if len(m.Sections) > 0 {
		for _, e := range m.Sections {
			l = e.Size()
			n += 1 + l + sovCommandLine(uint64(l))
		}
	}
	return n
}

func (m *CommandLineSection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SectionLabel)
	if l > 0 {
		n += 1 + l + sovCommandLine(uint64(l))
	}
	if m.SectionType != nil {
		n += m.SectionType.Size()
	}
	return n
}

func (m *CommandLineSection_ChunkList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkList != nil {
		l = m.ChunkList.Size()
		n += 1 + l + sovCommandLine(uint64(l))
	}
	return n
}
func (m *CommandLineSection_OptionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionList != nil {
		l = m.OptionList.Size()
		n += 1 + l + sovCommandLine(uint64(l))
	}
	return n
}
func (m *ChunkList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunk) > 0 {
		for _, s := range m.Chunk {
			l = len(s)
			n += 1 + l + sovCommandLine(uint64(l))
		}
	}
	return n
}

func (m *OptionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Option) > 0 {
		for _, e := range m.Option {
			l = e.Size()
			n += 1 + l + sovCommandLine(uint64(l))
		}
	}
	return n
}

func (m *Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CombinedForm)
	if l > 0 {
		n += 1 + l + sovCommandLine(uint64(l))
	}
	l = len(m.OptionName)
	if l > 0 {
		n += 1 + l + sovCommandLine(uint64(l))
	}
	l = len(m.OptionValue)
	if l > 0 {
		n += 1 + l + sovCommandLine(uint64(l))
	}
	if len(m.EffectTags) > 0 {
		l = 0
		for _, e := range m.EffectTags {
			l += sovCommandLine(uint64(e))
		}
		n += 1 + sovCommandLine(uint64(l)) + l
	}
	if len(m.MetadataTags) > 0 {
		l = 0
		for _, e := range m.MetadataTags {
			l += sovCommandLine(uint64(e))
		}
		n += 1 + sovCommandLine(uint64(l)) + l
	}
	return n
}

func sovCommandLine(x uint64) (n int) {
	return int((uint32(math_bits.Len64(x|1)+6) * 37) >> 8)
}
func sozCommandLine(x uint64) (n int) {
	return sovCommandLine(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommandLine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommandLine
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLineLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLineLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sections = append(m.Sections, &CommandLineSection{})
			if err := m.Sections[len(m.Sections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommandLine(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommandLine
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLineSection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommandLine
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLineSection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLineSection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SectionLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value CommandLineSection_ChunkList
				field ChunkList
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.ChunkList = &alloc.field
			m.SectionType = &alloc.value
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			alloc := new(struct {
				value CommandLineSection_OptionList
				field OptionList
			})
			if err := alloc.field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			alloc.value.OptionList = &alloc.field
			m.SectionType = &alloc.value
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommandLine(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommandLine
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommandLine
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunk = append(m.Chunk, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommandLine(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommandLine
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommandLine
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, &Option{})
			if err := m.Option[len(m.Option)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommandLine(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommandLine
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommandLine
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombinedForm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombinedForm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommandLine
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommandLine
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v option_filters.OptionEffectTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommandLine
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= option_filters.OptionEffectTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EffectTags = append(m.EffectTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommandLine
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommandLine
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommandLine
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 {
					if m.EffectTags == nil {
						m.EffectTags = make([]option_filters.OptionEffectTag, 0, elementCount)
					} else {
						m.EffectTags = slices.Grow(m.EffectTags, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v option_filters.OptionEffectTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommandLine
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= option_filters.OptionEffectTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EffectTags = append(m.EffectTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectTags", wireType)
			}
		case 5:
			if wireType == 0 {
				var v option_filters.OptionMetadataTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommandLine
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= option_filters.OptionMetadataTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MetadataTags = append(m.MetadataTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommandLine
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommandLine
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommandLine
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 {
					if m.MetadataTags == nil {
						m.MetadataTags = make([]option_filters.OptionMetadataTag, 0, elementCount)
					} else {
						m.MetadataTags = slices.Grow(m.MetadataTags, elementCount)
					}
				}
				for iNdEx < postIndex {
					var v option_filters.OptionMetadataTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommandLine
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= option_filters.OptionMetadataTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MetadataTags = append(m.MetadataTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataTags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommandLine(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommandLine
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommandLine(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommandLine
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommandLine
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommandLine
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommandLine
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommandLine
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommandLine        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommandLine          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommandLine = fmt.Errorf("proto: unexpected end of group")
)

