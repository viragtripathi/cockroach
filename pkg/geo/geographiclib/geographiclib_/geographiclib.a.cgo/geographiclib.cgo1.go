// Code generated by cmd/cgo; DO NOT EDIT.

//line com_github_cockroachdb_cockroach/pkg/geo/geographiclib/geographiclib.go:1:1
// Copyright 2020 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

// Package geographiclib is a wrapper around the GeographicLib library.
package geographiclib

// #cgo CXXFLAGS: -std=c++14
// #cgo LDFLAGS: -lm
//
// #include "geodesic.h"
// #include "geographiclib.h"
import _ "unsafe"

import (
	"math"

	"github.com/cockroachdb/cockroach/pkg/geo/geoprojbase"
	"github.com/golang/geo/s1"
	"github.com/golang/geo/s2"
)

func init() {
	geoprojbase.MakeSpheroid = func(radius, flattening float64) (geoprojbase.Spheroid, error) {
		return NewSpheroid(radius, flattening), nil
	}
}

var (
	// WGS84Spheroid represents the default WGS84 ellipsoid.
	WGS84Spheroid = NewSpheroid(6378137, 1/298.257223563)
)

// Spheroid is an object that can perform geodesic operations
// on a given spheroid.
type Spheroid struct {
	cRepr         /*line :38:15*/_Ctype_struct_geod_geodesic /*line :38:37*/
	radius       float64
	flattening   float64
	sphereRadius float64
}

// NewSpheroid creates a spheroid from a radius and flattening.
func NewSpheroid(radius float64, flattening float64) *Spheroid {
	minorAxis := radius - radius*flattening
	s := &Spheroid{
		radius:       radius,
		flattening:   flattening,
		sphereRadius: (radius*2 + minorAxis) / 3,
	}
	( /*line :52:2*/_Cfunc_geod_init /*line :52:12*/)(&s.cRepr,  /*line :52:24*/_Ctype_double /*line :52:32*/(radius),  /*line :52:42*/_Ctype_double /*line :52:50*/(flattening))
	return s
}

// Radius returns the radius of the spheroid.
func (s *Spheroid) Radius() float64 {
	return s.radius
}

// Flattening returns the flattening factor of the spheroid.
func (s *Spheroid) Flattening() float64 {
	return s.flattening
}

// SphereRadius returns the radius of a sphere that fits inside the spheroid.
func (s *Spheroid) SphereRadius() float64 {
	return s.sphereRadius
}

// Inverse solves the geodetic inverse problem on the given spheroid
// (https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).
// Returns s12 (distance in meters), az1 (azimuth at point 1) and az2 (azimuth at point 2).
func (s *Spheroid) Inverse(a, b s2.LatLng) (s12, az1, az2 float64) {
	var retS12, retAZ1, retAZ2  /*line :75:29*/_Ctype_double /*line :75:37*/
	( /*line :76:2*/_Cfunc_geod_inverse /*line :76:15*/)(
		&s.cRepr,
		 /*line :78:3*/_Ctype_double /*line :78:11*/(a.Lat.Degrees()),
		 /*line :79:3*/_Ctype_double /*line :79:11*/(a.Lng.Degrees()),
		 /*line :80:3*/_Ctype_double /*line :80:11*/(b.Lat.Degrees()),
		 /*line :81:3*/_Ctype_double /*line :81:11*/(b.Lng.Degrees()),
		&retS12,
		&retAZ1,
		&retAZ2,
	)
	return float64(retS12), float64(retAZ1), float64(retAZ2)
}

// InverseBatch computes the sum of the length of the lines represented
// by the line of points.
// This is intended for use for LineStrings. LinearRings/Polygons should use "AreaAndPerimeter".
// Returns the sum of the s12 (distance in meters) units.
func (s *Spheroid) InverseBatch(points []s2.Point) float64 {
	lats := make([] /*line :94:17*/_Ctype_double /*line :94:25*/, len(points))
	lngs := make([] /*line :95:17*/_Ctype_double /*line :95:25*/, len(points))
	for i, p := range points {
		latlng := s2.LatLngFromPoint(p)
		lats[i] =  /*line :98:13*/_Ctype_double /*line :98:21*/(latlng.Lat.Degrees())
		lngs[i] =  /*line :99:13*/_Ctype_double /*line :99:21*/(latlng.Lng.Degrees())
	}
	var result  /*line :101:13*/_Ctype_double /*line :101:21*/
	( /*line :102:2*/_Cfunc_CR_GEOGRAPHICLIB_InverseBatch /*line :102:32*/)(
		&s.cRepr,
		&lats[0],
		&lngs[0],
		 /*line :106:3*/_Ctype_int /*line :106:8*/(len(points)),
		&result,
	)
	return float64(result)
}

// AreaAndPerimeter computes the area and perimeter of a polygon on a given spheroid.
// The points must never be duplicated (i.e. do not include the "final" point of a Polygon LinearRing).
// Area is in meter^2, Perimeter is in meters.
func (s *Spheroid) AreaAndPerimeter(points []s2.Point) (area float64, perimeter float64) {
	lats := make([] /*line :116:17*/_Ctype_double /*line :116:25*/, len(points))
	lngs := make([] /*line :117:17*/_Ctype_double /*line :117:25*/, len(points))
	for i, p := range points {
		latlng := s2.LatLngFromPoint(p)
		lats[i] =  /*line :120:13*/_Ctype_double /*line :120:21*/(latlng.Lat.Degrees())
		lngs[i] =  /*line :121:13*/_Ctype_double /*line :121:21*/(latlng.Lng.Degrees())
	}
	var areaDouble, perimeterDouble  /*line :123:34*/_Ctype_double /*line :123:42*/
	( /*line :124:2*/_Cfunc_geod_polygonarea /*line :124:19*/)(
		&s.cRepr,
		&lats[0],
		&lngs[0],
		 /*line :128:3*/_Ctype_int /*line :128:8*/(len(points)),
		&areaDouble,
		&perimeterDouble,
	)
	return float64(areaDouble), float64(perimeterDouble)
}

// Project returns computes the location of the projected point.
//
// Using the direct geodesic problem from GeographicLib (Karney 2013).
func (s *Spheroid) Project(point s2.LatLng, distance float64, azimuth s1.Angle) s2.LatLng {
	var lat, lng  /*line :139:15*/_Ctype_double /*line :139:23*/

	( /*line :141:2*/_Cfunc_geod_direct /*line :141:14*/)(
		&s.cRepr,
		 /*line :143:3*/_Ctype_double /*line :143:11*/(point.Lat.Degrees()),
		 /*line :144:3*/_Ctype_double /*line :144:11*/(point.Lng.Degrees()),
		 /*line :145:3*/_Ctype_double /*line :145:11*/(azimuth*180.0/math.Pi),
		 /*line :146:3*/_Ctype_double /*line :146:11*/(distance),
		&lat,
		&lng,
		nil,
	)

	return s2.LatLngFromDegrees(float64(lat), float64(lng))
}
