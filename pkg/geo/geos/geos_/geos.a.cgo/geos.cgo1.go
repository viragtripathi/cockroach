// Code generated by cmd/cgo; DO NOT EDIT.

//line com_github_cockroachdb_cockroach/pkg/geo/geos/geos.go:1:1
// Copyright 2020 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

// Package geos is a wrapper around the spatial data types between the geo
// package and the GEOS C library. The GEOS library is dynamically loaded
// at init time.
// Operations will error if the GEOS library was not found.
package geos

import (
	"fmt"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"sync"
	"unsafe"

	"github.com/cockroachdb/cockroach/pkg/build/bazel"
	"github.com/cockroachdb/cockroach/pkg/docs"
	"github.com/cockroachdb/cockroach/pkg/geo/geopb"
	"github.com/cockroachdb/cockroach/pkg/sql/pgwire/pgcode"
	"github.com/cockroachdb/cockroach/pkg/sql/pgwire/pgerror"
	"github.com/cockroachdb/errors"
)

// #cgo CXXFLAGS: -std=c++14
// #cgo !windows LDFLAGS: -ldl -lm
//
// #include "geos.h"
import _ "unsafe"

// EnsureInitErrorDisplay is used to control the error message displayed by
// EnsureInit.
type EnsureInitErrorDisplay int

const (
	// EnsureInitErrorDisplayPrivate displays the full error message, including
	// path info. It is intended for log messages.
	EnsureInitErrorDisplayPrivate EnsureInitErrorDisplay = iota
	// EnsureInitErrorDisplayPublic displays a redacted error message, excluding
	// path info. It is intended for errors to display for the client.
	EnsureInitErrorDisplayPublic
)

// maxArrayLen is the maximum safe length for this architecture.
const maxArrayLen = 1<<31 - 1

// geosOnce contains the global instance of CR_GEOS, to be initialized
// during at a maximum of once.
// If it has failed to open, the error will be populated in "err".
// This should only be touched by "fetchGEOSOrError".
var geosOnce struct {
	geos * /*line :56:8*/_Ctype_CR_GEOS /*line :56:17*/
	loc  string
	err  error
	once sync.Once
}

// PreparedGeometry is an instance of a GEOS PreparedGeometry.
type PreparedGeometry * /*line :63:24*/_Ctype_CR_GEOS_PreparedGeometry /*line :63:50*/

// EnsureInit attempts to start GEOS if it has not been opened already
// and returns the location if found, and an error if the CR_GEOS is not valid.
func EnsureInit(
	errDisplay EnsureInitErrorDisplay, flagLibraryDirectoryValue string,
) (string, error) {
	crdbBinaryLoc := ""
	if len(os.Args) > 0 {
		crdbBinaryLoc = os.Args[0]
	}
	_, err := ensureInit(errDisplay, flagLibraryDirectoryValue, crdbBinaryLoc)
	return geosOnce.loc, err
}

// ensureInitInternal ensures initialization has been done, always displaying
// errors privately and not assuming a flag has been set if initialized
// for the first time.
func ensureInitInternal() (* /*line :81:29*/_Ctype_CR_GEOS /*line :81:38*/, error) {
	return ensureInit(EnsureInitErrorDisplayPrivate, "", "")
}

// ensureInits behaves as described in EnsureInit, but also returns the GEOS
// C object which should be hidden from the public eye.
func ensureInit(
	errDisplay EnsureInitErrorDisplay, flagLibraryDirectoryValue string, crdbBinaryLoc string,
) (* /*line :89:5*/_Ctype_CR_GEOS /*line :89:14*/, error) {
	geosOnce.once.Do(func() {
		geosOnce.geos, geosOnce.loc, geosOnce.err = initGEOS(
			findLibraryDirectories(flagLibraryDirectoryValue, crdbBinaryLoc),
		)
	})
	if geosOnce.err != nil && errDisplay == EnsureInitErrorDisplayPublic {
		return nil, pgerror.Newf(pgcode.System, "geos: this operation is not available")
	}
	return geosOnce.geos, geosOnce.err
}

// appendLibraryExt appends the extension expected for the running OS.
func getLibraryExt(base string) string {
	switch runtime.GOOS {
	case "darwin":
		return base + ".dylib"
	case "windows":
		return base + ".dll"
	default:
		return base + ".so"
	}
}

const (
	libgeosFileName  = "libgeos"
	libgeoscFileName = "libgeos_c"
)

// findLibraryDirectories returns the default locations where GEOS is installed.
func findLibraryDirectories(flagLibraryDirectoryValue string, crdbBinaryLoc string) []string {
	// Try path by trying to find all parenting paths and appending
	// `lib/libgeos_c.<ext>` to the current working directory, as well
	// as the directory in which the cockroach binary is initialized.
	locs := []string{}
	if flagLibraryDirectoryValue != "" {
		locs = append(locs, flagLibraryDirectoryValue)
	}
	// Account for the libraries to be in a bazel runfile path.
	if bazel.BuiltWithBazel() {
		pathsToCheck := []string{
			path.Join("c-deps", "libgeos_foreign", "lib"),
			path.Join("external", "archived_cdep_libgeos_linux", "lib"),
			path.Join("external", "archived_cdep_libgeos_linuxarm", "lib"),
			path.Join("external", "archived_cdep_libgeos_macos", "lib"),
			path.Join("external", "archived_cdep_libgeos_macosarm", "lib"),
			path.Join("external", "archived_cdep_libgeos_windows", "bin"),
		}
		for _, path := range pathsToCheck {
			if p, err := bazel.Runfile(path); err == nil {
				locs = append(locs, p)
			}
		}
	}
	locs = append(
		locs,
		findLibraryDirectoriesInParentingDirectories(crdbBinaryLoc)...,
	)
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "warning: cannot retrieve cwd: %v", err)
	} else {
		locs = append(
			locs,
			findLibraryDirectoriesInParentingDirectories(cwd)...,
		)
	}
	return locs
}

// findLibraryDirectoriesInParentingDirectories attempts to find GEOS by looking at
// parenting folders and looking inside `lib/libgeos_c.*`.
// This is basically only useful for CI runs.
func findLibraryDirectoriesInParentingDirectories(dir string) []string {
	locs := []string{}

	for {
		checkDir := filepath.Join(dir, "lib")
		found := true
		for _, file := range []string{
			filepath.Join(checkDir, getLibraryExt(libgeoscFileName)),
			filepath.Join(checkDir, getLibraryExt(libgeosFileName)),
		} {
			if _, err := os.Stat(file); err != nil {
				found = false
				break
			}
		}
		if found {
			locs = append(locs, checkDir)
		}
		parentDir := filepath.Dir(dir)
		if parentDir == dir {
			break
		}
		dir = parentDir
	}
	return locs
}

// initGEOS initializes the CR_GEOS by attempting to dlopen all
// the paths as parsed in by locs.
func initGEOS(dirs []string) (* /*line :191:32*/_Ctype_CR_GEOS /*line :191:41*/, string, error) {
	var err error
	for _, dir := range dirs {
		var ret * /*line :194:12*/_Ctype_CR_GEOS /*line :194:21*/
		newErr := statusToError(
			func() _Ctype_struct___1{ var _cgo0 _Ctype_struct___0 = /*line :197:5*/goToCSlice([]byte(filepath.Join(dir, getLibraryExt(libgeoscFileName)))); var _cgo1 _Ctype_struct___0 = /*line :198:5*/goToCSlice([]byte(filepath.Join(dir, getLibraryExt(libgeosFileName)))); _cgoBase2 := /*line :199:5*/&ret; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :200:5*/_Cfunc_CR_GEOS_Init(_cgo0, _cgo1, _cgo2); }(),
		)
		if newErr == nil {
			return ret, dir, nil
		}
		err = errors.CombineErrors(
			err,
			errors.Wrapf(
				newErr,
				"geos: cannot load GEOS from dir %q",
				dir,
			),
		)
	}
	if err != nil {
		return nil, "", wrapGEOSInitError(errors.Wrap(err, "geos: error during GEOS init"))
	}
	return nil, "", wrapGEOSInitError(errors.Newf("geos: no locations to init GEOS"))
}

func wrapGEOSInitError(err error) error {
	page := "linux"
	switch runtime.GOOS {
	case "darwin":
		page = "mac"
	case "windows":
		page = "windows"
	}
	return pgerror.WithCandidateCode(
		errors.WithHintf(
			err,
			"Ensure you have the spatial libraries installed as per the instructions in %s",
			docs.URL("install-cockroachdb-"+page),
		),
		pgcode.ConfigFile,
	)
}

// goToCSlice returns a CR_GEOS_Slice from a given Go byte slice.
func goToCSlice(b []byte)  /*line :239:27*/_Ctype_CR_GEOS_Slice /*line :239:42*/ {
	if len(b) == 0 {
		return  /*line :241:10*/_Ctype_CR_GEOS_Slice /*line :241:25*/{data: nil, len: 0}
	}
	return  /*line :243:9*/_Ctype_CR_GEOS_Slice /*line :243:24*/{
		data: (* /*line :244:11*/_Ctype_char /*line :244:17*/)(unsafe.Pointer(&b[0])),
		len:   /*line :245:9*/_Ctype_size_t /*line :245:17*/(len(b)),
	}
}

// cStringToUnsafeGoBytes convert a CR_GEOS_String to a Go
// byte slice that refer to the underlying C memory.
func cStringToUnsafeGoBytes(s  /*line :251:31*/_Ctype_CR_GEOS_String /*line :251:47*/) []byte {
	return cToUnsafeGoBytes(s.data, s.len)
}

func cToUnsafeGoBytes(data * /*line :255:29*/_Ctype_char /*line :255:35*/, len  /*line :255:41*/_Ctype_size_t /*line :255:49*/) []byte {
	if data == nil {
		return nil
	}
	// Interpret the C pointer as a pointer to a Go array, then slice.
	return (*[maxArrayLen]byte)(unsafe.Pointer(data))[:len:len]
}

// cStringToSafeGoBytes converts a CR_GEOS_String to a Go byte slice.
// Additionally, it frees the C memory.
func cStringToSafeGoBytes(s  /*line :265:29*/_Ctype_CR_GEOS_String /*line :265:45*/) []byte {
	unsafeBytes := cStringToUnsafeGoBytes(s)
	b := make([]byte, len(unsafeBytes))
	copy(b, unsafeBytes)
	func() { _cgo0 := /*line :269:9*/unsafe.Pointer(s.data); _cgoCheckPointer(_cgo0, nil); /*line :269:32*/_Cfunc_free(_cgo0); }()
	return b
}

// A Error wraps an error returned from a GEOS operation.
type Error struct {
	msg string
}

// Error implements the error interface.
func (err *Error) Error() string {
	return err.msg
}

func statusToError(s  /*line :283:22*/_Ctype_CR_GEOS_Status /*line :283:38*/) error {
	if s.data == nil {
		return nil
	}
	return &Error{msg: string(cStringToSafeGoBytes(s))}
}

// Version returns the GEOS version used.
func Version() (string, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return "", err
	}
	var version  /*line :296:14*/_Ctype_CR_GEOS_String /*line :296:30*/
	func() { _cgo0 := /*line :297:20*/g; _cgoBase1 := /*line :297:23*/&version; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); /*line :297:32*/_Cfunc_CR_GEOS_Version(_cgo0, _cgo1); }()
	// Returns a `const char*`, so we don't have to free anything.
	return string(cStringToUnsafeGoBytes(version)), nil
}

// BufferParamsJoinStyle maps to the GEOSBufJoinStyles enum in geos_c.h.in.
type BufferParamsJoinStyle int

// These should be kept in sync with the geos_c.h.in corresponding enum definition.
const (
	BufferParamsJoinStyleRound = 1
	BufferParamsJoinStyleMitre = 2
	BufferParamsJoinStyleBevel = 3
)

// BufferParamsEndCapStyle maps to the GEOSBufCapStyles enum in geos_c.h.in.
type BufferParamsEndCapStyle int

// These should be kept in sync with the geos_c.h.in corresponding enum definition.
const (
	BufferParamsEndCapStyleRound  = 1
	BufferParamsEndCapStyleFlat   = 2
	BufferParamsEndCapStyleSquare = 3
)

// BufferParams are parameters to provide into the GEOS buffer function.
type BufferParams struct {
	JoinStyle        BufferParamsJoinStyle
	EndCapStyle      BufferParamsEndCapStyle
	SingleSided      bool
	QuadrantSegments int
	MitreLimit       float64
}

// Buffer buffers the given geometry by the given distance and params.
func Buffer(ewkb geopb.EWKB, params BufferParams, distance float64) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	singleSided := 0
	if params.SingleSided {
		singleSided = 1
	}
	cParams :=  /*line :341:13*/_Ctype_CR_GEOS_BufferParamsInput /*line :341:40*/{
		endCapStyle:       /*line :342:21*/_Ctype_int /*line :342:26*/(params.EndCapStyle),
		joinStyle:         /*line :343:21*/_Ctype_int /*line :343:26*/(params.JoinStyle),
		singleSided:       /*line :344:21*/_Ctype_int /*line :344:26*/(singleSided),
		quadrantSegments:  /*line :345:21*/_Ctype_int /*line :345:26*/(params.QuadrantSegments),
		mitreLimit:        /*line :346:21*/_Ctype_double /*line :346:29*/(params.MitreLimit),
	}
	var cEWKB  /*line :348:12*/_Ctype_CR_GEOS_String /*line :348:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :349:43*/g; var _cgo1 _Ctype_struct___0 = /*line :349:46*/goToCSlice(ewkb); var _cgo2 _Ctype_struct___2 = /*line :349:64*/cParams; var _cgo3 _Ctype_double = _Ctype_double /*line :349:81*/(distance); _cgoBase4 := /*line :349:93*/&cEWKB; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :349:100*/_Cfunc_CR_GEOS_Buffer(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// Area returns the area of an EWKB.
func Area(ewkb geopb.EWKB) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var area  /*line :361:11*/_Ctype_double /*line :361:19*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :362:41*/g; var _cgo1 _Ctype_struct___0 = /*line :362:44*/goToCSlice(ewkb); var _cgo2 *_Ctype_double = /*line :362:62*/&area; _cgoCheckPointer(_cgo0, nil); return /*line :362:68*/_Cfunc_CR_GEOS_Area(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return 0, err
	}
	return float64(area), nil
}

// Boundary returns the boundary of an EWKB.
func Boundary(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :374:12*/_Ctype_CR_GEOS_String /*line :374:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :375:45*/g; var _cgo1 _Ctype_struct___0 = /*line :375:48*/goToCSlice(ewkb); _cgoBase2 := /*line :375:66*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :375:73*/_Cfunc_CR_GEOS_Boundary(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// Difference returns the difference between two EWKB.
func Difference(ewkb1 geopb.EWKB, ewkb2 geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var diffEWKB  /*line :387:15*/_Ctype_CR_GEOS_String /*line :387:31*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :388:47*/g; var _cgo1 _Ctype_struct___0 = /*line :388:50*/goToCSlice(ewkb1); var _cgo2 _Ctype_struct___0 = /*line :388:69*/goToCSlice(ewkb2); _cgoBase3 := /*line :388:88*/&diffEWKB; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :388:98*/_Cfunc_CR_GEOS_Difference(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(diffEWKB), nil
}

// Length returns the length of an EWKB.
func Length(ewkb geopb.EWKB) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var length  /*line :400:13*/_Ctype_double /*line :400:21*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :401:43*/g; var _cgo1 _Ctype_struct___0 = /*line :401:46*/goToCSlice(ewkb); var _cgo2 *_Ctype_double = /*line :401:64*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :401:72*/_Cfunc_CR_GEOS_Length(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return 0, err
	}
	return float64(length), nil
}

// Normalize returns the geometry in its normalized form.
func Normalize(a geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :413:12*/_Ctype_CR_GEOS_String /*line :413:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :414:46*/g; var _cgo1 _Ctype_struct___0 = /*line :414:49*/goToCSlice(a); _cgoBase2 := /*line :414:64*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :414:71*/_Cfunc_CR_GEOS_Normalize(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// LineMerge merges multilinestring constituents.
func LineMerge(a geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :426:12*/_Ctype_CR_GEOS_String /*line :426:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :427:46*/g; var _cgo1 _Ctype_struct___0 = /*line :427:49*/goToCSlice(a); _cgoBase2 := /*line :427:64*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :427:71*/_Cfunc_CR_GEOS_LineMerge(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// IsSimple returns whether the EWKB is simple.
func IsSimple(ewkb geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :439:10*/_Ctype_char /*line :439:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :440:45*/g; var _cgo1 _Ctype_struct___0 = /*line :440:48*/goToCSlice(ewkb); var _cgo2 *_Ctype_char = /*line :440:66*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :440:71*/_Cfunc_CR_GEOS_IsSimple(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Centroid returns the centroid of an EWKB.
func Centroid(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :452:12*/_Ctype_CR_GEOS_String /*line :452:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :453:45*/g; var _cgo1 _Ctype_struct___0 = /*line :453:48*/goToCSlice(ewkb); _cgoBase2 := /*line :453:66*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :453:73*/_Cfunc_CR_GEOS_Centroid(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// MinimumBoundingCircle returns minimum bounding circle of an EWKB
func MinimumBoundingCircle(ewkb geopb.EWKB) (geopb.EWKB, geopb.EWKB, float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, nil, 0, err
	}
	var centerEWKB  /*line :465:17*/_Ctype_CR_GEOS_String /*line :465:33*/
	var polygonEWKB  /*line :466:18*/_Ctype_CR_GEOS_String /*line :466:34*/
	var radius  /*line :467:13*/_Ctype_double /*line :467:21*/

	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :469:58*/g; var _cgo1 _Ctype_struct___0 = /*line :469:61*/goToCSlice(ewkb); var _cgo2 *_Ctype_double = /*line :469:79*/&radius; _cgoBase3 := /*line :469:88*/&centerEWKB; _cgo3 := _cgoBase3; _cgoBase4 := /*line :469:101*/&polygonEWKB; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :469:114*/_Cfunc_CR_GEOS_MinimumBoundingCircle(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()); err != nil {
		return nil, nil, 0, err
	}
	return cStringToSafeGoBytes(polygonEWKB), cStringToSafeGoBytes(centerEWKB), float64(radius), nil

}

// ConvexHull returns an EWKB which returns the convex hull of the given EWKB.
func ConvexHull(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :482:12*/_Ctype_CR_GEOS_String /*line :482:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :483:47*/g; var _cgo1 _Ctype_struct___0 = /*line :483:50*/goToCSlice(ewkb); _cgoBase2 := /*line :483:68*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :483:75*/_Cfunc_CR_GEOS_ConvexHull(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// Simplify returns an EWKB which returns the simplified EWKB.
func Simplify(ewkb geopb.EWKB, tolerance float64) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :495:12*/_Ctype_CR_GEOS_String /*line :495:28*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :497:22*/g; var _cgo1 _Ctype_struct___0 = /*line :497:25*/goToCSlice(ewkb); _cgoBase2 := /*line :497:43*/&cEWKB; _cgo2 := _cgoBase2; var _cgo3 _Ctype_double = _Ctype_double /*line :497:59*/(tolerance); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :497:71*/_Cfunc_CR_GEOS_Simplify(_cgo0, _cgo1, _cgo2, _cgo3); }(),
	); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// TopologyPreserveSimplify returns an EWKB which returns the simplified EWKB
// with the topology preserved.
func TopologyPreserveSimplify(ewkb geopb.EWKB, tolerance float64) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :511:12*/_Ctype_CR_GEOS_String /*line :511:28*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :513:38*/g; var _cgo1 _Ctype_struct___0 = /*line :513:41*/goToCSlice(ewkb); _cgoBase2 := /*line :513:59*/&cEWKB; _cgo2 := _cgoBase2; var _cgo3 _Ctype_double = _Ctype_double /*line :513:75*/(tolerance); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :513:87*/_Cfunc_CR_GEOS_TopologyPreserveSimplify(_cgo0, _cgo1, _cgo2, _cgo3); }(),
	); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// PointOnSurface returns an EWKB with a point that is on the surface of the given EWKB.
func PointOnSurface(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :526:12*/_Ctype_CR_GEOS_String /*line :526:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :527:51*/g; var _cgo1 _Ctype_struct___0 = /*line :527:54*/goToCSlice(ewkb); _cgoBase2 := /*line :527:72*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :527:79*/_Cfunc_CR_GEOS_PointOnSurface(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// Intersection returns an EWKB which contains the geometries of intersection between A and B.
func Intersection(a geopb.EWKB, b geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :539:12*/_Ctype_CR_GEOS_String /*line :539:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :540:49*/g; var _cgo1 _Ctype_struct___0 = /*line :540:52*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :540:67*/goToCSlice(b); _cgoBase3 := /*line :540:82*/&cEWKB; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :540:89*/_Cfunc_CR_GEOS_Intersection(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// UnaryUnion Returns an EWKB which is a union of input geometry components.
func UnaryUnion(a geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var unionEWKB  /*line :552:16*/_Ctype_CR_GEOS_String /*line :552:32*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :553:47*/g; var _cgo1 _Ctype_struct___0 = /*line :553:50*/goToCSlice(a); _cgoBase2 := /*line :553:65*/&unionEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :553:76*/_Cfunc_CR_GEOS_UnaryUnion(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(unionEWKB), nil
}

// Union returns an EWKB which is a union of shapes A and B.
func Union(a geopb.EWKB, b geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :565:12*/_Ctype_CR_GEOS_String /*line :565:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :566:42*/g; var _cgo1 _Ctype_struct___0 = /*line :566:45*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :566:60*/goToCSlice(b); _cgoBase3 := /*line :566:75*/&cEWKB; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :566:82*/_Cfunc_CR_GEOS_Union(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// SymDifference returns an EWKB which is the symmetric difference of shapes A and B.
func SymDifference(a geopb.EWKB, b geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :578:12*/_Ctype_CR_GEOS_String /*line :578:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :579:50*/g; var _cgo1 _Ctype_struct___0 = /*line :579:53*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :579:68*/goToCSlice(b); _cgoBase3 := /*line :579:83*/&cEWKB; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :579:90*/_Cfunc_CR_GEOS_SymDifference(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// InterpolateLine returns the point along the given LineString which is at
// a given distance from starting point.
// Note: For distance less than 0 it returns start point similarly for distance
// greater LineString's length.
// InterpolateLine also works with (Multi)LineString. However, the result is
// not appropriate as it combines all the LineString present in (MULTI)LineString,
// considering all the corner points of LineString overlaps each other.
func InterpolateLine(ewkb geopb.EWKB, distance float64) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :597:12*/_Ctype_CR_GEOS_String /*line :597:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :598:48*/g; var _cgo1 _Ctype_struct___0 = /*line :598:51*/goToCSlice(ewkb); var _cgo2 _Ctype_double = _Ctype_double /*line :598:77*/(distance); _cgoBase3 := /*line :598:89*/&cEWKB; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :598:96*/_Cfunc_CR_GEOS_Interpolate(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// MinDistance returns the minimum distance between two EWKBs.
func MinDistance(a geopb.EWKB, b geopb.EWKB) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var distance  /*line :610:15*/_Ctype_double /*line :610:23*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :611:45*/g; var _cgo1 _Ctype_struct___0 = /*line :611:48*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :611:63*/goToCSlice(b); var _cgo3 *_Ctype_double = /*line :611:78*/&distance; _cgoCheckPointer(_cgo0, nil); return /*line :611:88*/_Cfunc_CR_GEOS_Distance(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return 0, err
	}
	return float64(distance), nil
}

// MinimumClearance returns the minimum distance a vertex can move to result in an
// invalid geometry.
func MinimumClearance(ewkb geopb.EWKB) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var distance  /*line :624:15*/_Ctype_double /*line :624:23*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :625:53*/g; var _cgo1 _Ctype_struct___0 = /*line :625:56*/goToCSlice(ewkb); var _cgo2 *_Ctype_double = /*line :625:74*/&distance; _cgoCheckPointer(_cgo0, nil); return /*line :625:84*/_Cfunc_CR_GEOS_MinimumClearance(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return 0, err
	}
	return float64(distance), nil
}

// MinimumClearanceLine returns the line spanning the minimum clearance a vertex can
// move before producing an invalid geometry.
func MinimumClearanceLine(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var clearanceEWKB  /*line :638:20*/_Ctype_CR_GEOS_String /*line :638:36*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :639:57*/g; var _cgo1 _Ctype_struct___0 = /*line :639:60*/goToCSlice(ewkb); _cgoBase2 := /*line :639:78*/&clearanceEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :639:93*/_Cfunc_CR_GEOS_MinimumClearanceLine(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(clearanceEWKB), nil
}

// ClipByRect clips a EWKB to the specified rectangle.
func ClipByRect(
	ewkb geopb.EWKB, xMin float64, yMin float64, xMax float64, yMax float64,
) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :653:12*/_Ctype_CR_GEOS_String /*line :653:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :654:47*/g; var _cgo1 _Ctype_struct___0 = /*line :654:50*/goToCSlice(ewkb); var _cgo2 _Ctype_double = _Ctype_double /*line :654:76*/(xMin); var _cgo3 _Ctype_double = _Ctype_double /*line :655:11*/(yMin); var _cgo4 _Ctype_double = _Ctype_double /*line :655:27*/(xMax); var _cgo5 _Ctype_double = _Ctype_double /*line :655:43*/(yMax); _cgoBase6 := /*line :655:51*/&cEWKB; _cgo6 := _cgoBase6; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase6, 0 == 0); return /*line :655:58*/_Cfunc_CR_GEOS_ClipByRect(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

//
// PreparedGeometry
//

// PrepareGeometry prepares a geometry in GEOS.
func PrepareGeometry(a geopb.EWKB) (PreparedGeometry, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var ret * /*line :671:11*/_Ctype_CR_GEOS_PreparedGeometry /*line :671:37*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :672:44*/g; var _cgo1 _Ctype_struct___0 = /*line :672:47*/goToCSlice(a); _cgoBase2 := /*line :672:62*/&ret; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :672:67*/_Cfunc_CR_GEOS_Prepare(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return PreparedGeometry(ret), nil
}

// PreparedGeomDestroy destroys a prepared geometry.
func PreparedGeomDestroy(a PreparedGeometry) {
	g, err := ensureInitInternal()
	if err != nil {
		panic(errors.NewAssertionErrorWithWrappedErrf(err, "trying to destroy PreparedGeometry with no GEOS"))
	}
	ap := (* /*line :684:10*/_Ctype_CR_GEOS_PreparedGeometry /*line :684:36*/)(unsafe.Pointer(a))
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :685:60*/g; _cgo1 := /*line :685:63*/ap; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :685:66*/_Cfunc_CR_GEOS_PreparedGeometryDestroy(_cgo0, _cgo1); }()); err != nil {
		panic(errors.NewAssertionErrorWithWrappedErrf(err, "PreparedGeometryDestroy returned an error"))
	}
}

//
// Binary predicates.
//

// Covers returns whether the EWKB provided by A covers the EWKB provided by B.
func Covers(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :700:10*/_Ctype_char /*line :700:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :701:43*/g; var _cgo1 _Ctype_struct___0 = /*line :701:46*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :701:61*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :701:76*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :701:81*/_Cfunc_CR_GEOS_Covers(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// CoveredBy returns whether the EWKB provided by A is covered by the EWKB provided by B.
func CoveredBy(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :713:10*/_Ctype_char /*line :713:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :714:46*/g; var _cgo1 _Ctype_struct___0 = /*line :714:49*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :714:64*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :714:79*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :714:84*/_Cfunc_CR_GEOS_CoveredBy(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Contains returns whether the EWKB provided by A contains the EWKB provided by B.
func Contains(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :726:10*/_Ctype_char /*line :726:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :727:45*/g; var _cgo1 _Ctype_struct___0 = /*line :727:48*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :727:63*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :727:78*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :727:83*/_Cfunc_CR_GEOS_Contains(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Crosses returns whether the EWKB provided by A crosses the EWKB provided by B.
func Crosses(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :739:10*/_Ctype_char /*line :739:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :740:44*/g; var _cgo1 _Ctype_struct___0 = /*line :740:47*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :740:62*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :740:77*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :740:82*/_Cfunc_CR_GEOS_Crosses(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Disjoint returns whether the EWKB provided by A is disjoint from the EWKB provided by B.
func Disjoint(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :752:10*/_Ctype_char /*line :752:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :753:45*/g; var _cgo1 _Ctype_struct___0 = /*line :753:48*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :753:63*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :753:78*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :753:83*/_Cfunc_CR_GEOS_Disjoint(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Equals returns whether the EWKB provided by A equals the EWKB provided by B.
func Equals(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :765:10*/_Ctype_char /*line :765:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :766:43*/g; var _cgo1 _Ctype_struct___0 = /*line :766:46*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :766:61*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :766:76*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :766:81*/_Cfunc_CR_GEOS_Equals(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// PreparedIntersects returns whether the EWKB provided by A intersects the EWKB provided by B.
func PreparedIntersects(a PreparedGeometry, b geopb.EWKB) (bool, error) {
	// Double check - since PreparedGeometry is actually a pointer to C type.
	if a == nil {
		return false, errors.New("provided PreparedGeometry is nil")
	}
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :782:10*/_Ctype_char /*line :782:16*/
	ap := (* /*line :783:10*/_Ctype_CR_GEOS_PreparedGeometry /*line :783:36*/)(unsafe.Pointer(a))
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :784:55*/g; _cgo1 := /*line :784:58*/ap; var _cgo2 _Ctype_struct___0 = /*line :784:62*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :784:77*/&ret; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :784:82*/_Cfunc_CR_GEOS_PreparedIntersects(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Intersects returns whether the EWKB provided by A intersects the EWKB provided by B.
func Intersects(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :796:10*/_Ctype_char /*line :796:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :797:47*/g; var _cgo1 _Ctype_struct___0 = /*line :797:50*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :797:65*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :797:80*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :797:85*/_Cfunc_CR_GEOS_Intersects(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Overlaps returns whether the EWKB provided by A overlaps the EWKB provided by B.
func Overlaps(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :809:10*/_Ctype_char /*line :809:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :810:45*/g; var _cgo1 _Ctype_struct___0 = /*line :810:48*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :810:63*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :810:78*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :810:83*/_Cfunc_CR_GEOS_Overlaps(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Touches returns whether the EWKB provided by A touches the EWKB provided by B.
func Touches(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :822:10*/_Ctype_char /*line :822:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :823:44*/g; var _cgo1 _Ctype_struct___0 = /*line :823:47*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :823:62*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :823:77*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :823:82*/_Cfunc_CR_GEOS_Touches(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// Within returns whether the EWKB provided by A is within the EWKB provided by B.
func Within(a geopb.EWKB, b geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :835:10*/_Ctype_char /*line :835:16*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :836:43*/g; var _cgo1 _Ctype_struct___0 = /*line :836:46*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :836:61*/goToCSlice(b); var _cgo3 *_Ctype_char = /*line :836:76*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :836:81*/_Cfunc_CR_GEOS_Within(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// FrechetDistance returns the Frechet distance between the geometries.
func FrechetDistance(a, b geopb.EWKB) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var distance  /*line :848:15*/_Ctype_double /*line :848:23*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :850:29*/g; var _cgo1 _Ctype_struct___0 = /*line :850:32*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :850:47*/goToCSlice(b); var _cgo3 *_Ctype_double = /*line :850:62*/&distance; _cgoCheckPointer(_cgo0, nil); return /*line :850:72*/_Cfunc_CR_GEOS_FrechetDistance(_cgo0, _cgo1, _cgo2, _cgo3); }(),
	); err != nil {
		return 0, err
	}
	return float64(distance), nil
}

// FrechetDistanceDensify returns the Frechet distance between the geometries.
func FrechetDistanceDensify(a, b geopb.EWKB, densifyFrac float64) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var distance  /*line :863:15*/_Ctype_double /*line :863:23*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :865:36*/g; var _cgo1 _Ctype_struct___0 = /*line :865:39*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :865:54*/goToCSlice(b); var _cgo3 _Ctype_double = _Ctype_double /*line :865:77*/(densifyFrac); var _cgo4 *_Ctype_double = /*line :865:92*/&distance; _cgoCheckPointer(_cgo0, nil); return /*line :865:102*/_Cfunc_CR_GEOS_FrechetDistanceDensify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(),
	); err != nil {
		return 0, err
	}
	return float64(distance), nil
}

// HausdorffDistance returns the Hausdorff distance between the geometries.
func HausdorffDistance(a, b geopb.EWKB) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var distance  /*line :878:15*/_Ctype_double /*line :878:23*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :880:31*/g; var _cgo1 _Ctype_struct___0 = /*line :880:34*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :880:49*/goToCSlice(b); var _cgo3 *_Ctype_double = /*line :880:64*/&distance; _cgoCheckPointer(_cgo0, nil); return /*line :880:74*/_Cfunc_CR_GEOS_HausdorffDistance(_cgo0, _cgo1, _cgo2, _cgo3); }(),
	); err != nil {
		return 0, err
	}
	return float64(distance), nil
}

// HausdorffDistanceDensify returns the Hausdorff distance between the geometries.
func HausdorffDistanceDensify(a, b geopb.EWKB, densifyFrac float64) (float64, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return 0, err
	}
	var distance  /*line :893:15*/_Ctype_double /*line :893:23*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :895:38*/g; var _cgo1 _Ctype_struct___0 = /*line :895:41*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :895:56*/goToCSlice(b); var _cgo3 _Ctype_double = _Ctype_double /*line :895:79*/(densifyFrac); var _cgo4 *_Ctype_double = /*line :895:94*/&distance; _cgoCheckPointer(_cgo0, nil); return /*line :895:104*/_Cfunc_CR_GEOS_HausdorffDistanceDensify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(),
	); err != nil {
		return 0, err
	}
	return float64(distance), nil
}

// EqualsExact returns whether two geometry objects are equal with some epsilon
func EqualsExact(lhs, rhs geopb.EWKB, epsilon float64) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :908:10*/_Ctype_char /*line :908:16*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :910:25*/g; var _cgo1 _Ctype_struct___0 = /*line :910:28*/goToCSlice(lhs); var _cgo2 _Ctype_struct___0 = /*line :910:45*/goToCSlice(rhs); var _cgo3 _Ctype_double = _Ctype_double /*line :910:70*/(epsilon); var _cgo4 *_Ctype_char = /*line :910:81*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :910:86*/_Cfunc_CR_GEOS_EqualsExact(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(),
	); err != nil {
		return false, err
	}
	return ret == 1, nil
}

//
// DE-9IM related
//

// Relate returns the DE-9IM relation between A and B.
func Relate(a geopb.EWKB, b geopb.EWKB) (string, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return "", err
	}
	var ret  /*line :927:10*/_Ctype_CR_GEOS_String /*line :927:26*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :928:43*/g; var _cgo1 _Ctype_struct___0 = /*line :928:46*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :928:61*/goToCSlice(b); _cgoBase3 := /*line :928:76*/&ret; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :928:81*/_Cfunc_CR_GEOS_Relate(_cgo0, _cgo1, _cgo2, _cgo3); }()); err != nil {
		return "", err
	}
	if ret.data == nil {
		return "", errors.Newf("expected DE-9IM string but found nothing")
	}
	return string(cStringToSafeGoBytes(ret)), nil
}

// RelateBoundaryNodeRule returns the DE-9IM relation between A and B given a boundary node rule.
func RelateBoundaryNodeRule(a geopb.EWKB, b geopb.EWKB, bnr int) (string, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return "", err
	}
	var ret  /*line :943:10*/_Ctype_CR_GEOS_String /*line :943:26*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :944:59*/g; var _cgo1 _Ctype_struct___0 = /*line :944:62*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :944:77*/goToCSlice(b); var _cgo3 _Ctype_int = _Ctype_int /*line :944:97*/(bnr); _cgoBase4 := /*line :944:104*/&ret; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :944:109*/_Cfunc_CR_GEOS_RelateBoundaryNodeRule(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()); err != nil {
		return "", err
	}
	if ret.data == nil {
		return "", errors.Newf("expected DE-9IM string but found nothing")
	}
	return string(cStringToSafeGoBytes(ret)), nil
}

// RelatePattern whether A and B have a DE-9IM relation matching the given pattern.
func RelatePattern(a geopb.EWKB, b geopb.EWKB, pattern string) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :959:10*/_Ctype_char /*line :959:16*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :961:27*/g; var _cgo1 _Ctype_struct___0 = /*line :961:30*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :961:45*/goToCSlice(b); var _cgo3 _Ctype_struct___0 = /*line :961:60*/goToCSlice([]byte(pattern)); var _cgo4 *_Ctype_char = /*line :961:89*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :961:94*/_Cfunc_CR_GEOS_RelatePattern(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(),
	); err != nil {
		return false, err
	}
	return ret == 1, nil
}

//
// Validity checking.
//

// IsValid returns whether the given geometry is valid.
func IsValid(ewkb geopb.EWKB) (bool, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, err
	}
	var ret  /*line :978:10*/_Ctype_char /*line :978:16*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :980:21*/g; var _cgo1 _Ctype_struct___0 = /*line :980:24*/goToCSlice(ewkb); var _cgo2 *_Ctype_char = /*line :980:42*/&ret; _cgoCheckPointer(_cgo0, nil); return /*line :980:47*/_Cfunc_CR_GEOS_IsValid(_cgo0, _cgo1, _cgo2); }(),
	); err != nil {
		return false, err
	}
	return ret == 1, nil
}

// IsValidReason the reasoning for whether the Geometry is valid or invalid.
func IsValidReason(ewkb geopb.EWKB) (string, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return "", err
	}
	var ret  /*line :993:10*/_Ctype_CR_GEOS_String /*line :993:26*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :995:27*/g; var _cgo1 _Ctype_struct___0 = /*line :995:30*/goToCSlice(ewkb); _cgoBase2 := /*line :995:48*/&ret; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :995:53*/_Cfunc_CR_GEOS_IsValidReason(_cgo0, _cgo1, _cgo2); }(),
	); err != nil {
		return "", err
	}

	return string(cStringToSafeGoBytes(ret)), nil
}

// IsValidDetail returns information regarding whether a geometry is valid or invalid.
// It takes in a flag parameter which behaves the same as the GEOS module, where 1
// means that self-intersecting rings forming holes are considered valid.
// It returns a bool representing whether it is valid, a string giving a reason for
// invalidity and an EWKB representing the location things are invalid at.
func IsValidDetail(ewkb geopb.EWKB, flags int) (bool, string, geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return false, "", nil, err
	}
	var retIsValid  /*line :1013:17*/_Ctype_char /*line :1013:23*/
	var retReason  /*line :1014:16*/_Ctype_CR_GEOS_String /*line :1014:32*/
	var retLocationEWKB  /*line :1015:22*/_Ctype_CR_GEOS_String /*line :1015:38*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :1018:4*/g; var _cgo1 _Ctype_struct___0 = /*line :1019:4*/goToCSlice(ewkb); var _cgo2 _Ctype_int = _Ctype_int /*line :1020:9*/(flags); var _cgo3 *_Ctype_char = /*line :1021:4*/&retIsValid; _cgoBase4 := /*line :1022:4*/&retReason; _cgo4 := _cgoBase4; _cgoBase5 := /*line :1023:4*/&retLocationEWKB; _cgo5 := _cgoBase5; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :1024:4*/_Cfunc_CR_GEOS_IsValidDetail(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }(),
	); err != nil {
		return false, "", nil, err
	}
	return retIsValid == 1,
		string(cStringToSafeGoBytes(retReason)),
		cStringToSafeGoBytes(retLocationEWKB),
		nil
}

// MakeValid returns a valid form of the EWKB.
func MakeValid(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :1040:12*/_Ctype_CR_GEOS_String /*line :1040:28*/
	if err := statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :1041:46*/g; var _cgo1 _Ctype_struct___0 = /*line :1041:49*/goToCSlice(ewkb); _cgoBase2 := /*line :1041:67*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1041:74*/_Cfunc_CR_GEOS_MakeValid(_cgo0, _cgo1, _cgo2); }()); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// SharedPaths Returns a EWKB containing paths shared by the two given EWKBs.
func SharedPaths(a geopb.EWKB, b geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :1053:12*/_Ctype_CR_GEOS_String /*line :1053:28*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :1055:25*/g; var _cgo1 _Ctype_struct___0 = /*line :1055:28*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :1055:43*/goToCSlice(b); _cgoBase3 := /*line :1055:58*/&cEWKB; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :1055:65*/_Cfunc_CR_GEOS_SharedPaths(_cgo0, _cgo1, _cgo2, _cgo3); }(),
	); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// Node returns a EWKB containing a set of linestrings using the least possible number of nodes while preserving all of the input ones.
func Node(a geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :1068:12*/_Ctype_CR_GEOS_String /*line :1068:28*/
	err = statusToError(func() _Ctype_struct___1{ _cgo0 := /*line :1069:37*/g; var _cgo1 _Ctype_struct___0 = /*line :1069:40*/goToCSlice(a); _cgoBase2 := /*line :1069:55*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1069:62*/_Cfunc_CR_GEOS_Node(_cgo0, _cgo1, _cgo2); }())
	if err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// VoronoiDiagram Computes the Voronoi Diagram from the vertices of the supplied EWKBs.
func VoronoiDiagram(a, env geopb.EWKB, tolerance float64, onlyEdges bool) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :1082:12*/_Ctype_CR_GEOS_String /*line :1082:28*/
	flag := 0
	if onlyEdges {
		flag = 1
	}
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :1088:28*/g; var _cgo1 _Ctype_struct___0 = /*line :1088:31*/goToCSlice(a); var _cgo2 _Ctype_struct___0 = /*line :1088:46*/goToCSlice(env); var _cgo3 _Ctype_double = _Ctype_double /*line :1088:71*/(tolerance); var _cgo4 _Ctype_int = _Ctype_int /*line :1088:89*/(flag); _cgoBase5 := /*line :1088:97*/&cEWKB; _cgo5 := _cgoBase5; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :1088:104*/_Cfunc_CR_GEOS_VoronoiDiagram(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }(),
	); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// MinimumRotatedRectangle Returns a minimum rotated rectangle enclosing a geometry
func MinimumRotatedRectangle(ewkb geopb.EWKB) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :1101:12*/_Ctype_CR_GEOS_String /*line :1101:28*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :1103:37*/g; var _cgo1 _Ctype_struct___0 = /*line :1103:40*/goToCSlice(ewkb); _cgoBase2 := /*line :1103:58*/&cEWKB; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1103:65*/_Cfunc_CR_GEOS_MinimumRotatedRectangle(_cgo0, _cgo1, _cgo2); }(),
	); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}

// Snap returns the input EWKB with the vertices snapped to the target
// EWKB. Tolerance is used to control where snapping is performed.
// If no snapping occurs then the input geometry is returned unchanged.
func Snap(input, target geopb.EWKB, tolerance float64) (geopb.EWKB, error) {
	g, err := ensureInitInternal()
	if err != nil {
		return nil, err
	}
	var cEWKB  /*line :1118:12*/_Ctype_CR_GEOS_String /*line :1118:28*/
	if err := statusToError(
		func() _Ctype_struct___1{ _cgo0 := /*line :1120:18*/g; var _cgo1 _Ctype_struct___0 = /*line :1120:21*/goToCSlice(input); var _cgo2 _Ctype_struct___0 = /*line :1120:40*/goToCSlice(target); var _cgo3 _Ctype_double = _Ctype_double /*line :1120:68*/(tolerance); _cgoBase4 := /*line :1120:81*/&cEWKB; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1120:88*/_Cfunc_CR_GEOS_Snap(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(),
	); err != nil {
		return nil, err
	}
	return cStringToSafeGoBytes(cEWKB), nil
}
